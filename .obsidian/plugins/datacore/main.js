/* Datacore: Autogenerated ESBuild file. See https://github.com/blacksmithgu/datacore for source. */
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/parsimmon/build/parsimmon.umd.min.js
var require_parsimmon_umd_min = __commonJS({
  "node_modules/parsimmon/build/parsimmon.umd.min.js"(exports, module2) {
    !function(n3, t5) {
      "object" == typeof exports && "object" == typeof module2 ? module2.exports = t5() : "function" == typeof define && define.amd ? define([], t5) : "object" == typeof exports ? exports.Parsimmon = t5() : n3.Parsimmon = t5();
    }("undefined" != typeof self ? self : exports, function() {
      return function(n3) {
        var t5 = {};
        function r4(e3) {
          if (t5[e3]) return t5[e3].exports;
          var u4 = t5[e3] = { i: e3, l: false, exports: {} };
          return n3[e3].call(u4.exports, u4, u4.exports, r4), u4.l = true, u4.exports;
        }
        return r4.m = n3, r4.c = t5, r4.d = function(n4, t6, e3) {
          r4.o(n4, t6) || Object.defineProperty(n4, t6, { configurable: false, enumerable: true, get: e3 });
        }, r4.r = function(n4) {
          Object.defineProperty(n4, "__esModule", { value: true });
        }, r4.n = function(n4) {
          var t6 = n4 && n4.__esModule ? function() {
            return n4.default;
          } : function() {
            return n4;
          };
          return r4.d(t6, "a", t6), t6;
        }, r4.o = function(n4, t6) {
          return Object.prototype.hasOwnProperty.call(n4, t6);
        }, r4.p = "", r4(r4.s = 0);
      }([function(n3, t5, r4) {
        "use strict";
        function e3(n4) {
          if (!(this instanceof e3)) return new e3(n4);
          this._ = n4;
        }
        var u4 = e3.prototype;
        function o4(n4, t6) {
          for (var r5 = 0; r5 < n4; r5++) t6(r5);
        }
        function i4(n4, t6, r5) {
          return function(n5, t7) {
            o4(t7.length, function(r6) {
              n5(t7[r6], r6, t7);
            });
          }(function(r6, e4, u5) {
            t6 = n4(t6, r6, e4, u5);
          }, r5), t6;
        }
        function a4(n4, t6) {
          return i4(function(t7, r5, e4, u5) {
            return t7.concat([n4(r5, e4, u5)]);
          }, [], t6);
        }
        function f4(n4, t6) {
          var r5 = { v: 0, buf: t6 };
          return o4(n4, function() {
            var n5;
            r5 = { v: r5.v << 1 | (n5 = r5.buf, n5[0] >> 7), buf: function(n6) {
              var t7 = i4(function(n7, t8, r6, e4) {
                return n7.concat(r6 === e4.length - 1 ? Buffer.from([t8, 0]).readUInt16BE(0) : e4.readUInt16BE(r6));
              }, [], n6);
              return Buffer.from(a4(function(n7) {
                return (n7 << 1 & 65535) >> 8;
              }, t7));
            }(r5.buf) };
          }), r5;
        }
        function c4() {
          return "undefined" != typeof Buffer;
        }
        function s4() {
          if (!c4()) throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
        }
        function l4(n4) {
          s4();
          var t6 = i4(function(n5, t7) {
            return n5 + t7;
          }, 0, n4);
          if (t6 % 8 != 0) throw new Error("The bits [" + n4.join(", ") + "] add up to " + t6 + " which is not an even number of bytes; the total should be divisible by 8");
          var r5, u5 = t6 / 8, o5 = (r5 = function(n5) {
            return n5 > 48;
          }, i4(function(n5, t7) {
            return n5 || (r5(t7) ? t7 : n5);
          }, null, n4));
          if (o5) throw new Error(o5 + " bit range requested exceeds 48 bit (6 byte) Number max.");
          return new e3(function(t7, r6) {
            var e4 = u5 + r6;
            return e4 > t7.length ? x4(r6, u5.toString() + " bytes") : b3(e4, i4(function(n5, t8) {
              var r7 = f4(t8, n5.buf);
              return { coll: n5.coll.concat(r7.v), buf: r7.buf };
            }, { coll: [], buf: t7.slice(r6, e4) }, n4).coll);
          });
        }
        function h3(n4, t6) {
          return new e3(function(r5, e4) {
            return s4(), e4 + t6 > r5.length ? x4(e4, t6 + " bytes for " + n4) : b3(e4 + t6, r5.slice(e4, e4 + t6));
          });
        }
        function p3(n4, t6) {
          if ("number" != typeof (r5 = t6) || Math.floor(r5) !== r5 || t6 < 0 || t6 > 6) throw new Error(n4 + " requires integer length in range [0, 6].");
          var r5;
        }
        function d3(n4) {
          return p3("uintBE", n4), h3("uintBE(" + n4 + ")", n4).map(function(t6) {
            return t6.readUIntBE(0, n4);
          });
        }
        function v3(n4) {
          return p3("uintLE", n4), h3("uintLE(" + n4 + ")", n4).map(function(t6) {
            return t6.readUIntLE(0, n4);
          });
        }
        function g4(n4) {
          return p3("intBE", n4), h3("intBE(" + n4 + ")", n4).map(function(t6) {
            return t6.readIntBE(0, n4);
          });
        }
        function m3(n4) {
          return p3("intLE", n4), h3("intLE(" + n4 + ")", n4).map(function(t6) {
            return t6.readIntLE(0, n4);
          });
        }
        function y4(n4) {
          return n4 instanceof e3;
        }
        function E3(n4) {
          return "[object Array]" === {}.toString.call(n4);
        }
        function w5(n4) {
          return c4() && Buffer.isBuffer(n4);
        }
        function b3(n4, t6) {
          return { status: true, index: n4, value: t6, furthest: -1, expected: [] };
        }
        function x4(n4, t6) {
          return E3(t6) || (t6 = [t6]), { status: false, index: -1, value: null, furthest: n4, expected: t6 };
        }
        function B4(n4, t6) {
          if (!t6) return n4;
          if (n4.furthest > t6.furthest) return n4;
          var r5 = n4.furthest === t6.furthest ? function(n5, t7) {
            if (function() {
              if (void 0 !== e3._supportsSet) return e3._supportsSet;
              var n6 = "undefined" != typeof Set;
              return e3._supportsSet = n6, n6;
            }() && Array.from) {
              for (var r6 = new Set(n5), u5 = 0; u5 < t7.length; u5++) r6.add(t7[u5]);
              var o5 = Array.from(r6);
              return o5.sort(), o5;
            }
            for (var i5 = {}, a5 = 0; a5 < n5.length; a5++) i5[n5[a5]] = true;
            for (var f5 = 0; f5 < t7.length; f5++) i5[t7[f5]] = true;
            var c5 = [];
            for (var s5 in i5) ({}).hasOwnProperty.call(i5, s5) && c5.push(s5);
            return c5.sort(), c5;
          }(n4.expected, t6.expected) : t6.expected;
          return { status: n4.status, index: n4.index, value: n4.value, furthest: t6.furthest, expected: r5 };
        }
        var j4 = {};
        function S2(n4, t6) {
          if (w5(n4)) return { offset: t6, line: -1, column: -1 };
          n4 in j4 || (j4[n4] = {});
          for (var r5 = j4[n4], e4 = 0, u5 = 0, o5 = 0, i5 = t6; i5 >= 0; ) {
            if (i5 in r5) {
              e4 = r5[i5].line, 0 === o5 && (o5 = r5[i5].lineStart);
              break;
            }
            ("\n" === n4.charAt(i5) || "\r" === n4.charAt(i5) && "\n" !== n4.charAt(i5 + 1)) && (u5++, 0 === o5 && (o5 = i5 + 1)), i5--;
          }
          var a5 = e4 + u5, f5 = t6 - o5;
          return r5[t6] = { line: a5, lineStart: o5 }, { offset: t6, line: a5 + 1, column: f5 + 1 };
        }
        function _3(n4) {
          if (!y4(n4)) throw new Error("not a parser: " + n4);
        }
        function L3(n4, t6) {
          return "string" == typeof n4 ? n4.charAt(t6) : n4[t6];
        }
        function O3(n4) {
          if ("number" != typeof n4) throw new Error("not a number: " + n4);
        }
        function k4(n4) {
          if ("function" != typeof n4) throw new Error("not a function: " + n4);
        }
        function P7(n4) {
          if ("string" != typeof n4) throw new Error("not a string: " + n4);
        }
        var q4 = 2, A4 = 3, I3 = 8, F4 = 5 * I3, M3 = 4 * I3, z4 = "  ";
        function R2(n4, t6) {
          return new Array(t6 + 1).join(n4);
        }
        function U2(n4, t6, r5) {
          var e4 = t6 - n4.length;
          return e4 <= 0 ? n4 : R2(r5, e4) + n4;
        }
        function W2(n4, t6, r5, e4) {
          return { from: n4 - t6 > 0 ? n4 - t6 : 0, to: n4 + r5 > e4 ? e4 : n4 + r5 };
        }
        function D4(n4, t6) {
          var r5, e4, u5, o5, f5, c5 = t6.index, s5 = c5.offset, l5 = 1;
          if (s5 === n4.length) return "Got the end of the input";
          if (w5(n4)) {
            var h4 = s5 - s5 % I3, p4 = s5 - h4, d4 = W2(h4, F4, M3 + I3, n4.length), v4 = a4(function(n5) {
              return a4(function(n6) {
                return U2(n6.toString(16), 2, "0");
              }, n5);
            }, function(n5, t7) {
              var r6 = n5.length, e5 = [], u6 = 0;
              if (r6 <= t7) return [n5.slice()];
              for (var o6 = 0; o6 < r6; o6++) e5[u6] || e5.push([]), e5[u6].push(n5[o6]), (o6 + 1) % t7 == 0 && u6++;
              return e5;
            }(n4.slice(d4.from, d4.to).toJSON().data, I3));
            o5 = function(n5) {
              return 0 === n5.from && 1 === n5.to ? { from: n5.from, to: n5.to } : { from: n5.from / I3, to: Math.floor(n5.to / I3) };
            }(d4), e4 = h4 / I3, r5 = 3 * p4, p4 >= 4 && (r5 += 1), l5 = 2, u5 = a4(function(n5) {
              return n5.length <= 4 ? n5.join(" ") : n5.slice(0, 4).join(" ") + "  " + n5.slice(4).join(" ");
            }, v4), (f5 = (8 * (o5.to > 0 ? o5.to - 1 : o5.to)).toString(16).length) < 2 && (f5 = 2);
          } else {
            var g5 = n4.split(/\r\n|[\n\r\u2028\u2029]/);
            r5 = c5.column - 1, e4 = c5.line - 1, o5 = W2(e4, q4, A4, g5.length), u5 = g5.slice(o5.from, o5.to), f5 = o5.to.toString().length;
          }
          var m4 = e4 - o5.from;
          return w5(n4) && (f5 = (8 * (o5.to > 0 ? o5.to - 1 : o5.to)).toString(16).length) < 2 && (f5 = 2), i4(function(t7, e5, u6) {
            var i5, a5 = u6 === m4, c6 = a5 ? "> " : z4;
            return i5 = w5(n4) ? U2((8 * (o5.from + u6)).toString(16), f5, "0") : U2((o5.from + u6 + 1).toString(), f5, " "), [].concat(t7, [c6 + i5 + " | " + e5], a5 ? [z4 + R2(" ", f5) + " | " + U2("", r5, " ") + R2("^", l5)] : []);
          }, [], u5).join("\n");
        }
        function N3(n4, t6) {
          return ["\n", "-- PARSING FAILED " + R2("-", 50), "\n\n", D4(n4, t6), "\n\n", (r5 = t6.expected, 1 === r5.length ? "Expected:\n\n" + r5[0] : "Expected one of the following: \n\n" + r5.join(", ")), "\n"].join("");
          var r5;
        }
        function G3(n4) {
          return void 0 !== n4.flags ? n4.flags : [n4.global ? "g" : "", n4.ignoreCase ? "i" : "", n4.multiline ? "m" : "", n4.unicode ? "u" : "", n4.sticky ? "y" : ""].join("");
        }
        function C4() {
          for (var n4 = [].slice.call(arguments), t6 = n4.length, r5 = 0; r5 < t6; r5 += 1) _3(n4[r5]);
          return e3(function(r6, e4) {
            for (var u5, o5 = new Array(t6), i5 = 0; i5 < t6; i5 += 1) {
              if (!(u5 = B4(n4[i5]._(r6, e4), u5)).status) return u5;
              o5[i5] = u5.value, e4 = u5.index;
            }
            return B4(b3(e4, o5), u5);
          });
        }
        function J2() {
          var n4 = [].slice.call(arguments);
          if (0 === n4.length) throw new Error("seqMap needs at least one argument");
          var t6 = n4.pop();
          return k4(t6), C4.apply(null, n4).map(function(n5) {
            return t6.apply(null, n5);
          });
        }
        function T4() {
          var n4 = [].slice.call(arguments), t6 = n4.length;
          if (0 === t6) return Y2("zero alternates");
          for (var r5 = 0; r5 < t6; r5 += 1) _3(n4[r5]);
          return e3(function(t7, r6) {
            for (var e4, u5 = 0; u5 < n4.length; u5 += 1) if ((e4 = B4(n4[u5]._(t7, r6), e4)).status) return e4;
            return e4;
          });
        }
        function V3(n4, t6) {
          return H3(n4, t6).or(X2([]));
        }
        function H3(n4, t6) {
          return _3(n4), _3(t6), J2(n4, t6.then(n4).many(), function(n5, t7) {
            return [n5].concat(t7);
          });
        }
        function K2(n4) {
          P7(n4);
          var t6 = "'" + n4 + "'";
          return e3(function(r5, e4) {
            var u5 = e4 + n4.length, o5 = r5.slice(e4, u5);
            return o5 === n4 ? b3(u5, o5) : x4(e4, t6);
          });
        }
        function Q2(n4, t6) {
          !function(n5) {
            if (!(n5 instanceof RegExp)) throw new Error("not a regexp: " + n5);
            for (var t7 = G3(n5), r6 = 0; r6 < t7.length; r6++) {
              var e4 = t7.charAt(r6);
              if ("i" !== e4 && "m" !== e4 && "u" !== e4 && "s" !== e4) throw new Error('unsupported regexp flag "' + e4 + '": ' + n5);
            }
          }(n4), arguments.length >= 2 ? O3(t6) : t6 = 0;
          var r5 = function(n5) {
            return RegExp("^(?:" + n5.source + ")", G3(n5));
          }(n4), u5 = "" + n4;
          return e3(function(n5, e4) {
            var o5 = r5.exec(n5.slice(e4));
            if (o5) {
              if (0 <= t6 && t6 <= o5.length) {
                var i5 = o5[0], a5 = o5[t6];
                return b3(e4 + i5.length, a5);
              }
              return x4(e4, "valid match group (0 to " + o5.length + ") in " + u5);
            }
            return x4(e4, u5);
          });
        }
        function X2(n4) {
          return e3(function(t6, r5) {
            return b3(r5, n4);
          });
        }
        function Y2(n4) {
          return e3(function(t6, r5) {
            return x4(r5, n4);
          });
        }
        function Z2(n4) {
          if (y4(n4)) return e3(function(t6, r5) {
            var e4 = n4._(t6, r5);
            return e4.index = r5, e4.value = "", e4;
          });
          if ("string" == typeof n4) return Z2(K2(n4));
          if (n4 instanceof RegExp) return Z2(Q2(n4));
          throw new Error("not a string, regexp, or parser: " + n4);
        }
        function $3(n4) {
          return _3(n4), e3(function(t6, r5) {
            var e4 = n4._(t6, r5), u5 = t6.slice(r5, e4.index);
            return e4.status ? x4(r5, 'not "' + u5 + '"') : b3(r5, null);
          });
        }
        function nn2(n4) {
          return k4(n4), e3(function(t6, r5) {
            var e4 = L3(t6, r5);
            return r5 < t6.length && n4(e4) ? b3(r5 + 1, e4) : x4(r5, "a character/byte matching " + n4);
          });
        }
        function tn2(n4, t6) {
          arguments.length < 2 && (t6 = n4, n4 = void 0);
          var r5 = e3(function(n5, e4) {
            return r5._ = t6()._, r5._(n5, e4);
          });
          return n4 ? r5.desc(n4) : r5;
        }
        function rn2() {
          return Y2("fantasy-land/empty");
        }
        u4.parse = function(n4) {
          if ("string" != typeof n4 && !w5(n4)) throw new Error(".parse must be called with a string or Buffer as its argument");
          var t6, r5 = this.skip(an2)._(n4, 0);
          return t6 = r5.status ? { status: true, value: r5.value } : { status: false, index: S2(n4, r5.furthest), expected: r5.expected }, delete j4[n4], t6;
        }, u4.tryParse = function(n4) {
          var t6 = this.parse(n4);
          if (t6.status) return t6.value;
          var r5 = N3(n4, t6), e4 = new Error(r5);
          throw e4.type = "ParsimmonError", e4.result = t6, e4;
        }, u4.assert = function(n4, t6) {
          return this.chain(function(r5) {
            return n4(r5) ? X2(r5) : Y2(t6);
          });
        }, u4.or = function(n4) {
          return T4(this, n4);
        }, u4.trim = function(n4) {
          return this.wrap(n4, n4);
        }, u4.wrap = function(n4, t6) {
          return J2(n4, this, t6, function(n5, t7) {
            return t7;
          });
        }, u4.thru = function(n4) {
          return n4(this);
        }, u4.then = function(n4) {
          return _3(n4), C4(this, n4).map(function(n5) {
            return n5[1];
          });
        }, u4.many = function() {
          var n4 = this;
          return e3(function(t6, r5) {
            for (var e4 = [], u5 = void 0; ; ) {
              if (!(u5 = B4(n4._(t6, r5), u5)).status) return B4(b3(r5, e4), u5);
              if (r5 === u5.index) throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
              r5 = u5.index, e4.push(u5.value);
            }
          });
        }, u4.tieWith = function(n4) {
          return P7(n4), this.map(function(t6) {
            if (function(n5) {
              if (!E3(n5)) throw new Error("not an array: " + n5);
            }(t6), t6.length) {
              P7(t6[0]);
              for (var r5 = t6[0], e4 = 1; e4 < t6.length; e4++) P7(t6[e4]), r5 += n4 + t6[e4];
              return r5;
            }
            return "";
          });
        }, u4.tie = function() {
          return this.tieWith("");
        }, u4.times = function(n4, t6) {
          var r5 = this;
          return arguments.length < 2 && (t6 = n4), O3(n4), O3(t6), e3(function(e4, u5) {
            for (var o5 = [], i5 = void 0, a5 = void 0, f5 = 0; f5 < n4; f5 += 1) {
              if (a5 = B4(i5 = r5._(e4, u5), a5), !i5.status) return a5;
              u5 = i5.index, o5.push(i5.value);
            }
            for (; f5 < t6 && (a5 = B4(i5 = r5._(e4, u5), a5), i5.status); f5 += 1) u5 = i5.index, o5.push(i5.value);
            return B4(b3(u5, o5), a5);
          });
        }, u4.result = function(n4) {
          return this.map(function() {
            return n4;
          });
        }, u4.atMost = function(n4) {
          return this.times(0, n4);
        }, u4.atLeast = function(n4) {
          return J2(this.times(n4), this.many(), function(n5, t6) {
            return n5.concat(t6);
          });
        }, u4.map = function(n4) {
          k4(n4);
          var t6 = this;
          return e3(function(r5, e4) {
            var u5 = t6._(r5, e4);
            return u5.status ? B4(b3(u5.index, n4(u5.value)), u5) : u5;
          });
        }, u4.contramap = function(n4) {
          k4(n4);
          var t6 = this;
          return e3(function(r5, e4) {
            var u5 = t6.parse(n4(r5.slice(e4)));
            return u5.status ? b3(e4 + r5.length, u5.value) : u5;
          });
        }, u4.promap = function(n4, t6) {
          return k4(n4), k4(t6), this.contramap(n4).map(t6);
        }, u4.skip = function(n4) {
          return C4(this, n4).map(function(n5) {
            return n5[0];
          });
        }, u4.mark = function() {
          return J2(en2, this, en2, function(n4, t6, r5) {
            return { start: n4, value: t6, end: r5 };
          });
        }, u4.node = function(n4) {
          return J2(en2, this, en2, function(t6, r5, e4) {
            return { name: n4, value: r5, start: t6, end: e4 };
          });
        }, u4.sepBy = function(n4) {
          return V3(this, n4);
        }, u4.sepBy1 = function(n4) {
          return H3(this, n4);
        }, u4.lookahead = function(n4) {
          return this.skip(Z2(n4));
        }, u4.notFollowedBy = function(n4) {
          return this.skip($3(n4));
        }, u4.desc = function(n4) {
          E3(n4) || (n4 = [n4]);
          var t6 = this;
          return e3(function(r5, e4) {
            var u5 = t6._(r5, e4);
            return u5.status || (u5.expected = n4), u5;
          });
        }, u4.fallback = function(n4) {
          return this.or(X2(n4));
        }, u4.ap = function(n4) {
          return J2(n4, this, function(n5, t6) {
            return n5(t6);
          });
        }, u4.chain = function(n4) {
          var t6 = this;
          return e3(function(r5, e4) {
            var u5 = t6._(r5, e4);
            return u5.status ? B4(n4(u5.value)._(r5, u5.index), u5) : u5;
          });
        }, u4.concat = u4.or, u4.empty = rn2, u4.of = X2, u4["fantasy-land/ap"] = u4.ap, u4["fantasy-land/chain"] = u4.chain, u4["fantasy-land/concat"] = u4.concat, u4["fantasy-land/empty"] = u4.empty, u4["fantasy-land/of"] = u4.of, u4["fantasy-land/map"] = u4.map;
        var en2 = e3(function(n4, t6) {
          return b3(t6, S2(n4, t6));
        }), un2 = e3(function(n4, t6) {
          return t6 >= n4.length ? x4(t6, "any character/byte") : b3(t6 + 1, L3(n4, t6));
        }), on3 = e3(function(n4, t6) {
          return b3(n4.length, n4.slice(t6));
        }), an2 = e3(function(n4, t6) {
          return t6 < n4.length ? x4(t6, "EOF") : b3(t6, null);
        }), fn2 = Q2(/[0-9]/).desc("a digit"), cn2 = Q2(/[0-9]*/).desc("optional digits"), sn2 = Q2(/[a-z]/i).desc("a letter"), ln2 = Q2(/[a-z]*/i).desc("optional letters"), hn2 = Q2(/\s*/).desc("optional whitespace"), pn2 = Q2(/\s+/).desc("whitespace"), dn2 = K2("\r"), vn2 = K2("\n"), gn2 = K2("\r\n"), mn2 = T4(gn2, vn2, dn2).desc("newline"), yn2 = T4(mn2, an2);
        e3.all = on3, e3.alt = T4, e3.any = un2, e3.cr = dn2, e3.createLanguage = function(n4) {
          var t6 = {};
          for (var r5 in n4) ({}).hasOwnProperty.call(n4, r5) && function(r6) {
            t6[r6] = tn2(function() {
              return n4[r6](t6);
            });
          }(r5);
          return t6;
        }, e3.crlf = gn2, e3.custom = function(n4) {
          return e3(n4(b3, x4));
        }, e3.digit = fn2, e3.digits = cn2, e3.empty = rn2, e3.end = yn2, e3.eof = an2, e3.fail = Y2, e3.formatError = N3, e3.index = en2, e3.isParser = y4, e3.lazy = tn2, e3.letter = sn2, e3.letters = ln2, e3.lf = vn2, e3.lookahead = Z2, e3.makeFailure = x4, e3.makeSuccess = b3, e3.newline = mn2, e3.noneOf = function(n4) {
          return nn2(function(t6) {
            return n4.indexOf(t6) < 0;
          }).desc("none of '" + n4 + "'");
        }, e3.notFollowedBy = $3, e3.of = X2, e3.oneOf = function(n4) {
          for (var t6 = n4.split(""), r5 = 0; r5 < t6.length; r5++) t6[r5] = "'" + t6[r5] + "'";
          return nn2(function(t7) {
            return n4.indexOf(t7) >= 0;
          }).desc(t6);
        }, e3.optWhitespace = hn2, e3.Parser = e3, e3.range = function(n4, t6) {
          return nn2(function(r5) {
            return n4 <= r5 && r5 <= t6;
          }).desc(n4 + "-" + t6);
        }, e3.regex = Q2, e3.regexp = Q2, e3.sepBy = V3, e3.sepBy1 = H3, e3.seq = C4, e3.seqMap = J2, e3.seqObj = function() {
          for (var n4, t6 = {}, r5 = 0, u5 = (n4 = arguments, Array.prototype.slice.call(n4)), o5 = u5.length, i5 = 0; i5 < o5; i5 += 1) {
            var a5 = u5[i5];
            if (!y4(a5)) {
              if (E3(a5) && 2 === a5.length && "string" == typeof a5[0] && y4(a5[1])) {
                var f5 = a5[0];
                if (Object.prototype.hasOwnProperty.call(t6, f5)) throw new Error("seqObj: duplicate key " + f5);
                t6[f5] = true, r5++;
                continue;
              }
              throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
            }
          }
          if (0 === r5) throw new Error("seqObj expects at least one named parser, found zero");
          return e3(function(n5, t7) {
            for (var r6, e4 = {}, i6 = 0; i6 < o5; i6 += 1) {
              var a6, f6;
              if (E3(u5[i6]) ? (a6 = u5[i6][0], f6 = u5[i6][1]) : (a6 = null, f6 = u5[i6]), !(r6 = B4(f6._(n5, t7), r6)).status) return r6;
              a6 && (e4[a6] = r6.value), t7 = r6.index;
            }
            return B4(b3(t7, e4), r6);
          });
        }, e3.string = K2, e3.succeed = X2, e3.takeWhile = function(n4) {
          return k4(n4), e3(function(t6, r5) {
            for (var e4 = r5; e4 < t6.length && n4(L3(t6, e4)); ) e4++;
            return b3(e4, t6.slice(r5, e4));
          });
        }, e3.test = nn2, e3.whitespace = pn2, e3["fantasy-land/empty"] = rn2, e3["fantasy-land/of"] = X2, e3.Binary = { bitSeq: l4, bitSeqObj: function(n4) {
          s4();
          var t6 = {}, r5 = 0, e4 = a4(function(n5) {
            if (E3(n5)) {
              var e5 = n5;
              if (2 !== e5.length) throw new Error("[" + e5.join(", ") + "] should be length 2, got length " + e5.length);
              if (P7(e5[0]), O3(e5[1]), Object.prototype.hasOwnProperty.call(t6, e5[0])) throw new Error("duplicate key in bitSeqObj: " + e5[0]);
              return t6[e5[0]] = true, r5++, e5;
            }
            return O3(n5), [null, n5];
          }, n4);
          if (r5 < 1) throw new Error("bitSeqObj expects at least one named pair, got [" + n4.join(", ") + "]");
          var u5 = a4(function(n5) {
            return n5[0];
          }, e4);
          return l4(a4(function(n5) {
            return n5[1];
          }, e4)).map(function(n5) {
            return i4(function(n6, t7) {
              return null !== t7[0] && (n6[t7[0]] = t7[1]), n6;
            }, {}, a4(function(t7, r6) {
              return [t7, n5[r6]];
            }, u5));
          });
        }, byte: function(n4) {
          if (s4(), O3(n4), n4 > 255) throw new Error("Value specified to byte constructor (" + n4 + "=0x" + n4.toString(16) + ") is larger in value than a single byte.");
          var t6 = (n4 > 15 ? "0x" : "0x0") + n4.toString(16);
          return e3(function(r5, e4) {
            var u5 = L3(r5, e4);
            return u5 === n4 ? b3(e4 + 1, u5) : x4(e4, t6);
          });
        }, buffer: function(n4) {
          return h3("buffer", n4).map(function(n5) {
            return Buffer.from(n5);
          });
        }, encodedString: function(n4, t6) {
          return h3("string", t6).map(function(t7) {
            return t7.toString(n4);
          });
        }, uintBE: d3, uint8BE: d3(1), uint16BE: d3(2), uint32BE: d3(4), uintLE: v3, uint8LE: v3(1), uint16LE: v3(2), uint32LE: v3(4), intBE: g4, int8BE: g4(1), int16BE: g4(2), int32BE: g4(4), intLE: m3, int8LE: m3(1), int16LE: m3(2), int32LE: m3(4), floatBE: h3("floatBE", 4).map(function(n4) {
          return n4.readFloatBE(0);
        }), floatLE: h3("floatLE", 4).map(function(n4) {
          return n4.readFloatLE(0);
        }), doubleBE: h3("doubleBE", 8).map(function(n4) {
          return n4.readDoubleBE(0);
        }), doubleLE: h3("doubleLE", 8).map(function(n4) {
          return n4.readDoubleLE(0);
        }) }, n3.exports = e3;
      }]);
    });
  }
});

// node_modules/@jridgewell/set-array/dist/set-array.umd.js
var require_set_array_umd = __commonJS({
  "node_modules/@jridgewell/set-array/dist/set-array.umd.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.setArray = {}));
    })(exports, function(exports2) {
      "use strict";
      class SetArray {
        constructor() {
          this._indexes = { __proto__: null };
          this.array = [];
        }
      }
      function cast(set) {
        return set;
      }
      function get(setarr, key) {
        return cast(setarr)._indexes[key];
      }
      function put(setarr, key) {
        const index2 = get(setarr, key);
        if (index2 !== void 0)
          return index2;
        const { array: array2, _indexes: indexes } = cast(setarr);
        const length2 = array2.push(key);
        return indexes[key] = length2 - 1;
      }
      function pop(setarr) {
        const { array: array2, _indexes: indexes } = cast(setarr);
        if (array2.length === 0)
          return;
        const last = array2.pop();
        indexes[last] = void 0;
      }
      function remove(setarr, key) {
        const index2 = get(setarr, key);
        if (index2 === void 0)
          return;
        const { array: array2, _indexes: indexes } = cast(setarr);
        for (let i4 = index2 + 1; i4 < array2.length; i4++) {
          const k4 = array2[i4];
          array2[i4 - 1] = k4;
          indexes[k4]--;
        }
        indexes[key] = void 0;
        array2.pop();
      }
      exports2.SetArray = SetArray;
      exports2.get = get;
      exports2.pop = pop;
      exports2.put = put;
      exports2.remove = remove;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS({
  "node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.sourcemapCodec = {}));
    })(exports, function(exports2) {
      "use strict";
      const comma2 = ",".charCodeAt(0);
      const semicolon3 = ";".charCodeAt(0);
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      const intToChar = new Uint8Array(64);
      const charToInt = new Uint8Array(128);
      for (let i4 = 0; i4 < chars.length; i4++) {
        const c4 = chars.charCodeAt(i4);
        intToChar[i4] = c4;
        charToInt[c4] = i4;
      }
      function decodeInteger(reader, relative) {
        let value = 0;
        let shift2 = 0;
        let integer = 0;
        do {
          const c4 = reader.next();
          integer = charToInt[c4];
          value |= (integer & 31) << shift2;
          shift2 += 5;
        } while (integer & 32);
        const shouldNegate = value & 1;
        value >>>= 1;
        if (shouldNegate) {
          value = -2147483648 | -value;
        }
        return relative + value;
      }
      function encodeInteger(builder, num, relative) {
        let delta = num - relative;
        delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
        do {
          let clamped = delta & 31;
          delta >>>= 5;
          if (delta > 0)
            clamped |= 32;
          builder.write(intToChar[clamped]);
        } while (delta > 0);
        return num;
      }
      function hasMoreVlq(reader, max2) {
        if (reader.pos >= max2)
          return false;
        return reader.peek() !== comma2;
      }
      const bufLength = 1024 * 16;
      const td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
        decode(buf) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        }
      } : {
        decode(buf) {
          let out = "";
          for (let i4 = 0; i4 < buf.length; i4++) {
            out += String.fromCharCode(buf[i4]);
          }
          return out;
        }
      };
      class StringWriter {
        constructor() {
          this.pos = 0;
          this.out = "";
          this.buffer = new Uint8Array(bufLength);
        }
        write(v3) {
          const { buffer } = this;
          buffer[this.pos++] = v3;
          if (this.pos === bufLength) {
            this.out += td.decode(buffer);
            this.pos = 0;
          }
        }
        flush() {
          const { buffer, out, pos } = this;
          return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
        }
      }
      class StringReader {
        constructor(buffer) {
          this.pos = 0;
          this.buffer = buffer;
        }
        next() {
          return this.buffer.charCodeAt(this.pos++);
        }
        peek() {
          return this.buffer.charCodeAt(this.pos);
        }
        indexOf(char2) {
          const { buffer, pos } = this;
          const idx = buffer.indexOf(char2, pos);
          return idx === -1 ? buffer.length : idx;
        }
      }
      const EMPTY = [];
      function decodeOriginalScopes(input2) {
        const { length: length2 } = input2;
        const reader = new StringReader(input2);
        const scopes = [];
        const stack = [];
        let line2 = 0;
        for (; reader.pos < length2; reader.pos++) {
          line2 = decodeInteger(reader, line2);
          const column2 = decodeInteger(reader, 0);
          if (!hasMoreVlq(reader, length2)) {
            const last = stack.pop();
            last[2] = line2;
            last[3] = column2;
            continue;
          }
          const kind = decodeInteger(reader, 0);
          const fields = decodeInteger(reader, 0);
          const hasName = fields & 1;
          const scope = hasName ? [line2, column2, 0, 0, kind, decodeInteger(reader, 0)] : [line2, column2, 0, 0, kind];
          let vars = EMPTY;
          if (hasMoreVlq(reader, length2)) {
            vars = [];
            do {
              const varsIndex = decodeInteger(reader, 0);
              vars.push(varsIndex);
            } while (hasMoreVlq(reader, length2));
          }
          scope.vars = vars;
          scopes.push(scope);
          stack.push(scope);
        }
        return scopes;
      }
      function encodeOriginalScopes(scopes) {
        const writer = new StringWriter();
        for (let i4 = 0; i4 < scopes.length; ) {
          i4 = _encodeOriginalScopes(scopes, i4, writer, [0]);
        }
        return writer.flush();
      }
      function _encodeOriginalScopes(scopes, index2, writer, state2) {
        const scope = scopes[index2];
        const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;
        if (index2 > 0)
          writer.write(comma2);
        state2[0] = encodeInteger(writer, startLine, state2[0]);
        encodeInteger(writer, startColumn, 0);
        encodeInteger(writer, kind, 0);
        const fields = scope.length === 6 ? 1 : 0;
        encodeInteger(writer, fields, 0);
        if (scope.length === 6)
          encodeInteger(writer, scope[5], 0);
        for (const v3 of vars) {
          encodeInteger(writer, v3, 0);
        }
        for (index2++; index2 < scopes.length; ) {
          const next3 = scopes[index2];
          const { 0: l4, 1: c4 } = next3;
          if (l4 > endLine || l4 === endLine && c4 >= endColumn) {
            break;
          }
          index2 = _encodeOriginalScopes(scopes, index2, writer, state2);
        }
        writer.write(comma2);
        state2[0] = encodeInteger(writer, endLine, state2[0]);
        encodeInteger(writer, endColumn, 0);
        return index2;
      }
      function decodeGeneratedRanges(input2) {
        const { length: length2 } = input2;
        const reader = new StringReader(input2);
        const ranges = [];
        const stack = [];
        let genLine = 0;
        let definitionSourcesIndex = 0;
        let definitionScopeIndex = 0;
        let callsiteSourcesIndex = 0;
        let callsiteLine = 0;
        let callsiteColumn = 0;
        let bindingLine = 0;
        let bindingColumn = 0;
        do {
          const semi = reader.indexOf(";");
          let genColumn = 0;
          for (; reader.pos < semi; reader.pos++) {
            genColumn = decodeInteger(reader, genColumn);
            if (!hasMoreVlq(reader, semi)) {
              const last = stack.pop();
              last[2] = genLine;
              last[3] = genColumn;
              continue;
            }
            const fields = decodeInteger(reader, 0);
            const hasDefinition = fields & 1;
            const hasCallsite = fields & 2;
            const hasScope = fields & 4;
            let callsite = null;
            let bindings = EMPTY;
            let range;
            if (hasDefinition) {
              const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);
              definitionScopeIndex = decodeInteger(reader, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);
              definitionSourcesIndex = defSourcesIndex;
              range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];
            } else {
              range = [genLine, genColumn, 0, 0];
            }
            range.isScope = !!hasScope;
            if (hasCallsite) {
              const prevCsi = callsiteSourcesIndex;
              const prevLine = callsiteLine;
              callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);
              const sameSource = prevCsi === callsiteSourcesIndex;
              callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);
              callsiteColumn = decodeInteger(reader, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);
              callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];
            }
            range.callsite = callsite;
            if (hasMoreVlq(reader, semi)) {
              bindings = [];
              do {
                bindingLine = genLine;
                bindingColumn = genColumn;
                const expressionsCount = decodeInteger(reader, 0);
                let expressionRanges;
                if (expressionsCount < -1) {
                  expressionRanges = [[decodeInteger(reader, 0)]];
                  for (let i4 = -1; i4 > expressionsCount; i4--) {
                    const prevBl = bindingLine;
                    bindingLine = decodeInteger(reader, bindingLine);
                    bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);
                    const expression = decodeInteger(reader, 0);
                    expressionRanges.push([expression, bindingLine, bindingColumn]);
                  }
                } else {
                  expressionRanges = [[expressionsCount]];
                }
                bindings.push(expressionRanges);
              } while (hasMoreVlq(reader, semi));
            }
            range.bindings = bindings;
            ranges.push(range);
            stack.push(range);
          }
          genLine++;
          reader.pos = semi + 1;
        } while (reader.pos < length2);
        return ranges;
      }
      function encodeGeneratedRanges(ranges) {
        if (ranges.length === 0)
          return "";
        const writer = new StringWriter();
        for (let i4 = 0; i4 < ranges.length; ) {
          i4 = _encodeGeneratedRanges(ranges, i4, writer, [0, 0, 0, 0, 0, 0, 0]);
        }
        return writer.flush();
      }
      function _encodeGeneratedRanges(ranges, index2, writer, state2) {
        const range = ranges[index2];
        const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, isScope, callsite, bindings } = range;
        if (state2[0] < startLine) {
          catchupLine(writer, state2[0], startLine);
          state2[0] = startLine;
          state2[1] = 0;
        } else if (index2 > 0) {
          writer.write(comma2);
        }
        state2[1] = encodeInteger(writer, range[1], state2[1]);
        const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);
        encodeInteger(writer, fields, 0);
        if (range.length === 6) {
          const { 4: sourcesIndex, 5: scopesIndex } = range;
          if (sourcesIndex !== state2[2]) {
            state2[3] = 0;
          }
          state2[2] = encodeInteger(writer, sourcesIndex, state2[2]);
          state2[3] = encodeInteger(writer, scopesIndex, state2[3]);
        }
        if (callsite) {
          const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;
          if (sourcesIndex !== state2[4]) {
            state2[5] = 0;
            state2[6] = 0;
          } else if (callLine !== state2[5]) {
            state2[6] = 0;
          }
          state2[4] = encodeInteger(writer, sourcesIndex, state2[4]);
          state2[5] = encodeInteger(writer, callLine, state2[5]);
          state2[6] = encodeInteger(writer, callColumn, state2[6]);
        }
        if (bindings) {
          for (const binding of bindings) {
            if (binding.length > 1)
              encodeInteger(writer, -binding.length, 0);
            const expression = binding[0][0];
            encodeInteger(writer, expression, 0);
            let bindingStartLine = startLine;
            let bindingStartColumn = startColumn;
            for (let i4 = 1; i4 < binding.length; i4++) {
              const expRange = binding[i4];
              bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);
              bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);
              encodeInteger(writer, expRange[0], 0);
            }
          }
        }
        for (index2++; index2 < ranges.length; ) {
          const next3 = ranges[index2];
          const { 0: l4, 1: c4 } = next3;
          if (l4 > endLine || l4 === endLine && c4 >= endColumn) {
            break;
          }
          index2 = _encodeGeneratedRanges(ranges, index2, writer, state2);
        }
        if (state2[0] < endLine) {
          catchupLine(writer, state2[0], endLine);
          state2[0] = endLine;
          state2[1] = 0;
        } else {
          writer.write(comma2);
        }
        state2[1] = encodeInteger(writer, endColumn, state2[1]);
        return index2;
      }
      function catchupLine(writer, lastLine, line2) {
        do {
          writer.write(semicolon3);
        } while (++lastLine < line2);
      }
      function decode(mappings) {
        const { length: length2 } = mappings;
        const reader = new StringReader(mappings);
        const decoded = [];
        let genColumn = 0;
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        do {
          const semi = reader.indexOf(";");
          const line2 = [];
          let sorted = true;
          let lastCol = 0;
          genColumn = 0;
          while (reader.pos < semi) {
            let seg;
            genColumn = decodeInteger(reader, genColumn);
            if (genColumn < lastCol)
              sorted = false;
            lastCol = genColumn;
            if (hasMoreVlq(reader, semi)) {
              sourcesIndex = decodeInteger(reader, sourcesIndex);
              sourceLine = decodeInteger(reader, sourceLine);
              sourceColumn = decodeInteger(reader, sourceColumn);
              if (hasMoreVlq(reader, semi)) {
                namesIndex = decodeInteger(reader, namesIndex);
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
              } else {
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
              }
            } else {
              seg = [genColumn];
            }
            line2.push(seg);
            reader.pos++;
          }
          if (!sorted)
            sort(line2);
          decoded.push(line2);
          reader.pos = semi + 1;
        } while (reader.pos <= length2);
        return decoded;
      }
      function sort(line2) {
        line2.sort(sortComparator);
      }
      function sortComparator(a4, b3) {
        return a4[0] - b3[0];
      }
      function encode(decoded) {
        const writer = new StringWriter();
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        for (let i4 = 0; i4 < decoded.length; i4++) {
          const line2 = decoded[i4];
          if (i4 > 0)
            writer.write(semicolon3);
          if (line2.length === 0)
            continue;
          let genColumn = 0;
          for (let j4 = 0; j4 < line2.length; j4++) {
            const segment = line2[j4];
            if (j4 > 0)
              writer.write(comma2);
            genColumn = encodeInteger(writer, segment[0], genColumn);
            if (segment.length === 1)
              continue;
            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
            sourceLine = encodeInteger(writer, segment[2], sourceLine);
            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
            if (segment.length === 4)
              continue;
            namesIndex = encodeInteger(writer, segment[4], namesIndex);
          }
        }
        return writer.flush();
      }
      exports2.decode = decode;
      exports2.decodeGeneratedRanges = decodeGeneratedRanges;
      exports2.decodeOriginalScopes = decodeOriginalScopes;
      exports2.encode = encode;
      exports2.encodeGeneratedRanges = encodeGeneratedRanges;
      exports2.encodeOriginalScopes = encodeOriginalScopes;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.resolveURI = factory());
    })(exports, function() {
      "use strict";
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function isAbsoluteUrl(input2) {
        return schemeRegex.test(input2);
      }
      function isSchemeRelativeUrl(input2) {
        return input2.startsWith("//");
      }
      function isAbsolutePath(input2) {
        return input2.startsWith("/");
      }
      function isFileUrl(input2) {
        return input2.startsWith("file:");
      }
      function isRelative(input2) {
        return /^[.?#]/.test(input2);
      }
      function parseAbsoluteUrl(input2) {
        const match4 = urlRegex.exec(input2);
        return makeUrl(match4[1], match4[2] || "", match4[3], match4[4] || "", match4[5] || "/", match4[6] || "", match4[7] || "");
      }
      function parseFileUrl(input2) {
        const match4 = fileRegex.exec(input2);
        const path = match4[2];
        return makeUrl("file:", "", match4[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match4[3] || "", match4[4] || "");
      }
      function makeUrl(scheme, user, host, port, path, query, hash2) {
        return {
          scheme,
          user,
          host,
          port,
          path,
          query,
          hash: hash2,
          type: 7
        };
      }
      function parseUrl(input2) {
        if (isSchemeRelativeUrl(input2)) {
          const url2 = parseAbsoluteUrl("http:" + input2);
          url2.scheme = "";
          url2.type = 6;
          return url2;
        }
        if (isAbsolutePath(input2)) {
          const url2 = parseAbsoluteUrl("http://foo.com" + input2);
          url2.scheme = "";
          url2.host = "";
          url2.type = 5;
          return url2;
        }
        if (isFileUrl(input2))
          return parseFileUrl(input2);
        if (isAbsoluteUrl(input2))
          return parseAbsoluteUrl(input2);
        const url = parseAbsoluteUrl("http://foo.com/" + input2);
        url.scheme = "";
        url.host = "";
        url.type = input2 ? input2.startsWith("?") ? 3 : input2.startsWith("#") ? 2 : 4 : 1;
        return url;
      }
      function stripPathFilename(path) {
        if (path.endsWith("/.."))
          return path;
        const index2 = path.lastIndexOf("/");
        return path.slice(0, index2 + 1);
      }
      function mergePaths(url, base) {
        normalizePath(base, base.type);
        if (url.path === "/") {
          url.path = base.path;
        } else {
          url.path = stripPathFilename(base.path) + url.path;
        }
      }
      function normalizePath(url, type) {
        const rel = type <= 4;
        const pieces = url.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i4 = 1; i4 < pieces.length; i4++) {
          const piece = pieces[i4];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path = "";
        for (let i4 = 1; i4 < pointer; i4++) {
          path += "/" + pieces[i4];
        }
        if (!path || addTrailingSlash && !path.endsWith("/..")) {
          path += "/";
        }
        url.path = path;
      }
      function resolve(input2, base) {
        if (!input2 && !base)
          return "";
        const url = parseUrl(input2);
        let inputType = url.type;
        if (base && inputType !== 7) {
          const baseUrl = parseUrl(base);
          const baseType = baseUrl.type;
          switch (inputType) {
            case 1:
              url.hash = baseUrl.hash;
            // fall through
            case 2:
              url.query = baseUrl.query;
            // fall through
            case 3:
            case 4:
              mergePaths(url, baseUrl);
            // fall through
            case 5:
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            // fall through
            case 6:
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
          // This is impossible, because of the empty checks at the start of the function.
          // case UrlType.Empty:
          case 2:
          case 3:
            return queryHash;
          case 4: {
            const path = url.path.slice(1);
            if (!path)
              return queryHash || ".";
            if (isRelative(base || input2) && !isRelative(path)) {
              return "./" + path + queryHash;
            }
            return path + queryHash;
          }
          case 5:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve;
    });
  }
});

// node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var require_trace_mapping_umd = __commonJS({
  "node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports, require_sourcemap_codec_umd(), require_resolve_uri_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/sourcemap-codec", "@jridgewell/resolve-uri"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.traceMapping = {}, global2.sourcemapCodec, global2.resolveURI));
    })(exports, function(exports2, sourcemapCodec, resolveUri) {
      "use strict";
      function resolve(input2, base) {
        if (base && !base.endsWith("/"))
          base += "/";
        return resolveUri(input2, base);
      }
      function stripFilename(path) {
        if (!path)
          return "";
        const index2 = path.lastIndexOf("/");
        return path.slice(0, index2 + 1);
      }
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const REV_GENERATED_LINE = 1;
      const REV_GENERATED_COLUMN = 2;
      function maybeSort(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length)
          return mappings;
        if (!owned)
          mappings = mappings.slice();
        for (let i4 = unsortedIndex; i4 < mappings.length; i4 = nextUnsortedSegmentLine(mappings, i4 + 1)) {
          mappings[i4] = sortSegments(mappings[i4], owned);
        }
        return mappings;
      }
      function nextUnsortedSegmentLine(mappings, start) {
        for (let i4 = start; i4 < mappings.length; i4++) {
          if (!isSorted(mappings[i4]))
            return i4;
        }
        return mappings.length;
      }
      function isSorted(line2) {
        for (let j4 = 1; j4 < line2.length; j4++) {
          if (line2[j4][COLUMN] < line2[j4 - 1][COLUMN]) {
            return false;
          }
        }
        return true;
      }
      function sortSegments(line2, owned) {
        if (!owned)
          line2 = line2.slice();
        return line2.sort(sortComparator);
      }
      function sortComparator(a4, b3) {
        return a4[COLUMN] - b3[COLUMN];
      }
      let found = false;
      function binarySearch(haystack, needle, low, high) {
        while (low <= high) {
          const mid = low + (high - low >> 1);
          const cmp = haystack[mid][COLUMN] - needle;
          if (cmp === 0) {
            found = true;
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        found = false;
        return low - 1;
      }
      function upperBound(haystack, needle, index2) {
        for (let i4 = index2 + 1; i4 < haystack.length; index2 = i4++) {
          if (haystack[i4][COLUMN] !== needle)
            break;
        }
        return index2;
      }
      function lowerBound(haystack, needle, index2) {
        for (let i4 = index2 - 1; i4 >= 0; index2 = i4--) {
          if (haystack[i4][COLUMN] !== needle)
            break;
        }
        return index2;
      }
      function memoizedState() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function memoizedBinarySearch(haystack, needle, state2, key) {
        const { lastKey, lastNeedle, lastIndex } = state2;
        let low = 0;
        let high = haystack.length - 1;
        if (key === lastKey) {
          if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
          }
          if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
          } else {
            high = lastIndex;
          }
        }
        state2.lastKey = key;
        state2.lastNeedle = needle;
        return state2.lastIndex = binarySearch(haystack, needle, low, high);
      }
      function buildBySources(decoded, memos) {
        const sources = memos.map(buildNullArray);
        for (let i4 = 0; i4 < decoded.length; i4++) {
          const line2 = decoded[i4];
          for (let j4 = 0; j4 < line2.length; j4++) {
            const seg = line2[j4];
            if (seg.length === 1)
              continue;
            const sourceIndex2 = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const originalSource = sources[sourceIndex2];
            const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
            const memo = memos[sourceIndex2];
            let index2 = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
            memo.lastIndex = ++index2;
            insert(originalLine, index2, [sourceColumn, i4, seg[COLUMN]]);
          }
        }
        return sources;
      }
      function insert(array2, index2, value) {
        for (let i4 = array2.length; i4 > index2; i4--) {
          array2[i4] = array2[i4 - 1];
        }
        array2[index2] = value;
      }
      function buildNullArray() {
        return { __proto__: null };
      }
      const AnyMap = function(map, mapUrl) {
        const parsed = parse5(map);
        if (!("sections" in parsed)) {
          return new TraceMap(parsed, mapUrl);
        }
        const mappings = [];
        const sources = [];
        const sourcesContent = [];
        const names = [];
        const ignoreList = [];
        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);
        const joined = {
          version: 3,
          file: parsed.file,
          names,
          sources,
          sourcesContent,
          mappings,
          ignoreList
        };
        return presortedDecodedMap(joined);
      };
      function parse5(map) {
        return typeof map === "string" ? JSON.parse(map) : map;
      }
      function recurse(input2, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const { sections } = input2;
        for (let i4 = 0; i4 < sections.length; i4++) {
          const { map, offset: offset3 } = sections[i4];
          let sl = stopLine;
          let sc = stopColumn;
          if (i4 + 1 < sections.length) {
            const nextOffset = sections[i4 + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) {
              sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            } else if (sl < stopLine) {
              sc = columnOffset + nextOffset.column;
            }
          }
          addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset3.line, columnOffset + offset3.column, sl, sc);
        }
      }
      function addSection(input2, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const parsed = parse5(input2);
        if ("sections" in parsed)
          return recurse(...arguments);
        const map = new TraceMap(parsed, mapUrl);
        const sourcesOffset = sources.length;
        const namesOffset = names.length;
        const decoded = decodedMappings(map);
        const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;
        append2(sources, resolvedSources);
        append2(names, map.names);
        if (contents)
          append2(sourcesContent, contents);
        else
          for (let i4 = 0; i4 < resolvedSources.length; i4++)
            sourcesContent.push(null);
        if (ignores)
          for (let i4 = 0; i4 < ignores.length; i4++)
            ignoreList.push(ignores[i4] + sourcesOffset);
        for (let i4 = 0; i4 < decoded.length; i4++) {
          const lineI = lineOffset + i4;
          if (lineI > stopLine)
            return;
          const out = getLine(mappings, lineI);
          const cOffset = i4 === 0 ? columnOffset : 0;
          const line2 = decoded[i4];
          for (let j4 = 0; j4 < line2.length; j4++) {
            const seg = line2[j4];
            const column2 = cOffset + seg[COLUMN];
            if (lineI === stopLine && column2 >= stopColumn)
              return;
            if (seg.length === 1) {
              out.push([column2]);
              continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            out.push(seg.length === 4 ? [column2, sourcesIndex, sourceLine, sourceColumn] : [column2, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
          }
        }
      }
      function append2(arr, other) {
        for (let i4 = 0; i4 < other.length; i4++)
          arr.push(other[i4]);
      }
      function getLine(arr, index2) {
        for (let i4 = arr.length; i4 <= index2; i4++)
          arr[i4] = [];
        return arr[index2];
      }
      const LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
      const COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
      const LEAST_UPPER_BOUND = -1;
      const GREATEST_LOWER_BOUND = 1;
      class TraceMap {
        constructor(map, mapUrl) {
          const isString2 = typeof map === "string";
          if (!isString2 && map._decodedMemo)
            return map;
          const parsed = isString2 ? JSON.parse(map) : map;
          const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
          this.version = version;
          this.file = file;
          this.names = names || [];
          this.sourceRoot = sourceRoot;
          this.sources = sources;
          this.sourcesContent = sourcesContent;
          this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
          const from2 = resolve(sourceRoot || "", stripFilename(mapUrl));
          this.resolvedSources = sources.map((s4) => resolve(s4 || "", from2));
          const { mappings } = parsed;
          if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
          } else {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString2);
          }
          this._decodedMemo = memoizedState();
          this._bySources = void 0;
          this._bySourceMemos = void 0;
        }
      }
      function cast(map) {
        return map;
      }
      function encodedMappings(map) {
        var _a;
        var _b;
        return (_a = (_b = cast(map))._encoded) !== null && _a !== void 0 ? _a : _b._encoded = sourcemapCodec.encode(cast(map)._decoded);
      }
      function decodedMappings(map) {
        var _a;
        return (_a = cast(map))._decoded || (_a._decoded = sourcemapCodec.decode(cast(map)._encoded));
      }
      function traceSegment(map, line2, column2) {
        const decoded = decodedMappings(map);
        if (line2 >= decoded.length)
          return null;
        const segments = decoded[line2];
        const index2 = traceSegmentInternal(segments, cast(map)._decodedMemo, line2, column2, GREATEST_LOWER_BOUND);
        return index2 === -1 ? null : segments[index2];
      }
      function originalPositionFor(map, needle) {
        let { line: line2, column: column2, bias } = needle;
        line2--;
        if (line2 < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column2 < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        const decoded = decodedMappings(map);
        if (line2 >= decoded.length)
          return OMapping(null, null, null, null);
        const segments = decoded[line2];
        const index2 = traceSegmentInternal(segments, cast(map)._decodedMemo, line2, column2, bias || GREATEST_LOWER_BOUND);
        if (index2 === -1)
          return OMapping(null, null, null, null);
        const segment = segments[index2];
        if (segment.length === 1)
          return OMapping(null, null, null, null);
        const { names, resolvedSources } = map;
        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
      }
      function generatedPositionFor(map, needle) {
        const { source, line: line2, column: column2, bias } = needle;
        return generatedPosition(map, source, line2, column2, bias || GREATEST_LOWER_BOUND, false);
      }
      function allGeneratedPositionsFor(map, needle) {
        const { source, line: line2, column: column2, bias } = needle;
        return generatedPosition(map, source, line2, column2, bias || LEAST_UPPER_BOUND, true);
      }
      function eachMapping(map, cb) {
        const decoded = decodedMappings(map);
        const { names, resolvedSources } = map;
        for (let i4 = 0; i4 < decoded.length; i4++) {
          const line2 = decoded[i4];
          for (let j4 = 0; j4 < line2.length; j4++) {
            const seg = line2[j4];
            const generatedLine = i4 + 1;
            const generatedColumn = seg[0];
            let source = null;
            let originalLine = null;
            let originalColumn = null;
            let name = null;
            if (seg.length !== 1) {
              source = resolvedSources[seg[1]];
              originalLine = seg[2] + 1;
              originalColumn = seg[3];
            }
            if (seg.length === 5)
              name = names[seg[4]];
            cb({
              generatedLine,
              generatedColumn,
              source,
              originalLine,
              originalColumn,
              name
            });
          }
        }
      }
      function sourceIndex(map, source) {
        const { sources, resolvedSources } = map;
        let index2 = sources.indexOf(source);
        if (index2 === -1)
          index2 = resolvedSources.indexOf(source);
        return index2;
      }
      function sourceContentFor(map, source) {
        const { sourcesContent } = map;
        if (sourcesContent == null)
          return null;
        const index2 = sourceIndex(map, source);
        return index2 === -1 ? null : sourcesContent[index2];
      }
      function isIgnored(map, source) {
        const { ignoreList } = map;
        if (ignoreList == null)
          return false;
        const index2 = sourceIndex(map, source);
        return index2 === -1 ? false : ignoreList.includes(index2);
      }
      function presortedDecodedMap(map, mapUrl) {
        const tracer = new TraceMap(clone3(map, []), mapUrl);
        cast(tracer)._decoded = map.mappings;
        return tracer;
      }
      function decodedMap(map) {
        return clone3(map, decodedMappings(map));
      }
      function encodedMap(map) {
        return clone3(map, encodedMappings(map));
      }
      function clone3(map, mappings) {
        return {
          version: map.version,
          file: map.file,
          names: map.names,
          sourceRoot: map.sourceRoot,
          sources: map.sources,
          sourcesContent: map.sourcesContent,
          mappings,
          ignoreList: map.ignoreList || map.x_google_ignoreList
        };
      }
      function OMapping(source, line2, column2, name) {
        return { source, line: line2, column: column2, name };
      }
      function GMapping(line2, column2) {
        return { line: line2, column: column2 };
      }
      function traceSegmentInternal(segments, memo, line2, column2, bias) {
        let index2 = memoizedBinarySearch(segments, column2, memo, line2);
        if (found) {
          index2 = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column2, index2);
        } else if (bias === LEAST_UPPER_BOUND)
          index2++;
        if (index2 === -1 || index2 === segments.length)
          return -1;
        return index2;
      }
      function sliceGeneratedPositions(segments, memo, line2, column2, bias) {
        let min2 = traceSegmentInternal(segments, memo, line2, column2, GREATEST_LOWER_BOUND);
        if (!found && bias === LEAST_UPPER_BOUND)
          min2++;
        if (min2 === -1 || min2 === segments.length)
          return [];
        const matchedColumn = found ? column2 : segments[min2][COLUMN];
        if (!found)
          min2 = lowerBound(segments, matchedColumn, min2);
        const max2 = upperBound(segments, matchedColumn, min2);
        const result = [];
        for (; min2 <= max2; min2++) {
          const segment = segments[min2];
          result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
        }
        return result;
      }
      function generatedPosition(map, source, line2, column2, bias, all) {
        var _a;
        line2--;
        if (line2 < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column2 < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        const { sources, resolvedSources } = map;
        let sourceIndex2 = sources.indexOf(source);
        if (sourceIndex2 === -1)
          sourceIndex2 = resolvedSources.indexOf(source);
        if (sourceIndex2 === -1)
          return all ? [] : GMapping(null, null);
        const generated = (_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), cast(map)._bySourceMemos = sources.map(memoizedState)));
        const segments = generated[sourceIndex2][line2];
        if (segments == null)
          return all ? [] : GMapping(null, null);
        const memo = cast(map)._bySourceMemos[sourceIndex2];
        if (all)
          return sliceGeneratedPositions(segments, memo, line2, column2, bias);
        const index2 = traceSegmentInternal(segments, memo, line2, column2, bias);
        if (index2 === -1)
          return GMapping(null, null);
        const segment = segments[index2];
        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
      }
      exports2.AnyMap = AnyMap;
      exports2.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;
      exports2.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;
      exports2.TraceMap = TraceMap;
      exports2.allGeneratedPositionsFor = allGeneratedPositionsFor;
      exports2.decodedMap = decodedMap;
      exports2.decodedMappings = decodedMappings;
      exports2.eachMapping = eachMapping;
      exports2.encodedMap = encodedMap;
      exports2.encodedMappings = encodedMappings;
      exports2.generatedPositionFor = generatedPositionFor;
      exports2.isIgnored = isIgnored;
      exports2.originalPositionFor = originalPositionFor;
      exports2.presortedDecodedMap = presortedDecodedMap;
      exports2.sourceContentFor = sourceContentFor;
      exports2.traceSegment = traceSegment;
    });
  }
});

// node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var require_gen_mapping_umd = __commonJS({
  "node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports, require_set_array_umd(), require_sourcemap_codec_umd(), require_trace_mapping_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.genMapping = {}, global2.setArray, global2.sourcemapCodec, global2.traceMapping));
    })(exports, function(exports2, setArray, sourcemapCodec, traceMapping) {
      "use strict";
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const NO_NAME = -1;
      class GenMapping2 {
        constructor({ file, sourceRoot } = {}) {
          this._names = new setArray.SetArray();
          this._sources = new setArray.SetArray();
          this._sourcesContent = [];
          this._mappings = [];
          this.file = file;
          this.sourceRoot = sourceRoot;
          this._ignoreList = new setArray.SetArray();
        }
      }
      function cast(map) {
        return map;
      }
      function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
      }
      function addMapping(map, mapping) {
        return addMappingInternal(false, map, mapping);
      }
      const maybeAddSegment2 = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
      };
      const maybeAddMapping = (map, mapping) => {
        return addMappingInternal(true, map, mapping);
      };
      function setSourceContent(map, source, content) {
        const { _sources: sources, _sourcesContent: sourcesContent } = cast(map);
        const index2 = setArray.put(sources, source);
        sourcesContent[index2] = content;
      }
      function setIgnore(map, source, ignore = true) {
        const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast(map);
        const index2 = setArray.put(sources, source);
        if (index2 === sourcesContent.length)
          sourcesContent[index2] = null;
        if (ignore)
          setArray.put(ignoreList, index2);
        else
          setArray.remove(ignoreList, index2);
      }
      function toDecodedMap(map) {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList } = cast(map);
        removeEmptyFinalLines(mappings);
        return {
          version: 3,
          file: map.file || void 0,
          names: names.array,
          sourceRoot: map.sourceRoot || void 0,
          sources: sources.array,
          sourcesContent,
          mappings,
          ignoreList: ignoreList.array
        };
      }
      function toEncodedMap2(map) {
        const decoded = toDecodedMap(map);
        return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });
      }
      function fromMap(input2) {
        const map = new traceMapping.TraceMap(input2);
        const gen = new GenMapping2({ file: map.file, sourceRoot: map.sourceRoot });
        putAll(cast(gen)._names, map.names);
        putAll(cast(gen)._sources, map.sources);
        cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);
        cast(gen)._mappings = traceMapping.decodedMappings(map);
        if (map.ignoreList)
          putAll(cast(gen)._ignoreList, map.ignoreList);
        return gen;
      }
      function allMappings(map) {
        const out = [];
        const { _mappings: mappings, _sources: sources, _names: names } = cast(map);
        for (let i4 = 0; i4 < mappings.length; i4++) {
          const line2 = mappings[i4];
          for (let j4 = 0; j4 < line2.length; j4++) {
            const seg = line2[j4];
            const generated = { line: i4 + 1, column: seg[COLUMN] };
            let source = void 0;
            let original = void 0;
            let name = void 0;
            if (seg.length !== 1) {
              source = sources.array[seg[SOURCES_INDEX]];
              original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
              if (seg.length === 5)
                name = names.array[seg[NAMES_INDEX]];
            }
            out.push({ generated, source, original, name });
          }
        }
        return out;
      }
      function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = cast(map);
        const line2 = getLine(mappings, genLine);
        const index2 = getColumnIndex(line2, genColumn);
        if (!source) {
          if (skipable && skipSourceless(line2, index2))
            return;
          return insert(line2, index2, [genColumn]);
        }
        const sourcesIndex = setArray.put(sources, source);
        const namesIndex = name ? setArray.put(names, name) : NO_NAME;
        if (sourcesIndex === sourcesContent.length)
          sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
        if (skipable && skipSource(line2, index2, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
          return;
        }
        return insert(line2, index2, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
      }
      function getLine(mappings, index2) {
        for (let i4 = mappings.length; i4 <= index2; i4++) {
          mappings[i4] = [];
        }
        return mappings[index2];
      }
      function getColumnIndex(line2, genColumn) {
        let index2 = line2.length;
        for (let i4 = index2 - 1; i4 >= 0; index2 = i4--) {
          const current = line2[i4];
          if (genColumn >= current[COLUMN])
            break;
        }
        return index2;
      }
      function insert(array2, index2, value) {
        for (let i4 = array2.length; i4 > index2; i4--) {
          array2[i4] = array2[i4 - 1];
        }
        array2[index2] = value;
      }
      function removeEmptyFinalLines(mappings) {
        const { length: length2 } = mappings;
        let len = length2;
        for (let i4 = len - 1; i4 >= 0; len = i4, i4--) {
          if (mappings[i4].length > 0)
            break;
        }
        if (len < length2)
          mappings.length = len;
      }
      function putAll(setarr, array2) {
        for (let i4 = 0; i4 < array2.length; i4++)
          setArray.put(setarr, array2[i4]);
      }
      function skipSourceless(line2, index2) {
        if (index2 === 0)
          return true;
        const prev2 = line2[index2 - 1];
        return prev2.length === 1;
      }
      function skipSource(line2, index2, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        if (index2 === 0)
          return false;
        const prev2 = line2[index2 - 1];
        if (prev2.length === 1)
          return false;
        return sourcesIndex === prev2[SOURCES_INDEX] && sourceLine === prev2[SOURCE_LINE] && sourceColumn === prev2[SOURCE_COLUMN] && namesIndex === (prev2.length === 5 ? prev2[NAMES_INDEX] : NO_NAME);
      }
      function addMappingInternal(skipable, map, mapping) {
        const { generated, source, original, name, content } = mapping;
        if (!source) {
          return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
        }
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);
      }
      exports2.GenMapping = GenMapping2;
      exports2.addMapping = addMapping;
      exports2.addSegment = addSegment;
      exports2.allMappings = allMappings;
      exports2.fromMap = fromMap;
      exports2.maybeAddMapping = maybeAddMapping;
      exports2.maybeAddSegment = maybeAddSegment2;
      exports2.setIgnore = setIgnore;
      exports2.setSourceContent = setSourceContent;
      exports2.toDecodedMap = toDecodedMap;
      exports2.toEncodedMap = toEncodedMap2;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/ts-interface-checker/dist/util.js
var require_util = __commonJS({
  "node_modules/ts-interface-checker/dist/util.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4) if (b4.hasOwnProperty(p3)) d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DetailContext = exports.NoopContext = exports.VError = void 0;
    var VError = (
      /** @class */
      function(_super) {
        __extends(VError2, _super);
        function VError2(path, message) {
          var _this = _super.call(this, message) || this;
          _this.path = path;
          Object.setPrototypeOf(_this, VError2.prototype);
          return _this;
        }
        return VError2;
      }(Error)
    );
    exports.VError = VError;
    var NoopContext = (
      /** @class */
      function() {
        function NoopContext2() {
        }
        NoopContext2.prototype.fail = function(relPath, message, score2) {
          return false;
        };
        NoopContext2.prototype.unionResolver = function() {
          return this;
        };
        NoopContext2.prototype.createContext = function() {
          return this;
        };
        NoopContext2.prototype.resolveUnion = function(ur) {
        };
        return NoopContext2;
      }()
    );
    exports.NoopContext = NoopContext;
    var DetailContext = (
      /** @class */
      function() {
        function DetailContext2() {
          this._propNames = [""];
          this._messages = [null];
          this._score = 0;
        }
        DetailContext2.prototype.fail = function(relPath, message, score2) {
          this._propNames.push(relPath);
          this._messages.push(message);
          this._score += score2;
          return false;
        };
        DetailContext2.prototype.unionResolver = function() {
          return new DetailUnionResolver();
        };
        DetailContext2.prototype.resolveUnion = function(unionResolver) {
          var _a, _b;
          var u4 = unionResolver;
          var best = null;
          for (var _i = 0, _c = u4.contexts; _i < _c.length; _i++) {
            var ctx = _c[_i];
            if (!best || ctx._score >= best._score) {
              best = ctx;
            }
          }
          if (best && best._score > 0) {
            (_a = this._propNames).push.apply(_a, best._propNames);
            (_b = this._messages).push.apply(_b, best._messages);
          }
        };
        DetailContext2.prototype.getError = function(path) {
          var msgParts = [];
          for (var i4 = this._propNames.length - 1; i4 >= 0; i4--) {
            var p3 = this._propNames[i4];
            path += typeof p3 === "number" ? "[" + p3 + "]" : p3 ? "." + p3 : "";
            var m3 = this._messages[i4];
            if (m3) {
              msgParts.push(path + " " + m3);
            }
          }
          return new VError(path, msgParts.join("; "));
        };
        DetailContext2.prototype.getErrorDetail = function(path) {
          var details = [];
          for (var i4 = this._propNames.length - 1; i4 >= 0; i4--) {
            var p3 = this._propNames[i4];
            path += typeof p3 === "number" ? "[" + p3 + "]" : p3 ? "." + p3 : "";
            var message = this._messages[i4];
            if (message) {
              details.push({ path, message });
            }
          }
          var detail = null;
          for (var i4 = details.length - 1; i4 >= 0; i4--) {
            if (detail) {
              details[i4].nested = [detail];
            }
            detail = details[i4];
          }
          return detail;
        };
        return DetailContext2;
      }()
    );
    exports.DetailContext = DetailContext;
    var DetailUnionResolver = (
      /** @class */
      function() {
        function DetailUnionResolver2() {
          this.contexts = [];
        }
        DetailUnionResolver2.prototype.createContext = function() {
          var ctx = new DetailContext();
          this.contexts.push(ctx);
          return ctx;
        };
        return DetailUnionResolver2;
      }()
    );
  }
});

// node_modules/ts-interface-checker/dist/types.js
var require_types = __commonJS({
  "node_modules/ts-interface-checker/dist/types.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4) if (b4.hasOwnProperty(p3)) d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.basicTypes = exports.BasicType = exports.TParamList = exports.TParam = exports.param = exports.TFunc = exports.func = exports.TProp = exports.TOptional = exports.opt = exports.TIface = exports.iface = exports.TEnumLiteral = exports.enumlit = exports.TEnumType = exports.enumtype = exports.TIntersection = exports.intersection = exports.TUnion = exports.union = exports.TTuple = exports.tuple = exports.TArray = exports.array = exports.TLiteral = exports.lit = exports.TName = exports.name = exports.TType = void 0;
    var util_1 = require_util();
    var TType = (
      /** @class */
      /* @__PURE__ */ function() {
        function TType2() {
        }
        return TType2;
      }()
    );
    exports.TType = TType;
    function parseSpec(typeSpec) {
      return typeof typeSpec === "string" ? name(typeSpec) : typeSpec;
    }
    function getNamedType(suite, name2) {
      var ttype = suite[name2];
      if (!ttype) {
        throw new Error("Unknown type " + name2);
      }
      return ttype;
    }
    function name(value) {
      return new TName(value);
    }
    exports.name = name;
    var TName = (
      /** @class */
      function(_super) {
        __extends(TName2, _super);
        function TName2(name2) {
          var _this = _super.call(this) || this;
          _this.name = name2;
          _this._failMsg = "is not a " + name2;
          return _this;
        }
        TName2.prototype.getChecker = function(suite, strict, allowedProps) {
          var _this = this;
          var ttype = getNamedType(suite, this.name);
          var checker = ttype.getChecker(suite, strict, allowedProps);
          if (ttype instanceof BasicType || ttype instanceof TName2) {
            return checker;
          }
          return function(value, ctx) {
            return checker(value, ctx) ? true : ctx.fail(null, _this._failMsg, 0);
          };
        };
        return TName2;
      }(TType)
    );
    exports.TName = TName;
    function lit2(value) {
      return new TLiteral(value);
    }
    exports.lit = lit2;
    var TLiteral = (
      /** @class */
      function(_super) {
        __extends(TLiteral2, _super);
        function TLiteral2(value) {
          var _this = _super.call(this) || this;
          _this.value = value;
          _this.name = JSON.stringify(value);
          _this._failMsg = "is not " + _this.name;
          return _this;
        }
        TLiteral2.prototype.getChecker = function(suite, strict) {
          var _this = this;
          return function(value, ctx) {
            return value === _this.value ? true : ctx.fail(null, _this._failMsg, -1);
          };
        };
        return TLiteral2;
      }(TType)
    );
    exports.TLiteral = TLiteral;
    function array2(typeSpec) {
      return new TArray(parseSpec(typeSpec));
    }
    exports.array = array2;
    var TArray = (
      /** @class */
      function(_super) {
        __extends(TArray2, _super);
        function TArray2(ttype) {
          var _this = _super.call(this) || this;
          _this.ttype = ttype;
          return _this;
        }
        TArray2.prototype.getChecker = function(suite, strict) {
          var itemChecker = this.ttype.getChecker(suite, strict);
          return function(value, ctx) {
            if (!Array.isArray(value)) {
              return ctx.fail(null, "is not an array", 0);
            }
            for (var i4 = 0; i4 < value.length; i4++) {
              var ok = itemChecker(value[i4], ctx);
              if (!ok) {
                return ctx.fail(i4, null, 1);
              }
            }
            return true;
          };
        };
        return TArray2;
      }(TType)
    );
    exports.TArray = TArray;
    function tuple() {
      var typeSpec = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        typeSpec[_i2] = arguments[_i2];
      }
      return new TTuple(typeSpec.map(function(t5) {
        return parseSpec(t5);
      }));
    }
    exports.tuple = tuple;
    var TTuple = (
      /** @class */
      function(_super) {
        __extends(TTuple2, _super);
        function TTuple2(ttypes) {
          var _this = _super.call(this) || this;
          _this.ttypes = ttypes;
          return _this;
        }
        TTuple2.prototype.getChecker = function(suite, strict) {
          var itemCheckers = this.ttypes.map(function(t5) {
            return t5.getChecker(suite, strict);
          });
          var checker = function(value, ctx) {
            if (!Array.isArray(value)) {
              return ctx.fail(null, "is not an array", 0);
            }
            for (var i4 = 0; i4 < itemCheckers.length; i4++) {
              var ok = itemCheckers[i4](value[i4], ctx);
              if (!ok) {
                return ctx.fail(i4, null, 1);
              }
            }
            return true;
          };
          if (!strict) {
            return checker;
          }
          return function(value, ctx) {
            if (!checker(value, ctx)) {
              return false;
            }
            return value.length <= itemCheckers.length ? true : ctx.fail(itemCheckers.length, "is extraneous", 2);
          };
        };
        return TTuple2;
      }(TType)
    );
    exports.TTuple = TTuple;
    function union2() {
      var typeSpec = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        typeSpec[_i2] = arguments[_i2];
      }
      return new TUnion(typeSpec.map(function(t5) {
        return parseSpec(t5);
      }));
    }
    exports.union = union2;
    var TUnion = (
      /** @class */
      function(_super) {
        __extends(TUnion2, _super);
        function TUnion2(ttypes) {
          var _this = _super.call(this) || this;
          _this.ttypes = ttypes;
          var names = ttypes.map(function(t5) {
            return t5 instanceof TName || t5 instanceof TLiteral ? t5.name : null;
          }).filter(function(n3) {
            return n3;
          });
          var otherTypes = ttypes.length - names.length;
          if (names.length) {
            if (otherTypes > 0) {
              names.push(otherTypes + " more");
            }
            _this._failMsg = "is none of " + names.join(", ");
          } else {
            _this._failMsg = "is none of " + otherTypes + " types";
          }
          return _this;
        }
        TUnion2.prototype.getChecker = function(suite, strict) {
          var _this = this;
          var itemCheckers = this.ttypes.map(function(t5) {
            return t5.getChecker(suite, strict);
          });
          return function(value, ctx) {
            var ur = ctx.unionResolver();
            for (var i4 = 0; i4 < itemCheckers.length; i4++) {
              var ok = itemCheckers[i4](value, ur.createContext());
              if (ok) {
                return true;
              }
            }
            ctx.resolveUnion(ur);
            return ctx.fail(null, _this._failMsg, 0);
          };
        };
        return TUnion2;
      }(TType)
    );
    exports.TUnion = TUnion;
    function intersection() {
      var typeSpec = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        typeSpec[_i2] = arguments[_i2];
      }
      return new TIntersection(typeSpec.map(function(t5) {
        return parseSpec(t5);
      }));
    }
    exports.intersection = intersection;
    var TIntersection = (
      /** @class */
      function(_super) {
        __extends(TIntersection2, _super);
        function TIntersection2(ttypes) {
          var _this = _super.call(this) || this;
          _this.ttypes = ttypes;
          return _this;
        }
        TIntersection2.prototype.getChecker = function(suite, strict) {
          var allowedProps = /* @__PURE__ */ new Set();
          var itemCheckers = this.ttypes.map(function(t5) {
            return t5.getChecker(suite, strict, allowedProps);
          });
          return function(value, ctx) {
            var ok = itemCheckers.every(function(checker) {
              return checker(value, ctx);
            });
            if (ok) {
              return true;
            }
            return ctx.fail(null, null, 0);
          };
        };
        return TIntersection2;
      }(TType)
    );
    exports.TIntersection = TIntersection;
    function enumtype(values) {
      return new TEnumType(values);
    }
    exports.enumtype = enumtype;
    var TEnumType = (
      /** @class */
      function(_super) {
        __extends(TEnumType2, _super);
        function TEnumType2(members) {
          var _this = _super.call(this) || this;
          _this.members = members;
          _this.validValues = /* @__PURE__ */ new Set();
          _this._failMsg = "is not a valid enum value";
          _this.validValues = new Set(Object.keys(members).map(function(name2) {
            return members[name2];
          }));
          return _this;
        }
        TEnumType2.prototype.getChecker = function(suite, strict) {
          var _this = this;
          return function(value, ctx) {
            return _this.validValues.has(value) ? true : ctx.fail(null, _this._failMsg, 0);
          };
        };
        return TEnumType2;
      }(TType)
    );
    exports.TEnumType = TEnumType;
    function enumlit(name2, prop) {
      return new TEnumLiteral(name2, prop);
    }
    exports.enumlit = enumlit;
    var TEnumLiteral = (
      /** @class */
      function(_super) {
        __extends(TEnumLiteral2, _super);
        function TEnumLiteral2(enumName, prop) {
          var _this = _super.call(this) || this;
          _this.enumName = enumName;
          _this.prop = prop;
          _this._failMsg = "is not " + enumName + "." + prop;
          return _this;
        }
        TEnumLiteral2.prototype.getChecker = function(suite, strict) {
          var _this = this;
          var ttype = getNamedType(suite, this.enumName);
          if (!(ttype instanceof TEnumType)) {
            throw new Error("Type " + this.enumName + " used in enumlit is not an enum type");
          }
          var val = ttype.members[this.prop];
          if (!ttype.members.hasOwnProperty(this.prop)) {
            throw new Error("Unknown value " + this.enumName + "." + this.prop + " used in enumlit");
          }
          return function(value, ctx) {
            return value === val ? true : ctx.fail(null, _this._failMsg, -1);
          };
        };
        return TEnumLiteral2;
      }(TType)
    );
    exports.TEnumLiteral = TEnumLiteral;
    function makeIfaceProps(props) {
      return Object.keys(props).map(function(name2) {
        return makeIfaceProp(name2, props[name2]);
      });
    }
    function makeIfaceProp(name2, prop) {
      return prop instanceof TOptional ? new TProp(name2, prop.ttype, true) : new TProp(name2, parseSpec(prop), false);
    }
    function iface2(bases, props) {
      return new TIface(bases, makeIfaceProps(props));
    }
    exports.iface = iface2;
    var TIface = (
      /** @class */
      function(_super) {
        __extends(TIface2, _super);
        function TIface2(bases, props) {
          var _this = _super.call(this) || this;
          _this.bases = bases;
          _this.props = props;
          _this.propSet = new Set(props.map(function(p3) {
            return p3.name;
          }));
          return _this;
        }
        TIface2.prototype.getChecker = function(suite, strict, allowedProps) {
          var _this = this;
          var baseCheckers = this.bases.map(function(b3) {
            return getNamedType(suite, b3).getChecker(suite, strict);
          });
          var propCheckers = this.props.map(function(prop) {
            return prop.ttype.getChecker(suite, strict);
          });
          var testCtx = new util_1.NoopContext();
          var isPropRequired = this.props.map(function(prop, i4) {
            return !prop.isOpt && !propCheckers[i4](void 0, testCtx);
          });
          var checker = function(value, ctx) {
            if (typeof value !== "object" || value === null) {
              return ctx.fail(null, "is not an object", 0);
            }
            for (var i4 = 0; i4 < baseCheckers.length; i4++) {
              if (!baseCheckers[i4](value, ctx)) {
                return false;
              }
            }
            for (var i4 = 0; i4 < propCheckers.length; i4++) {
              var name_1 = _this.props[i4].name;
              var v3 = value[name_1];
              if (v3 === void 0) {
                if (isPropRequired[i4]) {
                  return ctx.fail(name_1, "is missing", 1);
                }
              } else {
                var ok = propCheckers[i4](v3, ctx);
                if (!ok) {
                  return ctx.fail(name_1, null, 1);
                }
              }
            }
            return true;
          };
          if (!strict) {
            return checker;
          }
          var propSet = this.propSet;
          if (allowedProps) {
            this.propSet.forEach(function(prop) {
              return allowedProps.add(prop);
            });
            propSet = allowedProps;
          }
          return function(value, ctx) {
            if (!checker(value, ctx)) {
              return false;
            }
            for (var prop in value) {
              if (!propSet.has(prop)) {
                return ctx.fail(prop, "is extraneous", 2);
              }
            }
            return true;
          };
        };
        return TIface2;
      }(TType)
    );
    exports.TIface = TIface;
    function opt2(typeSpec) {
      return new TOptional(parseSpec(typeSpec));
    }
    exports.opt = opt2;
    var TOptional = (
      /** @class */
      function(_super) {
        __extends(TOptional2, _super);
        function TOptional2(ttype) {
          var _this = _super.call(this) || this;
          _this.ttype = ttype;
          return _this;
        }
        TOptional2.prototype.getChecker = function(suite, strict) {
          var itemChecker = this.ttype.getChecker(suite, strict);
          return function(value, ctx) {
            return value === void 0 || itemChecker(value, ctx);
          };
        };
        return TOptional2;
      }(TType)
    );
    exports.TOptional = TOptional;
    var TProp = (
      /** @class */
      /* @__PURE__ */ function() {
        function TProp2(name2, ttype, isOpt) {
          this.name = name2;
          this.ttype = ttype;
          this.isOpt = isOpt;
        }
        return TProp2;
      }()
    );
    exports.TProp = TProp;
    function func(resultSpec) {
      var params = [];
      for (var _i2 = 1; _i2 < arguments.length; _i2++) {
        params[_i2 - 1] = arguments[_i2];
      }
      return new TFunc(new TParamList(params), parseSpec(resultSpec));
    }
    exports.func = func;
    var TFunc = (
      /** @class */
      function(_super) {
        __extends(TFunc2, _super);
        function TFunc2(paramList, result) {
          var _this = _super.call(this) || this;
          _this.paramList = paramList;
          _this.result = result;
          return _this;
        }
        TFunc2.prototype.getChecker = function(suite, strict) {
          return function(value, ctx) {
            return typeof value === "function" ? true : ctx.fail(null, "is not a function", 0);
          };
        };
        return TFunc2;
      }(TType)
    );
    exports.TFunc = TFunc;
    function param(name2, typeSpec, isOpt) {
      return new TParam(name2, parseSpec(typeSpec), Boolean(isOpt));
    }
    exports.param = param;
    var TParam = (
      /** @class */
      /* @__PURE__ */ function() {
        function TParam2(name2, ttype, isOpt) {
          this.name = name2;
          this.ttype = ttype;
          this.isOpt = isOpt;
        }
        return TParam2;
      }()
    );
    exports.TParam = TParam;
    var TParamList = (
      /** @class */
      function(_super) {
        __extends(TParamList2, _super);
        function TParamList2(params) {
          var _this = _super.call(this) || this;
          _this.params = params;
          return _this;
        }
        TParamList2.prototype.getChecker = function(suite, strict) {
          var _this = this;
          var itemCheckers = this.params.map(function(t5) {
            return t5.ttype.getChecker(suite, strict);
          });
          var testCtx = new util_1.NoopContext();
          var isParamRequired = this.params.map(function(param2, i4) {
            return !param2.isOpt && !itemCheckers[i4](void 0, testCtx);
          });
          var checker = function(value, ctx) {
            if (!Array.isArray(value)) {
              return ctx.fail(null, "is not an array", 0);
            }
            for (var i4 = 0; i4 < itemCheckers.length; i4++) {
              var p3 = _this.params[i4];
              if (value[i4] === void 0) {
                if (isParamRequired[i4]) {
                  return ctx.fail(p3.name, "is missing", 1);
                }
              } else {
                var ok = itemCheckers[i4](value[i4], ctx);
                if (!ok) {
                  return ctx.fail(p3.name, null, 1);
                }
              }
            }
            return true;
          };
          if (!strict) {
            return checker;
          }
          return function(value, ctx) {
            if (!checker(value, ctx)) {
              return false;
            }
            return value.length <= itemCheckers.length ? true : ctx.fail(itemCheckers.length, "is extraneous", 2);
          };
        };
        return TParamList2;
      }(TType)
    );
    exports.TParamList = TParamList;
    var BasicType = (
      /** @class */
      function(_super) {
        __extends(BasicType2, _super);
        function BasicType2(validator, message) {
          var _this = _super.call(this) || this;
          _this.validator = validator;
          _this.message = message;
          return _this;
        }
        BasicType2.prototype.getChecker = function(suite, strict) {
          var _this = this;
          return function(value, ctx) {
            return _this.validator(value) ? true : ctx.fail(null, _this.message, 0);
          };
        };
        return BasicType2;
      }(TType)
    );
    exports.BasicType = BasicType;
    exports.basicTypes = {
      any: new BasicType(function(v3) {
        return true;
      }, "is invalid"),
      number: new BasicType(function(v3) {
        return typeof v3 === "number";
      }, "is not a number"),
      object: new BasicType(function(v3) {
        return typeof v3 === "object" && v3;
      }, "is not an object"),
      boolean: new BasicType(function(v3) {
        return typeof v3 === "boolean";
      }, "is not a boolean"),
      string: new BasicType(function(v3) {
        return typeof v3 === "string";
      }, "is not a string"),
      symbol: new BasicType(function(v3) {
        return typeof v3 === "symbol";
      }, "is not a symbol"),
      void: new BasicType(function(v3) {
        return v3 == null;
      }, "is not void"),
      undefined: new BasicType(function(v3) {
        return v3 === void 0;
      }, "is not undefined"),
      null: new BasicType(function(v3) {
        return v3 === null;
      }, "is not null"),
      never: new BasicType(function(v3) {
        return false;
      }, "is unexpected"),
      Date: new BasicType(getIsNativeChecker("[object Date]"), "is not a Date"),
      RegExp: new BasicType(getIsNativeChecker("[object RegExp]"), "is not a RegExp")
    };
    var nativeToString = Object.prototype.toString;
    function getIsNativeChecker(tag) {
      return function(v3) {
        return typeof v3 === "object" && v3 && nativeToString.call(v3) === tag;
      };
    }
    if (typeof Buffer !== "undefined") {
      exports.basicTypes.Buffer = new BasicType(function(v3) {
        return Buffer.isBuffer(v3);
      }, "is not a Buffer");
    }
    var _loop_1 = function(array_12) {
      exports.basicTypes[array_12.name] = new BasicType(function(v3) {
        return v3 instanceof array_12;
      }, "is not a " + array_12.name);
    };
    for (_i = 0, _a = [
      Int8Array,
      Uint8Array,
      Uint8ClampedArray,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array,
      ArrayBuffer
    ]; _i < _a.length; _i++) {
      array_1 = _a[_i];
      _loop_1(array_1);
    }
    var array_1;
    var _i;
    var _a;
  }
});

// node_modules/ts-interface-checker/dist/index.js
var require_dist = __commonJS({
  "node_modules/ts-interface-checker/dist/index.js"(exports) {
    "use strict";
    var __spreadArrays = exports && exports.__spreadArrays || function() {
      for (var s4 = 0, i4 = 0, il = arguments.length; i4 < il; i4++) s4 += arguments[i4].length;
      for (var r4 = Array(s4), k4 = 0, i4 = 0; i4 < il; i4++)
        for (var a4 = arguments[i4], j4 = 0, jl = a4.length; j4 < jl; j4++, k4++)
          r4[k4] = a4[j4];
      return r4;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Checker = exports.createCheckers = void 0;
    var types_1 = require_types();
    var util_1 = require_util();
    var types_2 = require_types();
    Object.defineProperty(exports, "TArray", { enumerable: true, get: function() {
      return types_2.TArray;
    } });
    Object.defineProperty(exports, "TEnumType", { enumerable: true, get: function() {
      return types_2.TEnumType;
    } });
    Object.defineProperty(exports, "TEnumLiteral", { enumerable: true, get: function() {
      return types_2.TEnumLiteral;
    } });
    Object.defineProperty(exports, "TFunc", { enumerable: true, get: function() {
      return types_2.TFunc;
    } });
    Object.defineProperty(exports, "TIface", { enumerable: true, get: function() {
      return types_2.TIface;
    } });
    Object.defineProperty(exports, "TLiteral", { enumerable: true, get: function() {
      return types_2.TLiteral;
    } });
    Object.defineProperty(exports, "TName", { enumerable: true, get: function() {
      return types_2.TName;
    } });
    Object.defineProperty(exports, "TOptional", { enumerable: true, get: function() {
      return types_2.TOptional;
    } });
    Object.defineProperty(exports, "TParam", { enumerable: true, get: function() {
      return types_2.TParam;
    } });
    Object.defineProperty(exports, "TParamList", { enumerable: true, get: function() {
      return types_2.TParamList;
    } });
    Object.defineProperty(exports, "TProp", { enumerable: true, get: function() {
      return types_2.TProp;
    } });
    Object.defineProperty(exports, "TTuple", { enumerable: true, get: function() {
      return types_2.TTuple;
    } });
    Object.defineProperty(exports, "TType", { enumerable: true, get: function() {
      return types_2.TType;
    } });
    Object.defineProperty(exports, "TUnion", { enumerable: true, get: function() {
      return types_2.TUnion;
    } });
    Object.defineProperty(exports, "TIntersection", { enumerable: true, get: function() {
      return types_2.TIntersection;
    } });
    Object.defineProperty(exports, "array", { enumerable: true, get: function() {
      return types_2.array;
    } });
    Object.defineProperty(exports, "enumlit", { enumerable: true, get: function() {
      return types_2.enumlit;
    } });
    Object.defineProperty(exports, "enumtype", { enumerable: true, get: function() {
      return types_2.enumtype;
    } });
    Object.defineProperty(exports, "func", { enumerable: true, get: function() {
      return types_2.func;
    } });
    Object.defineProperty(exports, "iface", { enumerable: true, get: function() {
      return types_2.iface;
    } });
    Object.defineProperty(exports, "lit", { enumerable: true, get: function() {
      return types_2.lit;
    } });
    Object.defineProperty(exports, "name", { enumerable: true, get: function() {
      return types_2.name;
    } });
    Object.defineProperty(exports, "opt", { enumerable: true, get: function() {
      return types_2.opt;
    } });
    Object.defineProperty(exports, "param", { enumerable: true, get: function() {
      return types_2.param;
    } });
    Object.defineProperty(exports, "tuple", { enumerable: true, get: function() {
      return types_2.tuple;
    } });
    Object.defineProperty(exports, "union", { enumerable: true, get: function() {
      return types_2.union;
    } });
    Object.defineProperty(exports, "intersection", { enumerable: true, get: function() {
      return types_2.intersection;
    } });
    Object.defineProperty(exports, "BasicType", { enumerable: true, get: function() {
      return types_2.BasicType;
    } });
    var util_2 = require_util();
    Object.defineProperty(exports, "VError", { enumerable: true, get: function() {
      return util_2.VError;
    } });
    function createCheckers2() {
      var typeSuite = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        typeSuite[_i] = arguments[_i];
      }
      var fullSuite = Object.assign.apply(Object, __spreadArrays([{}, types_1.basicTypes], typeSuite));
      var checkers = {};
      for (var _a = 0, typeSuite_1 = typeSuite; _a < typeSuite_1.length; _a++) {
        var suite_1 = typeSuite_1[_a];
        for (var _b = 0, _c = Object.keys(suite_1); _b < _c.length; _b++) {
          var name = _c[_b];
          checkers[name] = new Checker(fullSuite, suite_1[name]);
        }
      }
      return checkers;
    }
    exports.createCheckers = createCheckers2;
    var Checker = (
      /** @class */
      function() {
        function Checker2(suite, ttype, _path) {
          if (_path === void 0) {
            _path = "value";
          }
          this.suite = suite;
          this.ttype = ttype;
          this._path = _path;
          this.props = /* @__PURE__ */ new Map();
          if (ttype instanceof types_1.TIface) {
            for (var _i = 0, _a = ttype.props; _i < _a.length; _i++) {
              var p3 = _a[_i];
              this.props.set(p3.name, p3.ttype);
            }
          }
          this.checkerPlain = this.ttype.getChecker(suite, false);
          this.checkerStrict = this.ttype.getChecker(suite, true);
        }
        Checker2.prototype.setReportedPath = function(path) {
          this._path = path;
        };
        Checker2.prototype.check = function(value) {
          return this._doCheck(this.checkerPlain, value);
        };
        Checker2.prototype.test = function(value) {
          return this.checkerPlain(value, new util_1.NoopContext());
        };
        Checker2.prototype.validate = function(value) {
          return this._doValidate(this.checkerPlain, value);
        };
        Checker2.prototype.strictCheck = function(value) {
          return this._doCheck(this.checkerStrict, value);
        };
        Checker2.prototype.strictTest = function(value) {
          return this.checkerStrict(value, new util_1.NoopContext());
        };
        Checker2.prototype.strictValidate = function(value) {
          return this._doValidate(this.checkerStrict, value);
        };
        Checker2.prototype.getProp = function(prop) {
          var ttype = this.props.get(prop);
          if (!ttype) {
            throw new Error("Type has no property " + prop);
          }
          return new Checker2(this.suite, ttype, this._path + "." + prop);
        };
        Checker2.prototype.methodArgs = function(methodName) {
          var tfunc = this._getMethod(methodName);
          return new Checker2(this.suite, tfunc.paramList);
        };
        Checker2.prototype.methodResult = function(methodName) {
          var tfunc = this._getMethod(methodName);
          return new Checker2(this.suite, tfunc.result);
        };
        Checker2.prototype.getArgs = function() {
          if (!(this.ttype instanceof types_1.TFunc)) {
            throw new Error("getArgs() applied to non-function");
          }
          return new Checker2(this.suite, this.ttype.paramList);
        };
        Checker2.prototype.getResult = function() {
          if (!(this.ttype instanceof types_1.TFunc)) {
            throw new Error("getResult() applied to non-function");
          }
          return new Checker2(this.suite, this.ttype.result);
        };
        Checker2.prototype.getType = function() {
          return this.ttype;
        };
        Checker2.prototype._doCheck = function(checkerFunc, value) {
          var noopCtx = new util_1.NoopContext();
          if (!checkerFunc(value, noopCtx)) {
            var detailCtx = new util_1.DetailContext();
            checkerFunc(value, detailCtx);
            throw detailCtx.getError(this._path);
          }
        };
        Checker2.prototype._doValidate = function(checkerFunc, value) {
          var noopCtx = new util_1.NoopContext();
          if (checkerFunc(value, noopCtx)) {
            return null;
          }
          var detailCtx = new util_1.DetailContext();
          checkerFunc(value, detailCtx);
          return detailCtx.getErrorDetail(this._path);
        };
        Checker2.prototype._getMethod = function(methodName) {
          var ttype = this.props.get(methodName);
          if (!ttype) {
            throw new Error("Type has no property " + methodName);
          }
          if (!(ttype instanceof types_1.TFunc)) {
            throw new Error("Property " + methodName + " is not a method");
          }
          return ttype;
        };
        return Checker2;
      }()
    );
    exports.Checker = Checker;
  }
});

// node_modules/lines-and-columns/build/index.js
var require_build = __commonJS({
  "node_modules/lines-and-columns/build/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.LinesAndColumns = void 0;
    var LF = "\n";
    var CR = "\r";
    var LinesAndColumns2 = (
      /** @class */
      function() {
        function LinesAndColumns3(string2) {
          this.string = string2;
          var offsets = [0];
          for (var offset3 = 0; offset3 < string2.length; ) {
            switch (string2[offset3]) {
              case LF:
                offset3 += LF.length;
                offsets.push(offset3);
                break;
              case CR:
                offset3 += CR.length;
                if (string2[offset3] === LF) {
                  offset3 += LF.length;
                }
                offsets.push(offset3);
                break;
              default:
                offset3++;
                break;
            }
          }
          this.offsets = offsets;
        }
        LinesAndColumns3.prototype.locationForIndex = function(index2) {
          if (index2 < 0 || index2 > this.string.length) {
            return null;
          }
          var line2 = 0;
          var offsets = this.offsets;
          while (offsets[line2 + 1] <= index2) {
            line2++;
          }
          var column2 = index2 - offsets[line2];
          return { line: line2, column: column2 };
        };
        LinesAndColumns3.prototype.indexForLocation = function(location) {
          var line2 = location.line, column2 = location.column;
          if (line2 < 0 || line2 >= this.offsets.length) {
            return null;
          }
          if (column2 < 0 || column2 > this.lengthOfLine(line2)) {
            return null;
          }
          return this.offsets[line2] + column2;
        };
        LinesAndColumns3.prototype.lengthOfLine = function(line2) {
          var offset3 = this.offsets[line2];
          var nextOffset = line2 === this.offsets.length - 1 ? this.string.length : this.offsets[line2 + 1];
          return nextOffset - offset3;
        };
        return LinesAndColumns3;
      }()
    );
    exports.LinesAndColumns = LinesAndColumns2;
    exports["default"] = LinesAndColumns2;
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement2;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module2) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys2 = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i4 = 0; i4 < keys2.length; ++i4) {
          var key = keys2[i4];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e3) {
            }
          }
        }
      }
      return targetComponent;
    }
    module2.exports = hoistNonReactStatics;
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i4 = 0; i4 < 10; i4++) {
          test2["_" + String.fromCharCode(i4)] = i4;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n3) {
          return test2[n3];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to = toObject(target);
      var symbols;
      for (var s4 = 1; s4 < arguments.length; s4++) {
        from2 = Object(arguments[s4]);
        for (var key in from2) {
          if (hasOwnProperty2.call(from2, key)) {
            to[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from2);
          for (var i4 = 0; i4 < symbols.length; i4++) {
            if (propIsEnumerable.call(from2, symbols[i4])) {
              to[symbols[i4]] = from2[symbols[i4]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module2) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module2.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module2) {
    module2.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module2) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text2) {
        var message = "Warning: " + text2;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x4) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module2.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module2) {
    "use strict";
    var ReactIs = require_react_is();
    var assign2 = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text2) {
        var message = "Warning: " + text2;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x4) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module2.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x4, y4) {
        if (x4 === y4) {
          return x4 !== 0 || 1 / x4 === 1 / y4;
        } else {
          return x4 !== x4 && y4 !== y4;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i4 = 0; i4 < propValue.length; i4++) {
            var error = typeChecker(propValue, i4, componentName, location, propFullName + "[" + i4 + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i4 = 0; i4 < expectedValues.length; i4++) {
            if (is(propValue, expectedValues[i4])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i4 = 0; i4 < arrayOfTypeCheckers.length; i4++) {
          var checker = arrayOfTypeCheckers[i4];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i4 + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i5 = 0; i5 < arrayOfTypeCheckers.length; i5++) {
            var checker2 = arrayOfTypeCheckers[i5];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode2(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign2({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode2(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode2);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode2(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode2(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module2) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module2.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module2.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/sorted-btree/b+tree.js
var require_b_tree = __commonJS({
  "node_modules/sorted-btree/b+tree.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4) if (Object.prototype.hasOwnProperty.call(b4, p3)) d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmptyBTree = exports.asSet = exports.simpleComparator = exports.defaultComparator = void 0;
    function defaultComparator(a4, b3) {
      if (Number.isFinite(a4) && Number.isFinite(b3)) {
        return a4 - b3;
      }
      var ta = typeof a4;
      var tb = typeof b3;
      if (ta !== tb) {
        return ta < tb ? -1 : 1;
      }
      if (ta === "object") {
        if (a4 === null)
          return b3 === null ? 0 : -1;
        else if (b3 === null)
          return 1;
        a4 = a4.valueOf();
        b3 = b3.valueOf();
        ta = typeof a4;
        tb = typeof b3;
        if (ta !== tb) {
          return ta < tb ? -1 : 1;
        }
      }
      if (a4 < b3)
        return -1;
      if (a4 > b3)
        return 1;
      if (a4 === b3)
        return 0;
      if (Number.isNaN(a4))
        return Number.isNaN(b3) ? 0 : -1;
      else if (Number.isNaN(b3))
        return 1;
      return Array.isArray(a4) ? 0 : Number.NaN;
    }
    exports.defaultComparator = defaultComparator;
    function simpleComparator(a4, b3) {
      return a4 > b3 ? 1 : a4 < b3 ? -1 : 0;
    }
    exports.simpleComparator = simpleComparator;
    var BTree2 = (
      /** @class */
      function() {
        function BTree3(entries, compare, maxNodeSize) {
          this._root = EmptyLeaf;
          this._size = 0;
          this._maxNodeSize = maxNodeSize >= 4 ? Math.min(maxNodeSize, 256) : 32;
          this._compare = compare || defaultComparator;
          if (entries)
            this.setPairs(entries);
        }
        Object.defineProperty(BTree3.prototype, "size", {
          /////////////////////////////////////////////////////////////////////////////
          // ES6 Map<K,V> methods /////////////////////////////////////////////////////
          /** Gets the number of key-value pairs in the tree. */
          get: function() {
            return this._size;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(BTree3.prototype, "length", {
          /** Gets the number of key-value pairs in the tree. */
          get: function() {
            return this._size;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(BTree3.prototype, "isEmpty", {
          /** Returns true iff the tree contains no key-value pairs. */
          get: function() {
            return this._size === 0;
          },
          enumerable: false,
          configurable: true
        });
        BTree3.prototype.clear = function() {
          this._root = EmptyLeaf;
          this._size = 0;
        };
        BTree3.prototype.forEach = function(callback, thisArg) {
          var _this = this;
          if (thisArg !== void 0)
            callback = callback.bind(thisArg);
          return this.forEachPair(function(k4, v3) {
            return callback(v3, k4, _this);
          });
        };
        BTree3.prototype.forEachPair = function(callback, initialCounter) {
          var low = this.minKey(), high = this.maxKey();
          return this.forRange(low, high, true, callback, initialCounter);
        };
        BTree3.prototype.get = function(key, defaultValue) {
          return this._root.get(key, defaultValue, this);
        };
        BTree3.prototype.set = function(key, value, overwrite) {
          if (this._root.isShared)
            this._root = this._root.clone();
          var result = this._root.set(key, value, overwrite, this);
          if (result === true || result === false)
            return result;
          this._root = new BNodeInternal([this._root, result]);
          return true;
        };
        BTree3.prototype.has = function(key) {
          return this.forRange(key, key, true, void 0) !== 0;
        };
        BTree3.prototype.delete = function(key) {
          return this.editRange(key, key, true, DeleteRange) !== 0;
        };
        BTree3.prototype.with = function(key, value, overwrite) {
          var nu = this.clone();
          return nu.set(key, value, overwrite) || overwrite ? nu : this;
        };
        BTree3.prototype.withPairs = function(pairs, overwrite) {
          var nu = this.clone();
          return nu.setPairs(pairs, overwrite) !== 0 || overwrite ? nu : this;
        };
        BTree3.prototype.withKeys = function(keys2, returnThisIfUnchanged) {
          var nu = this.clone(), changed = false;
          for (var i4 = 0; i4 < keys2.length; i4++)
            changed = nu.set(keys2[i4], void 0, false) || changed;
          return returnThisIfUnchanged && !changed ? this : nu;
        };
        BTree3.prototype.without = function(key, returnThisIfUnchanged) {
          return this.withoutRange(key, key, true, returnThisIfUnchanged);
        };
        BTree3.prototype.withoutKeys = function(keys2, returnThisIfUnchanged) {
          var nu = this.clone();
          return nu.deleteKeys(keys2) || !returnThisIfUnchanged ? nu : this;
        };
        BTree3.prototype.withoutRange = function(low, high, includeHigh, returnThisIfUnchanged) {
          var nu = this.clone();
          if (nu.deleteRange(low, high, includeHigh) === 0 && returnThisIfUnchanged)
            return this;
          return nu;
        };
        BTree3.prototype.filter = function(callback, returnThisIfUnchanged) {
          var nu = this.greedyClone();
          var del;
          nu.editAll(function(k4, v3, i4) {
            if (!callback(k4, v3, i4))
              return del = Delete;
          });
          if (!del && returnThisIfUnchanged)
            return this;
          return nu;
        };
        BTree3.prototype.mapValues = function(callback) {
          var tmp = {};
          var nu = this.greedyClone();
          nu.editAll(function(k4, v3, i4) {
            return tmp.value = callback(v3, k4, i4), tmp;
          });
          return nu;
        };
        BTree3.prototype.reduce = function(callback, initialValue) {
          var i4 = 0, p3 = initialValue;
          var it = this.entries(this.minKey(), ReusedArray), next3;
          while (!(next3 = it.next()).done)
            p3 = callback(p3, next3.value, i4++, this);
          return p3;
        };
        BTree3.prototype.entries = function(lowestKey, reusedArray) {
          var info = this.findPath(lowestKey);
          if (info === void 0)
            return iterator();
          var nodequeue = info.nodequeue, nodeindex = info.nodeindex, leaf = info.leaf;
          var state2 = reusedArray !== void 0 ? 1 : 0;
          var i4 = lowestKey === void 0 ? -1 : leaf.indexOf(lowestKey, 0, this._compare) - 1;
          return iterator(function() {
            jump: for (; ; ) {
              switch (state2) {
                case 0:
                  if (++i4 < leaf.keys.length)
                    return { done: false, value: [leaf.keys[i4], leaf.values[i4]] };
                  state2 = 2;
                  continue;
                case 1:
                  if (++i4 < leaf.keys.length) {
                    reusedArray[0] = leaf.keys[i4], reusedArray[1] = leaf.values[i4];
                    return { done: false, value: reusedArray };
                  }
                  state2 = 2;
                case 2:
                  for (var level = -1; ; ) {
                    if (++level >= nodequeue.length) {
                      state2 = 3;
                      continue jump;
                    }
                    if (++nodeindex[level] < nodequeue[level].length)
                      break;
                  }
                  for (; level > 0; level--) {
                    nodequeue[level - 1] = nodequeue[level][nodeindex[level]].children;
                    nodeindex[level - 1] = 0;
                  }
                  leaf = nodequeue[0][nodeindex[0]];
                  i4 = -1;
                  state2 = reusedArray !== void 0 ? 1 : 0;
                  continue;
                case 3:
                  return { done: true, value: void 0 };
              }
            }
          });
        };
        BTree3.prototype.entriesReversed = function(highestKey, reusedArray, skipHighest) {
          if (highestKey === void 0) {
            highestKey = this.maxKey();
            skipHighest = void 0;
            if (highestKey === void 0)
              return iterator();
          }
          var _a = this.findPath(highestKey) || this.findPath(this.maxKey()), nodequeue = _a.nodequeue, nodeindex = _a.nodeindex, leaf = _a.leaf;
          check(!nodequeue[0] || leaf === nodequeue[0][nodeindex[0]], "wat!");
          var i4 = leaf.indexOf(highestKey, 0, this._compare);
          if (!skipHighest && i4 < leaf.keys.length && this._compare(leaf.keys[i4], highestKey) <= 0)
            i4++;
          var state2 = reusedArray !== void 0 ? 1 : 0;
          return iterator(function() {
            jump: for (; ; ) {
              switch (state2) {
                case 0:
                  if (--i4 >= 0)
                    return { done: false, value: [leaf.keys[i4], leaf.values[i4]] };
                  state2 = 2;
                  continue;
                case 1:
                  if (--i4 >= 0) {
                    reusedArray[0] = leaf.keys[i4], reusedArray[1] = leaf.values[i4];
                    return { done: false, value: reusedArray };
                  }
                  state2 = 2;
                case 2:
                  for (var level = -1; ; ) {
                    if (++level >= nodequeue.length) {
                      state2 = 3;
                      continue jump;
                    }
                    if (--nodeindex[level] >= 0)
                      break;
                  }
                  for (; level > 0; level--) {
                    nodequeue[level - 1] = nodequeue[level][nodeindex[level]].children;
                    nodeindex[level - 1] = nodequeue[level - 1].length - 1;
                  }
                  leaf = nodequeue[0][nodeindex[0]];
                  i4 = leaf.keys.length;
                  state2 = reusedArray !== void 0 ? 1 : 0;
                  continue;
                case 3:
                  return { done: true, value: void 0 };
              }
            }
          });
        };
        BTree3.prototype.findPath = function(key) {
          var nextnode = this._root;
          var nodequeue, nodeindex;
          if (nextnode.isLeaf) {
            nodequeue = EmptyArray, nodeindex = EmptyArray;
          } else {
            nodequeue = [], nodeindex = [];
            for (var d3 = 0; !nextnode.isLeaf; d3++) {
              nodequeue[d3] = nextnode.children;
              nodeindex[d3] = key === void 0 ? 0 : nextnode.indexOf(key, 0, this._compare);
              if (nodeindex[d3] >= nodequeue[d3].length)
                return;
              nextnode = nodequeue[d3][nodeindex[d3]];
            }
            nodequeue.reverse();
            nodeindex.reverse();
          }
          return { nodequeue, nodeindex, leaf: nextnode };
        };
        BTree3.prototype.diffAgainst = function(other, onlyThis, onlyOther, different) {
          if (other._compare !== this._compare) {
            throw new Error("Tree comparators are not the same.");
          }
          if (this.isEmpty || other.isEmpty) {
            if (this.isEmpty && other.isEmpty)
              return void 0;
            if (this.isEmpty)
              return onlyOther === void 0 ? void 0 : BTree3.stepToEnd(BTree3.makeDiffCursor(other), onlyOther);
            return onlyThis === void 0 ? void 0 : BTree3.stepToEnd(BTree3.makeDiffCursor(this), onlyThis);
          }
          var _compare = this._compare;
          var thisCursor = BTree3.makeDiffCursor(this);
          var otherCursor = BTree3.makeDiffCursor(other);
          var thisSuccess = true, otherSuccess = true, prevCursorOrder = BTree3.compare(thisCursor, otherCursor, _compare);
          while (thisSuccess && otherSuccess) {
            var cursorOrder = BTree3.compare(thisCursor, otherCursor, _compare);
            var thisLeaf = thisCursor.leaf, thisInternalSpine = thisCursor.internalSpine, thisLevelIndices = thisCursor.levelIndices;
            var otherLeaf = otherCursor.leaf, otherInternalSpine = otherCursor.internalSpine, otherLevelIndices = otherCursor.levelIndices;
            if (thisLeaf || otherLeaf) {
              if (prevCursorOrder !== 0) {
                if (cursorOrder === 0) {
                  if (thisLeaf && otherLeaf && different) {
                    var valThis = thisLeaf.values[thisLevelIndices[thisLevelIndices.length - 1]];
                    var valOther = otherLeaf.values[otherLevelIndices[otherLevelIndices.length - 1]];
                    if (!Object.is(valThis, valOther)) {
                      var result = different(thisCursor.currentKey, valThis, valOther);
                      if (result && result.break)
                        return result.break;
                    }
                  }
                } else if (cursorOrder > 0) {
                  if (otherLeaf && onlyOther) {
                    var otherVal = otherLeaf.values[otherLevelIndices[otherLevelIndices.length - 1]];
                    var result = onlyOther(otherCursor.currentKey, otherVal);
                    if (result && result.break)
                      return result.break;
                  }
                } else if (onlyThis) {
                  if (thisLeaf && prevCursorOrder !== 0) {
                    var valThis = thisLeaf.values[thisLevelIndices[thisLevelIndices.length - 1]];
                    var result = onlyThis(thisCursor.currentKey, valThis);
                    if (result && result.break)
                      return result.break;
                  }
                }
              }
            } else if (!thisLeaf && !otherLeaf && cursorOrder === 0) {
              var lastThis = thisInternalSpine.length - 1;
              var lastOther = otherInternalSpine.length - 1;
              var nodeThis = thisInternalSpine[lastThis][thisLevelIndices[lastThis]];
              var nodeOther = otherInternalSpine[lastOther][otherLevelIndices[lastOther]];
              if (nodeOther === nodeThis) {
                prevCursorOrder = 0;
                thisSuccess = BTree3.step(thisCursor, true);
                otherSuccess = BTree3.step(otherCursor, true);
                continue;
              }
            }
            prevCursorOrder = cursorOrder;
            if (cursorOrder < 0) {
              thisSuccess = BTree3.step(thisCursor);
            } else {
              otherSuccess = BTree3.step(otherCursor);
            }
          }
          if (thisSuccess && onlyThis)
            return BTree3.finishCursorWalk(thisCursor, otherCursor, _compare, onlyThis);
          if (otherSuccess && onlyOther)
            return BTree3.finishCursorWalk(otherCursor, thisCursor, _compare, onlyOther);
        };
        BTree3.finishCursorWalk = function(cursor2, cursorFinished, compareKeys, callback) {
          var compared = BTree3.compare(cursor2, cursorFinished, compareKeys);
          if (compared === 0) {
            if (!BTree3.step(cursor2))
              return void 0;
          } else if (compared < 0) {
            check(false, "cursor walk terminated early");
          }
          return BTree3.stepToEnd(cursor2, callback);
        };
        BTree3.stepToEnd = function(cursor2, callback) {
          var canStep = true;
          while (canStep) {
            var leaf = cursor2.leaf, levelIndices = cursor2.levelIndices, currentKey = cursor2.currentKey;
            if (leaf) {
              var value = leaf.values[levelIndices[levelIndices.length - 1]];
              var result = callback(currentKey, value);
              if (result && result.break)
                return result.break;
            }
            canStep = BTree3.step(cursor2);
          }
          return void 0;
        };
        BTree3.makeDiffCursor = function(tree) {
          var _root = tree._root, height = tree.height;
          return { height, internalSpine: [[_root]], levelIndices: [0], leaf: void 0, currentKey: _root.maxKey() };
        };
        BTree3.step = function(cursor2, stepToNode) {
          var internalSpine = cursor2.internalSpine, levelIndices = cursor2.levelIndices, leaf = cursor2.leaf;
          if (stepToNode === true || leaf) {
            var levelsLength = levelIndices.length;
            if (stepToNode === true || levelIndices[levelsLength - 1] === 0) {
              var spineLength = internalSpine.length;
              if (spineLength === 0)
                return false;
              var nodeLevelIndex = spineLength - 1;
              var levelIndexWalkBack = nodeLevelIndex;
              while (levelIndexWalkBack >= 0) {
                if (levelIndices[levelIndexWalkBack] > 0) {
                  if (levelIndexWalkBack < levelsLength - 1) {
                    cursor2.leaf = void 0;
                    levelIndices.pop();
                  }
                  if (levelIndexWalkBack < nodeLevelIndex)
                    cursor2.internalSpine = internalSpine.slice(0, levelIndexWalkBack + 1);
                  cursor2.currentKey = internalSpine[levelIndexWalkBack][--levelIndices[levelIndexWalkBack]].maxKey();
                  return true;
                }
                levelIndexWalkBack--;
              }
              return false;
            } else {
              var valueIndex = --levelIndices[levelsLength - 1];
              cursor2.currentKey = leaf.keys[valueIndex];
              return true;
            }
          } else {
            var nextLevel = internalSpine.length;
            var currentLevel = nextLevel - 1;
            var node2 = internalSpine[currentLevel][levelIndices[currentLevel]];
            if (node2.isLeaf) {
              cursor2.leaf = node2;
              var valueIndex = levelIndices[nextLevel] = node2.values.length - 1;
              cursor2.currentKey = node2.keys[valueIndex];
            } else {
              var children = node2.children;
              internalSpine[nextLevel] = children;
              var childIndex = children.length - 1;
              levelIndices[nextLevel] = childIndex;
              cursor2.currentKey = children[childIndex].maxKey();
            }
            return true;
          }
        };
        BTree3.compare = function(cursorA, cursorB, compareKeys) {
          var heightA = cursorA.height, currentKeyA = cursorA.currentKey, levelIndicesA = cursorA.levelIndices;
          var heightB = cursorB.height, currentKeyB = cursorB.currentKey, levelIndicesB = cursorB.levelIndices;
          var keyComparison = compareKeys(currentKeyB, currentKeyA);
          if (keyComparison !== 0) {
            return keyComparison;
          }
          var heightMin = heightA < heightB ? heightA : heightB;
          var depthANormalized = levelIndicesA.length - (heightA - heightMin);
          var depthBNormalized = levelIndicesB.length - (heightB - heightMin);
          return depthANormalized - depthBNormalized;
        };
        BTree3.prototype.keys = function(firstKey) {
          var it = this.entries(firstKey, ReusedArray);
          return iterator(function() {
            var n3 = it.next();
            if (n3.value)
              n3.value = n3.value[0];
            return n3;
          });
        };
        BTree3.prototype.values = function(firstKey) {
          var it = this.entries(firstKey, ReusedArray);
          return iterator(function() {
            var n3 = it.next();
            if (n3.value)
              n3.value = n3.value[1];
            return n3;
          });
        };
        Object.defineProperty(BTree3.prototype, "maxNodeSize", {
          /////////////////////////////////////////////////////////////////////////////
          // Additional methods ///////////////////////////////////////////////////////
          /** Returns the maximum number of children/values before nodes will split. */
          get: function() {
            return this._maxNodeSize;
          },
          enumerable: false,
          configurable: true
        });
        BTree3.prototype.minKey = function() {
          return this._root.minKey();
        };
        BTree3.prototype.maxKey = function() {
          return this._root.maxKey();
        };
        BTree3.prototype.clone = function() {
          this._root.isShared = true;
          var result = new BTree3(void 0, this._compare, this._maxNodeSize);
          result._root = this._root;
          result._size = this._size;
          return result;
        };
        BTree3.prototype.greedyClone = function(force) {
          var result = new BTree3(void 0, this._compare, this._maxNodeSize);
          result._root = this._root.greedyClone(force);
          result._size = this._size;
          return result;
        };
        BTree3.prototype.toArray = function(maxLength) {
          if (maxLength === void 0) {
            maxLength = 2147483647;
          }
          var min2 = this.minKey(), max2 = this.maxKey();
          if (min2 !== void 0)
            return this.getRange(min2, max2, true, maxLength);
          return [];
        };
        BTree3.prototype.keysArray = function() {
          var results = [];
          this._root.forRange(this.minKey(), this.maxKey(), true, false, this, 0, function(k4, v3) {
            results.push(k4);
          });
          return results;
        };
        BTree3.prototype.valuesArray = function() {
          var results = [];
          this._root.forRange(this.minKey(), this.maxKey(), true, false, this, 0, function(k4, v3) {
            results.push(v3);
          });
          return results;
        };
        BTree3.prototype.toString = function() {
          return this.toArray().toString();
        };
        BTree3.prototype.setIfNotPresent = function(key, value) {
          return this.set(key, value, false);
        };
        BTree3.prototype.nextHigherPair = function(key, reusedArray) {
          reusedArray = reusedArray || [];
          if (key === void 0) {
            return this._root.minPair(reusedArray);
          }
          return this._root.getPairOrNextHigher(key, this._compare, false, reusedArray);
        };
        BTree3.prototype.nextHigherKey = function(key) {
          var p3 = this.nextHigherPair(key, ReusedArray);
          return p3 && p3[0];
        };
        BTree3.prototype.nextLowerPair = function(key, reusedArray) {
          reusedArray = reusedArray || [];
          if (key === void 0) {
            return this._root.maxPair(reusedArray);
          }
          return this._root.getPairOrNextLower(key, this._compare, false, reusedArray);
        };
        BTree3.prototype.nextLowerKey = function(key) {
          var p3 = this.nextLowerPair(key, ReusedArray);
          return p3 && p3[0];
        };
        BTree3.prototype.getPairOrNextLower = function(key, reusedArray) {
          return this._root.getPairOrNextLower(key, this._compare, true, reusedArray || []);
        };
        BTree3.prototype.getPairOrNextHigher = function(key, reusedArray) {
          return this._root.getPairOrNextHigher(key, this._compare, true, reusedArray || []);
        };
        BTree3.prototype.changeIfPresent = function(key, value) {
          return this.editRange(key, key, true, function(k4, v3) {
            return { value };
          }) !== 0;
        };
        BTree3.prototype.getRange = function(low, high, includeHigh, maxLength) {
          if (maxLength === void 0) {
            maxLength = 67108863;
          }
          var results = [];
          this._root.forRange(low, high, includeHigh, false, this, 0, function(k4, v3) {
            results.push([k4, v3]);
            return results.length > maxLength ? Break : void 0;
          });
          return results;
        };
        BTree3.prototype.setPairs = function(pairs, overwrite) {
          var added = 0;
          for (var i4 = 0; i4 < pairs.length; i4++)
            if (this.set(pairs[i4][0], pairs[i4][1], overwrite))
              added++;
          return added;
        };
        BTree3.prototype.forRange = function(low, high, includeHigh, onFound, initialCounter) {
          var r4 = this._root.forRange(low, high, includeHigh, false, this, initialCounter || 0, onFound);
          return typeof r4 === "number" ? r4 : r4.break;
        };
        BTree3.prototype.editRange = function(low, high, includeHigh, onFound, initialCounter) {
          var root = this._root;
          if (root.isShared)
            this._root = root = root.clone();
          try {
            var r4 = root.forRange(low, high, includeHigh, true, this, initialCounter || 0, onFound);
            return typeof r4 === "number" ? r4 : r4.break;
          } finally {
            var isShared = void 0;
            while (root.keys.length <= 1 && !root.isLeaf) {
              isShared || (isShared = root.isShared);
              this._root = root = root.keys.length === 0 ? EmptyLeaf : root.children[0];
            }
            if (isShared) {
              root.isShared = true;
            }
          }
        };
        BTree3.prototype.editAll = function(onFound, initialCounter) {
          return this.editRange(this.minKey(), this.maxKey(), true, onFound, initialCounter);
        };
        BTree3.prototype.deleteRange = function(low, high, includeHigh) {
          return this.editRange(low, high, includeHigh, DeleteRange);
        };
        BTree3.prototype.deleteKeys = function(keys2) {
          for (var i4 = 0, r4 = 0; i4 < keys2.length; i4++)
            if (this.delete(keys2[i4]))
              r4++;
          return r4;
        };
        Object.defineProperty(BTree3.prototype, "height", {
          /** Gets the height of the tree: the number of internal nodes between the
           *  BTree object and its leaf nodes (zero if there are no internal nodes). */
          get: function() {
            var node2 = this._root;
            var height = -1;
            while (node2) {
              height++;
              node2 = node2.isLeaf ? void 0 : node2.children[0];
            }
            return height;
          },
          enumerable: false,
          configurable: true
        });
        BTree3.prototype.freeze = function() {
          var t5 = this;
          t5.clear = t5.set = t5.editRange = function() {
            throw new Error("Attempted to modify a frozen BTree");
          };
        };
        BTree3.prototype.unfreeze = function() {
          delete this.clear;
          delete this.set;
          delete this.editRange;
        };
        Object.defineProperty(BTree3.prototype, "isFrozen", {
          /** Returns true if the tree appears to be frozen. */
          get: function() {
            return this.hasOwnProperty("editRange");
          },
          enumerable: false,
          configurable: true
        });
        BTree3.prototype.checkValid = function() {
          var size2 = this._root.checkValid(0, this, 0);
          check(size2 === this.size, "size mismatch: counted ", size2, "but stored", this.size);
        };
        return BTree3;
      }()
    );
    exports.default = BTree2;
    function asSet(btree) {
      return btree;
    }
    exports.asSet = asSet;
    if (Symbol && Symbol.iterator)
      BTree2.prototype[Symbol.iterator] = BTree2.prototype.entries;
    BTree2.prototype.where = BTree2.prototype.filter;
    BTree2.prototype.setRange = BTree2.prototype.setPairs;
    BTree2.prototype.add = BTree2.prototype.set;
    function iterator(next3) {
      if (next3 === void 0) {
        next3 = function() {
          return { done: true, value: void 0 };
        };
      }
      var result = { next: next3 };
      if (Symbol && Symbol.iterator)
        result[Symbol.iterator] = function() {
          return this;
        };
      return result;
    }
    var BNode = (
      /** @class */
      function() {
        function BNode2(keys2, values) {
          if (keys2 === void 0) {
            keys2 = [];
          }
          this.keys = keys2;
          this.values = values || undefVals;
          this.isShared = void 0;
        }
        Object.defineProperty(BNode2.prototype, "isLeaf", {
          get: function() {
            return this.children === void 0;
          },
          enumerable: false,
          configurable: true
        });
        BNode2.prototype.maxKey = function() {
          return this.keys[this.keys.length - 1];
        };
        BNode2.prototype.indexOf = function(key, failXor, cmp) {
          var keys2 = this.keys;
          var lo2 = 0, hi = keys2.length, mid = hi >> 1;
          while (lo2 < hi) {
            var c4 = cmp(keys2[mid], key);
            if (c4 < 0)
              lo2 = mid + 1;
            else if (c4 > 0)
              hi = mid;
            else if (c4 === 0)
              return mid;
            else {
              if (key === key)
                return keys2.length;
              else
                throw new Error("BTree: NaN was used as a key");
            }
            mid = lo2 + hi >> 1;
          }
          return mid ^ failXor;
        };
        BNode2.prototype.minKey = function() {
          return this.keys[0];
        };
        BNode2.prototype.minPair = function(reusedArray) {
          if (this.keys.length === 0)
            return void 0;
          reusedArray[0] = this.keys[0];
          reusedArray[1] = this.values[0];
          return reusedArray;
        };
        BNode2.prototype.maxPair = function(reusedArray) {
          if (this.keys.length === 0)
            return void 0;
          var lastIndex = this.keys.length - 1;
          reusedArray[0] = this.keys[lastIndex];
          reusedArray[1] = this.values[lastIndex];
          return reusedArray;
        };
        BNode2.prototype.clone = function() {
          var v3 = this.values;
          return new BNode2(this.keys.slice(0), v3 === undefVals ? v3 : v3.slice(0));
        };
        BNode2.prototype.greedyClone = function(force) {
          return this.isShared && !force ? this : this.clone();
        };
        BNode2.prototype.get = function(key, defaultValue, tree) {
          var i4 = this.indexOf(key, -1, tree._compare);
          return i4 < 0 ? defaultValue : this.values[i4];
        };
        BNode2.prototype.getPairOrNextLower = function(key, compare, inclusive, reusedArray) {
          var i4 = this.indexOf(key, -1, compare);
          var indexOrLower = i4 < 0 ? ~i4 - 1 : inclusive ? i4 : i4 - 1;
          if (indexOrLower >= 0) {
            reusedArray[0] = this.keys[indexOrLower];
            reusedArray[1] = this.values[indexOrLower];
            return reusedArray;
          }
          return void 0;
        };
        BNode2.prototype.getPairOrNextHigher = function(key, compare, inclusive, reusedArray) {
          var i4 = this.indexOf(key, -1, compare);
          var indexOrLower = i4 < 0 ? ~i4 : inclusive ? i4 : i4 + 1;
          var keys2 = this.keys;
          if (indexOrLower < keys2.length) {
            reusedArray[0] = keys2[indexOrLower];
            reusedArray[1] = this.values[indexOrLower];
            return reusedArray;
          }
          return void 0;
        };
        BNode2.prototype.checkValid = function(depth, tree, baseIndex) {
          var kL = this.keys.length, vL = this.values.length;
          check(this.values === undefVals ? kL <= vL : kL === vL, "keys/values length mismatch: depth", depth, "with lengths", kL, vL, "and baseIndex", baseIndex);
          check(depth == 0 || kL > 0, "empty leaf at depth", depth, "and baseIndex", baseIndex);
          return kL;
        };
        BNode2.prototype.set = function(key, value, overwrite, tree) {
          var i4 = this.indexOf(key, -1, tree._compare);
          if (i4 < 0) {
            i4 = ~i4;
            tree._size++;
            if (this.keys.length < tree._maxNodeSize) {
              return this.insertInLeaf(i4, key, value, tree);
            } else {
              var newRightSibling = this.splitOffRightSide(), target = this;
              if (i4 > this.keys.length) {
                i4 -= this.keys.length;
                target = newRightSibling;
              }
              target.insertInLeaf(i4, key, value, tree);
              return newRightSibling;
            }
          } else {
            if (overwrite !== false) {
              if (value !== void 0)
                this.reifyValues();
              this.keys[i4] = key;
              this.values[i4] = value;
            }
            return false;
          }
        };
        BNode2.prototype.reifyValues = function() {
          if (this.values === undefVals)
            return this.values = this.values.slice(0, this.keys.length);
          return this.values;
        };
        BNode2.prototype.insertInLeaf = function(i4, key, value, tree) {
          this.keys.splice(i4, 0, key);
          if (this.values === undefVals) {
            while (undefVals.length < tree._maxNodeSize)
              undefVals.push(void 0);
            if (value === void 0) {
              return true;
            } else {
              this.values = undefVals.slice(0, this.keys.length - 1);
            }
          }
          this.values.splice(i4, 0, value);
          return true;
        };
        BNode2.prototype.takeFromRight = function(rhs) {
          var v3 = this.values;
          if (rhs.values === undefVals) {
            if (v3 !== undefVals)
              v3.push(void 0);
          } else {
            v3 = this.reifyValues();
            v3.push(rhs.values.shift());
          }
          this.keys.push(rhs.keys.shift());
        };
        BNode2.prototype.takeFromLeft = function(lhs) {
          var v3 = this.values;
          if (lhs.values === undefVals) {
            if (v3 !== undefVals)
              v3.unshift(void 0);
          } else {
            v3 = this.reifyValues();
            v3.unshift(lhs.values.pop());
          }
          this.keys.unshift(lhs.keys.pop());
        };
        BNode2.prototype.splitOffRightSide = function() {
          var half = this.keys.length >> 1, keys2 = this.keys.splice(half);
          var values = this.values === undefVals ? undefVals : this.values.splice(half);
          return new BNode2(keys2, values);
        };
        BNode2.prototype.forRange = function(low, high, includeHigh, editMode, tree, count, onFound) {
          var cmp = tree._compare;
          var iLow, iHigh;
          if (high === low) {
            if (!includeHigh)
              return count;
            iHigh = (iLow = this.indexOf(low, -1, cmp)) + 1;
            if (iLow < 0)
              return count;
          } else {
            iLow = this.indexOf(low, 0, cmp);
            iHigh = this.indexOf(high, -1, cmp);
            if (iHigh < 0)
              iHigh = ~iHigh;
            else if (includeHigh === true)
              iHigh++;
          }
          var keys2 = this.keys, values = this.values;
          if (onFound !== void 0) {
            for (var i4 = iLow; i4 < iHigh; i4++) {
              var key = keys2[i4];
              var result = onFound(key, values[i4], count++);
              if (result !== void 0) {
                if (editMode === true) {
                  if (key !== keys2[i4] || this.isShared === true)
                    throw new Error("BTree illegally changed or cloned in editRange");
                  if (result.delete) {
                    this.keys.splice(i4, 1);
                    if (this.values !== undefVals)
                      this.values.splice(i4, 1);
                    tree._size--;
                    i4--;
                    iHigh--;
                  } else if (result.hasOwnProperty("value")) {
                    values[i4] = result.value;
                  }
                }
                if (result.break !== void 0)
                  return result;
              }
            }
          } else
            count += iHigh - iLow;
          return count;
        };
        BNode2.prototype.mergeSibling = function(rhs, _3) {
          this.keys.push.apply(this.keys, rhs.keys);
          if (this.values === undefVals) {
            if (rhs.values === undefVals)
              return;
            this.values = this.values.slice(0, this.keys.length);
          }
          this.values.push.apply(this.values, rhs.reifyValues());
        };
        return BNode2;
      }()
    );
    var BNodeInternal = (
      /** @class */
      function(_super) {
        __extends(BNodeInternal2, _super);
        function BNodeInternal2(children, keys2) {
          var _this = this;
          if (!keys2) {
            keys2 = [];
            for (var i4 = 0; i4 < children.length; i4++)
              keys2[i4] = children[i4].maxKey();
          }
          _this = _super.call(this, keys2) || this;
          _this.children = children;
          return _this;
        }
        BNodeInternal2.prototype.clone = function() {
          var children = this.children.slice(0);
          for (var i4 = 0; i4 < children.length; i4++)
            children[i4].isShared = true;
          return new BNodeInternal2(children, this.keys.slice(0));
        };
        BNodeInternal2.prototype.greedyClone = function(force) {
          if (this.isShared && !force)
            return this;
          var nu = new BNodeInternal2(this.children.slice(0), this.keys.slice(0));
          for (var i4 = 0; i4 < nu.children.length; i4++)
            nu.children[i4] = nu.children[i4].greedyClone(force);
          return nu;
        };
        BNodeInternal2.prototype.minKey = function() {
          return this.children[0].minKey();
        };
        BNodeInternal2.prototype.minPair = function(reusedArray) {
          return this.children[0].minPair(reusedArray);
        };
        BNodeInternal2.prototype.maxPair = function(reusedArray) {
          return this.children[this.children.length - 1].maxPair(reusedArray);
        };
        BNodeInternal2.prototype.get = function(key, defaultValue, tree) {
          var i4 = this.indexOf(key, 0, tree._compare), children = this.children;
          return i4 < children.length ? children[i4].get(key, defaultValue, tree) : void 0;
        };
        BNodeInternal2.prototype.getPairOrNextLower = function(key, compare, inclusive, reusedArray) {
          var i4 = this.indexOf(key, 0, compare), children = this.children;
          if (i4 >= children.length)
            return this.maxPair(reusedArray);
          var result = children[i4].getPairOrNextLower(key, compare, inclusive, reusedArray);
          if (result === void 0 && i4 > 0) {
            return children[i4 - 1].maxPair(reusedArray);
          }
          return result;
        };
        BNodeInternal2.prototype.getPairOrNextHigher = function(key, compare, inclusive, reusedArray) {
          var i4 = this.indexOf(key, 0, compare), children = this.children, length2 = children.length;
          if (i4 >= length2)
            return void 0;
          var result = children[i4].getPairOrNextHigher(key, compare, inclusive, reusedArray);
          if (result === void 0 && i4 < length2 - 1) {
            return children[i4 + 1].minPair(reusedArray);
          }
          return result;
        };
        BNodeInternal2.prototype.checkValid = function(depth, tree, baseIndex) {
          var kL = this.keys.length, cL = this.children.length;
          check(kL === cL, "keys/children length mismatch: depth", depth, "lengths", kL, cL, "baseIndex", baseIndex);
          check(kL > 1 || depth > 0, "internal node has length", kL, "at depth", depth, "baseIndex", baseIndex);
          var size2 = 0, c4 = this.children, k4 = this.keys, childSize = 0;
          for (var i4 = 0; i4 < cL; i4++) {
            size2 += c4[i4].checkValid(depth + 1, tree, baseIndex + size2);
            childSize += c4[i4].keys.length;
            check(size2 >= childSize, "wtf", baseIndex);
            check(i4 === 0 || c4[i4 - 1].constructor === c4[i4].constructor, "type mismatch, baseIndex:", baseIndex);
            if (c4[i4].maxKey() != k4[i4])
              check(false, "keys[", i4, "] =", k4[i4], "is wrong, should be ", c4[i4].maxKey(), "at depth", depth, "baseIndex", baseIndex);
            if (!(i4 === 0 || tree._compare(k4[i4 - 1], k4[i4]) < 0))
              check(false, "sort violation at depth", depth, "index", i4, "keys", k4[i4 - 1], k4[i4]);
          }
          var toofew = childSize === 0;
          if (toofew || childSize > tree.maxNodeSize * cL)
            check(false, toofew ? "too few" : "too many", "children (", childSize, size2, ") at depth", depth, "maxNodeSize:", tree.maxNodeSize, "children.length:", cL, "baseIndex:", baseIndex);
          return size2;
        };
        BNodeInternal2.prototype.set = function(key, value, overwrite, tree) {
          var c4 = this.children, max2 = tree._maxNodeSize, cmp = tree._compare;
          var i4 = Math.min(this.indexOf(key, 0, cmp), c4.length - 1), child = c4[i4];
          if (child.isShared)
            c4[i4] = child = child.clone();
          if (child.keys.length >= max2) {
            var other;
            if (i4 > 0 && (other = c4[i4 - 1]).keys.length < max2 && cmp(child.keys[0], key) < 0) {
              if (other.isShared)
                c4[i4 - 1] = other = other.clone();
              other.takeFromRight(child);
              this.keys[i4 - 1] = other.maxKey();
            } else if ((other = c4[i4 + 1]) !== void 0 && other.keys.length < max2 && cmp(child.maxKey(), key) < 0) {
              if (other.isShared)
                c4[i4 + 1] = other = other.clone();
              other.takeFromLeft(child);
              this.keys[i4] = c4[i4].maxKey();
            }
          }
          var result = child.set(key, value, overwrite, tree);
          if (result === false)
            return false;
          this.keys[i4] = child.maxKey();
          if (result === true)
            return true;
          if (this.keys.length < max2) {
            this.insert(i4 + 1, result);
            return true;
          } else {
            var newRightSibling = this.splitOffRightSide(), target = this;
            if (cmp(result.maxKey(), this.maxKey()) > 0) {
              target = newRightSibling;
              i4 -= this.keys.length;
            }
            target.insert(i4 + 1, result);
            return newRightSibling;
          }
        };
        BNodeInternal2.prototype.insert = function(i4, child) {
          this.children.splice(i4, 0, child);
          this.keys.splice(i4, 0, child.maxKey());
        };
        BNodeInternal2.prototype.splitOffRightSide = function() {
          var half = this.children.length >> 1;
          return new BNodeInternal2(this.children.splice(half), this.keys.splice(half));
        };
        BNodeInternal2.prototype.takeFromRight = function(rhs) {
          this.keys.push(rhs.keys.shift());
          this.children.push(rhs.children.shift());
        };
        BNodeInternal2.prototype.takeFromLeft = function(lhs) {
          this.keys.unshift(lhs.keys.pop());
          this.children.unshift(lhs.children.pop());
        };
        BNodeInternal2.prototype.forRange = function(low, high, includeHigh, editMode, tree, count, onFound) {
          var cmp = tree._compare;
          var keys2 = this.keys, children = this.children;
          var iLow = this.indexOf(low, 0, cmp), i4 = iLow;
          var iHigh = Math.min(high === low ? iLow : this.indexOf(high, 0, cmp), keys2.length - 1);
          if (!editMode) {
            for (; i4 <= iHigh; i4++) {
              var result = children[i4].forRange(low, high, includeHigh, editMode, tree, count, onFound);
              if (typeof result !== "number")
                return result;
              count = result;
            }
          } else if (i4 <= iHigh) {
            try {
              for (; i4 <= iHigh; i4++) {
                if (children[i4].isShared)
                  children[i4] = children[i4].clone();
                var result = children[i4].forRange(low, high, includeHigh, editMode, tree, count, onFound);
                keys2[i4] = children[i4].maxKey();
                if (typeof result !== "number")
                  return result;
                count = result;
              }
            } finally {
              var half = tree._maxNodeSize >> 1;
              if (iLow > 0)
                iLow--;
              for (i4 = iHigh; i4 >= iLow; i4--) {
                if (children[i4].keys.length <= half) {
                  if (children[i4].keys.length !== 0) {
                    this.tryMerge(i4, tree._maxNodeSize);
                  } else {
                    keys2.splice(i4, 1);
                    children.splice(i4, 1);
                  }
                }
              }
              if (children.length !== 0 && children[0].keys.length === 0)
                check(false, "emptiness bug");
            }
          }
          return count;
        };
        BNodeInternal2.prototype.tryMerge = function(i4, maxSize) {
          var children = this.children;
          if (i4 >= 0 && i4 + 1 < children.length) {
            if (children[i4].keys.length + children[i4 + 1].keys.length <= maxSize) {
              if (children[i4].isShared)
                children[i4] = children[i4].clone();
              children[i4].mergeSibling(children[i4 + 1], maxSize);
              children.splice(i4 + 1, 1);
              this.keys.splice(i4 + 1, 1);
              this.keys[i4] = children[i4].maxKey();
              return true;
            }
          }
          return false;
        };
        BNodeInternal2.prototype.mergeSibling = function(rhs, maxNodeSize) {
          var oldLength = this.keys.length;
          this.keys.push.apply(this.keys, rhs.keys);
          var rhsChildren = rhs.children;
          this.children.push.apply(this.children, rhsChildren);
          if (rhs.isShared && !this.isShared) {
            for (var i4 = 0; i4 < rhsChildren.length; i4++)
              rhsChildren[i4].isShared = true;
          }
          this.tryMerge(oldLength - 1, maxNodeSize);
        };
        return BNodeInternal2;
      }(BNode)
    );
    var undefVals = [];
    var Delete = { delete: true };
    var DeleteRange = function() {
      return Delete;
    };
    var Break = { break: true };
    var EmptyLeaf = function() {
      var n3 = new BNode();
      n3.isShared = true;
      return n3;
    }();
    var EmptyArray = [];
    var ReusedArray = [];
    function check(fact) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      if (!fact) {
        args.unshift("B+ tree");
        throw new Error(args.join(" "));
      }
    }
    exports.EmptyBTree = function() {
      var t5 = new BTree2();
      t5.freeze();
      return t5;
    }();
  }
});

// node_modules/localforage/dist/localforage.js
var require_localforage = __commonJS({
  "node_modules/localforage/dist/localforage.js"(exports, module2) {
    (function(f4) {
      if (typeof exports === "object" && typeof module2 !== "undefined") {
        module2.exports = f4();
      } else if (typeof define === "function" && define.amd) {
        define([], f4);
      } else {
        var g4;
        if (typeof window !== "undefined") {
          g4 = window;
        } else if (typeof global !== "undefined") {
          g4 = global;
        } else if (typeof self !== "undefined") {
          g4 = self;
        } else {
          g4 = this;
        }
        g4.localforage = f4();
      }
    })(function() {
      var define2, module3, exports2;
      return function e3(t5, n3, r4) {
        function s4(o5, u4) {
          if (!n3[o5]) {
            if (!t5[o5]) {
              var a4 = typeof require == "function" && require;
              if (!u4 && a4) return a4(o5, true);
              if (i4) return i4(o5, true);
              var f4 = new Error("Cannot find module '" + o5 + "'");
              throw f4.code = "MODULE_NOT_FOUND", f4;
            }
            var l4 = n3[o5] = { exports: {} };
            t5[o5][0].call(l4.exports, function(e4) {
              var n4 = t5[o5][1][e4];
              return s4(n4 ? n4 : e4);
            }, l4, l4.exports, e3, t5, n3, r4);
          }
          return n3[o5].exports;
        }
        var i4 = typeof require == "function" && require;
        for (var o4 = 0; o4 < r4.length; o4++) s4(r4[o4]);
        return s4;
      }({ 1: [function(_dereq_, module4, exports3) {
        (function(global2) {
          "use strict";
          var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
          var scheduleDrain;
          {
            if (Mutation) {
              var called = 0;
              var observer = new Mutation(nextTick);
              var element = global2.document.createTextNode("");
              observer.observe(element, {
                characterData: true
              });
              scheduleDrain = function() {
                element.data = called = ++called % 2;
              };
            } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
              var channel = new global2.MessageChannel();
              channel.port1.onmessage = nextTick;
              scheduleDrain = function() {
                channel.port2.postMessage(0);
              };
            } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
              scheduleDrain = function() {
                var scriptEl = global2.document.createElement("script");
                scriptEl.onreadystatechange = function() {
                  nextTick();
                  scriptEl.onreadystatechange = null;
                  scriptEl.parentNode.removeChild(scriptEl);
                  scriptEl = null;
                };
                global2.document.documentElement.appendChild(scriptEl);
              };
            } else {
              scheduleDrain = function() {
                setTimeout(nextTick, 0);
              };
            }
          }
          var draining;
          var queue = [];
          function nextTick() {
            draining = true;
            var i4, oldQueue;
            var len = queue.length;
            while (len) {
              oldQueue = queue;
              queue = [];
              i4 = -1;
              while (++i4 < len) {
                oldQueue[i4]();
              }
              len = queue.length;
            }
            draining = false;
          }
          module4.exports = immediate;
          function immediate(task) {
            if (queue.push(task) === 1 && !draining) {
              scheduleDrain();
            }
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 2: [function(_dereq_, module4, exports3) {
        "use strict";
        var immediate = _dereq_(1);
        function INTERNAL() {
        }
        var handlers = {};
        var REJECTED = ["REJECTED"];
        var FULFILLED = ["FULFILLED"];
        var PENDING = ["PENDING"];
        module4.exports = Promise2;
        function Promise2(resolver) {
          if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function");
          }
          this.state = PENDING;
          this.queue = [];
          this.outcome = void 0;
          if (resolver !== INTERNAL) {
            safelyResolveThenable(this, resolver);
          }
        }
        Promise2.prototype["catch"] = function(onRejected) {
          return this.then(null, onRejected);
        };
        Promise2.prototype.then = function(onFulfilled, onRejected) {
          if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
            return this;
          }
          var promise = new this.constructor(INTERNAL);
          if (this.state !== PENDING) {
            var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
            unwrap(promise, resolver, this.outcome);
          } else {
            this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
          }
          return promise;
        };
        function QueueItem(promise, onFulfilled, onRejected) {
          this.promise = promise;
          if (typeof onFulfilled === "function") {
            this.onFulfilled = onFulfilled;
            this.callFulfilled = this.otherCallFulfilled;
          }
          if (typeof onRejected === "function") {
            this.onRejected = onRejected;
            this.callRejected = this.otherCallRejected;
          }
        }
        QueueItem.prototype.callFulfilled = function(value) {
          handlers.resolve(this.promise, value);
        };
        QueueItem.prototype.otherCallFulfilled = function(value) {
          unwrap(this.promise, this.onFulfilled, value);
        };
        QueueItem.prototype.callRejected = function(value) {
          handlers.reject(this.promise, value);
        };
        QueueItem.prototype.otherCallRejected = function(value) {
          unwrap(this.promise, this.onRejected, value);
        };
        function unwrap(promise, func, value) {
          immediate(function() {
            var returnValue;
            try {
              returnValue = func(value);
            } catch (e3) {
              return handlers.reject(promise, e3);
            }
            if (returnValue === promise) {
              handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
            } else {
              handlers.resolve(promise, returnValue);
            }
          });
        }
        handlers.resolve = function(self2, value) {
          var result = tryCatch(getThen, value);
          if (result.status === "error") {
            return handlers.reject(self2, result.value);
          }
          var thenable = result.value;
          if (thenable) {
            safelyResolveThenable(self2, thenable);
          } else {
            self2.state = FULFILLED;
            self2.outcome = value;
            var i4 = -1;
            var len = self2.queue.length;
            while (++i4 < len) {
              self2.queue[i4].callFulfilled(value);
            }
          }
          return self2;
        };
        handlers.reject = function(self2, error) {
          self2.state = REJECTED;
          self2.outcome = error;
          var i4 = -1;
          var len = self2.queue.length;
          while (++i4 < len) {
            self2.queue[i4].callRejected(error);
          }
          return self2;
        };
        function getThen(obj) {
          var then = obj && obj.then;
          if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
            return function appyThen() {
              then.apply(obj, arguments);
            };
          }
        }
        function safelyResolveThenable(self2, thenable) {
          var called = false;
          function onError(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.reject(self2, value);
          }
          function onSuccess(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.resolve(self2, value);
          }
          function tryToUnwrap() {
            thenable(onSuccess, onError);
          }
          var result = tryCatch(tryToUnwrap);
          if (result.status === "error") {
            onError(result.value);
          }
        }
        function tryCatch(func, value) {
          var out = {};
          try {
            out.value = func(value);
            out.status = "success";
          } catch (e3) {
            out.status = "error";
            out.value = e3;
          }
          return out;
        }
        Promise2.resolve = resolve;
        function resolve(value) {
          if (value instanceof this) {
            return value;
          }
          return handlers.resolve(new this(INTERNAL), value);
        }
        Promise2.reject = reject;
        function reject(reason) {
          var promise = new this(INTERNAL);
          return handlers.reject(promise, reason);
        }
        Promise2.all = all;
        function all(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var values = new Array(len);
          var resolved = 0;
          var i4 = -1;
          var promise = new this(INTERNAL);
          while (++i4 < len) {
            allResolver(iterable[i4], i4);
          }
          return promise;
          function allResolver(value, i5) {
            self2.resolve(value).then(resolveFromAll, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
            function resolveFromAll(outValue) {
              values[i5] = outValue;
              if (++resolved === len && !called) {
                called = true;
                handlers.resolve(promise, values);
              }
            }
          }
        }
        Promise2.race = race;
        function race(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var i4 = -1;
          var promise = new this(INTERNAL);
          while (++i4 < len) {
            resolver(iterable[i4]);
          }
          return promise;
          function resolver(value) {
            self2.resolve(value).then(function(response) {
              if (!called) {
                called = true;
                handlers.resolve(promise, response);
              }
            }, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
          }
        }
      }, { "1": 1 }], 3: [function(_dereq_, module4, exports3) {
        (function(global2) {
          "use strict";
          if (typeof global2.Promise !== "function") {
            global2.Promise = _dereq_(2);
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "2": 2 }], 4: [function(_dereq_, module4, exports3) {
        "use strict";
        var _typeof3 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        function _classCallCheck2(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function getIDB() {
          try {
            if (typeof indexedDB !== "undefined") {
              return indexedDB;
            }
            if (typeof webkitIndexedDB !== "undefined") {
              return webkitIndexedDB;
            }
            if (typeof mozIndexedDB !== "undefined") {
              return mozIndexedDB;
            }
            if (typeof OIndexedDB !== "undefined") {
              return OIndexedDB;
            }
            if (typeof msIndexedDB !== "undefined") {
              return msIndexedDB;
            }
          } catch (e3) {
            return;
          }
        }
        var idb = getIDB();
        function isIndexedDBValid() {
          try {
            if (!idb || !idb.open) {
              return false;
            }
            var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
            var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
            return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && // some outdated implementations of IDB that appear on Samsung
            // and HTC Android devices <4.4 are missing IDBKeyRange
            // See: https://github.com/mozilla/localForage/issues/128
            // See: https://github.com/mozilla/localForage/issues/272
            typeof IDBKeyRange !== "undefined";
          } catch (e3) {
            return false;
          }
        }
        function createBlob(parts, properties) {
          parts = parts || [];
          properties = properties || {};
          try {
            return new Blob(parts, properties);
          } catch (e3) {
            if (e3.name !== "TypeError") {
              throw e3;
            }
            var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
            var builder = new Builder();
            for (var i4 = 0; i4 < parts.length; i4 += 1) {
              builder.append(parts[i4]);
            }
            return builder.getBlob(properties.type);
          }
        }
        if (typeof Promise === "undefined") {
          _dereq_(3);
        }
        var Promise$1 = Promise;
        function executeCallback(promise, callback) {
          if (callback) {
            promise.then(function(result) {
              callback(null, result);
            }, function(error) {
              callback(error);
            });
          }
        }
        function executeTwoCallbacks(promise, callback, errorCallback) {
          if (typeof callback === "function") {
            promise.then(callback);
          }
          if (typeof errorCallback === "function") {
            promise["catch"](errorCallback);
          }
        }
        function normalizeKey(key2) {
          if (typeof key2 !== "string") {
            console.warn(key2 + " used as a key, but it is not a string.");
            key2 = String(key2);
          }
          return key2;
        }
        function getCallback() {
          if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
            return arguments[arguments.length - 1];
          }
        }
        var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
        var supportsBlobs = void 0;
        var dbContexts = {};
        var toString = Object.prototype.toString;
        var READ_ONLY = "readonly";
        var READ_WRITE = "readwrite";
        function _binStringToArrayBuffer(bin) {
          var length3 = bin.length;
          var buf = new ArrayBuffer(length3);
          var arr = new Uint8Array(buf);
          for (var i4 = 0; i4 < length3; i4++) {
            arr[i4] = bin.charCodeAt(i4);
          }
          return buf;
        }
        function _checkBlobSupportWithoutCaching(idb2) {
          return new Promise$1(function(resolve) {
            var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
            var blob = createBlob([""]);
            txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
            txn.onabort = function(e3) {
              e3.preventDefault();
              e3.stopPropagation();
              resolve(false);
            };
            txn.oncomplete = function() {
              var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
              var matchedEdge = navigator.userAgent.match(/Edge\//);
              resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
            };
          })["catch"](function() {
            return false;
          });
        }
        function _checkBlobSupport(idb2) {
          if (typeof supportsBlobs === "boolean") {
            return Promise$1.resolve(supportsBlobs);
          }
          return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
            supportsBlobs = value;
            return supportsBlobs;
          });
        }
        function _deferReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = {};
          deferredOperation.promise = new Promise$1(function(resolve, reject) {
            deferredOperation.resolve = resolve;
            deferredOperation.reject = reject;
          });
          dbContext.deferredOperations.push(deferredOperation);
          if (!dbContext.dbReady) {
            dbContext.dbReady = deferredOperation.promise;
          } else {
            dbContext.dbReady = dbContext.dbReady.then(function() {
              return deferredOperation.promise;
            });
          }
        }
        function _advanceReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.resolve();
            return deferredOperation.promise;
          }
        }
        function _rejectReadiness(dbInfo, err) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.reject(err);
            return deferredOperation.promise;
          }
        }
        function _getConnection(dbInfo, upgradeNeeded) {
          return new Promise$1(function(resolve, reject) {
            dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
            if (dbInfo.db) {
              if (upgradeNeeded) {
                _deferReadiness(dbInfo);
                dbInfo.db.close();
              } else {
                return resolve(dbInfo.db);
              }
            }
            var dbArgs = [dbInfo.name];
            if (upgradeNeeded) {
              dbArgs.push(dbInfo.version);
            }
            var openreq = idb.open.apply(idb, dbArgs);
            if (upgradeNeeded) {
              openreq.onupgradeneeded = function(e3) {
                var db = openreq.result;
                try {
                  db.createObjectStore(dbInfo.storeName);
                  if (e3.oldVersion <= 1) {
                    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                  }
                } catch (ex) {
                  if (ex.name === "ConstraintError") {
                    console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e3.oldVersion + " to version " + e3.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                  } else {
                    throw ex;
                  }
                }
              };
            }
            openreq.onerror = function(e3) {
              e3.preventDefault();
              reject(openreq.error);
            };
            openreq.onsuccess = function() {
              var db = openreq.result;
              db.onversionchange = function(e3) {
                e3.target.close();
              };
              resolve(db);
              _advanceReadiness(dbInfo);
            };
          });
        }
        function _getOriginalConnection(dbInfo) {
          return _getConnection(dbInfo, false);
        }
        function _getUpgradedConnection(dbInfo) {
          return _getConnection(dbInfo, true);
        }
        function _isUpgradeNeeded(dbInfo, defaultVersion) {
          if (!dbInfo.db) {
            return true;
          }
          var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
          var isDowngrade = dbInfo.version < dbInfo.db.version;
          var isUpgrade = dbInfo.version > dbInfo.db.version;
          if (isDowngrade) {
            if (dbInfo.version !== defaultVersion) {
              console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
            }
            dbInfo.version = dbInfo.db.version;
          }
          if (isUpgrade || isNewStore) {
            if (isNewStore) {
              var incVersion = dbInfo.db.version + 1;
              if (incVersion > dbInfo.version) {
                dbInfo.version = incVersion;
              }
            }
            return true;
          }
          return false;
        }
        function _encodeBlob(blob) {
          return new Promise$1(function(resolve, reject) {
            var reader = new FileReader();
            reader.onerror = reject;
            reader.onloadend = function(e3) {
              var base64 = btoa(e3.target.result || "");
              resolve({
                __local_forage_encoded_blob: true,
                data: base64,
                type: blob.type
              });
            };
            reader.readAsBinaryString(blob);
          });
        }
        function _decodeBlob(encodedBlob) {
          var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
          return createBlob([arrayBuff], { type: encodedBlob.type });
        }
        function _isEncodedBlob(value) {
          return value && value.__local_forage_encoded_blob;
        }
        function _fullyReady(callback) {
          var self2 = this;
          var promise = self2._initReady().then(function() {
            var dbContext = dbContexts[self2._dbInfo.name];
            if (dbContext && dbContext.dbReady) {
              return dbContext.dbReady;
            }
          });
          executeTwoCallbacks(promise, callback, callback);
          return promise;
        }
        function _tryReconnect(dbInfo) {
          _deferReadiness(dbInfo);
          var dbContext = dbContexts[dbInfo.name];
          var forages = dbContext.forages;
          for (var i4 = 0; i4 < forages.length; i4++) {
            var forage = forages[i4];
            if (forage._dbInfo.db) {
              forage._dbInfo.db.close();
              forage._dbInfo.db = null;
            }
          }
          dbInfo.db = null;
          return _getOriginalConnection(dbInfo).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            for (var i5 = 0; i5 < forages.length; i5++) {
              forages[i5]._dbInfo.db = db;
            }
          })["catch"](function(err) {
            _rejectReadiness(dbInfo, err);
            throw err;
          });
        }
        function createTransaction(dbInfo, mode, callback, retries) {
          if (retries === void 0) {
            retries = 1;
          }
          try {
            var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
            callback(null, tx);
          } catch (err) {
            if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
              return Promise$1.resolve().then(function() {
                if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                  if (dbInfo.db) {
                    dbInfo.version = dbInfo.db.version + 1;
                  }
                  return _getUpgradedConnection(dbInfo);
                }
              }).then(function() {
                return _tryReconnect(dbInfo).then(function() {
                  createTransaction(dbInfo, mode, callback, retries - 1);
                });
              })["catch"](callback);
            }
            callback(err);
          }
        }
        function createDbContext() {
          return {
            // Running localForages sharing a database.
            forages: [],
            // Shared database.
            db: null,
            // Database readiness (promise).
            dbReady: null,
            // Deferred operations on the database.
            deferredOperations: []
          };
        }
        function _initStorage(options2) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options2) {
            for (var i4 in options2) {
              dbInfo[i4] = options2[i4];
            }
          }
          var dbContext = dbContexts[dbInfo.name];
          if (!dbContext) {
            dbContext = createDbContext();
            dbContexts[dbInfo.name] = dbContext;
          }
          dbContext.forages.push(self2);
          if (!self2._initReady) {
            self2._initReady = self2.ready;
            self2.ready = _fullyReady;
          }
          var initPromises = [];
          function ignoreErrors() {
            return Promise$1.resolve();
          }
          for (var j4 = 0; j4 < dbContext.forages.length; j4++) {
            var forage = dbContext.forages[j4];
            if (forage !== self2) {
              initPromises.push(forage._initReady()["catch"](ignoreErrors));
            }
          }
          var forages = dbContext.forages.slice(0);
          return Promise$1.all(initPromises).then(function() {
            dbInfo.db = dbContext.db;
            return _getOriginalConnection(dbInfo);
          }).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            self2._dbInfo = dbInfo;
            for (var k4 = 0; k4 < forages.length; k4++) {
              var forage2 = forages[k4];
              if (forage2 !== self2) {
                forage2._dbInfo.db = dbInfo.db;
                forage2._dbInfo.version = dbInfo.version;
              }
            }
          });
        }
        function getItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.get(key2);
                  req.onsuccess = function() {
                    var value = req.result;
                    if (value === void 0) {
                      value = null;
                    }
                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }
                    resolve(value);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e3) {
                  reject(e3);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openCursor();
                  var iterationNumber = 1;
                  req.onsuccess = function() {
                    var cursor2 = req.result;
                    if (cursor2) {
                      var value = cursor2.value;
                      if (_isEncodedBlob(value)) {
                        value = _decodeBlob(value);
                      }
                      var result = iterator(value, cursor2.key, iterationNumber++);
                      if (result !== void 0) {
                        resolve(result);
                      } else {
                        cursor2["continue"]();
                      }
                    } else {
                      resolve();
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e3) {
                  reject(e3);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            var dbInfo;
            self2.ready().then(function() {
              dbInfo = self2._dbInfo;
              if (toString.call(value) === "[object Blob]") {
                return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                  if (blobSupport) {
                    return value;
                  }
                  return _encodeBlob(value);
                });
              }
              return value;
            }).then(function(value2) {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  if (value2 === null) {
                    value2 = void 0;
                  }
                  var req = store.put(value2, key2);
                  transaction.oncomplete = function() {
                    if (value2 === void 0) {
                      value2 = null;
                    }
                    resolve(value2);
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e3) {
                  reject(e3);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store["delete"](key2);
                  transaction.oncomplete = function() {
                    resolve();
                  };
                  transaction.onerror = function() {
                    reject(req.error);
                  };
                  transaction.onabort = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e3) {
                  reject(e3);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.clear();
                  transaction.oncomplete = function() {
                    resolve();
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e3) {
                  reject(e3);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length2(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.count();
                  req.onsuccess = function() {
                    resolve(req.result);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e3) {
                  reject(e3);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key(n3, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            if (n3 < 0) {
              resolve(null);
              return;
            }
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var advanced = false;
                  var req = store.openKeyCursor();
                  req.onsuccess = function() {
                    var cursor2 = req.result;
                    if (!cursor2) {
                      resolve(null);
                      return;
                    }
                    if (n3 === 0) {
                      resolve(cursor2.key);
                    } else {
                      if (!advanced) {
                        advanced = true;
                        cursor2.advance(n3);
                      } else {
                        resolve(cursor2.key);
                      }
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e3) {
                  reject(e3);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys2(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openKeyCursor();
                  var keys3 = [];
                  req.onsuccess = function() {
                    var cursor2 = req.result;
                    if (!cursor2) {
                      resolve(keys3);
                      return;
                    }
                    keys3.push(cursor2.key);
                    cursor2["continue"]();
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e3) {
                  reject(e3);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance(options2, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options2 = typeof options2 !== "function" && options2 || {};
          if (!options2.name) {
            options2.name = options2.name || currentConfig.name;
            options2.storeName = options2.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options2.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            var isCurrentDb = options2.name === currentConfig.name && self2._dbInfo.db;
            var dbPromise = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options2).then(function(db) {
              var dbContext = dbContexts[options2.name];
              var forages = dbContext.forages;
              dbContext.db = db;
              for (var i4 = 0; i4 < forages.length; i4++) {
                forages[i4]._dbInfo.db = db;
              }
              return db;
            });
            if (!options2.storeName) {
              promise = dbPromise.then(function(db) {
                _deferReadiness(options2);
                var dbContext = dbContexts[options2.name];
                var forages = dbContext.forages;
                db.close();
                for (var i4 = 0; i4 < forages.length; i4++) {
                  var forage = forages[i4];
                  forage._dbInfo.db = null;
                }
                var dropDBPromise = new Promise$1(function(resolve, reject) {
                  var req = idb.deleteDatabase(options2.name);
                  req.onerror = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    reject(req.error);
                  };
                  req.onblocked = function() {
                    console.warn('dropInstance blocked for database "' + options2.name + '" until all open connections are closed');
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    resolve(db2);
                  };
                });
                return dropDBPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var i5 = 0; i5 < forages.length; i5++) {
                    var _forage = forages[i5];
                    _advanceReadiness(_forage._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options2, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            } else {
              promise = dbPromise.then(function(db) {
                if (!db.objectStoreNames.contains(options2.storeName)) {
                  return;
                }
                var newVersion = db.version + 1;
                _deferReadiness(options2);
                var dbContext = dbContexts[options2.name];
                var forages = dbContext.forages;
                db.close();
                for (var i4 = 0; i4 < forages.length; i4++) {
                  var forage = forages[i4];
                  forage._dbInfo.db = null;
                  forage._dbInfo.version = newVersion;
                }
                var dropObjectPromise = new Promise$1(function(resolve, reject) {
                  var req = idb.open(options2.name, newVersion);
                  req.onerror = function(err) {
                    var db2 = req.result;
                    db2.close();
                    reject(err);
                  };
                  req.onupgradeneeded = function() {
                    var db2 = req.result;
                    db2.deleteObjectStore(options2.storeName);
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    db2.close();
                    resolve(db2);
                  };
                });
                return dropObjectPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var j4 = 0; j4 < forages.length; j4++) {
                    var _forage2 = forages[j4];
                    _forage2._dbInfo.db = db2;
                    _advanceReadiness(_forage2._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options2, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            }
          }
          executeCallback(promise, callback);
          return promise;
        }
        var asyncStorage = {
          _driver: "asyncStorage",
          _initStorage,
          _support: isIndexedDBValid(),
          iterate,
          getItem,
          setItem,
          removeItem,
          clear,
          length: length2,
          key,
          keys: keys2,
          dropInstance
        };
        function isWebSQLValid() {
          return typeof openDatabase === "function";
        }
        var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var BLOB_TYPE_PREFIX = "~~local_forage_type~";
        var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
        var SERIALIZED_MARKER = "__lfsc__:";
        var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
        var TYPE_ARRAYBUFFER = "arbf";
        var TYPE_BLOB = "blob";
        var TYPE_INT8ARRAY = "si08";
        var TYPE_UINT8ARRAY = "ui08";
        var TYPE_UINT8CLAMPEDARRAY = "uic8";
        var TYPE_INT16ARRAY = "si16";
        var TYPE_INT32ARRAY = "si32";
        var TYPE_UINT16ARRAY = "ur16";
        var TYPE_UINT32ARRAY = "ui32";
        var TYPE_FLOAT32ARRAY = "fl32";
        var TYPE_FLOAT64ARRAY = "fl64";
        var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
        var toString$1 = Object.prototype.toString;
        function stringToBuffer(serializedString) {
          var bufferLength = serializedString.length * 0.75;
          var len = serializedString.length;
          var i4;
          var p3 = 0;
          var encoded1, encoded2, encoded3, encoded4;
          if (serializedString[serializedString.length - 1] === "=") {
            bufferLength--;
            if (serializedString[serializedString.length - 2] === "=") {
              bufferLength--;
            }
          }
          var buffer = new ArrayBuffer(bufferLength);
          var bytes = new Uint8Array(buffer);
          for (i4 = 0; i4 < len; i4 += 4) {
            encoded1 = BASE_CHARS.indexOf(serializedString[i4]);
            encoded2 = BASE_CHARS.indexOf(serializedString[i4 + 1]);
            encoded3 = BASE_CHARS.indexOf(serializedString[i4 + 2]);
            encoded4 = BASE_CHARS.indexOf(serializedString[i4 + 3]);
            bytes[p3++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p3++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p3++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return buffer;
        }
        function bufferToString(buffer) {
          var bytes = new Uint8Array(buffer);
          var base64String = "";
          var i4;
          for (i4 = 0; i4 < bytes.length; i4 += 3) {
            base64String += BASE_CHARS[bytes[i4] >> 2];
            base64String += BASE_CHARS[(bytes[i4] & 3) << 4 | bytes[i4 + 1] >> 4];
            base64String += BASE_CHARS[(bytes[i4 + 1] & 15) << 2 | bytes[i4 + 2] >> 6];
            base64String += BASE_CHARS[bytes[i4 + 2] & 63];
          }
          if (bytes.length % 3 === 2) {
            base64String = base64String.substring(0, base64String.length - 1) + "=";
          } else if (bytes.length % 3 === 1) {
            base64String = base64String.substring(0, base64String.length - 2) + "==";
          }
          return base64String;
        }
        function serialize2(value, callback) {
          var valueType = "";
          if (value) {
            valueType = toString$1.call(value);
          }
          if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$1.call(value.buffer) === "[object ArrayBuffer]")) {
            var buffer;
            var marker = SERIALIZED_MARKER;
            if (value instanceof ArrayBuffer) {
              buffer = value;
              marker += TYPE_ARRAYBUFFER;
            } else {
              buffer = value.buffer;
              if (valueType === "[object Int8Array]") {
                marker += TYPE_INT8ARRAY;
              } else if (valueType === "[object Uint8Array]") {
                marker += TYPE_UINT8ARRAY;
              } else if (valueType === "[object Uint8ClampedArray]") {
                marker += TYPE_UINT8CLAMPEDARRAY;
              } else if (valueType === "[object Int16Array]") {
                marker += TYPE_INT16ARRAY;
              } else if (valueType === "[object Uint16Array]") {
                marker += TYPE_UINT16ARRAY;
              } else if (valueType === "[object Int32Array]") {
                marker += TYPE_INT32ARRAY;
              } else if (valueType === "[object Uint32Array]") {
                marker += TYPE_UINT32ARRAY;
              } else if (valueType === "[object Float32Array]") {
                marker += TYPE_FLOAT32ARRAY;
              } else if (valueType === "[object Float64Array]") {
                marker += TYPE_FLOAT64ARRAY;
              } else {
                callback(new Error("Failed to get type for BinaryArray"));
              }
            }
            callback(marker + bufferToString(buffer));
          } else if (valueType === "[object Blob]") {
            var fileReader = new FileReader();
            fileReader.onload = function() {
              var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
              callback(SERIALIZED_MARKER + TYPE_BLOB + str);
            };
            fileReader.readAsArrayBuffer(value);
          } else {
            try {
              callback(JSON.stringify(value));
            } catch (e3) {
              console.error("Couldn't convert value into a JSON string: ", value);
              callback(null, e3);
            }
          }
        }
        function deserialize(value) {
          if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
            return JSON.parse(value);
          }
          var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
          var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
          var blobType;
          if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
            var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
            blobType = matcher[1];
            serializedString = serializedString.substring(matcher[0].length);
          }
          var buffer = stringToBuffer(serializedString);
          switch (type) {
            case TYPE_ARRAYBUFFER:
              return buffer;
            case TYPE_BLOB:
              return createBlob([buffer], { type: blobType });
            case TYPE_INT8ARRAY:
              return new Int8Array(buffer);
            case TYPE_UINT8ARRAY:
              return new Uint8Array(buffer);
            case TYPE_UINT8CLAMPEDARRAY:
              return new Uint8ClampedArray(buffer);
            case TYPE_INT16ARRAY:
              return new Int16Array(buffer);
            case TYPE_UINT16ARRAY:
              return new Uint16Array(buffer);
            case TYPE_INT32ARRAY:
              return new Int32Array(buffer);
            case TYPE_UINT32ARRAY:
              return new Uint32Array(buffer);
            case TYPE_FLOAT32ARRAY:
              return new Float32Array(buffer);
            case TYPE_FLOAT64ARRAY:
              return new Float64Array(buffer);
            default:
              throw new Error("Unkown type: " + type);
          }
        }
        var localforageSerializer = {
          serialize: serialize2,
          deserialize,
          stringToBuffer,
          bufferToString
        };
        function createDbTable(t5, dbInfo, callback, errorCallback) {
          t5.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
        }
        function _initStorage$1(options2) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options2) {
            for (var i4 in options2) {
              dbInfo[i4] = typeof options2[i4] !== "string" ? options2[i4].toString() : options2[i4];
            }
          }
          var dbInfoPromise = new Promise$1(function(resolve, reject) {
            try {
              dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
            } catch (e3) {
              return reject(e3);
            }
            dbInfo.db.transaction(function(t5) {
              createDbTable(t5, dbInfo, function() {
                self2._dbInfo = dbInfo;
                resolve();
              }, function(t6, error) {
                reject(error);
              });
            }, reject);
          });
          dbInfo.serializer = localforageSerializer;
          return dbInfoPromise;
        }
        function tryExecuteSql(t5, dbInfo, sqlStatement, args, callback, errorCallback) {
          t5.executeSql(sqlStatement, args, callback, function(t6, error) {
            if (error.code === error.SYNTAX_ERR) {
              t6.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t7, results) {
                if (!results.rows.length) {
                  createDbTable(t7, dbInfo, function() {
                    t7.executeSql(sqlStatement, args, callback, errorCallback);
                  }, errorCallback);
                } else {
                  errorCallback(t7, error);
                }
              }, errorCallback);
            } else {
              errorCallback(t6, error);
            }
          }, errorCallback);
        }
        function getItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t5) {
                tryExecuteSql(t5, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t6, results) {
                  var result = results.rows.length ? results.rows.item(0).value : null;
                  if (result) {
                    result = dbInfo.serializer.deserialize(result);
                  }
                  resolve(result);
                }, function(t6, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$1(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t5) {
                tryExecuteSql(t5, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t6, results) {
                  var rows = results.rows;
                  var length3 = rows.length;
                  for (var i4 = 0; i4 < length3; i4++) {
                    var item = rows.item(i4);
                    var result = item.value;
                    if (result) {
                      result = dbInfo.serializer.deserialize(result);
                    }
                    result = iterator(result, item.key, i4 + 1);
                    if (result !== void 0) {
                      resolve(result);
                      return;
                    }
                  }
                  resolve();
                }, function(t6, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function _setItem(key2, value, callback, retriesLeft) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              if (value === void 0) {
                value = null;
              }
              var originalValue = value;
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  dbInfo.db.transaction(function(t5) {
                    tryExecuteSql(t5, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                      resolve(originalValue);
                    }, function(t6, error2) {
                      reject(error2);
                    });
                  }, function(sqlError) {
                    if (sqlError.code === sqlError.QUOTA_ERR) {
                      if (retriesLeft > 0) {
                        resolve(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                        return;
                      }
                      reject(sqlError);
                    }
                  });
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$1(key2, value, callback) {
          return _setItem.apply(this, [key2, value, callback, 1]);
        }
        function removeItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t5) {
                tryExecuteSql(t5, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                  resolve();
                }, function(t6, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t5) {
                tryExecuteSql(t5, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                  resolve();
                }, function(t6, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t5) {
                tryExecuteSql(t5, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t6, results) {
                  var result = results.rows.item(0).c;
                  resolve(result);
                }, function(t6, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$1(n3, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t5) {
                tryExecuteSql(t5, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n3 + 1], function(t6, results) {
                  var result = results.rows.length ? results.rows.item(0).key : null;
                  resolve(result);
                }, function(t6, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t5) {
                tryExecuteSql(t5, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t6, results) {
                  var keys3 = [];
                  for (var i4 = 0; i4 < results.rows.length; i4++) {
                    keys3.push(results.rows.item(i4).key);
                  }
                  resolve(keys3);
                }, function(t6, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getAllStoreNames(db) {
          return new Promise$1(function(resolve, reject) {
            db.transaction(function(t5) {
              t5.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t6, results) {
                var storeNames = [];
                for (var i4 = 0; i4 < results.rows.length; i4++) {
                  storeNames.push(results.rows.item(i4).name);
                }
                resolve({
                  db,
                  storeNames
                });
              }, function(t6, error) {
                reject(error);
              });
            }, function(sqlError) {
              reject(sqlError);
            });
          });
        }
        function dropInstance$1(options2, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options2 = typeof options2 !== "function" && options2 || {};
          if (!options2.name) {
            options2.name = options2.name || currentConfig.name;
            options2.storeName = options2.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options2.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve) {
              var db;
              if (options2.name === currentConfig.name) {
                db = self2._dbInfo.db;
              } else {
                db = openDatabase(options2.name, "", "", 0);
              }
              if (!options2.storeName) {
                resolve(getAllStoreNames(db));
              } else {
                resolve({
                  db,
                  storeNames: [options2.storeName]
                });
              }
            }).then(function(operationInfo) {
              return new Promise$1(function(resolve, reject) {
                operationInfo.db.transaction(function(t5) {
                  function dropTable(storeName) {
                    return new Promise$1(function(resolve2, reject2) {
                      t5.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                        resolve2();
                      }, function(t6, error) {
                        reject2(error);
                      });
                    });
                  }
                  var operations = [];
                  for (var i4 = 0, len = operationInfo.storeNames.length; i4 < len; i4++) {
                    operations.push(dropTable(operationInfo.storeNames[i4]));
                  }
                  Promise$1.all(operations).then(function() {
                    resolve();
                  })["catch"](function(e3) {
                    reject(e3);
                  });
                }, function(sqlError) {
                  reject(sqlError);
                });
              });
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var webSQLStorage = {
          _driver: "webSQLStorage",
          _initStorage: _initStorage$1,
          _support: isWebSQLValid(),
          iterate: iterate$1,
          getItem: getItem$1,
          setItem: setItem$1,
          removeItem: removeItem$1,
          clear: clear$1,
          length: length$1,
          key: key$1,
          keys: keys$1,
          dropInstance: dropInstance$1
        };
        function isLocalStorageValid() {
          try {
            return typeof localStorage !== "undefined" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
            !!localStorage.setItem;
          } catch (e3) {
            return false;
          }
        }
        function _getKeyPrefix(options2, defaultConfig) {
          var keyPrefix = options2.name + "/";
          if (options2.storeName !== defaultConfig.storeName) {
            keyPrefix += options2.storeName + "/";
          }
          return keyPrefix;
        }
        function checkIfLocalStorageThrows() {
          var localStorageTestKey = "_localforage_support_test";
          try {
            localStorage.setItem(localStorageTestKey, true);
            localStorage.removeItem(localStorageTestKey);
            return false;
          } catch (e3) {
            return true;
          }
        }
        function _isLocalStorageUsable() {
          return !checkIfLocalStorageThrows() || localStorage.length > 0;
        }
        function _initStorage$2(options2) {
          var self2 = this;
          var dbInfo = {};
          if (options2) {
            for (var i4 in options2) {
              dbInfo[i4] = options2[i4];
            }
          }
          dbInfo.keyPrefix = _getKeyPrefix(options2, self2._defaultConfig);
          if (!_isLocalStorageUsable()) {
            return Promise$1.reject();
          }
          self2._dbInfo = dbInfo;
          dbInfo.serializer = localforageSerializer;
          return Promise$1.resolve();
        }
        function clear$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var keyPrefix = self2._dbInfo.keyPrefix;
            for (var i4 = localStorage.length - 1; i4 >= 0; i4--) {
              var key2 = localStorage.key(i4);
              if (key2.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key2);
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result = localStorage.getItem(dbInfo.keyPrefix + key2);
            if (result) {
              result = dbInfo.serializer.deserialize(result);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$2(iterator, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var keyPrefix = dbInfo.keyPrefix;
            var keyPrefixLength = keyPrefix.length;
            var length3 = localStorage.length;
            var iterationNumber = 1;
            for (var i4 = 0; i4 < length3; i4++) {
              var key2 = localStorage.key(i4);
              if (key2.indexOf(keyPrefix) !== 0) {
                continue;
              }
              var value = localStorage.getItem(key2);
              if (value) {
                value = dbInfo.serializer.deserialize(value);
              }
              value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
              if (value !== void 0) {
                return value;
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$2(n3, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result;
            try {
              result = localStorage.key(n3);
            } catch (error) {
              result = null;
            }
            if (result) {
              result = result.substring(dbInfo.keyPrefix.length);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var length3 = localStorage.length;
            var keys3 = [];
            for (var i4 = 0; i4 < length3; i4++) {
              var itemKey = localStorage.key(i4);
              if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                keys3.push(itemKey.substring(dbInfo.keyPrefix.length));
              }
            }
            return keys3;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$2(callback) {
          var self2 = this;
          var promise = self2.keys().then(function(keys3) {
            return keys3.length;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            localStorage.removeItem(dbInfo.keyPrefix + key2);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$2(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            if (value === void 0) {
              value = null;
            }
            var originalValue = value;
            return new Promise$1(function(resolve, reject) {
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  try {
                    localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                    resolve(originalValue);
                  } catch (e3) {
                    if (e3.name === "QuotaExceededError" || e3.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                      reject(e3);
                    }
                    reject(e3);
                  }
                }
              });
            });
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance$2(options2, callback) {
          callback = getCallback.apply(this, arguments);
          options2 = typeof options2 !== "function" && options2 || {};
          if (!options2.name) {
            var currentConfig = this.config();
            options2.name = options2.name || currentConfig.name;
            options2.storeName = options2.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options2.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve) {
              if (!options2.storeName) {
                resolve(options2.name + "/");
              } else {
                resolve(_getKeyPrefix(options2, self2._defaultConfig));
              }
            }).then(function(keyPrefix) {
              for (var i4 = localStorage.length - 1; i4 >= 0; i4--) {
                var key2 = localStorage.key(i4);
                if (key2.indexOf(keyPrefix) === 0) {
                  localStorage.removeItem(key2);
                }
              }
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var localStorageWrapper = {
          _driver: "localStorageWrapper",
          _initStorage: _initStorage$2,
          _support: isLocalStorageValid(),
          iterate: iterate$2,
          getItem: getItem$2,
          setItem: setItem$2,
          removeItem: removeItem$2,
          clear: clear$2,
          length: length$2,
          key: key$2,
          keys: keys$2,
          dropInstance: dropInstance$2
        };
        var sameValue = function sameValue2(x4, y4) {
          return x4 === y4 || typeof x4 === "number" && typeof y4 === "number" && isNaN(x4) && isNaN(y4);
        };
        var includes = function includes2(array2, searchElement) {
          var len = array2.length;
          var i4 = 0;
          while (i4 < len) {
            if (sameValue(array2[i4], searchElement)) {
              return true;
            }
            i4++;
          }
          return false;
        };
        var isArray2 = Array.isArray || function(arg) {
          return Object.prototype.toString.call(arg) === "[object Array]";
        };
        var DefinedDrivers = {};
        var DriverSupport = {};
        var DefaultDrivers = {
          INDEXEDDB: asyncStorage,
          WEBSQL: webSQLStorage,
          LOCALSTORAGE: localStorageWrapper
        };
        var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
        var OptionalDriverMethods = ["dropInstance"];
        var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
        var DefaultConfig = {
          description: "",
          driver: DefaultDriverOrder.slice(),
          name: "localforage",
          // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
          // we can use without a prompt.
          size: 4980736,
          storeName: "keyvaluepairs",
          version: 1
        };
        function callWhenReady(localForageInstance, libraryMethod) {
          localForageInstance[libraryMethod] = function() {
            var _args = arguments;
            return localForageInstance.ready().then(function() {
              return localForageInstance[libraryMethod].apply(localForageInstance, _args);
            });
          };
        }
        function extend() {
          for (var i4 = 1; i4 < arguments.length; i4++) {
            var arg = arguments[i4];
            if (arg) {
              for (var _key in arg) {
                if (arg.hasOwnProperty(_key)) {
                  if (isArray2(arg[_key])) {
                    arguments[0][_key] = arg[_key].slice();
                  } else {
                    arguments[0][_key] = arg[_key];
                  }
                }
              }
            }
          }
          return arguments[0];
        }
        var LocalForage = function() {
          function LocalForage2(options2) {
            _classCallCheck2(this, LocalForage2);
            for (var driverTypeKey in DefaultDrivers) {
              if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                var driver = DefaultDrivers[driverTypeKey];
                var driverName = driver._driver;
                this[driverTypeKey] = driverName;
                if (!DefinedDrivers[driverName]) {
                  this.defineDriver(driver);
                }
              }
            }
            this._defaultConfig = extend({}, DefaultConfig);
            this._config = extend({}, this._defaultConfig, options2);
            this._driverSet = null;
            this._initDriver = null;
            this._ready = false;
            this._dbInfo = null;
            this._wrapLibraryMethodsWithReady();
            this.setDriver(this._config.driver)["catch"](function() {
            });
          }
          LocalForage2.prototype.config = function config3(options2) {
            if ((typeof options2 === "undefined" ? "undefined" : _typeof3(options2)) === "object") {
              if (this._ready) {
                return new Error("Can't call config() after localforage has been used.");
              }
              for (var i4 in options2) {
                if (i4 === "storeName") {
                  options2[i4] = options2[i4].replace(/\W/g, "_");
                }
                if (i4 === "version" && typeof options2[i4] !== "number") {
                  return new Error("Database version must be a number.");
                }
                this._config[i4] = options2[i4];
              }
              if ("driver" in options2 && options2.driver) {
                return this.setDriver(this._config.driver);
              }
              return true;
            } else if (typeof options2 === "string") {
              return this._config[options2];
            } else {
              return this._config;
            }
          };
          LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
            var promise = new Promise$1(function(resolve, reject) {
              try {
                var driverName = driverObject._driver;
                var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                if (!driverObject._driver) {
                  reject(complianceError);
                  return;
                }
                var driverMethods = LibraryMethods.concat("_initStorage");
                for (var i4 = 0, len = driverMethods.length; i4 < len; i4++) {
                  var driverMethodName = driverMethods[i4];
                  var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                  if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                    reject(complianceError);
                    return;
                  }
                }
                var configureMissingMethods = function configureMissingMethods2() {
                  var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                    return function() {
                      var error = new Error("Method " + methodName + " is not implemented by the current driver");
                      var promise2 = Promise$1.reject(error);
                      executeCallback(promise2, arguments[arguments.length - 1]);
                      return promise2;
                    };
                  };
                  for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                    var optionalDriverMethod = OptionalDriverMethods[_i];
                    if (!driverObject[optionalDriverMethod]) {
                      driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                    }
                  }
                };
                configureMissingMethods();
                var setDriverSupport = function setDriverSupport2(support) {
                  if (DefinedDrivers[driverName]) {
                    console.info("Redefining LocalForage driver: " + driverName);
                  }
                  DefinedDrivers[driverName] = driverObject;
                  DriverSupport[driverName] = support;
                  resolve();
                };
                if ("_support" in driverObject) {
                  if (driverObject._support && typeof driverObject._support === "function") {
                    driverObject._support().then(setDriverSupport, reject);
                  } else {
                    setDriverSupport(!!driverObject._support);
                  }
                } else {
                  setDriverSupport(true);
                }
              } catch (e3) {
                reject(e3);
              }
            });
            executeTwoCallbacks(promise, callback, errorCallback);
            return promise;
          };
          LocalForage2.prototype.driver = function driver() {
            return this._driver || null;
          };
          LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
            var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
            executeTwoCallbacks(getDriverPromise, callback, errorCallback);
            return getDriverPromise;
          };
          LocalForage2.prototype.getSerializer = function getSerializer(callback) {
            var serializerPromise = Promise$1.resolve(localforageSerializer);
            executeTwoCallbacks(serializerPromise, callback);
            return serializerPromise;
          };
          LocalForage2.prototype.ready = function ready(callback) {
            var self2 = this;
            var promise = self2._driverSet.then(function() {
              if (self2._ready === null) {
                self2._ready = self2._initDriver();
              }
              return self2._ready;
            });
            executeTwoCallbacks(promise, callback, callback);
            return promise;
          };
          LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
            var self2 = this;
            if (!isArray2(drivers)) {
              drivers = [drivers];
            }
            var supportedDrivers = this._getSupportedDrivers(drivers);
            function setDriverToConfig() {
              self2._config.driver = self2.driver();
            }
            function extendSelfWithDriver(driver) {
              self2._extend(driver);
              setDriverToConfig();
              self2._ready = self2._initStorage(self2._config);
              return self2._ready;
            }
            function initDriver(supportedDrivers2) {
              return function() {
                var currentDriverIndex = 0;
                function driverPromiseLoop() {
                  while (currentDriverIndex < supportedDrivers2.length) {
                    var driverName = supportedDrivers2[currentDriverIndex];
                    currentDriverIndex++;
                    self2._dbInfo = null;
                    self2._ready = null;
                    return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                  }
                  setDriverToConfig();
                  var error = new Error("No available storage method found.");
                  self2._driverSet = Promise$1.reject(error);
                  return self2._driverSet;
                }
                return driverPromiseLoop();
              };
            }
            var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
              return Promise$1.resolve();
            }) : Promise$1.resolve();
            this._driverSet = oldDriverSetDone.then(function() {
              var driverName = supportedDrivers[0];
              self2._dbInfo = null;
              self2._ready = null;
              return self2.getDriver(driverName).then(function(driver) {
                self2._driver = driver._driver;
                setDriverToConfig();
                self2._wrapLibraryMethodsWithReady();
                self2._initDriver = initDriver(supportedDrivers);
              });
            })["catch"](function() {
              setDriverToConfig();
              var error = new Error("No available storage method found.");
              self2._driverSet = Promise$1.reject(error);
              return self2._driverSet;
            });
            executeTwoCallbacks(this._driverSet, callback, errorCallback);
            return this._driverSet;
          };
          LocalForage2.prototype.supports = function supports(driverName) {
            return !!DriverSupport[driverName];
          };
          LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
            extend(this, libraryMethodsAndProperties);
          };
          LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
            var supportedDrivers = [];
            for (var i4 = 0, len = drivers.length; i4 < len; i4++) {
              var driverName = drivers[i4];
              if (this.supports(driverName)) {
                supportedDrivers.push(driverName);
              }
            }
            return supportedDrivers;
          };
          LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
            for (var i4 = 0, len = LibraryMethods.length; i4 < len; i4++) {
              callWhenReady(this, LibraryMethods[i4]);
            }
          };
          LocalForage2.prototype.createInstance = function createInstance(options2) {
            return new LocalForage2(options2);
          };
          return LocalForage2;
        }();
        var localforage_js = new LocalForage();
        module4.exports = localforage_js;
      }, { "3": 3 }] }, {}, [4])(4);
    });
  }
});

// node_modules/@datastructures-js/queue/src/queue.js
var require_queue = __commonJS({
  "node_modules/@datastructures-js/queue/src/queue.js"(exports) {
    var Queue3 = class _Queue {
      /**
       * Creates a queue.
       * @param {array} [elements]
       */
      constructor(elements) {
        this._elements = Array.isArray(elements) ? elements : [];
        this._offset = 0;
      }
      /**
       * Adds an element to the back of the queue.
       * @public
       * @param {number|string|object} element
       */
      enqueue(element) {
        this._elements.push(element);
        return this;
      }
      /**
       * Adds an element to the back of the queue.
       * @public
       * @param {number|string|object} element
       */
      push(element) {
        return this.enqueue(element);
      }
      /**
       * Dequeues the front element in the queue.
       * @public
       * @returns {number|string|object}
       */
      dequeue() {
        if (this.size() === 0) return null;
        const first = this.front();
        this._offset += 1;
        if (this._offset * 2 < this._elements.length) return first;
        this._elements = this._elements.slice(this._offset);
        this._offset = 0;
        return first;
      }
      /**
       * Dequeues the front element in the queue.
       * @public
       * @returns {number|string|object}
       */
      pop() {
        return this.dequeue();
      }
      /**
       * Returns the front element of the queue.
       * @public
       * @returns {number|string|object}
       */
      front() {
        return this.size() > 0 ? this._elements[this._offset] : null;
      }
      /**
       * Returns the back element of the queue.
       * @public
       * @returns {number|string|object}
       */
      back() {
        return this.size() > 0 ? this._elements[this._elements.length - 1] : null;
      }
      /**
       * Returns the number of elements in the queue.
       * @public
       * @returns {number}
       */
      size() {
        return this._elements.length - this._offset;
      }
      /**
       * Checks if the queue is empty.
       * @public
       * @returns {boolean}
       */
      isEmpty() {
        return this.size() === 0;
      }
      /**
       * Returns the remaining elements in the queue as an array.
       * @public
       * @returns {array}
       */
      toArray() {
        return this._elements.slice(this._offset);
      }
      /**
       * Clears the queue.
       * @public
       */
      clear() {
        this._elements = [];
        this._offset = 0;
      }
      /**
       * Creates a shallow copy of the queue.
       * @public
       * @return {Queue}
       */
      clone() {
        return new _Queue(this._elements.slice(this._offset));
      }
      /**
       * Creates a queue from an existing array.
       * @public
       * @static
       * @param {array} elements
       * @return {Queue}
       */
      static fromArray(elements) {
        return new _Queue(elements);
      }
    };
    exports.Queue = Queue3;
  }
});

// node_modules/@datastructures-js/queue/index.js
var require_queue2 = __commonJS({
  "node_modules/@datastructures-js/queue/index.js"(exports) {
    var { Queue: Queue3 } = require_queue();
    exports.Queue = Queue3;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DatacorePlugin
});
module.exports = __toCommonJS(main_exports);

// node_modules/luxon/src/luxon.js
var luxon_exports = {};
__export(luxon_exports, {
  DateTime: () => DateTime,
  Duration: () => Duration,
  FixedOffsetZone: () => FixedOffsetZone,
  IANAZone: () => IANAZone,
  Info: () => Info,
  Interval: () => Interval,
  InvalidZone: () => InvalidZone,
  Settings: () => Settings,
  SystemZone: () => SystemZone,
  VERSION: () => VERSION,
  Zone: () => Zone
});

// node_modules/luxon/src/errors.js
var LuxonError = class extends Error {
};
var InvalidDateTimeError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
};
var InvalidIntervalError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
};
var InvalidDurationError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
};
var ConflictingSpecificationError = class extends LuxonError {
};
var InvalidUnitError = class extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
};
var InvalidArgumentError = class extends LuxonError {
};
var ZoneIsAbstractError = class extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
};

// node_modules/luxon/src/impl/formats.js
var n = "numeric";
var s = "short";
var l = "long";
var DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
var DATE_MED = {
  year: n,
  month: s,
  day: n
};
var DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s
};
var DATE_FULL = {
  year: n,
  month: l,
  day: n
};
var DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
var TIME_SIMPLE = {
  hour: n,
  minute: n
};
var TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
var TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
var TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s
};
var TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l
};
var DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n
};
var DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s
};
var DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
var DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};

// node_modules/luxon/src/impl/util.js
function isUndefined(o4) {
  return typeof o4 === "undefined";
}
function isNumber(o4) {
  return typeof o4 === "number";
}
function isInteger(o4) {
  return typeof o4 === "number" && o4 % 1 === 0;
}
function isString(o4) {
  return typeof o4 === "string";
}
function isDate(o4) {
  return Object.prototype.toString.call(o4) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e3) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return void 0;
  }
  return arr.reduce((best, next3) => {
    const pair2 = [by(next3), next3];
    if (!best) {
      return pair2;
    } else if (compare(best[0], pair2[0]) === best[0]) {
      return best;
    } else {
      return pair2;
    }
  }, null)[1];
}
function pick(obj, keys2) {
  return keys2.reduce((a4, k4) => {
    a4[k4] = obj[k4];
    return a4;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x4, n3) {
  return x4 - n3 * Math.floor(x4 / n3);
}
function padStart(input2, n3 = 2) {
  const isNeg = input2 < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input2).padStart(n3, "0");
  } else {
    padded = ("" + input2).padStart(n3, "0");
  }
  return padded;
}
function parseInteger(string2) {
  if (isUndefined(string2) || string2 === null || string2 === "") {
    return void 0;
  } else {
    return parseInt(string2, 10);
  }
}
function parseFloating(string2) {
  if (isUndefined(string2) || string2 === null || string2 === "") {
    return void 0;
  } else {
    return parseFloat(string2);
  }
}
function parseMillis(fraction) {
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f4 = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f4);
  }
}
function roundTo(number, digits, towardZero = false) {
  const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d3 = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );
  if (obj.year < 100 && obj.year >= 0) {
    d3 = new Date(d3);
    d3.setUTCFullYear(d3.getUTCFullYear() - 1900);
  }
  return +d3;
}
function weeksInWeekYear(weekYear) {
  const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p22 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
  return p1 === 4 || p22 === 3 ? 53 : 52;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else return year > 60 ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = { timeZoneName: offsetFormat, ...intlOpts };
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m3) => m3.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u4 in obj) {
    if (hasOwnProperty(obj, u4)) {
      const v3 = obj[u4];
      if (v3 === void 0 || v3 === null) continue;
      normalized[normalizer(u4)] = asNumber(v3);
    }
  }
  return normalized;
}
function formatOffset(offset3, format) {
  const hours = Math.trunc(Math.abs(offset3 / 60)), minutes = Math.trunc(Math.abs(offset3 % 60)), sign = offset3 >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}
var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;

// node_modules/luxon/src/impl/english.js
var monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length2) {
  switch (length2) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
var weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length2) {
  switch (length2) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
var meridiems = ["AM", "PM"];
var erasLong = ["Before Christ", "Anno Domini"];
var erasShort = ["BC", "AD"];
var erasNarrow = ["B", "A"];
function eras(length2) {
  switch (length2) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length2) {
  return weekdays(length2)[dt.weekday - 1];
}
function monthForDateTime(dt, length2) {
  return months(length2)[dt.month - 1];
}
function eraForDateTime(dt, length2) {
  return eras(length2)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
      default:
    }
  }
  const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}

// node_modules/luxon/src/impl/formatter.js
function stringifyTokens(splits, tokenToString) {
  let s4 = "";
  for (const token2 of splits) {
    if (token2.literal) {
      s4 += token2.val;
    } else {
      s4 += tokenToString(token2.val);
    }
  }
  return s4;
}
var macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
var Formatter = class _Formatter {
  static create(locale, opts = {}) {
    return new _Formatter(locale, opts);
  }
  static parseFormat(fmt) {
    let current = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i4 = 0; i4 < fmt.length; i4++) {
      const c4 = fmt.charAt(i4);
      if (c4 === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed, val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c4;
      } else if (c4 === current) {
        currentFull += c4;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: false, val: currentFull });
        }
        currentFull = c4;
        current = c4;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed, val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token2) {
    return macroTokenToFormatOpts[token2];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  formatDateTime(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  formatDateTimeParts(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.formatToParts();
  }
  resolvedOptions(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.resolvedOptions();
  }
  num(n3, p3 = 0) {
    if (this.opts.forceSimple) {
      return padStart(n3, p3);
    }
    const opts = { ...this.opts };
    if (p3 > 0) {
      opts.padTo = p3;
    }
    return this.loc.numberFormatter(opts).format(n3);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string2 = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string2({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length2, standalone) => knownEnglish ? monthForDateTime(dt, length2) : string2(standalone ? { month: length2 } : { month: length2, day: "numeric" }, "month"), weekday = (length2, standalone) => knownEnglish ? weekdayForDateTime(dt, length2) : string2(
      standalone ? { weekday: length2 } : { weekday: length2, month: "long", day: "numeric" },
      "weekday"
    ), maybeMacro = (token2) => {
      const formatOpts = _Formatter.macroTokenToFormatOpts(token2);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token2;
      }
    }, era = (length2) => knownEnglish ? eraForDateTime(dt, length2) : string2({ era: length2 }, "era"), tokenToString = (token2) => {
      switch (token2) {
        // ms
        case "S":
          return this.num(dt.millisecond);
        case "u":
        // falls through
        case "SSS":
          return this.num(dt.millisecond, 3);
        // seconds
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        // fractional seconds
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        // minutes
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        // hours
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        // offset
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        // zone
        case "z":
          return dt.zoneName;
        // meridiems
        case "a":
          return meridiem();
        // dates
        case "d":
          return useDateTimeFormatter ? string2({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string2({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        // weekdays - standalone
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        // weekdays - format
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        // months - standalone
        case "L":
          return useDateTimeFormatter ? string2({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string2({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        // months - format
        case "M":
          return useDateTimeFormatter ? string2({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string2({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        // years
        case "y":
          return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string2({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year, 6);
        // eras
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1e3));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token2);
      }
    };
    return stringifyTokens(_Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token2) => {
      switch (token2[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, tokenToString = (lildur) => (token2) => {
      const mapped = tokenToField(token2);
      if (mapped) {
        return this.num(lildur.get(mapped), token2.length);
      } else {
        return token2;
      }
    }, tokens = _Formatter.parseFormat(fmt), realTokens = tokens.reduce(
      (found, { literal, val }) => literal ? found : found.concat(val),
      []
    ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t5) => t5));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
};

// node_modules/luxon/src/impl/invalid.js
var Invalid = class {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
};

// node_modules/luxon/src/zone.js
var Zone = class {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
};

// node_modules/luxon/src/zones/systemZone.js
var singleton = null;
var SystemZone = class _SystemZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton === null) {
      singleton = new _SystemZone();
    }
    return singleton;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale);
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }
  /** @override **/
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/IANAZone.js
var dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i4 = 0; i4 < formatted.length; i4++) {
    const { type, value } = formatted[i4];
    const pos = typeToPos[type];
    if (type === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
var ianaZoneCache = {};
var IANAZone = class _IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new _IANAZone(name);
    }
    return ianaZoneCache[name];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(s4) {
    return this.isValidZone(s4);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e3) {
      return false;
    }
  }
  constructor(name) {
    super();
    this.zoneName = name;
    this.valid = _IANAZone.isValidZone(name);
  }
  /** @override **/
  get type() {
    return "iana";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  offset(ts) {
    const date = new Date(ts);
    if (isNaN(date)) return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  /** @override **/
  get isValid() {
    return this.valid;
  }
};

// node_modules/luxon/src/zones/fixedOffsetZone.js
var singleton2 = null;
var FixedOffsetZone = class _FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton2 === null) {
      singleton2 = new _FixedOffsetZone(0);
    }
    return singleton2;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset3) {
    return offset3 === 0 ? _FixedOffsetZone.utcInstance : new _FixedOffsetZone(offset3);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s4) {
    if (s4) {
      const r4 = s4.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r4) {
        return new _FixedOffsetZone(signedOffset(r4[1], r4[2]));
      }
    }
    return null;
  }
  constructor(offset3) {
    super();
    this.fixed = offset3;
  }
  /** @override **/
  get type() {
    return "fixed";
  }
  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  /** @override **/
  offsetName() {
    return this.name;
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }
  /** @override **/
  get isUniversal() {
    return true;
  }
  /** @override **/
  offset() {
    return this.fixed;
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  /** @override **/
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/invalidZone.js
var InvalidZone = class extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return false;
  }
  /** @override **/
  get isValid() {
    return false;
  }
};

// node_modules/luxon/src/impl/zoneUtil.js
function normalizeZone(input2, defaultZone2) {
  let offset3;
  if (isUndefined(input2) || input2 === null) {
    return defaultZone2;
  } else if (input2 instanceof Zone) {
    return input2;
  } else if (isString(input2)) {
    const lowered = input2.toLowerCase();
    if (lowered === "local" || lowered === "system") return defaultZone2;
    else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;
    else return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input2);
  } else if (isNumber(input2)) {
    return FixedOffsetZone.instance(input2);
  } else if (typeof input2 === "object" && input2.offset && typeof input2.offset === "number") {
    return input2;
  } else {
    return new InvalidZone(input2);
  }
}

// node_modules/luxon/src/settings.js
var now = () => Date.now();
var defaultZone = "system";
var defaultLocale = null;
var defaultNumberingSystem = null;
var defaultOutputCalendar = null;
var throwOnInvalid;
var Settings = class {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n3) {
    now = n3;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t5) {
    throwOnInvalid = t5;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
};

// node_modules/luxon/src/impl/locale.js
var intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
var intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
var intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
var intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const { base, ...cacheKeyOpts } = opts;
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
var sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
function parseLocaleString(localeStr) {
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options2;
    const smaller = localeStr.substring(0, uIndex);
    try {
      options2 = getCachedDTF(localeStr).resolvedOptions();
    } catch (e3) {
      options2 = getCachedDTF(smaller).resolvedOptions();
    }
    const { numberingSystem, calendar } = options2;
    return [smaller, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    localeStr += "-u";
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f4) {
  const ms = [];
  for (let i4 = 1; i4 <= 12; i4++) {
    const dt = DateTime.utc(2016, i4, 1);
    ms.push(f4(dt));
  }
  return ms;
}
function mapWeekdays(f4) {
  const ms = [];
  for (let i4 = 1; i4 <= 7; i4++) {
    const dt = DateTime.utc(2016, 11, 13 + i4);
    ms.push(f4(dt));
  }
  return ms;
}
function listStuff(loc, length2, defaultOK, englishFn, intlFn) {
  const mode = loc.listingMode(defaultOK);
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length2);
  } else {
    return intlFn(length2);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
var PolyNumberFormatter = class {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const { padTo, floor: floor2, ...otherOpts } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i4) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i4) : i4;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i4) : roundTo(i4, 3);
      return padStart(fixed, this.padTo);
    }
  }
};
var PolyDateFormatter = class {
  constructor(dt, intl, opts) {
    this.opts = opts;
    let z4;
    if (dt.zone.isUniversal) {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z4 = offsetZ;
        this.dt = dt;
      } else {
        z4 = "UTC";
        if (opts.timeZoneName) {
          this.dt = dt;
        } else {
          this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1e3);
        }
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else {
      this.dt = dt;
      z4 = dt.zone.name;
    }
    const intlOpts = { ...this.opts };
    if (z4) {
      intlOpts.timeZone = z4;
    }
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    return this.dtf.formatToParts(this.dt.toJSDate());
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
};
var PolyRelFormatter = class {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
};
var Locale = class _Locale {
  static fromOpts(opts) {
    return _Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
  }
  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    return new _Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
    return _Locale.create(locale, numberingSystem, outputCalendar);
  }
  constructor(locale, numbering, outputCalendar, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return _Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        alts.defaultToEN || false
      );
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }
  months(length2, format = false, defaultOK = true) {
    return listStuff(this, length2, defaultOK, months, () => {
      const intl = format ? { month: length2, day: "numeric" } : { month: length2 }, formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length2]) {
        this.monthsCache[formatStr][length2] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length2];
    });
  }
  weekdays(length2, format = false, defaultOK = true) {
    return listStuff(this, length2, defaultOK, weekdays, () => {
      const intl = format ? { weekday: length2, year: "numeric", month: "long", day: "numeric" } : { weekday: length2 }, formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length2]) {
        this.weekdaysCache[formatStr][length2] = mapWeekdays(
          (dt) => this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length2];
    });
  }
  meridiems(defaultOK = true) {
    return listStuff(
      this,
      void 0,
      defaultOK,
      () => meridiems,
      () => {
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (dt) => this.extract(dt, intl, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(length2, defaultOK = true) {
    return listStuff(this, length2, defaultOK, eras, () => {
      const intl = { era: length2 };
      if (!this.eraCache[length2]) {
        this.eraCache[length2] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
          (dt) => this.extract(dt, intl, "era")
        );
      }
      return this.eraCache[length2];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching2 = results.find((m3) => m3.type.toLowerCase() === field);
    return matching2 ? matching2.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
};

// node_modules/luxon/src/impl/regexParser.js
function combineRegexes(...regexes) {
  const full = regexes.reduce((f4, r4) => f4 + r4.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m3) => extractors.reduce(
    ([mergedVals, mergedZone, cursor2], ex) => {
      const [val, zone, next3] = ex(m3, cursor2);
      return [{ ...mergedVals, ...val }, zone || mergedZone, next3];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function parse(s4, ...patterns) {
  if (s4 == null) {
    return [null, null];
  }
  for (const [regex2, extractor] of patterns) {
    const m3 = regex2.exec(s4);
    if (m3) {
      return extractor(m3);
    }
  }
  return [null, null];
}
function simpleParse(...keys2) {
  return (match4, cursor2) => {
    const ret = {};
    let i4;
    for (i4 = 0; i4 < keys2.length; i4++) {
      ret[keys2[i4]] = parseInteger(match4[cursor2 + i4]);
    }
    return [ret, null, cursor2 + i4];
  };
}
var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
var extractISOOrdinalData = simpleParse("year", "ordinal");
var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
var sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match4, pos, fallback) {
  const m3 = match4[pos];
  return isUndefined(m3) ? fallback : parseInteger(m3);
}
function extractISOYmd(match4, cursor2) {
  const item = {
    year: int(match4, cursor2),
    month: int(match4, cursor2 + 1, 1),
    day: int(match4, cursor2 + 2, 1)
  };
  return [item, null, cursor2 + 3];
}
function extractISOTime(match4, cursor2) {
  const item = {
    hours: int(match4, cursor2, 0),
    minutes: int(match4, cursor2 + 1, 0),
    seconds: int(match4, cursor2 + 2, 0),
    milliseconds: parseMillis(match4[cursor2 + 3])
  };
  return [item, null, cursor2 + 4];
}
function extractISOOffset(match4, cursor2) {
  const local = !match4[cursor2] && !match4[cursor2 + 1], fullOffset = signedOffset(match4[cursor2 + 1], match4[cursor2 + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor2 + 3];
}
function extractIANAZone(match4, cursor2) {
  const zone = match4[cursor2] ? IANAZone.create(match4[cursor2]) : null;
  return [{}, zone, cursor2 + 1];
}
var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match4) {
  const [
    s4,
    yearStr,
    monthStr,
    weekStr,
    dayStr,
    hourStr,
    minuteStr,
    secondStr,
    millisecondsStr
  ] = match4;
  const hasNegativePrefix = s4[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
var obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr) result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match4) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match4, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset3;
  if (obsOffset) {
    offset3 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset3 = 0;
  } else {
    offset3 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset3)];
}
function preprocessRFC2822(s4) {
  return s4.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match4) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match4, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match4) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match4, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseISODate(s4) {
  return parse(
    s4,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}
function parseRFC2822Date(s4) {
  return parse(preprocessRFC2822(s4), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s4) {
  return parse(
    s4,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}
function parseISODuration(s4) {
  return parse(s4, [isoDuration, extractISODuration]);
}
var extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s4) {
  return parse(s4, [isoTimeOnly, extractISOTimeOnly]);
}
var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseSQL(s4) {
  return parse(
    s4,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}

// node_modules/luxon/src/duration.js
var INVALID = "Invalid Duration";
var lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
};
var casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var daysInYearAccurate = 146097 / 400;
var daysInMonthAccurate = 146097 / 4800;
var accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var orderedUnits = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
var reverseUnits = orderedUnits.slice(0).reverse();
function clone(dur, alts, clear = false) {
  const conf = {
    values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy
  };
  return new Duration(conf);
}
function antiTrunc(n3) {
  return n3 < 0 ? Math.floor(n3) : Math.ceil(n3);
}
function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
  const conv = matrix[toUnit][fromUnit], raw = fromMap[fromUnit] / conv, sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]), added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
  toMap[toUnit] += added;
  fromMap[fromUnit] -= added * conv;
}
function normalizeValues(matrix, vals) {
  reverseUnits.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        convert(matrix, vals, previous, vals, current);
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}
var Duration = class _Duration {
  /**
   * @private
   */
  constructor(config3) {
    const accurate = config3.conversionAccuracy === "longterm" || false;
    this.values = config3.values;
    this.loc = config3.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config3.invalid || null;
    this.matrix = accurate ? accurateMatrix : casualMatrix;
    this.isLuxonDuration = true;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count, opts) {
    return _Duration.fromObject({ milliseconds: count }, opts);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
      );
    }
    return new _Duration({
      values: normalizeObject(obj, _Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return _Duration.fromMillis(durationLike);
    } else if (_Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return _Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text2, opts) {
    const [parsed] = parseISODuration(text2);
    if (parsed) {
      return _Duration.fromObject(parsed, opts);
    } else {
      return _Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text2, opts) {
    const [parsed] = parseISOTimeOnly(text2);
    if (parsed) {
      return _Duration.fromObject(parsed, opts);
    } else {
      return _Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new _Duration({ invalid });
    }
  }
  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized) throw new InvalidUnitError(unit);
    return normalized;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o4) {
    return o4 && o4.isLuxonDuration || false;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
   * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(opts = {}) {
    const l4 = orderedUnits.map((unit) => {
      const val = this.values[unit];
      if (isUndefined(val)) {
        return null;
      }
      return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
    }).filter((n3) => n3);
    return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l4);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid) return {};
    return { ...this.values };
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid) return null;
    let s4 = "P";
    if (this.years !== 0) s4 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0) s4 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0) s4 += this.weeks + "W";
    if (this.days !== 0) s4 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s4 += "T";
    if (this.hours !== 0) s4 += this.hours + "H";
    if (this.minutes !== 0) s4 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s4 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s4 === "P") s4 += "T0S";
    return s4;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid) return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5) return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts
    };
    const value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
    let fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
    if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
      fmt += opts.format === "basic" ? "ss" : ":ss";
      if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
        fmt += ".SSS";
      }
    }
    let str = value.toFormat(fmt);
    if (opts.includePrefix) {
      str = "T" + str;
    }
    return str;
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.as("milliseconds");
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = _Duration.fromDurationLike(duration), result = {};
    for (const k4 of orderedUnits) {
      if (hasOwnProperty(dur.values, k4) || hasOwnProperty(this.values, k4)) {
        result[k4] = dur.get(k4) + this.get(k4);
      }
    }
    return clone(this, { values: result }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = _Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hour" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn2) {
    if (!this.isValid) return this;
    const result = {};
    for (const k4 of Object.keys(this.values)) {
      result[k4] = asNumber(fn2(this.values[k4], k4));
    }
    return clone(this, { values: result }, true);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[_Duration.normalizeUnit(unit)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid) return this;
    const mixed = { ...this.values, ...normalizeObject(values, _Duration.normalizeUnit) };
    return clone(this, { values: mixed });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale, numberingSystem, conversionAccuracy } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem }), opts = { loc };
    if (conversionAccuracy) {
      opts.conversionAccuracy = conversionAccuracy;
    }
    return clone(this, opts);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone(this, { values: vals }, true);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid) return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u4) => _Duration.normalizeUnit(u4));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k4 of orderedUnits) {
      if (units.indexOf(k4) >= 0) {
        lastUnit = k4;
        let own = 0;
        for (const ak in accumulated) {
          own += this.matrix[ak][k4] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber(vals[k4])) {
          own += vals[k4];
        }
        const i4 = Math.trunc(own);
        built[k4] = i4;
        accumulated[k4] = (own * 1e3 - i4 * 1e3) / 1e3;
        for (const down in vals) {
          if (orderedUnits.indexOf(down) > orderedUnits.indexOf(k4)) {
            convert(this.matrix, vals, down, built, k4);
          }
        }
      } else if (isNumber(vals[k4])) {
        accumulated[k4] = vals[k4];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    return clone(this, { values: built }, true).normalize();
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) return this;
    const negated = {};
    for (const k4 of Object.keys(this.values)) {
      negated[k4] = this.values[k4] === 0 ? 0 : -this.values[k4];
    }
    return clone(this, { values: negated }, true);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v22) {
      if (v1 === void 0 || v1 === 0) return v22 === void 0 || v22 === 0;
      return v1 === v22;
    }
    for (const u4 of orderedUnits) {
      if (!eq(this.values[u4], other.values[u4])) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/luxon/src/interval.js
var INVALID2 = "Invalid Interval";
function validateStartEnd(start, end2) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end2 || !end2.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end2 < start) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end2.toISO()}`
    );
  } else {
    return null;
  }
}
var Interval = class _Interval {
  /**
   * @private
   */
  constructor(config3) {
    this.s = config3.start;
    this.e = config3.end;
    this.invalid = config3.invalid || null;
    this.isLuxonInterval = true;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new _Interval({ invalid });
    }
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start, end2) {
    const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end2);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new _Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
    return _Interval.fromDateTimes(dt, dt.plus(dur));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end2, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end2);
    return _Interval.fromDateTimes(dt.minus(dur), dt);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text2, opts) {
    const [s4, e3] = (text2 || "").split("/", 2);
    if (s4 && e3) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s4, opts);
        startIsValid = start.isValid;
      } catch (e4) {
        startIsValid = false;
      }
      let end2, endIsValid;
      try {
        end2 = DateTime.fromISO(e3, opts);
        endIsValid = end2.isValid;
      } catch (e4) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return _Interval.fromDateTimes(start, end2);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e3, opts);
        if (dur.isValid) {
          return _Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s4, opts);
        if (dur.isValid) {
          return _Interval.before(end2, dur);
        }
      }
    }
    return _Interval.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o4) {
    return o4 && o4.isLuxonInterval || false;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @return {number}
   */
  count(unit = "milliseconds") {
    if (!this.isValid) return NaN;
    const start = this.start.startOf(unit), end2 = this.end.startOf(unit);
    return Math.floor(end2.diff(start, unit).get(unit)) + 1;
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid) return false;
    return this.s > dateTime;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid) return false;
    return this.e <= dateTime;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid) return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start, end: end2 } = {}) {
    if (!this.isValid) return this;
    return _Interval.fromDateTimes(start || this.s, end2 || this.e);
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid) return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d3) => this.contains(d3)).sort(), results = [];
    let { s: s4 } = this, i4 = 0;
    while (s4 < this.e) {
      const added = sorted[i4] || this.e, next3 = +added > +this.e ? this.e : added;
      results.push(_Interval.fromDateTimes(s4, next3));
      s4 = next3;
      i4 += 1;
    }
    return results;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s4 } = this, idx = 1, next3;
    const results = [];
    while (s4 < this.e) {
      const added = this.start.plus(dur.mapUnits((x4) => x4 * idx));
      next3 = +added > +this.e ? this.e : added;
      results.push(_Interval.fromDateTimes(s4, next3));
      s4 = next3;
      idx += 1;
    }
    return results;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid) return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid) return false;
    return +this.e === +other.s;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid) return false;
    return +other.e === +this.s;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid) return false;
    return this.s <= other.s && this.e >= other.e;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid) return this;
    const s4 = this.s > other.s ? this.s : other.s, e3 = this.e < other.e ? this.e : other.e;
    if (s4 >= e3) {
      return null;
    } else {
      return _Interval.fromDateTimes(s4, e3);
    }
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid) return this;
    const s4 = this.s < other.s ? this.s : other.s, e3 = this.e > other.e ? this.e : other.e;
    return _Interval.fromDateTimes(s4, e3);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals.sort((a4, b3) => a4.s - b3.s).reduce(
      ([sofar, current], item) => {
        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      },
      [[], null]
    );
    if (final) {
      found.push(final);
    }
    return found;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start = null, currentCount = 0;
    const results = [], ends = intervals.map((i4) => [
      { time: i4.s, type: "s" },
      { time: i4.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a4, b3) => a4.time - b3.time);
    for (const i4 of arr) {
      currentCount += i4.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i4.time;
      } else {
        if (start && +start !== +i4.time) {
          results.push(_Interval.fromDateTimes(start, i4.time));
        }
        start = null;
      }
    }
    return _Interval.merge(results);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return _Interval.xor([this].concat(intervals)).map((i4) => this.intersection(i4)).filter((i4) => i4 && !i4.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid) return INVALID2;
    return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid) return INVALID2;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid) return INVALID2;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid) return INVALID2;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format string.
   * @param {string} dateFormat - the format string. This string formats the start and end time. See {@link DateTime#toFormat} for details.
   * @param {Object} opts - options
   * @param {string} [opts.separator =  ' – '] - a separator to place between the start and end representations
   * @return {string}
   */
  toFormat(dateFormat, { separator = " \u2013 " } = {}) {
    if (!this.isValid) return INVALID2;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return _Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
};

// node_modules/luxon/src/info.js
var Info = class {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input2) {
    return normalizeZone(input2, Settings.defaultZone);
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months(length2 = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length2);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(length2 = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length2, true);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays(length2 = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length2);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(length2 = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length2, true);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras(length2 = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length2);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * @example Info.features() //=> { relative: false }
   * @return {Object}
   */
  static features() {
    return { relative: hasRelative() };
  }
};

// node_modules/luxon/src/impl/diff.js
function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor2, later, units) {
  const differs = [
    ["years", (a4, b3) => b3.year - a4.year],
    ["quarters", (a4, b3) => b3.quarter - a4.quarter],
    ["months", (a4, b3) => b3.month - a4.month + (b3.year - a4.year) * 12],
    [
      "weeks",
      (a4, b3) => {
        const days = dayDiff(a4, b3);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      let delta = differ(cursor2, later);
      highWater = cursor2.plus({ [unit]: delta });
      if (highWater > later) {
        cursor2 = cursor2.plus({ [unit]: delta - 1 });
        delta -= 1;
      } else {
        cursor2 = highWater;
      }
      results[unit] = delta;
    }
  }
  return [cursor2, results, highWater, lowestOrder];
}
function diff_default(earlier, later, units, opts) {
  let [cursor2, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor2;
  const lowerOrderUnits = units.filter(
    (u4) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u4) >= 0
  );
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor2.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor2) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor2);
    }
  }
  const duration = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}

// node_modules/luxon/src/impl/digits.js
var numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
var numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i4 = 0; i4 < str.length; i4++) {
      const code = str.charCodeAt(i4);
      if (str[i4].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i4]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min2, max2] = numberingSystemsUTF16[key];
          if (code >= min2 && code <= max2) {
            value += code - min2;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex({ numberingSystem }, append2 = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append2}`);
}

// node_modules/luxon/src/impl/tokenParser.js
var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex2, post = (i4) => i4) {
  return { regex: regex2, deser: ([s4]) => post(parseDigits(s4)) };
}
var NBSP = String.fromCharCode(160);
var spaceOrNBSP = `[ ${NBSP}]`;
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s4) {
  return s4.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s4) {
  return s4.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s4]) => strings.findIndex((i4) => stripInsensitivities(s4) === stripInsensitivities(i4)) + startIndex
    };
  }
}
function offset(regex2, groups) {
  return { regex: regex2, deser: ([, h3, m3]) => signedOffset(h3, m3), groups };
}
function simple(regex2) {
  return { regex: regex2, deser: ([s4]) => s4 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token2, loc) {
  const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t5) => ({ regex: RegExp(escapeToken(t5.val)), deser: ([s4]) => s4, literal: true }), unitate = (t5) => {
    if (token2.literal) {
      return literal(t5);
    }
    switch (t5.val) {
      // era
      case "G":
        return oneOf(loc.eras("short", false), 0);
      case "GG":
        return oneOf(loc.eras("long", false), 0);
      // years
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      // months
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true, false), 1);
      case "MMMM":
        return oneOf(loc.months("long", true, false), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false, false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false, false), 1);
      // dates
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      // ordinals
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      // time
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one);
      // meridiem
      case "a":
        return oneOf(loc.meridiems(), 0);
      // weekYear (k)
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      // weekNumber (W)
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      // weekdays
      case "E":
      case "c":
        return intUnit(one);
      case "EEE":
        return oneOf(loc.weekdays("short", false, false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false, false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true, false), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true, false), 1);
      // offset/zone
      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
      // because we don't have any way to figure out what they are
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      default:
        return literal(t5);
    }
  };
  const unit = unitate(token2) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token2;
  return unit;
}
var partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  }
};
function tokenForPart(part, locale, formatOpts) {
  const { type, value } = part;
  if (type === "literal") {
    return {
      literal: true,
      val: value
    };
  }
  const style = formatOpts[type];
  let val = partTypeStyleToTokenVal[type];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re = units.map((u4) => u4.regex).reduce((f4, r4) => `${f4}(${r4.source})`, "");
  return [`^${re}$`, units];
}
function match(input2, regex2, handlers) {
  const matches = input2.match(regex2);
  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i4 in handlers) {
      if (hasOwnProperty(handlers, i4)) {
        const h3 = handlers[i4], groups = h3.groups ? h3.groups + 1 : 1;
        if (!h3.literal && h3.token) {
          all[h3.token.val[0]] = h3.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = (token2) => {
    switch (token2) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r4, k4) => {
    const f4 = toField(k4);
    if (f4) {
      r4[f4] = matches[k4];
    }
    return r4;
  }, {});
  return [vals, zone, specificOffset];
}
var dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token2, locale) {
  if (token2.literal) {
    return token2;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token2.val);
  if (!formatOpts) {
    return token2;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const parts = formatter.formatDateTimeParts(getDummyDateTime());
  const tokens = parts.map((p3) => tokenForPart(p3, locale, formatOpts));
  if (tokens.includes(void 0)) {
    return token2;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t5) => maybeExpandMacroToken(t5, locale)));
}
function explainFromTokens(locale, input2, format) {
  const tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map((t5) => unitForToken(t5, locale)), disqualifyingUnit = units.find((t5) => t5.invalidReason);
  if (disqualifyingUnit) {
    return { input: input2, tokens, invalidReason: disqualifyingUnit.invalidReason };
  } else {
    const [regexString, handlers] = buildRegex(units), regex2 = RegExp(regexString, "i"), [rawMatches, matches] = match(input2, regex2, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
    if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
      throw new ConflictingSpecificationError(
        "Can't include meridiem when specifying 24-hour format"
      );
    }
    return { input: input2, tokens, regex: regex2, rawMatches, matches, result, zone, specificOffset };
  }
}
function parseFromTokens(locale, input2, format) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input2, format);
  return [result, zone, specificOffset, invalidReason];
}

// node_modules/luxon/src/impl/conversions.js
var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid(
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
  );
}
function dayOfWeek(year, month, day) {
  const d3 = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d3.setUTCFullYear(d3.getUTCFullYear() - 1900);
  }
  const js = d3.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i4) => i4 < ordinal), day = ordinal - table[month0];
  return { month: month0 + 1, day };
}
function gregorianToWeek(gregObj) {
  const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
  let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear);
  } else if (weekNumber > weeksInWeekYear(year)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}
function weekToGregorian(weekData) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(weekData) };
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return { year, ordinal, ...timeObject(gregData) };
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(ordinalData) };
}
function hasInvalidWeekData(obj) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.week);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else return false;
}

// node_modules/luxon/src/datetime.js
var INVALID3 = "Invalid DateTime";
var MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function clone2(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({ ...current, ...alts, old: current });
}
function fixOffset(localTS, o4, tz) {
  let utcGuess = localTS - o4 * 60 * 1e3;
  const o22 = tz.offset(utcGuess);
  if (o4 === o22) {
    return [utcGuess, o4];
  }
  utcGuess -= (o22 - o4) * 60 * 1e3;
  const o32 = tz.offset(utcGuess);
  if (o22 === o32) {
    return [utcGuess, o22];
  }
  return [localTS - Math.min(o22, o32) * 60 * 1e3, Math.max(o22, o32)];
}
function tsToObj(ts, offset3) {
  ts += offset3 * 60 * 1e3;
  const d3 = new Date(ts);
  return {
    year: d3.getUTCFullYear(),
    month: d3.getUTCMonth() + 1,
    day: d3.getUTCDate(),
    hour: d3.getUTCHours(),
    minute: d3.getUTCMinutes(),
    second: d3.getUTCSeconds(),
    millisecond: d3.getUTCMilliseconds()
  };
}
function objToTS(obj, offset3, zone) {
  return fixOffset(objToLocalTS(obj), offset3, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c4 = {
    ...inst.c,
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }, millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c4);
  let [ts, o4] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o4 = inst.zone.offset(ts);
  }
  return { ts, o: o4 };
}
function parseDataToDateTime(parsed, parsedZone, opts, format, text2, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
      ...opts,
      zone: interpretationZone,
      specificOffset
    });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${text2}" can't be parsed as ${format}`)
    );
  }
}
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
}
function toISODate(o4, extended) {
  const longFormat = o4.c.year > 9999 || o4.c.year < 0;
  let c4 = "";
  if (longFormat && o4.c.year >= 0) c4 += "+";
  c4 += padStart(o4.c.year, longFormat ? 6 : 4);
  if (extended) {
    c4 += "-";
    c4 += padStart(o4.c.month);
    c4 += "-";
    c4 += padStart(o4.c.day);
  } else {
    c4 += padStart(o4.c.month);
    c4 += padStart(o4.c.day);
  }
  return c4;
}
function toISOTime(o4, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c4 = padStart(o4.c.hour);
  if (extended) {
    c4 += ":";
    c4 += padStart(o4.c.minute);
    if (o4.c.second !== 0 || !suppressSeconds) {
      c4 += ":";
    }
  } else {
    c4 += padStart(o4.c.minute);
  }
  if (o4.c.second !== 0 || !suppressSeconds) {
    c4 += padStart(o4.c.second);
    if (o4.c.millisecond !== 0 || !suppressMilliseconds) {
      c4 += ".";
      c4 += padStart(o4.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o4.isOffsetFixed && o4.offset === 0 && !extendedZone) {
      c4 += "Z";
    } else if (o4.o < 0) {
      c4 += "-";
      c4 += padStart(Math.trunc(-o4.o / 60));
      c4 += ":";
      c4 += padStart(Math.trunc(-o4.o % 60));
    } else {
      c4 += "+";
      c4 += padStart(Math.trunc(o4.o / 60));
      c4 += ":";
      c4 += padStart(Math.trunc(o4.o % 60));
    }
  }
  if (extendedZone) {
    c4 += "[" + o4.zone.ianaName + "]";
  }
  return c4;
}
var defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized) throw new InvalidUnitError(unit);
  return normalized;
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
  let ts, o4;
  if (!isUndefined(obj.year)) {
    for (const u4 of orderedUnits2) {
      if (isUndefined(obj[u4])) {
        obj[u4] = defaultUnitValues[u4];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = zone.offset(tsNow);
    [ts, o4] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }
  return new DateTime({ ts, zone, loc, o: o4 });
}
function diffRelative(start, end2, opts) {
  const round2 = isUndefined(opts.round) ? true : opts.round, format = (c4, unit) => {
    c4 = roundTo(c4, round2 || opts.calendary ? 0 : 2, true);
    const formatter = end2.loc.clone(opts).relFormatter(opts);
    return formatter.format(c4, unit);
  }, differ = (unit) => {
    if (opts.calendary) {
      if (!end2.hasSame(start, unit)) {
        return end2.startOf(unit).diff(start.startOf(unit), unit).get(unit);
      } else return 0;
    } else {
      return end2.diff(start, unit).get(unit);
    }
  };
  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end2 ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
var DateTime = class _DateTime {
  /**
   * @access private
   */
  constructor(config3) {
    const zone = config3.zone || Settings.defaultZone;
    let invalid = config3.invalid || (Number.isNaN(config3.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined(config3.ts) ? Settings.now() : config3.ts;
    let c4 = null, o4 = null;
    if (!invalid) {
      const unchanged = config3.old && config3.old.ts === this.ts && config3.old.zone.equals(zone);
      if (unchanged) {
        [c4, o4] = [config3.old.c, config3.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c4 = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c4.year) ? new Invalid("invalid input") : null;
        c4 = invalid ? null : c4;
        o4 = invalid ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config3.loc || Locale.create();
    this.invalid = invalid;
    this.weekData = null;
    this.c = c4;
    this.o = o4;
    this.isLuxonDateTime = true;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new _DateTime({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date, options2 = {}) {
    const ts = isDate(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return _DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options2.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return _DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new _DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options2)
    });
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options2 = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return _DateTime.invalid("Timestamp out of range");
    } else {
      return new _DateTime({
        ts: milliseconds,
        zone: normalizeZone(options2.zone, Settings.defaultZone),
        loc: Locale.fromObject(options2)
      });
    }
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options2 = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new _DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options2.zone, Settings.defaultZone),
        loc: Locale.fromObject(options2)
      });
    }
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return _DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits2;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u4 of units) {
      const v3 = normalized[u4];
      if (!isUndefined(v3)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u4] = defaultValues[u4];
      } else {
        normalized[u4] = objNow[u4];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return _DateTime.invalid(invalid);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new _DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return _DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }
    return inst;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text2, opts = {}) {
    const [vals, parsedZone] = parseISODate(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text2);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text2, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text2);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text2, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text2, fmt, opts = {}) {
    if (isUndefined(text2) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text2, fmt);
    if (invalid) {
      return _DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text2, specificOffset);
    }
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text2, fmt, opts = {}) {
    return _DateTime.fromFormat(text2, fmt, opts);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text2, opts = {}) {
    const [vals, parsedZone] = parseSQL(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text2);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new _DateTime({ invalid });
    }
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o4) {
    return o4 && o4.isLuxonDateTime || false;
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset3 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset3), opts);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return _DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone2(this, { ts: newTS, zone });
    }
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone2(this, { loc });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({ locale });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values) {
    if (!this.isValid) return this;
    const normalized = normalizeObject(values, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian({ ...gregorianToWeek(this.c), ...normalized });
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o4] = objToTS(mixed, this.o, this.zone);
    return clone2(this, { ts, o: o4 });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration);
    return clone2(this, adjustTime(this, dur));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return clone2(this, adjustTime(this, dur));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit) {
    if (!this.isValid) return this;
    const o4 = {}, normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o4.month = 1;
      // falls through
      case "quarters":
      case "months":
        o4.day = 1;
      // falls through
      case "weeks":
      case "days":
        o4.hour = 0;
      // falls through
      case "hours":
        o4.minute = 0;
      // falls through
      case "minutes":
        o4.second = 0;
      // falls through
      case "seconds":
        o4.millisecond = 0;
        break;
      case "milliseconds":
        break;
    }
    if (normalizedUnit === "weeks") {
      o4.weekday = 1;
    }
    if (normalizedUnit === "quarters") {
      const q4 = Math.ceil(this.month / 3);
      o4.month = (q4 - 1) * 3 + 1;
    }
    return this.set(o4);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit) {
    return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID3;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString({ locale: 'en-gb' }); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID3;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format === "extended";
    let c4 = toISODate(this, ext);
    c4 += "T";
    c4 += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c4;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format === "extended");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c4 = includePrefix ? "T" : "";
    return c4 + toISOTime(
      this,
      format === "extended",
      suppressSeconds,
      suppressMilliseconds,
      includeOffset,
      extendedZone
    );
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID3;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid) return {};
    const base = { ...this.c };
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
    const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff_default(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(_DateTime.now(), unit, opts);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit) {
    if (!this.isValid) return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
  }
  /**
   * Equality check
   * Two DateTimes are equal iff they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options2 = {}) {
    if (!this.isValid) return null;
    const base = options2.base || _DateTime.fromObject({}, { zone: this.zone }), padding = options2.padding ? this < base ? -options2.padding : options2.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options2.unit;
    if (Array.isArray(options2.unit)) {
      units = options2.unit;
      unit = void 0;
    }
    return diffRelative(base, this.plus(padding), {
      ...options2,
      numeric: "always",
      units,
      unit
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options2 = {}) {
    if (!this.isValid) return null;
    return diffRelative(options2.base || _DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options2,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(_DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i4) => i4.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(_DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i4) => i4.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text2, fmt, options2 = {}) {
    const { locale = null, numberingSystem = null } = options2, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text2, fmt);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text2, fmt, options2 = {}) {
    return _DateTime.fromFormatExplain(text2, fmt, options2);
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
};
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}

// node_modules/luxon/src/luxon.js
var VERSION = "2.5.2";

// src/utils/normalizers.ts
var P = __toESM(require_parsimmon_umd_min());

// node_modules/emoji-regex/index.mjs
var emoji_regex_default = () => {
  return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
};

// src/utils/normalizers.ts
function currentLocale() {
  if (typeof window === "undefined") return "en-US";
  return window.navigator.language;
}
function normalizeDuration(dur) {
  if (dur === void 0 || dur === null) return dur;
  return dur.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds").normalize();
}
function renderMinimalDate(time, dateFormat, dateTimeFormat, locale) {
  if (time.second == 0 && time.minute == 0 && time.hour == 0) {
    return time.toLocal().toFormat(dateFormat, { locale });
  }
  return time.toLocal().toFormat(dateTimeFormat, { locale });
}
function renderMinimalDuration(dur) {
  dur = normalizeDuration(dur);
  let result = "";
  if (dur.years) result += `${dur.years} years, `;
  if (dur.months) result += `${dur.months} months, `;
  if (dur.weeks) result += `${dur.weeks} weeks, `;
  if (dur.days) result += `${dur.days} days, `;
  if (dur.hours) result += `${dur.hours} hours, `;
  if (dur.minutes) result += `${dur.minutes} minutes, `;
  if (dur.seconds) result += `${Math.round(dur.seconds)} seconds, `;
  if (dur.milliseconds) result += `${Math.round(dur.milliseconds)} ms, `;
  if (result.endsWith(", ")) result = result.substring(0, result.length - 2);
  return result;
}
function getParentFolder(path) {
  return path.split("/").slice(0, -1).join("/");
}
function getFileTitle(path) {
  if (path.includes("/")) path = path.substring(path.lastIndexOf("/") + 1);
  if (path.endsWith(".md")) path = path.substring(0, path.length - 3);
  return path;
}
function extractSubtags(tags3) {
  let result = [];
  for (let tag of typeof tags3 === "string" ? [tags3] : tags3) {
    result.push(tag);
    while (tag.includes("/")) {
      tag = tag.substring(0, tag.lastIndexOf("/"));
      result.push(tag);
    }
  }
  return result;
}
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
var HEADER_CANONICALIZER = P.alt(
  P.regex(new RegExp(emoji_regex_default(), "")),
  P.regex(/[0-9\p{Letter}_-]+/u),
  P.whitespace.map((_3) => " "),
  P.any.map((_3) => " ")
).many().map((result) => {
  return result.join("").split(/\s+/).join(" ").trim();
});
function normalizeHeaderForLink(header) {
  return HEADER_CANONICALIZER.tryParse(header);
}
function lineReplace(text2, start, end2, func) {
  const [_3, offset3] = lineSpan(text2, start, end2);
  if (!offset3) return text2;
  return text2.substring(0, offset3.start) + func(text2.substring(offset3.start, offset3.end)) + text2.substring(offset3.end);
}
function lineSpan(text2, start, end2) {
  start = Math.max(start, 0);
  end2 = Math.max(end2, 0);
  if (start >= end2) return ["", void 0];
  const startOffset = skipNewlines(text2, 0, start);
  if (startOffset == -1) return ["", void 0];
  const endOffset = skipNewlines(text2, startOffset, end2 - start);
  if (endOffset == -1) return [text2.substring(startOffset), { start: startOffset, end: text2.length }];
  else return [text2.substring(startOffset, endOffset - 1), { start: startOffset, end: endOffset - 1 }];
}
function lineRange(text2, start, end2) {
  return lineSpan(text2, start, end2)[0];
}
function skipNewlines(text2, start, count) {
  if (count == 0) return start;
  let position2 = start;
  while (count > 0) {
    position2 = text2.indexOf("\n", position2);
    if (position2 == -1) return -1;
    count--;
    position2 += 1;
  }
  return position2;
}

// src/expression/link.ts
var Link = class _Link {
  /** Create a link to a specific file. */
  static file(path, embed = false, display) {
    return new _Link({
      path,
      embed,
      display,
      subpath: void 0,
      type: "file"
    });
  }
  /** Infer the type of the link from the full internal link path. */
  static infer(linkpath, embed = false, display) {
    if (linkpath.includes("#^")) {
      let split = linkpath.split("#^");
      return _Link.block(split[0], split[1], embed, display);
    } else if (linkpath.includes("#")) {
      let split = linkpath.split("#");
      return _Link.header(split[0], split[1], embed, display);
    } else return _Link.file(linkpath, embed, display);
  }
  /** Create a link to a specific file and header in that file. */
  static header(path, header, embed, display) {
    return new _Link({
      path,
      embed,
      display,
      subpath: normalizeHeaderForLink(header),
      type: "header"
    });
  }
  /** Create a link to a specific file and block in that file. */
  static block(path, blockId, embed, display) {
    return new _Link({
      path,
      embed,
      display,
      subpath: blockId,
      type: "block"
    });
  }
  /** Load a link from it's raw JSON representation. */
  static fromObject(object) {
    return new _Link(object);
  }
  /** Create a link by parsing it's interior part (inside of the '[[]]'). */
  static parseInner(rawlink) {
    let [link, display] = splitOnUnescapedPipe(rawlink);
    return _Link.infer(link, false, display);
  }
  constructor(fields) {
    Object.assign(this, fields);
  }
  /** Update this link with a new path. */
  withPath(path) {
    return new _Link(Object.assign({}, this, { path }));
  }
  /** Return a new link which points to the same location but with a new display value. */
  withDisplay(display) {
    return new _Link(Object.assign({}, this, { display }));
  }
  /** Return a new link which has the given embedded status. */
  withEmbed(embed) {
    if (this.embed == embed) return this;
    return new _Link(Object.assign({}, this, { embed }));
  }
  /** Convert a file link into a link to a specific header. */
  withHeader(header) {
    return _Link.header(this.path, header, this.embed, this.display);
  }
  /** Convert a file link into a link to a specificb lock. */
  withBlock(block) {
    return _Link.block(this.path, block, this.embed, this.display);
  }
  /** Checks for link equality (i.e., that the links are pointing to the same exact location). */
  equals(other) {
    if (other == void 0 || other == null) return false;
    return this.path == other.path && this.type == other.type && this.subpath == other.subpath;
  }
  /** Convert this link to it's markdown representation. */
  toString() {
    return this.markdown();
  }
  /** Convert this link to a raw object which is serialization-friendly. */
  toObject() {
    return {
      path: this.path,
      type: this.type,
      subpath: this.subpath,
      display: this.display,
      embed: this.embed
    };
  }
  /** Convert any link into a link to its file. */
  toFile() {
    return _Link.file(this.path, this.embed, this.display);
  }
  /** Convert this link into an embedded link. */
  toEmbed() {
    return this.withEmbed(true);
  }
  /** Convert this link into a non-embedded link. */
  fromEmbed() {
    return this.withEmbed(false);
  }
  /** Convert this link to markdown so it can be rendered. */
  markdown() {
    let result = (this.embed ? "!" : "") + "[[" + this.obsidianLink();
    result += "|";
    result += this.displayOrDefault();
    result += "]]";
    return result;
  }
  /** Obtain the display for this link if present, or return a simple default display. */
  displayOrDefault() {
    if (this.display) {
      return this.display;
    } else {
      let result = getFileTitle(this.path);
      if (this.type == "header" || this.type == "block") result += " > " + this.subpath;
      return result;
    }
  }
  /** Convert the inner part of the link to something that Obsidian can open / understand. */
  obsidianLink() {
    var _a, _b;
    const escaped = this.path.replace("|", "\\|");
    if (this.type == "header") return escaped + "#" + ((_a = this.subpath) == null ? void 0 : _a.replace("|", "\\|"));
    if (this.type == "block") return escaped + "#^" + ((_b = this.subpath) == null ? void 0 : _b.replace("|", "\\|"));
    else return escaped;
  }
  /** The stripped name of the file this link points to. */
  fileName() {
    return getFileTitle(this.path);
  }
};
function splitOnUnescapedPipe(link) {
  let pipe = -1;
  while ((pipe = link.indexOf("|", pipe + 1)) >= 0) {
    if (pipe > 0 && link[pipe - 1] == "\\") continue;
    return [link.substring(0, pipe).replace(/\\\|/g, "|"), link.substring(pipe + 1)];
  }
  return [link.replace(/\\\|/g, "|"), void 0];
}

// src/expression/parser.ts
var P2 = __toESM(require_parsimmon_umd_min());

// src/expression/literal.ts
var Literals;
((Literals2) => {
  Literals2.DEFAULT_TO_STRING = {
    nullRepresentation: "-",
    dateFormat: "MMMM dd, yyyy",
    dateTimeFormat: "h:mm a - MMMM dd, yyyy"
  };
  function toString(field, setting = Literals2.DEFAULT_TO_STRING, recursive = false) {
    let wrapped = wrapValue(field);
    if (!wrapped) return setting.nullRepresentation;
    switch (wrapped.type) {
      case "null":
        return setting.nullRepresentation;
      case "string":
        return wrapped.value;
      case "number":
      case "boolean":
        return "" + wrapped.value;
      case "link":
        return wrapped.value.markdown();
      case "function":
        return "<function>";
      case "array":
        let result = "";
        if (recursive) result += "[";
        result += wrapped.value.map((f4) => toString(f4, setting, true)).join(", ");
        if (recursive) result += "]";
        return result;
      case "object":
        return "{ " + Object.entries(wrapped.value).map((e3) => e3[0] + ": " + toString(e3[1], setting, true)).join(", ") + " }";
      case "date":
        return renderMinimalDate(wrapped.value, setting.dateFormat, setting.dateTimeFormat);
      case "duration":
        return renderMinimalDuration(wrapped.value);
    }
  }
  Literals2.toString = toString;
  function wrapValue(val) {
    if (isNull(val)) return { type: "null", value: val };
    else if (isNumber2(val)) return { type: "number", value: val };
    else if (isString2(val)) return { type: "string", value: val };
    else if (isBoolean(val)) return { type: "boolean", value: val };
    else if (isDuration(val)) return { type: "duration", value: val };
    else if (isDate2(val)) return { type: "date", value: val };
    else if (isArray2(val)) return { type: "array", value: val };
    else if (isLink(val)) return { type: "link", value: val };
    else if (isFunction(val)) return { type: "function", value: val };
    else if (isObject(val)) return { type: "object", value: val };
    else return void 0;
  }
  Literals2.wrapValue = wrapValue;
  function mapLeaves(val, func) {
    if (isObject(val)) {
      let result = {};
      for (let [key, value] of Object.entries(val)) result[key] = mapLeaves(value, func);
      return result;
    } else if (isArray2(val)) {
      let result = [];
      for (let value of val) result.push(mapLeaves(value, func));
      return result;
    } else {
      return func(val);
    }
  }
  Literals2.mapLeaves = mapLeaves;
  function equals(first, second) {
    return compare(first, second) == 0;
  }
  Literals2.equals = equals;
  function compare(val1, val2, linkNormalizer) {
    var _a, _b;
    if (val1 === val2) return 0;
    if (val1 === void 0) val1 = null;
    if (val2 === void 0) val2 = null;
    if (val1 === null && val2 === null) return 0;
    else if (val1 === null) return -1;
    else if (val2 === null) return 1;
    let wrap1 = wrapValue(val1);
    let wrap2 = wrapValue(val2);
    if (wrap1 === void 0 && wrap2 === void 0) return 0;
    else if (wrap1 === void 0) return -1;
    else if (wrap2 === void 0) return 1;
    if (wrap1.type != wrap2.type) return wrap1.type.localeCompare(wrap2.type);
    if (wrap1.value === wrap2.value) return 0;
    switch (wrap1.type) {
      case "string":
        return wrap1.value.localeCompare(wrap2.value);
      case "number":
        if (wrap1.value < wrap2.value) return -1;
        else if (wrap1.value == wrap2.value) return 0;
        return 1;
      case "null":
        return 0;
      case "boolean":
        if (wrap1.value == wrap2.value) return 0;
        else return wrap1.value ? 1 : -1;
      case "link":
        let link1 = wrap1.value;
        let link2 = wrap2.value;
        let normalize = linkNormalizer != null ? linkNormalizer : (x4) => x4;
        let pathCompare = normalize(link1.path).localeCompare(normalize(link2.path));
        if (pathCompare != 0) return pathCompare;
        let typeCompare = link1.type.localeCompare(link2.type);
        if (typeCompare != 0) return typeCompare;
        if (link1.subpath && !link2.subpath) return 1;
        if (!link1.subpath && link2.subpath) return -1;
        if (!link1.subpath && !link2.subpath) return 0;
        return ((_a = link1.subpath) != null ? _a : "").localeCompare((_b = link2.subpath) != null ? _b : "");
      case "date":
        return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
      case "duration":
        return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
      case "array":
        let f1 = wrap1.value;
        let f22 = wrap2.value;
        for (let index2 = 0; index2 < Math.min(f1.length, f22.length); index2++) {
          let comp = compare(f1[index2], f22[index2]);
          if (comp != 0) return comp;
        }
        return f1.length - f22.length;
      case "object":
        let o1 = wrap1.value;
        let o22 = wrap2.value;
        let k1 = Array.from(Object.keys(o1));
        let k22 = Array.from(Object.keys(o22));
        k1.sort();
        k22.sort();
        let keyCompare = compare(k1, k22);
        if (keyCompare != 0) return keyCompare;
        for (let key of k1) {
          let comp = compare(o1[key], o22[key]);
          if (comp != 0) return comp;
        }
        return 0;
      case "function":
        return 0;
    }
  }
  Literals2.compare = compare;
  function typeOf(val) {
    var _a;
    return (_a = wrapValue(val)) == null ? void 0 : _a.type;
  }
  Literals2.typeOf = typeOf;
  function isTruthy(field) {
    let wrapped = wrapValue(field);
    if (!wrapped) return false;
    switch (wrapped.type) {
      case "number":
        return wrapped.value != 0;
      case "string":
        return wrapped.value.length > 0;
      case "boolean":
        return wrapped.value;
      case "link":
        return !!wrapped.value.path;
      case "date":
        return wrapped.value.toMillis() != 0;
      case "duration":
        return wrapped.value.as("seconds") != 0;
      case "object":
        return Object.keys(wrapped.value).length > 0;
      case "array":
        return wrapped.value.length > 0;
      case "null":
        return false;
      case "function":
        return true;
    }
  }
  Literals2.isTruthy = isTruthy;
  function deepCopy(field) {
    if (field === null || field === void 0) return field;
    if (Literals2.isArray(field)) {
      return [].concat(field.map((v3) => deepCopy(v3)));
    } else if (Literals2.isObject(field)) {
      let result = {};
      for (let [key, value] of Object.entries(field)) result[key] = deepCopy(value);
      return result;
    } else {
      return field;
    }
  }
  Literals2.deepCopy = deepCopy;
  function isString2(val) {
    return typeof val == "string";
  }
  Literals2.isString = isString2;
  function isNumber2(val) {
    return typeof val == "number";
  }
  Literals2.isNumber = isNumber2;
  function isDate2(val) {
    return val instanceof DateTime;
  }
  Literals2.isDate = isDate2;
  function isDuration(val) {
    return val instanceof Duration;
  }
  Literals2.isDuration = isDuration;
  function isNull(val) {
    return val === null || val === void 0;
  }
  Literals2.isNull = isNull;
  function isArray2(val) {
    return Array.isArray(val);
  }
  Literals2.isArray = isArray2;
  function isBoolean(val) {
    return typeof val === "boolean";
  }
  Literals2.isBoolean = isBoolean;
  function isLink(val) {
    return val instanceof Link;
  }
  Literals2.isLink = isLink;
  function isObject(val) {
    return val !== void 0 && typeof val == "object" && !isArray2(val) && !isDuration(val) && !isDate2(val) && !isLink(val) && !isNull(val);
  }
  Literals2.isObject = isObject;
  function isFunction(val) {
    return typeof val == "function";
  }
  Literals2.isFunction = isFunction;
})(Literals || (Literals = {}));
var Groupings;
((Groupings2) => {
  function isElementGroup(entry) {
    return Literals.isObject(entry) && Object.keys(entry).length == 2 && "key" in entry && "rows" in entry;
  }
  Groupings2.isElementGroup = isElementGroup;
  function isGrouping(entry) {
    for (let element of entry) if (!isElementGroup(element)) return false;
    return true;
  }
  Groupings2.isGrouping = isGrouping;
  function isLeaf(entry) {
    for (let element of entry) if (isElementGroup(element)) return false;
    return true;
  }
  Groupings2.isLeaf = isLeaf;
  function count(elements) {
    if (isElementGroup(elements)) {
      return count(elements.rows);
    } else if (isGrouping(elements)) {
      let result = 0;
      for (let subgroup of elements) result += count(subgroup.rows);
      return result;
    } else {
      return elements.length;
    }
  }
  Groupings2.count = count;
  function slice2(elements, start, end2) {
    if (end2 <= start) return [];
    if (isLeaf(elements)) return elements.slice(start, end2);
    let index2 = 0, seen = 0;
    while (index2 < elements.length && seen + count(elements[index2]) <= start) {
      seen += count(elements[index2]);
      index2++;
    }
    if (index2 >= elements.length) return [];
    const result = [];
    while (index2 < elements.length && seen < end2) {
      const group = elements[index2];
      const groupSize = count(group);
      const groupStart = Math.max(seen, start);
      const groupEnd = Math.min(groupSize + seen, end2);
      result.push({
        key: group.key,
        rows: slice2(group.rows, groupStart - seen, groupEnd - seen)
      });
      seen += groupSize;
      index2++;
    }
    return result;
  }
  Groupings2.slice = slice2;
})(Groupings || (Groupings = {}));

// src/api/result.ts
var Success = class _Success {
  constructor(value) {
    this.value = value;
    this.successful = true;
  }
  map(f4) {
    return new _Success(f4(this.value));
  }
  flatMap(f4) {
    return f4(this.value);
  }
  mapErr(f4) {
    return this;
  }
  bimap(succ, _fail) {
    return this.map(succ);
  }
  orElse(_value) {
    return this.value;
  }
  cast() {
    return this;
  }
  orElseThrow(_message) {
    return this.value;
  }
};
var Failure = class _Failure {
  constructor(error) {
    this.error = error;
    this.successful = false;
  }
  map(_f) {
    return this;
  }
  flatMap(_f) {
    return this;
  }
  mapErr(f4) {
    return new _Failure(f4(this.error));
  }
  bimap(_succ, fail) {
    return this.mapErr(fail);
  }
  orElse(value) {
    return value;
  }
  cast() {
    return this;
  }
  orElseThrow(message) {
    if (message) throw new Error(message(this.error));
    else throw new Error("" + this.error);
  }
};
var Result;
((Result2) => {
  function success(value) {
    return new Success(value);
  }
  Result2.success = success;
  function failure(error) {
    return new Failure(error);
  }
  Result2.failure = failure;
  function flatMap2(first, second, f4) {
    if (first.successful) {
      if (second.successful) return f4(first.value, second.value);
      else return failure(second.error);
    } else {
      return failure(first.error);
    }
  }
  Result2.flatMap2 = flatMap2;
  function map2(first, second, f4) {
    return flatMap2(first, second, (a4, b3) => success(f4(a4, b3)));
  }
  Result2.map2 = map2;
  function mapAll(input2, func) {
    const result = [];
    for (const element of input2) {
      const output = func(element);
      if (!output.successful) return output.cast();
      result.push(output.value);
    }
    return Result2.success(result);
  }
  Result2.mapAll = mapAll;
  function trying(call) {
    try {
      return Result2.success(call());
    } catch (error) {
      return Result2.failure(error);
    }
  }
  Result2.trying = trying;
  async function async(promise) {
    try {
      return Result2.success(await promise);
    } catch (error) {
      return Result2.failure(error);
    }
  }
  Result2.async = async;
})(Result || (Result = {}));

// src/expression/filters.ts
var Filters;
((Filters2) => {
  Filters2.EVERYTHING = { type: "everything" };
  Filters2.NOTHING = { type: "nothing" };
  Filters2.EMPTY_SET = /* @__PURE__ */ new Set();
  function atom(set) {
    if (set.size == 0) return Filters2.NOTHING;
    return { type: "atom", value: set };
  }
  Filters2.atom = atom;
  function constant(value) {
    if (value) return Filters2.EVERYTHING;
    else return Filters2.NOTHING;
  }
  Filters2.constant = constant;
  function nullableAtom(set) {
    return set !== void 0 ? atom(set) : Filters2.NOTHING;
  }
  Filters2.nullableAtom = nullableAtom;
  function negated(set) {
    if (set.size == 0) return Filters2.EVERYTHING;
    return { type: "negated", value: set };
  }
  Filters2.negated = negated;
  function negate(filter) {
    switch (filter.type) {
      case "everything":
        return Filters2.NOTHING;
      case "nothing":
        return Filters2.EVERYTHING;
      case "atom":
        return negated(filter.value);
      case "negated":
        return atom(filter.value);
    }
  }
  Filters2.negate = negate;
  function empty(filter) {
    switch (filter.type) {
      case "everything":
        return false;
      case "negated":
        return false;
      case "atom":
        return filter.value.size == 0;
      case "nothing":
        return true;
    }
  }
  Filters2.empty = empty;
  function resolve(filter, everything) {
    switch (filter.type) {
      case "everything":
        return everything;
      case "nothing":
        return Filters2.EMPTY_SET;
      case "atom":
        return filter.value;
      case "negated":
        return setIntersectNegation(everything, filter.value);
    }
  }
  Filters2.resolve = resolve;
  function intersect(elements) {
    return lazyIntersect(elements, (x4) => x4);
  }
  Filters2.intersect = intersect;
  function lazyIntersect(elements, produce) {
    return lazyFailableIntersection(elements, (x4) => Result.success(produce(x4))).orElseThrow();
  }
  Filters2.lazyIntersect = lazyIntersect;
  function lazyFailableIntersection(elements, produce) {
    const atoms = [];
    const negations = [];
    for (let element of elements) {
      const maybeFilter = produce(element);
      if (!maybeFilter.successful) return maybeFilter.cast();
      const filter = maybeFilter.value;
      if (filter === void 0) continue;
      if (empty(filter)) return Result.success(Filters2.NOTHING);
      if (filter.type === "everything") continue;
      if (filter.type == "atom") atoms.push(filter.value);
      else if (filter.type == "negated") negations.push(filter.value);
    }
    if (atoms.length == 0 && negations.length == 0) {
      return Result.success(Filters2.EVERYTHING);
    } else if (atoms.length > 0 && negations.length == 0) {
      return Result.success(atom(setIntersect(atoms)));
    } else if (atoms.length == 0 && negations.length > 0) {
      return Result.success(negated(setUnion(negations)));
    } else {
      return Result.success(Filters2.atom(setIntersectNegation(setIntersect(atoms), setUnion(negations))));
    }
  }
  Filters2.lazyFailableIntersection = lazyFailableIntersection;
  function union2(filters) {
    return lazyUnion(filters, (x4) => x4);
  }
  Filters2.union = union2;
  function lazyUnion(elements, produce) {
    return lazyFailableUnion(elements, (x4) => Result.success(produce(x4))).orElseThrow();
  }
  Filters2.lazyUnion = lazyUnion;
  function lazyFailableUnion(elements, produce) {
    const atoms = [];
    const negations = [];
    for (let element of elements) {
      const maybeFilter = produce(element);
      if (!maybeFilter.successful) return maybeFilter.cast();
      const filter = maybeFilter.value;
      if (filter === void 0) continue;
      if (filter.type === "everything") return Result.success(Filters2.EVERYTHING);
      if (empty(filter)) continue;
      if (filter.type == "atom") atoms.push(filter.value);
      else if (filter.type == "negated") negations.push(filter.value);
    }
    if (atoms.length == 0 && negations.length == 0) {
      return Result.success(Filters2.NOTHING);
    } else if (atoms.length > 0 && negations.length == 0) {
      return Result.success(Filters2.atom(setUnion(atoms)));
    } else if (atoms.length == 0 && negations.length > 0) {
      return Result.success(Filters2.negated(setIntersect(negations)));
    } else {
      return Result.success(negated(setIntersectNegation(setIntersect(negations), setUnion(atoms))));
    }
  }
  Filters2.lazyFailableUnion = lazyFailableUnion;
  function setIntersect(sets) {
    if (sets.length == 0) return /* @__PURE__ */ new Set();
    else if (sets.length == 1) return sets[0];
    let sorted = [].concat(sets).sort((a4, b3) => a4.size - b3.size);
    while (sorted.length > 1) {
      const result = /* @__PURE__ */ new Set();
      const largest = sorted.pop();
      for (let element of sorted[0]) {
        if (largest.has(element)) result.add(element);
      }
      sorted[0] = result;
    }
    return sorted[0];
  }
  Filters2.setIntersect = setIntersect;
  function setUnion(sets) {
    if (sets.length == 0) return /* @__PURE__ */ new Set();
    else if (sets.length == 1) return sets[0];
    const result = /* @__PURE__ */ new Set();
    for (const set of sets) {
      for (const element of set) {
        result.add(element);
      }
    }
    return result;
  }
  Filters2.setUnion = setUnion;
  function setIntersectNegation(atom2, negated2) {
    if (atom2.size > negated2.size) {
      const result = new Set(atom2);
      for (let element of negated2) {
        result.delete(element);
      }
      return result;
    } else {
      const result = /* @__PURE__ */ new Set();
      for (let element of atom2) {
        if (negated2.has(element)) continue;
        result.add(element);
      }
      return result;
    }
  }
  Filters2.setIntersectNegation = setIntersectNegation;
})(Filters || (Filters = {}));

// src/expression/expression.ts
var Expressions;
((Expressions2) => {
  Expressions2.ROW = "$row";
  function variable(name) {
    return { type: "variable", name };
  }
  Expressions2.variable = variable;
  function literal(value) {
    return { type: "literal", value };
  }
  Expressions2.literal = literal;
  function binaryOp(left, op, right) {
    return { type: "binaryop", left, op, right };
  }
  Expressions2.binaryOp = binaryOp;
  function index2(obj, index3) {
    return { type: "binaryop", left: obj, right: index3, op: "index" };
  }
  Expressions2.index = index2;
  function indexVariable(name) {
    let parts = name.split(".");
    let result = Expressions2.variable(parts[0]);
    for (let index3 = 1; index3 < parts.length; index3++) {
      result = Expressions2.index(result, Expressions2.literal(parts[index3]));
    }
    return result;
  }
  Expressions2.indexVariable = indexVariable;
  function lambda(args, value) {
    return { type: "lambda", arguments: args, value };
  }
  Expressions2.lambda = lambda;
  function func(func2, args) {
    return { type: "function", func: func2, arguments: args };
  }
  Expressions2.func = func;
  function list(values) {
    return { type: "list", values };
  }
  Expressions2.list = list;
  function object(values) {
    return { type: "object", values };
  }
  Expressions2.object = object;
  function negate(child) {
    return { type: "negated", child };
  }
  Expressions2.negate = negate;
  function isCompareOp(op) {
    return op == "<=" || op == "<" || op == ">" || op == ">=" || op == "!=" || op == "=";
  }
  Expressions2.isCompareOp = isCompareOp;
  function unboundVariables(expr, bound = /* @__PURE__ */ new Set([Expressions2.ROW])) {
    switch (expr.type) {
      case "binaryop":
        if (expr.op === "index" && expr.left.type == "variable" && expr.left.name == Expressions2.ROW && expr.right.type == "literal" && Literals.isString(expr.right.value)) {
          if (bound.has(expr.right.value)) return /* @__PURE__ */ new Set();
          else return /* @__PURE__ */ new Set([expr.right.value]);
        }
        return Filters.setUnion([unboundVariables(expr.left, bound), unboundVariables(expr.right, bound)]);
      case "function":
        return Filters.setUnion(expr.arguments.map((a4) => unboundVariables(a4, bound)));
      case "lambda":
        const newBound = bound != null ? bound : /* @__PURE__ */ new Set();
        for (const arg of expr.arguments) newBound.add(arg);
        return unboundVariables(expr.value, newBound);
      case "list":
        return Filters.setUnion(expr.values.map((v3) => unboundVariables(v3, bound)));
      case "negated":
        return unboundVariables(expr.child, bound);
      case "object":
        return Filters.setUnion(Object.values(expr.values).map((v3) => unboundVariables(v3, bound)));
      case "variable":
        if (bound && bound.has(expr.name)) return /* @__PURE__ */ new Set();
        else return /* @__PURE__ */ new Set([expr.name]);
      case "literal":
        return /* @__PURE__ */ new Set();
    }
  }
  Expressions2.unboundVariables = unboundVariables;
  function toString(expr) {
    switch (expr.type) {
      case "binaryop":
        if (expr.op === "index") {
          return `${toString(expr.left)}[${toString(expr.right)}]`;
        }
        return `${toString(expr.left)} ${expr.op} ${toString(expr.right)}`;
      case "function":
        return `${toString(expr.func)}(${expr.arguments.map(toString).join(", ")})`;
      case "lambda":
        return `(${expr.arguments.join(", ")}) => ${toString(expr.value)}`;
      case "list":
        return `[${expr.values.map(toString).join(", ")}]`;
      case "negated":
        return `!${toString(expr.child)}`;
      case "object":
        return `{${Object.entries(expr.values).map(([k4, v3]) => `${k4}: ${toString(v3)}`).join(", ")}}`;
      case "variable":
        return expr.name;
      case "literal":
        const wrapped = Literals.wrapValue(expr.value);
        if (!wrapped) return "null";
        switch (wrapped.type) {
          case "string":
            return `"${wrapped.value}"`;
          default:
            return Literals.toString(wrapped.value);
        }
    }
  }
  Expressions2.toString = toString;
  Expressions2.NULL = Expressions2.literal(null);
})(Expressions || (Expressions = {}));

// src/expression/parser.ts
var PRIMITIVES = P2.createLanguage({
  number: (_3) => P2.regexp(/-?[0-9]+(\.[0-9]+)?/).map((str) => Number.parseFloat(str)).desc("number"),
  // A quote-surrounded string which supports escape characters ('\').
  string: (q4) => P2.string('"').then(
    P2.alt(q4.escapeCharacter, P2.noneOf('"\\')).atLeast(0).map((chars) => chars.join(""))
  ).skip(P2.string('"')).desc("string"),
  escapeCharacter: (_3) => P2.string("\\").then(P2.any).map((escaped) => {
    if (escaped === '"') return '"';
    if (escaped === "\\") return "\\";
    else return "\\" + escaped;
  }),
  // A boolean true/false value.
  bool: (_3) => P2.regexp(/true|false|True|False/).map((str) => str.toLowerCase() == "true").desc("boolean"),
  // A tag of the form '#stuff/hello-there'.
  tag: (_3) => P2.seqMap(
    P2.string("#"),
    P2.alt(P2.regexp(/[^\u2000-\u206F\u2E00-\u2E7F'!"#$%&()*+,.:;<=>?@^`{|}~\[\]\\\s]/).desc("text")).many(),
    (start, rest) => start + rest.join("")
  ).desc("tag"),
  // A variable identifier, which is alphanumeric and must start with a letter or... emoji.
  identifier: (_3) => P2.seqMap(
    P2.alt(P2.regexp(/[\p{Letter}$]/u), P2.regexp(EMOJI_REGEX).desc("text")),
    P2.alt(P2.regexp(/[0-9\p{Letter}$_-]/u), P2.regexp(EMOJI_REGEX).desc("text")).many(),
    (first, rest) => first + rest.join("")
  ).desc("variable"),
  // An Obsidian link of the form [[<link>]].
  link: (_3) => P2.regexp(/\[\[([^\[\]]*?)\]\]/u, 1).map((linkInner) => Link.parseInner(linkInner)).desc("file link"),
  // An embeddable link which can start with '!'. This overlaps with the normal negation operator, so it is only
  // provided for metadata parsing.
  embedLink: (q4) => P2.seqMap(P2.string("!").atMost(1), q4.link, (p3, l4) => {
    if (p3.length > 0) l4.embed = true;
    return l4;
  }).desc("file link"),
  // Binary plus or minus operator.
  binaryPlusMinus: (_3) => P2.regexp(/\+|-/).map((str) => str).desc("'+' or '-'"),
  // Binary times or divide operator.
  binaryMulDiv: (_3) => P2.regexp(/\*|\/|%/).map((str) => str).desc("'*' or '/' or '%'"),
  // Binary comparison operator.
  binaryCompareOp: (_3) => P2.regexp(/>=|<=|!=|>|<|=/).map((str) => str).desc("'>=' or '<=' or '!=' or '=' or '>' or '<'"),
  // Binary boolean combination operator.
  binaryAndOp: (_3) => P2.regexp(/and|&/i).map((_str) => "&").desc("'and'"),
  binaryOrOp: (_3) => P2.regexp(/or|\|/i).map((_str) => "|").desc("'or'"),
  // A date which can be YYYY-MM[-DDTHH:mm:ss].
  rootDate: (_3) => P2.seqMap(P2.regexp(/\d{4}/), P2.string("-"), P2.regexp(/\d{2}/), (year, _4, month) => {
    return DateTime.fromObject({ year: Number.parseInt(year), month: Number.parseInt(month) });
  }).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
  dateShorthand: (_3) => P2.alt(
    ...Object.keys(DATE_SHORTHANDS).sort((a4, b3) => b3.length - a4.length).map(P2.string)
  ),
  date: (q4) => chainOpt(
    q4.rootDate,
    (ym) => P2.seqMap(P2.string("-"), P2.regexp(/\d{2}/), (_3, day) => ym.set({ day: Number.parseInt(day) })),
    (ymd) => P2.seqMap(P2.string("T"), P2.regexp(/\d{2}/), (_3, hour) => ymd.set({ hour: Number.parseInt(hour) })),
    (ymdh) => P2.seqMap(
      P2.string(":"),
      P2.regexp(/\d{2}/),
      (_3, minute) => ymdh.set({ minute: Number.parseInt(minute) })
    ),
    (ymdhm) => P2.seqMap(
      P2.string(":"),
      P2.regexp(/\d{2}/),
      (_3, second) => ymdhm.set({ second: Number.parseInt(second) })
    ),
    (ymdhms) => P2.alt(
      P2.seqMap(
        P2.string("."),
        P2.regexp(/\d{3}/),
        (_3, millisecond) => ymdhms.set({ millisecond: Number.parseInt(millisecond) })
      ),
      P2.succeed(ymdhms)
      // pass
    ),
    (dt) => P2.alt(
      P2.seqMap(
        P2.string("+").or(P2.string("-")),
        P2.regexp(/\d{1,2}(:\d{2})?/),
        (pm, hr) => dt.setZone("UTC" + pm + hr, { keepLocalTime: true })
      ),
      P2.seqMap(P2.string("Z"), () => dt.setZone("utc", { keepLocalTime: true })),
      P2.seqMap(
        P2.string("["),
        P2.regexp(/[0-9A-Za-z+-\/]+/u),
        P2.string("]"),
        (_a, zone, _b) => dt.setZone(zone, { keepLocalTime: true })
      )
    )
  ).assert((dt) => dt.isValid, "valid date").desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
  // A date, plus various shorthand times of day it could be.
  datePlus: (q4) => P2.alt(
    q4.dateShorthand.map((d3) => DATE_SHORTHANDS[d3]()),
    q4.date
  ).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS] or in shorthand"),
  // A duration of time.
  durationType: (_3) => P2.alt(
    ...Object.keys(DURATION_TYPES).sort((a4, b3) => b3.length - a4.length).map(P2.string)
  ),
  duration: (q4) => P2.seqMap(
    q4.number,
    P2.optWhitespace,
    q4.durationType,
    (count, _3, t5) => DURATION_TYPES[t5].mapUnits((x4) => x4 * count)
  ).sepBy1(P2.string(",").trim(P2.optWhitespace).or(P2.optWhitespace)).map((durations) => durations.reduce((p3, c4) => p3.plus(c4))).desc("duration like 4hr2min"),
  // A raw null value.
  rawNull: (_3) => P2.string("null"),
  // Inline field value parsing.
  atomInlineField: (q4) => P2.alt(
    q4.date,
    q4.duration.map((d3) => normalizeDuration(d3)),
    q4.string,
    q4.tag,
    q4.embedLink,
    q4.bool,
    q4.number,
    q4.rawNull
  ),
  inlineFieldList: (q4) => q4.atomInlineField.sepBy(P2.string(",").trim(P2.optWhitespace).lookahead(q4.atomInlineField)),
  inlineField: (q4) => P2.alt(
    P2.seqMap(
      q4.atomInlineField,
      P2.string(",").trim(P2.optWhitespace),
      q4.inlineFieldList,
      (f4, _s, l4) => [f4].concat(l4)
    ),
    q4.atomInlineField
  )
});
var EMOJI_REGEX = new RegExp(emoji_regex_default(), "");
var DURATION_TYPES = {
  year: Duration.fromObject({ years: 1 }),
  years: Duration.fromObject({ years: 1 }),
  yr: Duration.fromObject({ years: 1 }),
  yrs: Duration.fromObject({ years: 1 }),
  month: Duration.fromObject({ months: 1 }),
  months: Duration.fromObject({ months: 1 }),
  mo: Duration.fromObject({ months: 1 }),
  mos: Duration.fromObject({ months: 1 }),
  week: Duration.fromObject({ weeks: 1 }),
  weeks: Duration.fromObject({ weeks: 1 }),
  wk: Duration.fromObject({ weeks: 1 }),
  wks: Duration.fromObject({ weeks: 1 }),
  w: Duration.fromObject({ weeks: 1 }),
  day: Duration.fromObject({ days: 1 }),
  days: Duration.fromObject({ days: 1 }),
  d: Duration.fromObject({ days: 1 }),
  hour: Duration.fromObject({ hours: 1 }),
  hours: Duration.fromObject({ hours: 1 }),
  hr: Duration.fromObject({ hours: 1 }),
  hrs: Duration.fromObject({ hours: 1 }),
  h: Duration.fromObject({ hours: 1 }),
  minute: Duration.fromObject({ minutes: 1 }),
  minutes: Duration.fromObject({ minutes: 1 }),
  min: Duration.fromObject({ minutes: 1 }),
  mins: Duration.fromObject({ minutes: 1 }),
  m: Duration.fromObject({ minutes: 1 }),
  second: Duration.fromObject({ seconds: 1 }),
  seconds: Duration.fromObject({ seconds: 1 }),
  sec: Duration.fromObject({ seconds: 1 }),
  secs: Duration.fromObject({ seconds: 1 }),
  s: Duration.fromObject({ seconds: 1 })
};
var DATE_SHORTHANDS = {
  now: () => DateTime.local(),
  today: () => DateTime.local().startOf("day"),
  yesterday: () => DateTime.local().startOf("day").minus(Duration.fromObject({ days: 1 })),
  tomorrow: () => DateTime.local().startOf("day").plus(Duration.fromObject({ days: 1 })),
  sow: () => DateTime.local().startOf("week"),
  "start-of-week": () => DateTime.local().startOf("week"),
  eow: () => DateTime.local().endOf("week"),
  "end-of-week": () => DateTime.local().endOf("week"),
  soy: () => DateTime.local().startOf("year"),
  "start-of-year": () => DateTime.local().startOf("year"),
  eoy: () => DateTime.local().endOf("year"),
  "end-of-year": () => DateTime.local().endOf("year"),
  som: () => DateTime.local().startOf("month"),
  "start-of-month": () => DateTime.local().startOf("month"),
  eom: () => DateTime.local().endOf("month"),
  "end-of-month": () => DateTime.local().endOf("month")
};
var EXPRESSION = P2.createLanguage({
  // Field parsing.
  variable: (_3) => PRIMITIVES.identifier.map(Expressions.variable).desc("variable"),
  number: (_3) => PRIMITIVES.number.map(Expressions.literal).desc("number"),
  string: (_3) => PRIMITIVES.string.map(Expressions.literal).desc("string"),
  bool: (_3) => PRIMITIVES.bool.map(Expressions.literal).desc("boolean"),
  date: (_3) => createFunction("date", PRIMITIVES.datePlus).map(([_func, date]) => Expressions.literal(date)).desc("date"),
  duration: (_3) => createFunction("dur", PRIMITIVES.duration).map(([_func, dur]) => Expressions.literal(dur)).desc("duration"),
  null: (_3) => PRIMITIVES.rawNull.map((_4) => Expressions.NULL),
  link: (_3) => PRIMITIVES.link.map(Expressions.literal),
  list: (q4) => q4.expression.sepBy(P2.string(",").trim(P2.optWhitespace)).wrap(P2.string("[").skip(P2.optWhitespace), P2.optWhitespace.then(P2.string("]"))).map((l4) => Expressions.list(l4)).desc("list"),
  object: (q4) => P2.seqMap(
    PRIMITIVES.identifier.or(PRIMITIVES.string),
    P2.string(":").trim(P2.optWhitespace),
    q4.expression,
    (name, _sep, value) => {
      return { name, value };
    }
  ).sepBy(P2.string(",").trim(P2.optWhitespace)).wrap(P2.string("{").skip(P2.optWhitespace), P2.optWhitespace.then(P2.string("}"))).map((vals) => {
    let res = {};
    for (let entry of vals) res[entry.name] = entry.value;
    return Expressions.object(res);
  }).desc("object ('{ a: 1, b: 2 }')"),
  atom: (q4) => P2.alt(
    // Place embed links above negated fields as they are the special parser case '![[thing]]' and are generally unambigious.
    PRIMITIVES.embedLink.map((l4) => Expressions.literal(l4)),
    q4.negated,
    q4.link,
    q4.list,
    q4.object,
    q4.lambda,
    q4.parens,
    q4.bool,
    q4.number,
    q4.string,
    q4.date,
    q4.duration,
    q4.null,
    q4.variable
  ),
  index: (q4) => P2.seqMap(q4.atom, P2.alt(q4.dotPostfix, q4.indexPostfix, q4.functionPostfix).many(), (obj, postfixes) => {
    let result = obj;
    for (let post of postfixes) {
      switch (post.type) {
        case "dot":
          result = Expressions.index(result, Expressions.literal(post.expr));
          break;
        case "index":
          result = Expressions.index(result, post.expr);
          break;
        case "function":
          result = Expressions.func(result, post.exprs);
          break;
      }
    }
    return result;
  }),
  negated: (q4) => P2.seqMap(P2.string("!"), q4.index, (_3, field) => Expressions.negate(field)).desc("negated field"),
  parens: (q4) => q4.expression.trim(P2.optWhitespace).wrap(P2.string("("), P2.string(")")),
  lambda: (q4) => P2.seqMap(
    PRIMITIVES.identifier.sepBy(P2.string(",").trim(P2.optWhitespace)).wrap(P2.string("(").trim(P2.optWhitespace), P2.string(")").trim(P2.optWhitespace)),
    P2.string("=>").trim(P2.optWhitespace),
    q4.expression,
    (ident, _ignore, value) => {
      return { type: "lambda", arguments: ident, value };
    }
  ),
  dotPostfix: (q4) => P2.seqMap(P2.string("."), PRIMITIVES.identifier, (_3, expr) => ({ type: "dot", expr })),
  indexPostfix: (q4) => P2.seqMap(
    P2.string("["),
    P2.optWhitespace,
    q4.expression,
    P2.optWhitespace,
    P2.string("]"),
    (_3, _22, expr, _32, _4) => {
      return { type: "index", expr };
    }
  ),
  functionPostfix: (q4) => P2.seqMap(
    P2.string("("),
    P2.optWhitespace,
    q4.expression.sepBy(P2.string(",").trim(P2.optWhitespace)),
    P2.optWhitespace,
    P2.string(")"),
    (_3, _1, exprs, _22, _32) => {
      return { type: "function", exprs };
    }
  ),
  // The precedence hierarchy of operators - multiply/divide, add/subtract, compare, and then boolean operations.
  binaryMulDiv: (q4) => createBinaryParser(q4.index, PRIMITIVES.binaryMulDiv, Expressions.binaryOp),
  binaryPlusMinus: (q4) => createBinaryParser(q4.binaryMulDiv, PRIMITIVES.binaryPlusMinus, Expressions.binaryOp),
  binaryCompare: (q4) => createBinaryParser(q4.binaryPlusMinus, PRIMITIVES.binaryCompareOp, Expressions.binaryOp),
  binaryBoolean: (q4) => createBinaryParser(q4.binaryCompare, PRIMITIVES.binaryAndOp.or(PRIMITIVES.binaryOrOp), Expressions.binaryOp),
  binaryOp: (q4) => q4.binaryBoolean,
  expression: (q4) => q4.binaryOp
});
var QUERY = P2.createLanguage({
  queryTag: (_3) => PRIMITIVES.tag.map((value) => ({ type: "tagged", value })),
  queryId: (_3) => createFunction("id", PRIMITIVES.string).map(([_4, id2]) => ({ type: "id", value: id2 })),
  queryType: (_3) => P2.string("@").then(PRIMITIVES.identifier).map((value) => ({ type: "typed", value })),
  queryPath: (_3) => createFunction(P2.regexp(/e?path/i).desc("[e]path"), PRIMITIVES.string).map(([func, path]) => ({
    type: "path",
    value: path,
    exact: func.toLowerCase() === "epath"
  })),
  queryParentOf: (q4) => createFunction(P2.regexp(/parentof|supertree/i).desc("parentof"), q4.query).map(([func, children]) => ({
    type: "parent-of",
    children,
    inclusive: func.toLowerCase() === "supertree"
  })),
  queryChildOf: (q4) => createFunction(P2.regexp(/childof|subtree/i).desc("childof"), q4.query).map(([func, parents]) => ({
    type: "child-of",
    parents,
    inclusive: func.toLowerCase() === "subtree"
  })),
  querySimpleLinked: (_3) => PRIMITIVES.link.map((link) => ({
    type: "linked",
    source: { type: "link", value: link },
    direction: "incoming"
  })),
  queryLinked: (q4) => createFunction(P2.regexp(/linksto|linkedfrom|connected/i).desc("connected"), q4.query).map(([func, source]) => ({
    type: "linked",
    source,
    direction: func.toLowerCase() == "linksto" ? "incoming" : func.toLowerCase() == "linkedfrom" ? "outgoing" : "both"
  })),
  queryExists: (_3) => createFunction(P2.regexp(/exists/i).desc("exists"), PRIMITIVES.identifier.or(PRIMITIVES.string)).map(
    ([_func, ident]) => ({
      type: "field",
      value: ident
    })
  ),
  queryQuotedExpression: (q4) => createFunction(P2.regexp(/expr/i).desc("expr"), EXPRESSION.expression).map(([_3, expr]) => ({
    type: "expression",
    expression: expr
  })),
  queryRawExpression: (q4) => EXPRESSION.binaryCompare.map((expr) => ({ type: "expression", expression: expr })),
  queryParens: (q4) => q4.query.trim(P2.optWhitespace).wrap(P2.string("("), P2.string(")")),
  queryNegate: (q4) => P2.string("!").skip(P2.optWhitespace).then(q4.queryAtom).map((value) => ({
    type: "not",
    element: value
  })),
  queryAtom: (q4) => P2.alt(
    q4.queryParens,
    q4.queryNegate,
    q4.querySimpleLinked,
    q4.queryTag,
    q4.queryType,
    q4.queryId,
    q4.queryExists,
    q4.queryChildOf,
    q4.queryParentOf,
    q4.queryLinked,
    q4.queryPath,
    q4.queryQuotedExpression,
    // Expressions are essentially the "catch-all" of otherwise unparseable terms, so they should go absolute last.
    q4.queryRawExpression
  ),
  queryAnds: (q4) => createBinaryParser(q4.queryAtom, PRIMITIVES.binaryAndOp, (left, _op, right) => ({
    type: "and",
    elements: [left, right]
  })),
  queryOrs: (q4) => createBinaryParser(q4.queryAnds, PRIMITIVES.binaryOrOp, (left, _op, right) => ({
    type: "or",
    elements: [left, right]
  })),
  query: (q4) => q4.queryOrs.trim(P2.optWhitespace)
});
function createBinaryParser(child, sep, combine2) {
  return P2.seqMap(child, P2.seq(P2.optWhitespace, sep, P2.optWhitespace, child).many(), (first, rest) => {
    if (rest.length == 0) return first;
    let node2 = combine2(first, rest[0][1], rest[0][3]);
    for (let index2 = 1; index2 < rest.length; index2++) {
      node2 = combine2(node2, rest[index2][1], rest[index2][3]);
    }
    return node2;
  });
}
function createFunction(func, args) {
  const realFunc = typeof func === "string" ? P2.string(func) : func;
  return P2.seqMap(
    realFunc.skip(P2.optWhitespace),
    args.trim(P2.optWhitespace).wrap(P2.string("("), P2.string(")")),
    (f4, a4) => [f4, a4]
  );
}
function chainOpt(base, ...funcs) {
  return P2.custom((_success, _failure) => {
    return (input2, i4) => {
      let result = base._(input2, i4);
      if (!result.status) return result;
      for (let func of funcs) {
        let next3 = func(result.value)._(input2, result.index);
        if (!next3.status) return result;
        result = next3;
      }
      return result;
    };
  });
}

// src/ui/markdown.tsx
var import_obsidian = require("obsidian");

// src/utils/media.ts
var IMAGE_EXTENSIONS = Object.freeze(
  /* @__PURE__ */ new Set([
    ".tif",
    ".tiff",
    ".gif",
    ".png",
    ".apng",
    ".avif",
    ".jpg",
    ".jpeg",
    ".jfif",
    ".pjepg",
    ".pjp",
    ".svg",
    ".webp",
    ".bmp",
    ".ico",
    ".cur"
  ])
);
function isImageEmbed(link) {
  if (!link.path.contains(".")) return false;
  let extension = link.path.substring(link.path.lastIndexOf("."));
  return link.type == "file" && link.embed && IMAGE_EXTENSIONS.has(extension);
}
function extractImageDimensions(link) {
  if (!link.display) return void 0;
  let match4 = /^(\d+)x(\d+)$/iu.exec(link.display);
  if (match4) return [parseInt(match4[1]), parseInt(match4[2])];
  let match22 = /^(\d+)/.exec(link.display);
  if (match22) return [parseInt(match22[1])];
  return void 0;
}

// node_modules/preact/dist/preact.module.js
var preact_module_exports = {};
__export(preact_module_exports, {
  Component: () => k,
  Fragment: () => b,
  cloneElement: () => E,
  createContext: () => G,
  createElement: () => _,
  createRef: () => m,
  h: () => _,
  hydrate: () => D,
  isValidElement: () => t,
  options: () => l2,
  render: () => B,
  toChildArray: () => H
});
var n2;
var l2;
var u;
var t;
var i;
var o;
var r;
var f;
var e;
var c;
var s2;
var a;
var h = {};
var v = [];
var p = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
var y = Array.isArray;
function d(n3, l4) {
  for (var u4 in l4) n3[u4] = l4[u4];
  return n3;
}
function w(n3) {
  n3 && n3.parentNode && n3.parentNode.removeChild(n3);
}
function _(l4, u4, t5) {
  var i4, o4, r4, f4 = {};
  for (r4 in u4) "key" == r4 ? i4 = u4[r4] : "ref" == r4 ? o4 = u4[r4] : f4[r4] = u4[r4];
  if (arguments.length > 2 && (f4.children = arguments.length > 3 ? n2.call(arguments, 2) : t5), "function" == typeof l4 && null != l4.defaultProps) for (r4 in l4.defaultProps) void 0 === f4[r4] && (f4[r4] = l4.defaultProps[r4]);
  return g(l4, f4, i4, o4, null);
}
function g(n3, t5, i4, o4, r4) {
  var f4 = { type: n3, props: t5, key: i4, ref: o4, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: null == r4 ? ++u : r4, __i: -1, __u: 0 };
  return null == r4 && null != l2.vnode && l2.vnode(f4), f4;
}
function m() {
  return { current: null };
}
function b(n3) {
  return n3.children;
}
function k(n3, l4) {
  this.props = n3, this.context = l4;
}
function x(n3, l4) {
  if (null == l4) return n3.__ ? x(n3.__, n3.__i + 1) : null;
  for (var u4; l4 < n3.__k.length; l4++) if (null != (u4 = n3.__k[l4]) && null != u4.__e) return u4.__e;
  return "function" == typeof n3.type ? x(n3) : null;
}
function C(n3) {
  var l4, u4;
  if (null != (n3 = n3.__) && null != n3.__c) {
    for (n3.__e = n3.__c.base = null, l4 = 0; l4 < n3.__k.length; l4++) if (null != (u4 = n3.__k[l4]) && null != u4.__e) {
      n3.__e = n3.__c.base = u4.__e;
      break;
    }
    return C(n3);
  }
}
function S(n3) {
  (!n3.__d && (n3.__d = true) && i.push(n3) && !M.__r++ || o !== l2.debounceRendering) && ((o = l2.debounceRendering) || r)(M);
}
function M() {
  var n3, u4, t5, o4, r4, e3, c4, s4;
  for (i.sort(f); n3 = i.shift(); ) n3.__d && (u4 = i.length, o4 = void 0, e3 = (r4 = (t5 = n3).__v).__e, c4 = [], s4 = [], t5.__P && ((o4 = d({}, r4)).__v = r4.__v + 1, l2.vnode && l2.vnode(o4), O(t5.__P, o4, r4, t5.__n, t5.__P.namespaceURI, 32 & r4.__u ? [e3] : null, c4, null == e3 ? x(r4) : e3, !!(32 & r4.__u), s4), o4.__v = r4.__v, o4.__.__k[o4.__i] = o4, j(c4, o4, s4), o4.__e != e3 && C(o4)), i.length > u4 && i.sort(f));
  M.__r = 0;
}
function P3(n3, l4, u4, t5, i4, o4, r4, f4, e3, c4, s4) {
  var a4, p3, y4, d3, w5, _3 = t5 && t5.__k || v, g4 = l4.length;
  for (u4.__d = e3, $(u4, l4, _3), e3 = u4.__d, a4 = 0; a4 < g4; a4++) null != (y4 = u4.__k[a4]) && (p3 = -1 === y4.__i ? h : _3[y4.__i] || h, y4.__i = a4, O(n3, y4, p3, i4, o4, r4, f4, e3, c4, s4), d3 = y4.__e, y4.ref && p3.ref != y4.ref && (p3.ref && N(p3.ref, null, y4), s4.push(y4.ref, y4.__c || d3, y4)), null == w5 && null != d3 && (w5 = d3), 65536 & y4.__u || p3.__k === y4.__k ? e3 = I(y4, e3, n3) : "function" == typeof y4.type && void 0 !== y4.__d ? e3 = y4.__d : d3 && (e3 = d3.nextSibling), y4.__d = void 0, y4.__u &= -196609);
  u4.__d = e3, u4.__e = w5;
}
function $(n3, l4, u4) {
  var t5, i4, o4, r4, f4, e3 = l4.length, c4 = u4.length, s4 = c4, a4 = 0;
  for (n3.__k = [], t5 = 0; t5 < e3; t5++) null != (i4 = l4[t5]) && "boolean" != typeof i4 && "function" != typeof i4 ? (r4 = t5 + a4, (i4 = n3.__k[t5] = "string" == typeof i4 || "number" == typeof i4 || "bigint" == typeof i4 || i4.constructor == String ? g(null, i4, null, null, null) : y(i4) ? g(b, { children: i4 }, null, null, null) : void 0 === i4.constructor && i4.__b > 0 ? g(i4.type, i4.props, i4.key, i4.ref ? i4.ref : null, i4.__v) : i4).__ = n3, i4.__b = n3.__b + 1, o4 = null, -1 !== (f4 = i4.__i = L(i4, u4, r4, s4)) && (s4--, (o4 = u4[f4]) && (o4.__u |= 131072)), null == o4 || null === o4.__v ? (-1 == f4 && a4--, "function" != typeof i4.type && (i4.__u |= 65536)) : f4 !== r4 && (f4 == r4 - 1 ? a4-- : f4 == r4 + 1 ? a4++ : (f4 > r4 ? a4-- : a4++, i4.__u |= 65536))) : i4 = n3.__k[t5] = null;
  if (s4) for (t5 = 0; t5 < c4; t5++) null != (o4 = u4[t5]) && 0 == (131072 & o4.__u) && (o4.__e == n3.__d && (n3.__d = x(o4)), V(o4, o4));
}
function I(n3, l4, u4) {
  var t5, i4;
  if ("function" == typeof n3.type) {
    for (t5 = n3.__k, i4 = 0; t5 && i4 < t5.length; i4++) t5[i4] && (t5[i4].__ = n3, l4 = I(t5[i4], l4, u4));
    return l4;
  }
  n3.__e != l4 && (l4 && n3.type && !u4.contains(l4) && (l4 = x(n3)), u4.insertBefore(n3.__e, l4 || null), l4 = n3.__e);
  do {
    l4 = l4 && l4.nextSibling;
  } while (null != l4 && 8 === l4.nodeType);
  return l4;
}
function H(n3, l4) {
  return l4 = l4 || [], null == n3 || "boolean" == typeof n3 || (y(n3) ? n3.some(function(n4) {
    H(n4, l4);
  }) : l4.push(n3)), l4;
}
function L(n3, l4, u4, t5) {
  var i4 = n3.key, o4 = n3.type, r4 = u4 - 1, f4 = u4 + 1, e3 = l4[u4];
  if (null === e3 || e3 && i4 == e3.key && o4 === e3.type && 0 == (131072 & e3.__u)) return u4;
  if (t5 > (null != e3 && 0 == (131072 & e3.__u) ? 1 : 0)) for (; r4 >= 0 || f4 < l4.length; ) {
    if (r4 >= 0) {
      if ((e3 = l4[r4]) && 0 == (131072 & e3.__u) && i4 == e3.key && o4 === e3.type) return r4;
      r4--;
    }
    if (f4 < l4.length) {
      if ((e3 = l4[f4]) && 0 == (131072 & e3.__u) && i4 == e3.key && o4 === e3.type) return f4;
      f4++;
    }
  }
  return -1;
}
function T(n3, l4, u4) {
  "-" === l4[0] ? n3.setProperty(l4, null == u4 ? "" : u4) : n3[l4] = null == u4 ? "" : "number" != typeof u4 || p.test(l4) ? u4 : u4 + "px";
}
function A(n3, l4, u4, t5, i4) {
  var o4;
  n: if ("style" === l4) if ("string" == typeof u4) n3.style.cssText = u4;
  else {
    if ("string" == typeof t5 && (n3.style.cssText = t5 = ""), t5) for (l4 in t5) u4 && l4 in u4 || T(n3.style, l4, "");
    if (u4) for (l4 in u4) t5 && u4[l4] === t5[l4] || T(n3.style, l4, u4[l4]);
  }
  else if ("o" === l4[0] && "n" === l4[1]) o4 = l4 !== (l4 = l4.replace(/(PointerCapture)$|Capture$/i, "$1")), l4 = l4.toLowerCase() in n3 || "onFocusOut" === l4 || "onFocusIn" === l4 ? l4.toLowerCase().slice(2) : l4.slice(2), n3.l || (n3.l = {}), n3.l[l4 + o4] = u4, u4 ? t5 ? u4.u = t5.u : (u4.u = e, n3.addEventListener(l4, o4 ? s2 : c, o4)) : n3.removeEventListener(l4, o4 ? s2 : c, o4);
  else {
    if ("http://www.w3.org/2000/svg" == i4) l4 = l4.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" != l4 && "height" != l4 && "href" != l4 && "list" != l4 && "form" != l4 && "tabIndex" != l4 && "download" != l4 && "rowSpan" != l4 && "colSpan" != l4 && "role" != l4 && "popover" != l4 && l4 in n3) try {
      n3[l4] = null == u4 ? "" : u4;
      break n;
    } catch (n4) {
    }
    "function" == typeof u4 || (null == u4 || false === u4 && "-" !== l4[4] ? n3.removeAttribute(l4) : n3.setAttribute(l4, "popover" == l4 && 1 == u4 ? "" : u4));
  }
}
function F(n3) {
  return function(u4) {
    if (this.l) {
      var t5 = this.l[u4.type + n3];
      if (null == u4.t) u4.t = e++;
      else if (u4.t < t5.u) return;
      return t5(l2.event ? l2.event(u4) : u4);
    }
  };
}
function O(n3, u4, t5, i4, o4, r4, f4, e3, c4, s4) {
  var a4, h3, v3, p3, w5, _3, g4, m3, x4, C4, S2, M3, $3, I3, H3, L3, T4 = u4.type;
  if (void 0 !== u4.constructor) return null;
  128 & t5.__u && (c4 = !!(32 & t5.__u), r4 = [e3 = u4.__e = t5.__e]), (a4 = l2.__b) && a4(u4);
  n: if ("function" == typeof T4) try {
    if (m3 = u4.props, x4 = "prototype" in T4 && T4.prototype.render, C4 = (a4 = T4.contextType) && i4[a4.__c], S2 = a4 ? C4 ? C4.props.value : a4.__ : i4, t5.__c ? g4 = (h3 = u4.__c = t5.__c).__ = h3.__E : (x4 ? u4.__c = h3 = new T4(m3, S2) : (u4.__c = h3 = new k(m3, S2), h3.constructor = T4, h3.render = q), C4 && C4.sub(h3), h3.props = m3, h3.state || (h3.state = {}), h3.context = S2, h3.__n = i4, v3 = h3.__d = true, h3.__h = [], h3._sb = []), x4 && null == h3.__s && (h3.__s = h3.state), x4 && null != T4.getDerivedStateFromProps && (h3.__s == h3.state && (h3.__s = d({}, h3.__s)), d(h3.__s, T4.getDerivedStateFromProps(m3, h3.__s))), p3 = h3.props, w5 = h3.state, h3.__v = u4, v3) x4 && null == T4.getDerivedStateFromProps && null != h3.componentWillMount && h3.componentWillMount(), x4 && null != h3.componentDidMount && h3.__h.push(h3.componentDidMount);
    else {
      if (x4 && null == T4.getDerivedStateFromProps && m3 !== p3 && null != h3.componentWillReceiveProps && h3.componentWillReceiveProps(m3, S2), !h3.__e && (null != h3.shouldComponentUpdate && false === h3.shouldComponentUpdate(m3, h3.__s, S2) || u4.__v === t5.__v)) {
        for (u4.__v !== t5.__v && (h3.props = m3, h3.state = h3.__s, h3.__d = false), u4.__e = t5.__e, u4.__k = t5.__k, u4.__k.some(function(n4) {
          n4 && (n4.__ = u4);
        }), M3 = 0; M3 < h3._sb.length; M3++) h3.__h.push(h3._sb[M3]);
        h3._sb = [], h3.__h.length && f4.push(h3);
        break n;
      }
      null != h3.componentWillUpdate && h3.componentWillUpdate(m3, h3.__s, S2), x4 && null != h3.componentDidUpdate && h3.__h.push(function() {
        h3.componentDidUpdate(p3, w5, _3);
      });
    }
    if (h3.context = S2, h3.props = m3, h3.__P = n3, h3.__e = false, $3 = l2.__r, I3 = 0, x4) {
      for (h3.state = h3.__s, h3.__d = false, $3 && $3(u4), a4 = h3.render(h3.props, h3.state, h3.context), H3 = 0; H3 < h3._sb.length; H3++) h3.__h.push(h3._sb[H3]);
      h3._sb = [];
    } else do {
      h3.__d = false, $3 && $3(u4), a4 = h3.render(h3.props, h3.state, h3.context), h3.state = h3.__s;
    } while (h3.__d && ++I3 < 25);
    h3.state = h3.__s, null != h3.getChildContext && (i4 = d(d({}, i4), h3.getChildContext())), x4 && !v3 && null != h3.getSnapshotBeforeUpdate && (_3 = h3.getSnapshotBeforeUpdate(p3, w5)), P3(n3, y(L3 = null != a4 && a4.type === b && null == a4.key ? a4.props.children : a4) ? L3 : [L3], u4, t5, i4, o4, r4, f4, e3, c4, s4), h3.base = u4.__e, u4.__u &= -161, h3.__h.length && f4.push(h3), g4 && (h3.__E = h3.__ = null);
  } catch (n4) {
    if (u4.__v = null, c4 || null != r4) {
      for (u4.__u |= c4 ? 160 : 128; e3 && 8 === e3.nodeType && e3.nextSibling; ) e3 = e3.nextSibling;
      r4[r4.indexOf(e3)] = null, u4.__e = e3;
    } else u4.__e = t5.__e, u4.__k = t5.__k;
    l2.__e(n4, u4, t5);
  }
  else null == r4 && u4.__v === t5.__v ? (u4.__k = t5.__k, u4.__e = t5.__e) : u4.__e = z(t5.__e, u4, t5, i4, o4, r4, f4, c4, s4);
  (a4 = l2.diffed) && a4(u4);
}
function j(n3, u4, t5) {
  u4.__d = void 0;
  for (var i4 = 0; i4 < t5.length; i4++) N(t5[i4], t5[++i4], t5[++i4]);
  l2.__c && l2.__c(u4, n3), n3.some(function(u5) {
    try {
      n3 = u5.__h, u5.__h = [], n3.some(function(n4) {
        n4.call(u5);
      });
    } catch (n4) {
      l2.__e(n4, u5.__v);
    }
  });
}
function z(u4, t5, i4, o4, r4, f4, e3, c4, s4) {
  var a4, v3, p3, d3, _3, g4, m3, b3 = i4.props, k4 = t5.props, C4 = t5.type;
  if ("svg" === C4 ? r4 = "http://www.w3.org/2000/svg" : "math" === C4 ? r4 = "http://www.w3.org/1998/Math/MathML" : r4 || (r4 = "http://www.w3.org/1999/xhtml"), null != f4) {
    for (a4 = 0; a4 < f4.length; a4++) if ((_3 = f4[a4]) && "setAttribute" in _3 == !!C4 && (C4 ? _3.localName === C4 : 3 === _3.nodeType)) {
      u4 = _3, f4[a4] = null;
      break;
    }
  }
  if (null == u4) {
    if (null === C4) return document.createTextNode(k4);
    u4 = document.createElementNS(r4, C4, k4.is && k4), c4 && (l2.__m && l2.__m(t5, f4), c4 = false), f4 = null;
  }
  if (null === C4) b3 === k4 || c4 && u4.data === k4 || (u4.data = k4);
  else {
    if (f4 = f4 && n2.call(u4.childNodes), b3 = i4.props || h, !c4 && null != f4) for (b3 = {}, a4 = 0; a4 < u4.attributes.length; a4++) b3[(_3 = u4.attributes[a4]).name] = _3.value;
    for (a4 in b3) if (_3 = b3[a4], "children" == a4) ;
    else if ("dangerouslySetInnerHTML" == a4) p3 = _3;
    else if (!(a4 in k4)) {
      if ("value" == a4 && "defaultValue" in k4 || "checked" == a4 && "defaultChecked" in k4) continue;
      A(u4, a4, null, _3, r4);
    }
    for (a4 in k4) _3 = k4[a4], "children" == a4 ? d3 = _3 : "dangerouslySetInnerHTML" == a4 ? v3 = _3 : "value" == a4 ? g4 = _3 : "checked" == a4 ? m3 = _3 : c4 && "function" != typeof _3 || b3[a4] === _3 || A(u4, a4, _3, b3[a4], r4);
    if (v3) c4 || p3 && (v3.__html === p3.__html || v3.__html === u4.innerHTML) || (u4.innerHTML = v3.__html), t5.__k = [];
    else if (p3 && (u4.innerHTML = ""), P3(u4, y(d3) ? d3 : [d3], t5, i4, o4, "foreignObject" === C4 ? "http://www.w3.org/1999/xhtml" : r4, f4, e3, f4 ? f4[0] : i4.__k && x(i4, 0), c4, s4), null != f4) for (a4 = f4.length; a4--; ) w(f4[a4]);
    c4 || (a4 = "value", "progress" === C4 && null == g4 ? u4.removeAttribute("value") : void 0 !== g4 && (g4 !== u4[a4] || "progress" === C4 && !g4 || "option" === C4 && g4 !== b3[a4]) && A(u4, a4, g4, b3[a4], r4), a4 = "checked", void 0 !== m3 && m3 !== u4[a4] && A(u4, a4, m3, b3[a4], r4));
  }
  return u4;
}
function N(n3, u4, t5) {
  try {
    if ("function" == typeof n3) {
      var i4 = "function" == typeof n3.__u;
      i4 && n3.__u(), i4 && null == u4 || (n3.__u = n3(u4));
    } else n3.current = u4;
  } catch (n4) {
    l2.__e(n4, t5);
  }
}
function V(n3, u4, t5) {
  var i4, o4;
  if (l2.unmount && l2.unmount(n3), (i4 = n3.ref) && (i4.current && i4.current !== n3.__e || N(i4, null, u4)), null != (i4 = n3.__c)) {
    if (i4.componentWillUnmount) try {
      i4.componentWillUnmount();
    } catch (n4) {
      l2.__e(n4, u4);
    }
    i4.base = i4.__P = null;
  }
  if (i4 = n3.__k) for (o4 = 0; o4 < i4.length; o4++) i4[o4] && V(i4[o4], u4, t5 || "function" != typeof n3.type);
  t5 || w(n3.__e), n3.__c = n3.__ = n3.__e = n3.__d = void 0;
}
function q(n3, l4, u4) {
  return this.constructor(n3, u4);
}
function B(u4, t5, i4) {
  var o4, r4, f4, e3;
  l2.__ && l2.__(u4, t5), r4 = (o4 = "function" == typeof i4) ? null : i4 && i4.__k || t5.__k, f4 = [], e3 = [], O(t5, u4 = (!o4 && i4 || t5).__k = _(b, null, [u4]), r4 || h, h, t5.namespaceURI, !o4 && i4 ? [i4] : r4 ? null : t5.firstChild ? n2.call(t5.childNodes) : null, f4, !o4 && i4 ? i4 : r4 ? r4.__e : t5.firstChild, o4, e3), j(f4, u4, e3);
}
function D(n3, l4) {
  B(n3, l4, D);
}
function E(l4, u4, t5) {
  var i4, o4, r4, f4, e3 = d({}, l4.props);
  for (r4 in l4.type && l4.type.defaultProps && (f4 = l4.type.defaultProps), u4) "key" == r4 ? i4 = u4[r4] : "ref" == r4 ? o4 = u4[r4] : e3[r4] = void 0 === u4[r4] && void 0 !== f4 ? f4[r4] : u4[r4];
  return arguments.length > 2 && (e3.children = arguments.length > 3 ? n2.call(arguments, 2) : t5), g(l4.type, e3, i4 || l4.key, o4 || l4.ref, null);
}
function G(n3, l4) {
  var u4 = { __c: l4 = "__cC" + a++, __: n3, Consumer: function(n4, l5) {
    return n4.children(l5);
  }, Provider: function(n4) {
    var u5, t5;
    return this.getChildContext || (u5 = /* @__PURE__ */ new Set(), (t5 = {})[l4] = this, this.getChildContext = function() {
      return t5;
    }, this.componentWillUnmount = function() {
      u5 = null;
    }, this.shouldComponentUpdate = function(n5) {
      this.props.value !== n5.value && u5.forEach(function(n6) {
        n6.__e = true, S(n6);
      });
    }, this.sub = function(n5) {
      u5.add(n5);
      var l5 = n5.componentWillUnmount;
      n5.componentWillUnmount = function() {
        u5 && u5.delete(n5), l5 && l5.call(n5);
      };
    }), n4.children;
  } };
  return u4.Provider.__ = u4.Consumer.contextType = u4;
}
n2 = v.slice, l2 = { __e: function(n3, l4, u4, t5) {
  for (var i4, o4, r4; l4 = l4.__; ) if ((i4 = l4.__c) && !i4.__) try {
    if ((o4 = i4.constructor) && null != o4.getDerivedStateFromError && (i4.setState(o4.getDerivedStateFromError(n3)), r4 = i4.__d), null != i4.componentDidCatch && (i4.componentDidCatch(n3, t5 || {}), r4 = i4.__d), r4) return i4.__E = i4;
  } catch (l5) {
    n3 = l5;
  }
  throw n3;
} }, u = 0, t = function(n3) {
  return null != n3 && null == n3.constructor;
}, k.prototype.setState = function(n3, l4) {
  var u4;
  u4 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = d({}, this.state), "function" == typeof n3 && (n3 = n3(d({}, u4), this.props)), n3 && d(u4, n3), null != n3 && this.__v && (l4 && this._sb.push(l4), S(this));
}, k.prototype.forceUpdate = function(n3) {
  this.__v && (this.__e = true, n3 && this.__h.push(n3), S(this));
}, k.prototype.render = b, i = [], r = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f = function(n3, l4) {
  return n3.__v.__b - l4.__v.__b;
}, M.__r = 0, e = 0, c = F(false), s2 = F(true), a = 0;

// node_modules/preact/hooks/dist/hooks.module.js
var hooks_module_exports = {};
__export(hooks_module_exports, {
  useCallback: () => q2,
  useContext: () => x2,
  useDebugValue: () => P4,
  useEffect: () => y2,
  useErrorBoundary: () => b2,
  useId: () => g2,
  useImperativeHandle: () => F2,
  useLayoutEffect: () => _2,
  useMemo: () => T2,
  useReducer: () => p2,
  useRef: () => A2,
  useState: () => h2
});
var t2;
var r2;
var u2;
var i2;
var o2 = 0;
var f2 = [];
var c2 = l2;
var e2 = c2.__b;
var a2 = c2.__r;
var v2 = c2.diffed;
var l3 = c2.__c;
var m2 = c2.unmount;
var s3 = c2.__;
function d2(n3, t5) {
  c2.__h && c2.__h(r2, n3, o2 || t5), o2 = 0;
  var u4 = r2.__H || (r2.__H = { __: [], __h: [] });
  return n3 >= u4.__.length && u4.__.push({}), u4.__[n3];
}
function h2(n3) {
  return o2 = 1, p2(D2, n3);
}
function p2(n3, u4, i4) {
  var o4 = d2(t2++, 2);
  if (o4.t = n3, !o4.__c && (o4.__ = [i4 ? i4(u4) : D2(void 0, u4), function(n4) {
    var t5 = o4.__N ? o4.__N[0] : o4.__[0], r4 = o4.t(t5, n4);
    t5 !== r4 && (o4.__N = [r4, o4.__[1]], o4.__c.setState({}));
  }], o4.__c = r2, !r2.u)) {
    var f4 = function(n4, t5, r4) {
      if (!o4.__c.__H) return true;
      var u5 = o4.__c.__H.__.filter(function(n5) {
        return !!n5.__c;
      });
      if (u5.every(function(n5) {
        return !n5.__N;
      })) return !c4 || c4.call(this, n4, t5, r4);
      var i5 = false;
      return u5.forEach(function(n5) {
        if (n5.__N) {
          var t6 = n5.__[0];
          n5.__ = n5.__N, n5.__N = void 0, t6 !== n5.__[0] && (i5 = true);
        }
      }), !(!i5 && o4.__c.props === n4) && (!c4 || c4.call(this, n4, t5, r4));
    };
    r2.u = true;
    var c4 = r2.shouldComponentUpdate, e3 = r2.componentWillUpdate;
    r2.componentWillUpdate = function(n4, t5, r4) {
      if (this.__e) {
        var u5 = c4;
        c4 = void 0, f4(n4, t5, r4), c4 = u5;
      }
      e3 && e3.call(this, n4, t5, r4);
    }, r2.shouldComponentUpdate = f4;
  }
  return o4.__N || o4.__;
}
function y2(n3, u4) {
  var i4 = d2(t2++, 3);
  !c2.__s && C2(i4.__H, u4) && (i4.__ = n3, i4.i = u4, r2.__H.__h.push(i4));
}
function _2(n3, u4) {
  var i4 = d2(t2++, 4);
  !c2.__s && C2(i4.__H, u4) && (i4.__ = n3, i4.i = u4, r2.__h.push(i4));
}
function A2(n3) {
  return o2 = 5, T2(function() {
    return { current: n3 };
  }, []);
}
function F2(n3, t5, r4) {
  o2 = 6, _2(function() {
    return "function" == typeof n3 ? (n3(t5()), function() {
      return n3(null);
    }) : n3 ? (n3.current = t5(), function() {
      return n3.current = null;
    }) : void 0;
  }, null == r4 ? r4 : r4.concat(n3));
}
function T2(n3, r4) {
  var u4 = d2(t2++, 7);
  return C2(u4.__H, r4) && (u4.__ = n3(), u4.__H = r4, u4.__h = n3), u4.__;
}
function q2(n3, t5) {
  return o2 = 8, T2(function() {
    return n3;
  }, t5);
}
function x2(n3) {
  var u4 = r2.context[n3.__c], i4 = d2(t2++, 9);
  return i4.c = n3, u4 ? (null == i4.__ && (i4.__ = true, u4.sub(r2)), u4.props.value) : n3.__;
}
function P4(n3, t5) {
  c2.useDebugValue && c2.useDebugValue(t5 ? t5(n3) : n3);
}
function b2(n3) {
  var u4 = d2(t2++, 10), i4 = h2();
  return u4.__ = n3, r2.componentDidCatch || (r2.componentDidCatch = function(n4, t5) {
    u4.__ && u4.__(n4, t5), i4[1](n4);
  }), [i4[0], function() {
    i4[1](void 0);
  }];
}
function g2() {
  var n3 = d2(t2++, 11);
  if (!n3.__) {
    for (var u4 = r2.__v; null !== u4 && !u4.__m && null !== u4.__; ) u4 = u4.__;
    var i4 = u4.__m || (u4.__m = [0, 0]);
    n3.__ = "P" + i4[0] + "-" + i4[1]++;
  }
  return n3.__;
}
function j2() {
  for (var n3; n3 = f2.shift(); ) if (n3.__P && n3.__H) try {
    n3.__H.__h.forEach(z2), n3.__H.__h.forEach(B2), n3.__H.__h = [];
  } catch (t5) {
    n3.__H.__h = [], c2.__e(t5, n3.__v);
  }
}
c2.__b = function(n3) {
  r2 = null, e2 && e2(n3);
}, c2.__ = function(n3, t5) {
  n3 && t5.__k && t5.__k.__m && (n3.__m = t5.__k.__m), s3 && s3(n3, t5);
}, c2.__r = function(n3) {
  a2 && a2(n3), t2 = 0;
  var i4 = (r2 = n3.__c).__H;
  i4 && (u2 === r2 ? (i4.__h = [], r2.__h = [], i4.__.forEach(function(n4) {
    n4.__N && (n4.__ = n4.__N), n4.i = n4.__N = void 0;
  })) : (i4.__h.forEach(z2), i4.__h.forEach(B2), i4.__h = [], t2 = 0)), u2 = r2;
}, c2.diffed = function(n3) {
  v2 && v2(n3);
  var t5 = n3.__c;
  t5 && t5.__H && (t5.__H.__h.length && (1 !== f2.push(t5) && i2 === c2.requestAnimationFrame || ((i2 = c2.requestAnimationFrame) || w2)(j2)), t5.__H.__.forEach(function(n4) {
    n4.i && (n4.__H = n4.i), n4.i = void 0;
  })), u2 = r2 = null;
}, c2.__c = function(n3, t5) {
  t5.some(function(n4) {
    try {
      n4.__h.forEach(z2), n4.__h = n4.__h.filter(function(n5) {
        return !n5.__ || B2(n5);
      });
    } catch (r4) {
      t5.some(function(n5) {
        n5.__h && (n5.__h = []);
      }), t5 = [], c2.__e(r4, n4.__v);
    }
  }), l3 && l3(n3, t5);
}, c2.unmount = function(n3) {
  m2 && m2(n3);
  var t5, r4 = n3.__c;
  r4 && r4.__H && (r4.__H.__.forEach(function(n4) {
    try {
      z2(n4);
    } catch (n5) {
      t5 = n5;
    }
  }), r4.__H = void 0, t5 && c2.__e(t5, r4.__v));
};
var k2 = "function" == typeof requestAnimationFrame;
function w2(n3) {
  var t5, r4 = function() {
    clearTimeout(u4), k2 && cancelAnimationFrame(t5), setTimeout(n3);
  }, u4 = setTimeout(r4, 100);
  k2 && (t5 = requestAnimationFrame(r4));
}
function z2(n3) {
  var t5 = r2, u4 = n3.__c;
  "function" == typeof u4 && (n3.__c = void 0, u4()), r2 = t5;
}
function B2(n3) {
  var t5 = r2;
  n3.__c = n3.__(), r2 = t5;
}
function C2(n3, t5) {
  return !n3 || n3.length !== t5.length || t5.some(function(t6, r4) {
    return t6 !== n3[r4];
  });
}
function D2(n3, t5) {
  return "function" == typeof t5 ? t5(n3) : t5;
}

// node_modules/preact/compat/dist/compat.module.js
var compat_module_exports = {};
__export(compat_module_exports, {
  Children: () => I2,
  Component: () => k,
  Fragment: () => b,
  PureComponent: () => E2,
  StrictMode: () => mn,
  Suspense: () => D3,
  SuspenseList: () => F3,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => un,
  cloneElement: () => sn,
  createContext: () => G,
  createElement: () => _,
  createFactory: () => cn,
  createPortal: () => P5,
  createRef: () => m,
  default: () => xn,
  findDOMNode: () => vn,
  flushSync: () => pn,
  forwardRef: () => w3,
  hydrate: () => q3,
  isElement: () => gn,
  isFragment: () => ln,
  isMemo: () => an,
  isValidElement: () => fn,
  lazy: () => O2,
  memo: () => C3,
  render: () => $2,
  startTransition: () => yn,
  unmountComponentAtNode: () => hn,
  unstable_batchedUpdates: () => dn,
  useCallback: () => q2,
  useContext: () => x2,
  useDebugValue: () => P4,
  useDeferredValue: () => _n,
  useEffect: () => y2,
  useErrorBoundary: () => b2,
  useId: () => g2,
  useImperativeHandle: () => F2,
  useInsertionEffect: () => Sn,
  useLayoutEffect: () => _2,
  useMemo: () => T2,
  useReducer: () => p2,
  useRef: () => A2,
  useState: () => h2,
  useSyncExternalStore: () => En,
  useTransition: () => bn,
  version: () => on
});
function g3(n3, t5) {
  for (var e3 in n3) if ("__source" !== e3 && !(e3 in t5)) return true;
  for (var r4 in t5) if ("__source" !== r4 && n3[r4] !== t5[r4]) return true;
  return false;
}
function E2(n3, t5) {
  this.props = n3, this.context = t5;
}
function C3(n3, e3) {
  function r4(n4) {
    var t5 = this.props.ref, r5 = t5 == n4.ref;
    return !r5 && t5 && (t5.call ? t5(null) : t5.current = null), e3 ? !e3(this.props, n4) || !r5 : g3(this.props, n4);
  }
  function u4(e4) {
    return this.shouldComponentUpdate = r4, _(n3, e4);
  }
  return u4.displayName = "Memo(" + (n3.displayName || n3.name) + ")", u4.prototype.isReactComponent = true, u4.__f = true, u4;
}
(E2.prototype = new k()).isPureReactComponent = true, E2.prototype.shouldComponentUpdate = function(n3, t5) {
  return g3(this.props, n3) || g3(this.state, t5);
};
var x3 = l2.__b;
l2.__b = function(n3) {
  n3.type && n3.type.__f && n3.ref && (n3.props.ref = n3.ref, n3.ref = null), x3 && x3(n3);
};
var R = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
function w3(n3) {
  function t5(t6) {
    if (!("ref" in t6)) return n3(t6, null);
    var e3 = t6.ref;
    delete t6.ref;
    var r4 = n3(t6, e3);
    return t6.ref = e3, r4;
  }
  return t5.$$typeof = R, t5.render = t5, t5.prototype.isReactComponent = t5.__f = true, t5.displayName = "ForwardRef(" + (n3.displayName || n3.name) + ")", t5;
}
var k3 = function(n3, t5) {
  return null == n3 ? null : H(H(n3).map(t5));
};
var I2 = { map: k3, forEach: k3, count: function(n3) {
  return n3 ? H(n3).length : 0;
}, only: function(n3) {
  var t5 = H(n3);
  if (1 !== t5.length) throw "Children.only";
  return t5[0];
}, toArray: H };
var N2 = l2.__e;
l2.__e = function(n3, t5, e3, r4) {
  if (n3.then) {
    for (var u4, o4 = t5; o4 = o4.__; ) if ((u4 = o4.__c) && u4.__c) return null == t5.__e && (t5.__e = e3.__e, t5.__k = e3.__k), u4.__c(n3, t5);
  }
  N2(n3, t5, e3, r4);
};
var M2 = l2.unmount;
function T3(n3, t5, e3) {
  return n3 && (n3.__c && n3.__c.__H && (n3.__c.__H.__.forEach(function(n4) {
    "function" == typeof n4.__c && n4.__c();
  }), n3.__c.__H = null), null != (n3 = function(n4, t6) {
    for (var e4 in t6) n4[e4] = t6[e4];
    return n4;
  }({}, n3)).__c && (n3.__c.__P === e3 && (n3.__c.__P = t5), n3.__c = null), n3.__k = n3.__k && n3.__k.map(function(n4) {
    return T3(n4, t5, e3);
  })), n3;
}
function A3(n3, t5, e3) {
  return n3 && e3 && (n3.__v = null, n3.__k = n3.__k && n3.__k.map(function(n4) {
    return A3(n4, t5, e3);
  }), n3.__c && n3.__c.__P === t5 && (n3.__e && e3.appendChild(n3.__e), n3.__c.__e = true, n3.__c.__P = e3)), n3;
}
function D3() {
  this.__u = 0, this.t = null, this.__b = null;
}
function L2(n3) {
  var t5 = n3.__.__c;
  return t5 && t5.__a && t5.__a(n3);
}
function O2(n3) {
  var e3, r4, u4;
  function o4(o5) {
    if (e3 || (e3 = n3()).then(function(n4) {
      r4 = n4.default || n4;
    }, function(n4) {
      u4 = n4;
    }), u4) throw u4;
    if (!r4) throw e3;
    return _(r4, o5);
  }
  return o4.displayName = "Lazy", o4.__f = true, o4;
}
function F3() {
  this.u = null, this.o = null;
}
l2.unmount = function(n3) {
  var t5 = n3.__c;
  t5 && t5.__R && t5.__R(), t5 && 32 & n3.__u && (n3.type = null), M2 && M2(n3);
}, (D3.prototype = new k()).__c = function(n3, t5) {
  var e3 = t5.__c, r4 = this;
  null == r4.t && (r4.t = []), r4.t.push(e3);
  var u4 = L2(r4.__v), o4 = false, i4 = function() {
    o4 || (o4 = true, e3.__R = null, u4 ? u4(c4) : c4());
  };
  e3.__R = i4;
  var c4 = function() {
    if (!--r4.__u) {
      if (r4.state.__a) {
        var n4 = r4.state.__a;
        r4.__v.__k[0] = A3(n4, n4.__c.__P, n4.__c.__O);
      }
      var t6;
      for (r4.setState({ __a: r4.__b = null }); t6 = r4.t.pop(); ) t6.forceUpdate();
    }
  };
  r4.__u++ || 32 & t5.__u || r4.setState({ __a: r4.__b = r4.__v.__k[0] }), n3.then(i4, i4);
}, D3.prototype.componentWillUnmount = function() {
  this.t = [];
}, D3.prototype.render = function(n3, e3) {
  if (this.__b) {
    if (this.__v.__k) {
      var r4 = document.createElement("div"), o4 = this.__v.__k[0].__c;
      this.__v.__k[0] = T3(this.__b, r4, o4.__O = o4.__P);
    }
    this.__b = null;
  }
  var i4 = e3.__a && _(b, null, n3.fallback);
  return i4 && (i4.__u &= -33), [_(b, null, e3.__a ? null : n3.children), i4];
};
var U = function(n3, t5, e3) {
  if (++e3[1] === e3[0] && n3.o.delete(t5), n3.props.revealOrder && ("t" !== n3.props.revealOrder[0] || !n3.o.size)) for (e3 = n3.u; e3; ) {
    for (; e3.length > 3; ) e3.pop()();
    if (e3[1] < e3[0]) break;
    n3.u = e3 = e3[2];
  }
};
function V2(n3) {
  return this.getChildContext = function() {
    return n3.context;
  }, n3.children;
}
function W(n3) {
  var e3 = this, r4 = n3.i;
  e3.componentWillUnmount = function() {
    B(null, e3.l), e3.l = null, e3.i = null;
  }, e3.i && e3.i !== r4 && e3.componentWillUnmount(), e3.l || (e3.i = r4, e3.l = { nodeType: 1, parentNode: r4, childNodes: [], contains: function() {
    return true;
  }, appendChild: function(n4) {
    this.childNodes.push(n4), e3.i.appendChild(n4);
  }, insertBefore: function(n4, t5) {
    this.childNodes.push(n4), e3.i.appendChild(n4);
  }, removeChild: function(n4) {
    this.childNodes.splice(this.childNodes.indexOf(n4) >>> 1, 1), e3.i.removeChild(n4);
  } }), B(_(V2, { context: e3.context }, n3.__v), e3.l);
}
function P5(n3, e3) {
  var r4 = _(W, { __v: n3, i: e3 });
  return r4.containerInfo = e3, r4;
}
(F3.prototype = new k()).__a = function(n3) {
  var t5 = this, e3 = L2(t5.__v), r4 = t5.o.get(n3);
  return r4[0]++, function(u4) {
    var o4 = function() {
      t5.props.revealOrder ? (r4.push(u4), U(t5, n3, r4)) : u4();
    };
    e3 ? e3(o4) : o4();
  };
}, F3.prototype.render = function(n3) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var t5 = H(n3.children);
  n3.revealOrder && "b" === n3.revealOrder[0] && t5.reverse();
  for (var e3 = t5.length; e3--; ) this.o.set(t5[e3], this.u = [1, 0, this.u]);
  return n3.children;
}, F3.prototype.componentDidUpdate = F3.prototype.componentDidMount = function() {
  var n3 = this;
  this.o.forEach(function(t5, e3) {
    U(n3, e3, t5);
  });
};
var j3 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
var z3 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
var B3 = /^on(Ani|Tra|Tou|BeforeInp|Compo)/;
var H2 = /[A-Z0-9]/g;
var Z = "undefined" != typeof document;
var Y = function(n3) {
  return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n3);
};
function $2(n3, t5, e3) {
  return null == t5.__k && (t5.textContent = ""), B(n3, t5), "function" == typeof e3 && e3(), n3 ? n3.__c : null;
}
function q3(n3, t5, e3) {
  return D(n3, t5), "function" == typeof e3 && e3(), n3 ? n3.__c : null;
}
k.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t5) {
  Object.defineProperty(k.prototype, t5, { configurable: true, get: function() {
    return this["UNSAFE_" + t5];
  }, set: function(n3) {
    Object.defineProperty(this, t5, { configurable: true, writable: true, value: n3 });
  } });
});
var G2 = l2.event;
function J() {
}
function K() {
  return this.cancelBubble;
}
function Q() {
  return this.defaultPrevented;
}
l2.event = function(n3) {
  return G2 && (n3 = G2(n3)), n3.persist = J, n3.isPropagationStopped = K, n3.isDefaultPrevented = Q, n3.nativeEvent = n3;
};
var X;
var nn = { enumerable: false, configurable: true, get: function() {
  return this.class;
} };
var tn = l2.vnode;
l2.vnode = function(n3) {
  "string" == typeof n3.type && function(n4) {
    var t5 = n4.props, e3 = n4.type, u4 = {}, o4 = -1 === e3.indexOf("-");
    for (var i4 in t5) {
      var c4 = t5[i4];
      if (!("value" === i4 && "defaultValue" in t5 && null == c4 || Z && "children" === i4 && "noscript" === e3 || "class" === i4 || "className" === i4)) {
        var f4 = i4.toLowerCase();
        "defaultValue" === i4 && "value" in t5 && null == t5.value ? i4 = "value" : "download" === i4 && true === c4 ? c4 = "" : "translate" === f4 && "no" === c4 ? c4 = false : "o" === f4[0] && "n" === f4[1] ? "ondoubleclick" === f4 ? i4 = "ondblclick" : "onchange" !== f4 || "input" !== e3 && "textarea" !== e3 || Y(t5.type) ? "onfocus" === f4 ? i4 = "onfocusin" : "onblur" === f4 ? i4 = "onfocusout" : B3.test(i4) && (i4 = f4) : f4 = i4 = "oninput" : o4 && z3.test(i4) ? i4 = i4.replace(H2, "-$&").toLowerCase() : null === c4 && (c4 = void 0), "oninput" === f4 && u4[i4 = f4] && (i4 = "oninputCapture"), u4[i4] = c4;
      }
    }
    "select" == e3 && u4.multiple && Array.isArray(u4.value) && (u4.value = H(t5.children).forEach(function(n5) {
      n5.props.selected = -1 != u4.value.indexOf(n5.props.value);
    })), "select" == e3 && null != u4.defaultValue && (u4.value = H(t5.children).forEach(function(n5) {
      n5.props.selected = u4.multiple ? -1 != u4.defaultValue.indexOf(n5.props.value) : u4.defaultValue == n5.props.value;
    })), t5.class && !t5.className ? (u4.class = t5.class, Object.defineProperty(u4, "className", nn)) : (t5.className && !t5.class || t5.class && t5.className) && (u4.class = u4.className = t5.className), n4.props = u4;
  }(n3), n3.$$typeof = j3, tn && tn(n3);
};
var en = l2.__r;
l2.__r = function(n3) {
  en && en(n3), X = n3.__c;
};
var rn = l2.diffed;
l2.diffed = function(n3) {
  rn && rn(n3);
  var t5 = n3.props, e3 = n3.__e;
  null != e3 && "textarea" === n3.type && "value" in t5 && t5.value !== e3.value && (e3.value = null == t5.value ? "" : t5.value), X = null;
};
var un = { ReactCurrentDispatcher: { current: { readContext: function(n3) {
  return X.__n[n3.__c].props.value;
}, useCallback: q2, useContext: x2, useDebugValue: P4, useDeferredValue: _n, useEffect: y2, useId: g2, useImperativeHandle: F2, useInsertionEffect: Sn, useLayoutEffect: _2, useMemo: T2, useReducer: p2, useRef: A2, useState: h2, useSyncExternalStore: En, useTransition: bn } } };
var on = "18.3.1";
function cn(n3) {
  return _.bind(null, n3);
}
function fn(n3) {
  return !!n3 && n3.$$typeof === j3;
}
function ln(n3) {
  return fn(n3) && n3.type === b;
}
function an(n3) {
  return !!n3 && !!n3.displayName && ("string" == typeof n3.displayName || n3.displayName instanceof String) && n3.displayName.startsWith("Memo(");
}
function sn(n3) {
  return fn(n3) ? E.apply(null, arguments) : n3;
}
function hn(n3) {
  return !!n3.__k && (B(null, n3), true);
}
function vn(n3) {
  return n3 && (n3.base || 1 === n3.nodeType && n3) || null;
}
var dn = function(n3, t5) {
  return n3(t5);
};
var pn = function(n3, t5) {
  return n3(t5);
};
var mn = b;
function yn(n3) {
  n3();
}
function _n(n3) {
  return n3;
}
function bn() {
  return [false, yn];
}
var Sn = _2;
var gn = fn;
function En(n3, t5) {
  var e3 = t5(), r4 = h2({ h: { __: e3, v: t5 } }), u4 = r4[0].h, o4 = r4[1];
  return _2(function() {
    u4.__ = e3, u4.v = t5, Cn(u4) && o4({ h: u4 });
  }, [n3, e3, t5]), y2(function() {
    return Cn(u4) && o4({ h: u4 }), n3(function() {
      Cn(u4) && o4({ h: u4 });
    });
  }, [n3]), e3;
}
function Cn(n3) {
  var t5, e3, r4 = n3.v, u4 = n3.__;
  try {
    var o4 = r4();
    return !((t5 = u4) === (e3 = o4) && (0 !== t5 || 1 / t5 == 1 / e3) || t5 != t5 && e3 != e3);
  } catch (n4) {
    return true;
  }
}
var xn = { useState: h2, useId: g2, useReducer: p2, useEffect: y2, useLayoutEffect: _2, useInsertionEffect: Sn, useTransition: bn, useDeferredValue: _n, useSyncExternalStore: En, startTransition: yn, useRef: A2, useImperativeHandle: F2, useMemo: T2, useCallback: q2, useContext: x2, useDebugValue: P4, version: "18.3.1", Children: I2, render: $2, hydrate: q3, unmountComponentAtNode: hn, createPortal: P5, createElement: _, createContext: G, createFactory: cn, cloneElement: sn, createRef: m, Fragment: b, isValidElement: fn, isElement: gn, isFragment: ln, isMemo: an, findDOMNode: vn, Component: k, PureComponent: E2, memo: C3, forwardRef: w3, flushSync: pn, unstable_batchedUpdates: dn, StrictMode: mn, Suspense: D3, SuspenseList: F3, lazy: O2, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: un };

// node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js
var f3 = 0;
var i3 = Array.isArray;
function u3(e3, t5, n3, o4, i4, u4) {
  t5 || (t5 = {});
  var a4, c4, l4 = t5;
  "ref" in t5 && (a4 = t5.ref, delete t5.ref);
  var p3 = { type: e3, props: l4, key: n3, ref: a4, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: --f3, __i: -1, __u: 0, __source: i4, __self: u4 };
  if ("function" == typeof e3 && (a4 = e3.defaultProps)) for (c4 in a4) void 0 === l4[c4] && (l4[c4] = a4[c4]);
  return l2.vnode && l2.vnode(p3), p3;
}

// src/api/ui/embed.tsx
function Embed({
  link,
  inline: inline2,
  sourcePath: maybeSourcePath
}) {
  var _a;
  const app = x2(APP_CONTEXT);
  const component = x2(COMPONENT_CONTEXT);
  const currentFile = x2(CURRENT_FILE_CONTEXT);
  const sourcePath = (_a = maybeSourcePath != null ? maybeSourcePath : currentFile) != null ? _a : "";
  const container = A2(null);
  const linkedFile = T2(
    () => app.metadataCache.getFirstLinkpathDest(link.path, sourcePath),
    [link.path, sourcePath]
  );
  y2(() => {
    if (!container.current) return;
    if (!linkedFile) return;
    container.current.innerHTML = "";
    const creator = app.embedRegistry.getEmbedCreator(linkedFile);
    let embedComponent = new creator(
      {
        linktext: link.path,
        sourcePath,
        showInline: inline2,
        app,
        depth: 0,
        containerEl: container.current,
        displayMode: true
      },
      linkedFile,
      link.subpath
    );
    component.addChild(embedComponent);
    embedComponent.loadFile(linkedFile);
    return () => component.removeChild(embedComponent);
  }, [container.current, linkedFile, link.subpath]);
  if (!linkedFile) {
    return /* @__PURE__ */ u3(ErrorMessage, { message: `Could not find a page at linked location: ${link.path}` });
  } else {
    return /* @__PURE__ */ u3("div", { className: "dc-embed", ref: container });
  }
}
function LineSpanEmbed({
  path,
  start,
  end: end2,
  explain,
  showExplain = true
}) {
  var _a;
  const content = useLineSpan(path, start, end2);
  const explainer = explain != null ? explain : `${getFileTitle(path)} (${start} - ${end2})`;
  const workspace = (_a = x2(APP_CONTEXT)) == null ? void 0 : _a.workspace;
  const onExplainClick = q2(
    (event) => workspace == null ? void 0 : workspace.openLinkText(path, path, event.shiftKey),
    [path]
  );
  switch (content.type) {
    case "loading":
      return /* @__PURE__ */ u3(ErrorMessage, { message: `Reading ${path} (${start} - ${end2})` });
    case "file-not-found":
      return /* @__PURE__ */ u3(ErrorMessage, { message: `Could not find a file at path: ${content.path}` });
    case "error":
      return /* @__PURE__ */ u3(ErrorMessage, { message: content.message });
    case "loaded":
      return /* @__PURE__ */ u3("div", { className: "datacore-span-embed", children: [
        showExplain && /* @__PURE__ */ u3("a", { className: "datacore-embed-source", onClick: onExplainClick, children: explainer }),
        /* @__PURE__ */ u3(Markdown, { content: content.content, inline: false })
      ] });
  }
}
function useLineSpan(path, start, end2) {
  const app = x2(APP_CONTEXT);
  const datacore = x2(DATACORE_CONTEXT);
  const [state2, update] = p2(
    (state3, event) => {
      if (state3.type == "loaded" && event.type !== "loaded") return state3;
      else return event;
    },
    { type: "loading" }
  );
  y2(() => {
    const file = app.vault.getFileByPath(path);
    if (file == null) {
      update({ type: "file-not-found", path });
      return;
    }
    datacore.read(file).then((content) => {
      update({ type: "loaded", content: lineRange(content, start, end2) });
    }).catch((error) => {
      update({ type: "error", message: error.message });
    });
  }, [path, start, end2]);
  return state2;
}

// src/ui/markdown.tsx
var COMPONENT_CONTEXT = G(void 0);
var APP_CONTEXT = G(void 0);
var DATACORE_CONTEXT = G(void 0);
var SETTINGS_CONTEXT = G(void 0);
var CURRENT_FILE_CONTEXT = G("");
function DatacoreContextProvider({
  children,
  app,
  component,
  datacore,
  settings
}) {
  return /* @__PURE__ */ u3(COMPONENT_CONTEXT.Provider, { value: component, children: /* @__PURE__ */ u3(APP_CONTEXT.Provider, { value: app, children: /* @__PURE__ */ u3(DATACORE_CONTEXT.Provider, { value: datacore, children: /* @__PURE__ */ u3(SETTINGS_CONTEXT.Provider, { value: settings, children }) }) }) });
}
function RawLink({ link, sourcePath: maybeSourcePath }) {
  var _a;
  const app = x2(APP_CONTEXT);
  const workspace = app.workspace;
  const currentPath = x2(CURRENT_FILE_CONTEXT);
  const sourcePath = (_a = maybeSourcePath != null ? maybeSourcePath : currentPath) != null ? _a : "";
  const parsed = T2(() => Literals.isLink(link) ? link : Link.infer(link), [link]);
  const onClick = q2(
    (event) => {
      const newtab = event.shiftKey;
      workspace == null ? void 0 : workspace.openLinkText(parsed.obsidianLink(), sourcePath, newtab);
    },
    [parsed, sourcePath]
  );
  const linkRef = A2(null);
  const hoverCallback = q2(() => {
    let pagePreview = app.internalPlugins.getPluginById("page-preview").instance;
    const leaf = app.workspace.getMostRecentLeaf();
    if (linkRef.current && leaf && !(leaf.view instanceof import_obsidian.MarkdownView))
      pagePreview.onLinkHover(leaf.view, linkRef.current, parsed.obsidianLink(), sourcePath, null);
  }, [linkRef.current]);
  return /* @__PURE__ */ u3(
    "a",
    {
      ref: linkRef,
      "aria-label": parsed.displayOrDefault(),
      onClick,
      className: "internal-link",
      target: "_blank",
      rel: "noopener",
      "data-tooltip-position": "top",
      "data-href": parsed.obsidianLink(),
      onMouseOver: hoverCallback,
      children: parsed.displayOrDefault()
    }
  );
}
var ObsidianLink = C3(RawLink);
function RawMarkdown({
  content,
  sourcePath: maybeSourcePath,
  inline: inline2 = true,
  style,
  cls,
  onClick
}) {
  const container = A2(null);
  const component = x2(COMPONENT_CONTEXT);
  const defaultPath = x2(CURRENT_FILE_CONTEXT);
  const app = x2(APP_CONTEXT);
  const sourcePath = maybeSourcePath != null ? maybeSourcePath : defaultPath;
  y2(() => {
    if (!container.current) return;
    container.current.innerHTML = "";
    import_obsidian.MarkdownRenderer.render(app, content, container.current, sourcePath, component).then(() => {
      var _a;
      if (!container.current || !inline2) return;
      let paragraph = container.current.querySelector("p");
      while (paragraph) {
        let children = paragraph.childNodes;
        paragraph.replaceWith(...Array.from(children));
        paragraph = container.current.querySelector("p");
      }
      let embed = container.current.querySelector("span.internal-embed:not(.is-loaded)");
      while (embed) {
        embed.empty();
        B(
          /* @__PURE__ */ u3(APP_CONTEXT.Provider, { value: app, children: /* @__PURE__ */ u3(
            Embed,
            {
              link: Link.parseInner((_a = embed.getAttribute("src")) != null ? _a : ""),
              sourcePath,
              inline: true
            }
          ) }),
          embed
        );
        embed.addClass("is-loaded");
        embed = container.current.querySelector("span.internal-embed:not(.is-loaded)");
      }
    });
  }, [content, sourcePath, inline2, container.current]);
  return /* @__PURE__ */ u3("span", { ref: container, style, className: cls, onClick });
}
var Markdown = C3(RawMarkdown);
function RawLit({
  value,
  sourcePath: maybeSourcePath,
  inline: inline2 = false,
  depth = 0
}) {
  var _a, _b;
  const settings = x2(SETTINGS_CONTEXT);
  const app = x2(APP_CONTEXT);
  const defaultPath = x2(CURRENT_FILE_CONTEXT);
  const sourcePath = maybeSourcePath != null ? maybeSourcePath : defaultPath;
  if (depth >= settings.maxRecursiveRenderDepth) return /* @__PURE__ */ u3(b, { children: "..." });
  if (Literals.isNull(value) || value === void 0) {
    return /* @__PURE__ */ u3(Markdown, { inline: inline2, content: settings.renderNullAs, sourcePath });
  } else if (Literals.isString(value)) {
    return /* @__PURE__ */ u3(Markdown, { inline: inline2, content: value, sourcePath });
  } else if (Literals.isNumber(value)) {
    return /* @__PURE__ */ u3(b, { children: "" + value });
  } else if (Literals.isBoolean(value)) {
    return /* @__PURE__ */ u3(b, { children: "" + value });
  } else if (Literals.isDate(value)) {
    return /* @__PURE__ */ u3(b, { children: renderMinimalDate(value, settings.defaultDateFormat, settings.defaultDateTimeFormat, currentLocale()) });
  } else if (Literals.isDuration(value)) {
    return /* @__PURE__ */ u3(b, { children: renderMinimalDuration(value) });
  } else if (Literals.isLink(value)) {
    if (isImageEmbed(value)) {
      let realFile = app.metadataCache.getFirstLinkpathDest(value.path, sourcePath);
      if (!realFile) return /* @__PURE__ */ u3(Markdown, { content: value.markdown(), sourcePath });
      let dimensions = extractImageDimensions(value);
      let resourcePath = app.vault.getResourcePath(realFile);
      if (dimensions && dimensions.length == 2)
        return /* @__PURE__ */ u3("img", { alt: value.path, src: resourcePath, width: dimensions[0], height: dimensions[1] });
      else if (dimensions && dimensions.length == 1)
        return /* @__PURE__ */ u3("img", { alt: value.path, src: resourcePath, width: dimensions[0] });
      else return /* @__PURE__ */ u3("img", { alt: value.path, src: resourcePath });
    } else if (value.embed) {
      return /* @__PURE__ */ u3(Embed, { link: value, sourcePath, inline: inline2 });
    }
    return /* @__PURE__ */ u3(ObsidianLink, { link: value, sourcePath });
  } else if (Literals.isFunction(value)) {
    return /* @__PURE__ */ u3(b, { children: "<function>" });
  } else if (Literals.isArray(value)) {
    if (!inline2) {
      return /* @__PURE__ */ u3("ul", { className: "dataview dataview-ul dataview-result-list-ul", children: value.map((subvalue) => /* @__PURE__ */ u3("li", { className: "dataview-result-list-li", children: /* @__PURE__ */ u3(Lit, { value: subvalue, sourcePath, inline: inline2, depth: depth + 1 }) })) });
    } else {
      if (value.length == 0) return /* @__PURE__ */ u3(b, { children: "<Empty List>" });
      return /* @__PURE__ */ u3("span", { className: "dataview dataview-result-list-span", children: value.map((subvalue, index2) => /* @__PURE__ */ u3(b, { children: [
        index2 == 0 ? "" : ", ",
        /* @__PURE__ */ u3(Lit, { value: subvalue, sourcePath, inline: inline2, depth: depth + 1 })
      ] })) });
    }
  } else if (Literals.isObject(value)) {
    if (((_a = value == null ? void 0 : value.constructor) == null ? void 0 : _a.name) && ((_b = value == null ? void 0 : value.constructor) == null ? void 0 : _b.name) != "Object") {
      return /* @__PURE__ */ u3(b, { children: [
        "<",
        value.constructor.name,
        ">"
      ] });
    }
    if (!inline2) {
      return /* @__PURE__ */ u3("ul", { className: "dataview dataview-ul dataview-result-object-ul", children: Object.entries(value).map(([key, value2]) => /* @__PURE__ */ u3("li", { className: "dataview dataview-li dataview-result-object-li", children: [
        key,
        ": ",
        /* @__PURE__ */ u3(Lit, { value: value2, sourcePath, inline: inline2, depth: depth + 1 })
      ] })) });
    } else {
      if (Object.keys(value).length == 0) return /* @__PURE__ */ u3(b, { children: "<Empty Object>" });
      return /* @__PURE__ */ u3("span", { className: "dataview dataview-result-object-span", children: Object.entries(value).map(([key, value2], index2) => /* @__PURE__ */ u3(b, { children: [
        index2 == 0 ? "" : ", ",
        key,
        ": ",
        /* @__PURE__ */ u3(Lit, { value: value2, sourcePath, inline: inline2, depth: depth + 1 })
      ] })) });
    }
  }
  return /* @__PURE__ */ u3(b, { children: [
    "<Unrecognized: ",
    JSON.stringify(value),
    ">"
  ] });
}
var Lit = C3(RawLit);
function ErrorMessage({
  title,
  message,
  error,
  reset
}) {
  return /* @__PURE__ */ u3("div", { className: "datacore-error-box", children: [
    title && /* @__PURE__ */ u3("h4", { className: "datacore-error-title", children: title }),
    message && /* @__PURE__ */ u3("p", { className: "datacore-error-message", children: message }),
    error && /* @__PURE__ */ u3("pre", { className: "datacore-error-pre", children: error }),
    reset && /* @__PURE__ */ u3("button", { className: "datacore-error-retry", onClick: reset, children: "Rerun" })
  ] });
}
function SimpleErrorBoundary({
  title,
  message,
  children
}) {
  const [error, reset] = b2();
  if (error) {
    return /* @__PURE__ */ u3(ErrorMessage, { title, message, error: error.stack, reset });
  } else {
    return /* @__PURE__ */ u3(b, { children });
  }
}

// src/ui/javascript.tsx
var import_obsidian3 = require("obsidian");

// node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js
var ContextualKeyword;
(function(ContextualKeyword2) {
  const NONE = 0;
  ContextualKeyword2[ContextualKeyword2["NONE"] = NONE] = "NONE";
  const _abstract = NONE + 1;
  ContextualKeyword2[ContextualKeyword2["_abstract"] = _abstract] = "_abstract";
  const _accessor = _abstract + 1;
  ContextualKeyword2[ContextualKeyword2["_accessor"] = _accessor] = "_accessor";
  const _as = _accessor + 1;
  ContextualKeyword2[ContextualKeyword2["_as"] = _as] = "_as";
  const _assert = _as + 1;
  ContextualKeyword2[ContextualKeyword2["_assert"] = _assert] = "_assert";
  const _asserts = _assert + 1;
  ContextualKeyword2[ContextualKeyword2["_asserts"] = _asserts] = "_asserts";
  const _async = _asserts + 1;
  ContextualKeyword2[ContextualKeyword2["_async"] = _async] = "_async";
  const _await = _async + 1;
  ContextualKeyword2[ContextualKeyword2["_await"] = _await] = "_await";
  const _checks = _await + 1;
  ContextualKeyword2[ContextualKeyword2["_checks"] = _checks] = "_checks";
  const _constructor = _checks + 1;
  ContextualKeyword2[ContextualKeyword2["_constructor"] = _constructor] = "_constructor";
  const _declare = _constructor + 1;
  ContextualKeyword2[ContextualKeyword2["_declare"] = _declare] = "_declare";
  const _enum = _declare + 1;
  ContextualKeyword2[ContextualKeyword2["_enum"] = _enum] = "_enum";
  const _exports = _enum + 1;
  ContextualKeyword2[ContextualKeyword2["_exports"] = _exports] = "_exports";
  const _from = _exports + 1;
  ContextualKeyword2[ContextualKeyword2["_from"] = _from] = "_from";
  const _get = _from + 1;
  ContextualKeyword2[ContextualKeyword2["_get"] = _get] = "_get";
  const _global = _get + 1;
  ContextualKeyword2[ContextualKeyword2["_global"] = _global] = "_global";
  const _implements = _global + 1;
  ContextualKeyword2[ContextualKeyword2["_implements"] = _implements] = "_implements";
  const _infer = _implements + 1;
  ContextualKeyword2[ContextualKeyword2["_infer"] = _infer] = "_infer";
  const _interface = _infer + 1;
  ContextualKeyword2[ContextualKeyword2["_interface"] = _interface] = "_interface";
  const _is = _interface + 1;
  ContextualKeyword2[ContextualKeyword2["_is"] = _is] = "_is";
  const _keyof = _is + 1;
  ContextualKeyword2[ContextualKeyword2["_keyof"] = _keyof] = "_keyof";
  const _mixins = _keyof + 1;
  ContextualKeyword2[ContextualKeyword2["_mixins"] = _mixins] = "_mixins";
  const _module = _mixins + 1;
  ContextualKeyword2[ContextualKeyword2["_module"] = _module] = "_module";
  const _namespace = _module + 1;
  ContextualKeyword2[ContextualKeyword2["_namespace"] = _namespace] = "_namespace";
  const _of = _namespace + 1;
  ContextualKeyword2[ContextualKeyword2["_of"] = _of] = "_of";
  const _opaque = _of + 1;
  ContextualKeyword2[ContextualKeyword2["_opaque"] = _opaque] = "_opaque";
  const _out = _opaque + 1;
  ContextualKeyword2[ContextualKeyword2["_out"] = _out] = "_out";
  const _override = _out + 1;
  ContextualKeyword2[ContextualKeyword2["_override"] = _override] = "_override";
  const _private = _override + 1;
  ContextualKeyword2[ContextualKeyword2["_private"] = _private] = "_private";
  const _protected = _private + 1;
  ContextualKeyword2[ContextualKeyword2["_protected"] = _protected] = "_protected";
  const _proto = _protected + 1;
  ContextualKeyword2[ContextualKeyword2["_proto"] = _proto] = "_proto";
  const _public = _proto + 1;
  ContextualKeyword2[ContextualKeyword2["_public"] = _public] = "_public";
  const _readonly = _public + 1;
  ContextualKeyword2[ContextualKeyword2["_readonly"] = _readonly] = "_readonly";
  const _require = _readonly + 1;
  ContextualKeyword2[ContextualKeyword2["_require"] = _require] = "_require";
  const _satisfies = _require + 1;
  ContextualKeyword2[ContextualKeyword2["_satisfies"] = _satisfies] = "_satisfies";
  const _set = _satisfies + 1;
  ContextualKeyword2[ContextualKeyword2["_set"] = _set] = "_set";
  const _static = _set + 1;
  ContextualKeyword2[ContextualKeyword2["_static"] = _static] = "_static";
  const _symbol = _static + 1;
  ContextualKeyword2[ContextualKeyword2["_symbol"] = _symbol] = "_symbol";
  const _type = _symbol + 1;
  ContextualKeyword2[ContextualKeyword2["_type"] = _type] = "_type";
  const _unique = _type + 1;
  ContextualKeyword2[ContextualKeyword2["_unique"] = _unique] = "_unique";
  const _using = _unique + 1;
  ContextualKeyword2[ContextualKeyword2["_using"] = _using] = "_using";
})(ContextualKeyword || (ContextualKeyword = {}));

// node_modules/sucrase/dist/esm/parser/tokenizer/types.js
var TokenType;
(function(TokenType2) {
  const PRECEDENCE_MASK = 15;
  TokenType2[TokenType2["PRECEDENCE_MASK"] = PRECEDENCE_MASK] = "PRECEDENCE_MASK";
  const IS_KEYWORD = 1 << 4;
  TokenType2[TokenType2["IS_KEYWORD"] = IS_KEYWORD] = "IS_KEYWORD";
  const IS_ASSIGN = 1 << 5;
  TokenType2[TokenType2["IS_ASSIGN"] = IS_ASSIGN] = "IS_ASSIGN";
  const IS_RIGHT_ASSOCIATIVE = 1 << 6;
  TokenType2[TokenType2["IS_RIGHT_ASSOCIATIVE"] = IS_RIGHT_ASSOCIATIVE] = "IS_RIGHT_ASSOCIATIVE";
  const IS_PREFIX = 1 << 7;
  TokenType2[TokenType2["IS_PREFIX"] = IS_PREFIX] = "IS_PREFIX";
  const IS_POSTFIX = 1 << 8;
  TokenType2[TokenType2["IS_POSTFIX"] = IS_POSTFIX] = "IS_POSTFIX";
  const IS_EXPRESSION_START = 1 << 9;
  TokenType2[TokenType2["IS_EXPRESSION_START"] = IS_EXPRESSION_START] = "IS_EXPRESSION_START";
  const num = 512;
  TokenType2[TokenType2["num"] = num] = "num";
  const bigint = 1536;
  TokenType2[TokenType2["bigint"] = bigint] = "bigint";
  const decimal = 2560;
  TokenType2[TokenType2["decimal"] = decimal] = "decimal";
  const regexp3 = 3584;
  TokenType2[TokenType2["regexp"] = regexp3] = "regexp";
  const string2 = 4608;
  TokenType2[TokenType2["string"] = string2] = "string";
  const name = 5632;
  TokenType2[TokenType2["name"] = name] = "name";
  const eof = 6144;
  TokenType2[TokenType2["eof"] = eof] = "eof";
  const bracketL2 = 7680;
  TokenType2[TokenType2["bracketL"] = bracketL2] = "bracketL";
  const bracketR = 8192;
  TokenType2[TokenType2["bracketR"] = bracketR] = "bracketR";
  const braceL = 9728;
  TokenType2[TokenType2["braceL"] = braceL] = "braceL";
  const braceBarL = 10752;
  TokenType2[TokenType2["braceBarL"] = braceBarL] = "braceBarL";
  const braceR2 = 11264;
  TokenType2[TokenType2["braceR"] = braceR2] = "braceR";
  const braceBarR = 12288;
  TokenType2[TokenType2["braceBarR"] = braceBarR] = "braceBarR";
  const parenL = 13824;
  TokenType2[TokenType2["parenL"] = parenL] = "parenL";
  const parenR = 14336;
  TokenType2[TokenType2["parenR"] = parenR] = "parenR";
  const comma2 = 15360;
  TokenType2[TokenType2["comma"] = comma2] = "comma";
  const semi = 16384;
  TokenType2[TokenType2["semi"] = semi] = "semi";
  const colon = 17408;
  TokenType2[TokenType2["colon"] = colon] = "colon";
  const doubleColon = 18432;
  TokenType2[TokenType2["doubleColon"] = doubleColon] = "doubleColon";
  const dot2 = 19456;
  TokenType2[TokenType2["dot"] = dot2] = "dot";
  const question2 = 20480;
  TokenType2[TokenType2["question"] = question2] = "question";
  const questionDot2 = 21504;
  TokenType2[TokenType2["questionDot"] = questionDot2] = "questionDot";
  const arrow2 = 22528;
  TokenType2[TokenType2["arrow"] = arrow2] = "arrow";
  const template = 23552;
  TokenType2[TokenType2["template"] = template] = "template";
  const ellipsis = 24576;
  TokenType2[TokenType2["ellipsis"] = ellipsis] = "ellipsis";
  const backQuote = 25600;
  TokenType2[TokenType2["backQuote"] = backQuote] = "backQuote";
  const dollarBraceL = 27136;
  TokenType2[TokenType2["dollarBraceL"] = dollarBraceL] = "dollarBraceL";
  const at = 27648;
  TokenType2[TokenType2["at"] = at] = "at";
  const hash2 = 29184;
  TokenType2[TokenType2["hash"] = hash2] = "hash";
  const eq = 29728;
  TokenType2[TokenType2["eq"] = eq] = "eq";
  const assign2 = 30752;
  TokenType2[TokenType2["assign"] = assign2] = "assign";
  const preIncDec = 32640;
  TokenType2[TokenType2["preIncDec"] = preIncDec] = "preIncDec";
  const postIncDec = 33664;
  TokenType2[TokenType2["postIncDec"] = postIncDec] = "postIncDec";
  const bang = 34432;
  TokenType2[TokenType2["bang"] = bang] = "bang";
  const tilde = 35456;
  TokenType2[TokenType2["tilde"] = tilde] = "tilde";
  const pipeline = 35841;
  TokenType2[TokenType2["pipeline"] = pipeline] = "pipeline";
  const nullishCoalescing = 36866;
  TokenType2[TokenType2["nullishCoalescing"] = nullishCoalescing] = "nullishCoalescing";
  const logicalOR = 37890;
  TokenType2[TokenType2["logicalOR"] = logicalOR] = "logicalOR";
  const logicalAND = 38915;
  TokenType2[TokenType2["logicalAND"] = logicalAND] = "logicalAND";
  const bitwiseOR = 39940;
  TokenType2[TokenType2["bitwiseOR"] = bitwiseOR] = "bitwiseOR";
  const bitwiseXOR = 40965;
  TokenType2[TokenType2["bitwiseXOR"] = bitwiseXOR] = "bitwiseXOR";
  const bitwiseAND = 41990;
  TokenType2[TokenType2["bitwiseAND"] = bitwiseAND] = "bitwiseAND";
  const equality = 43015;
  TokenType2[TokenType2["equality"] = equality] = "equality";
  const lessThan = 44040;
  TokenType2[TokenType2["lessThan"] = lessThan] = "lessThan";
  const greaterThan = 45064;
  TokenType2[TokenType2["greaterThan"] = greaterThan] = "greaterThan";
  const relationalOrEqual = 46088;
  TokenType2[TokenType2["relationalOrEqual"] = relationalOrEqual] = "relationalOrEqual";
  const bitShiftL = 47113;
  TokenType2[TokenType2["bitShiftL"] = bitShiftL] = "bitShiftL";
  const bitShiftR = 48137;
  TokenType2[TokenType2["bitShiftR"] = bitShiftR] = "bitShiftR";
  const plus2 = 49802;
  TokenType2[TokenType2["plus"] = plus2] = "plus";
  const minus2 = 50826;
  TokenType2[TokenType2["minus"] = minus2] = "minus";
  const modulo = 51723;
  TokenType2[TokenType2["modulo"] = modulo] = "modulo";
  const star2 = 52235;
  TokenType2[TokenType2["star"] = star2] = "star";
  const slash2 = 53259;
  TokenType2[TokenType2["slash"] = slash2] = "slash";
  const exponent = 54348;
  TokenType2[TokenType2["exponent"] = exponent] = "exponent";
  const jsxName = 55296;
  TokenType2[TokenType2["jsxName"] = jsxName] = "jsxName";
  const jsxText = 56320;
  TokenType2[TokenType2["jsxText"] = jsxText] = "jsxText";
  const jsxEmptyText = 57344;
  TokenType2[TokenType2["jsxEmptyText"] = jsxEmptyText] = "jsxEmptyText";
  const jsxTagStart = 58880;
  TokenType2[TokenType2["jsxTagStart"] = jsxTagStart] = "jsxTagStart";
  const jsxTagEnd = 59392;
  TokenType2[TokenType2["jsxTagEnd"] = jsxTagEnd] = "jsxTagEnd";
  const typeParameterStart = 60928;
  TokenType2[TokenType2["typeParameterStart"] = typeParameterStart] = "typeParameterStart";
  const nonNullAssertion = 61440;
  TokenType2[TokenType2["nonNullAssertion"] = nonNullAssertion] = "nonNullAssertion";
  const _break = 62480;
  TokenType2[TokenType2["_break"] = _break] = "_break";
  const _case = 63504;
  TokenType2[TokenType2["_case"] = _case] = "_case";
  const _catch = 64528;
  TokenType2[TokenType2["_catch"] = _catch] = "_catch";
  const _continue = 65552;
  TokenType2[TokenType2["_continue"] = _continue] = "_continue";
  const _debugger = 66576;
  TokenType2[TokenType2["_debugger"] = _debugger] = "_debugger";
  const _default2 = 67600;
  TokenType2[TokenType2["_default"] = _default2] = "_default";
  const _do = 68624;
  TokenType2[TokenType2["_do"] = _do] = "_do";
  const _else = 69648;
  TokenType2[TokenType2["_else"] = _else] = "_else";
  const _finally = 70672;
  TokenType2[TokenType2["_finally"] = _finally] = "_finally";
  const _for = 71696;
  TokenType2[TokenType2["_for"] = _for] = "_for";
  const _function = 73232;
  TokenType2[TokenType2["_function"] = _function] = "_function";
  const _if = 73744;
  TokenType2[TokenType2["_if"] = _if] = "_if";
  const _return = 74768;
  TokenType2[TokenType2["_return"] = _return] = "_return";
  const _switch = 75792;
  TokenType2[TokenType2["_switch"] = _switch] = "_switch";
  const _throw = 77456;
  TokenType2[TokenType2["_throw"] = _throw] = "_throw";
  const _try = 77840;
  TokenType2[TokenType2["_try"] = _try] = "_try";
  const _var = 78864;
  TokenType2[TokenType2["_var"] = _var] = "_var";
  const _let = 79888;
  TokenType2[TokenType2["_let"] = _let] = "_let";
  const _const = 80912;
  TokenType2[TokenType2["_const"] = _const] = "_const";
  const _while = 81936;
  TokenType2[TokenType2["_while"] = _while] = "_while";
  const _with = 82960;
  TokenType2[TokenType2["_with"] = _with] = "_with";
  const _new = 84496;
  TokenType2[TokenType2["_new"] = _new] = "_new";
  const _this = 85520;
  TokenType2[TokenType2["_this"] = _this] = "_this";
  const _super = 86544;
  TokenType2[TokenType2["_super"] = _super] = "_super";
  const _class = 87568;
  TokenType2[TokenType2["_class"] = _class] = "_class";
  const _extends2 = 88080;
  TokenType2[TokenType2["_extends"] = _extends2] = "_extends";
  const _export = 89104;
  TokenType2[TokenType2["_export"] = _export] = "_export";
  const _import = 90640;
  TokenType2[TokenType2["_import"] = _import] = "_import";
  const _yield = 91664;
  TokenType2[TokenType2["_yield"] = _yield] = "_yield";
  const _null = 92688;
  TokenType2[TokenType2["_null"] = _null] = "_null";
  const _true = 93712;
  TokenType2[TokenType2["_true"] = _true] = "_true";
  const _false = 94736;
  TokenType2[TokenType2["_false"] = _false] = "_false";
  const _in = 95256;
  TokenType2[TokenType2["_in"] = _in] = "_in";
  const _instanceof = 96280;
  TokenType2[TokenType2["_instanceof"] = _instanceof] = "_instanceof";
  const _typeof3 = 97936;
  TokenType2[TokenType2["_typeof"] = _typeof3] = "_typeof";
  const _void = 98960;
  TokenType2[TokenType2["_void"] = _void] = "_void";
  const _delete = 99984;
  TokenType2[TokenType2["_delete"] = _delete] = "_delete";
  const _async = 100880;
  TokenType2[TokenType2["_async"] = _async] = "_async";
  const _get = 101904;
  TokenType2[TokenType2["_get"] = _get] = "_get";
  const _set = 102928;
  TokenType2[TokenType2["_set"] = _set] = "_set";
  const _declare = 103952;
  TokenType2[TokenType2["_declare"] = _declare] = "_declare";
  const _readonly = 104976;
  TokenType2[TokenType2["_readonly"] = _readonly] = "_readonly";
  const _abstract = 106e3;
  TokenType2[TokenType2["_abstract"] = _abstract] = "_abstract";
  const _static = 107024;
  TokenType2[TokenType2["_static"] = _static] = "_static";
  const _public = 107536;
  TokenType2[TokenType2["_public"] = _public] = "_public";
  const _private = 108560;
  TokenType2[TokenType2["_private"] = _private] = "_private";
  const _protected = 109584;
  TokenType2[TokenType2["_protected"] = _protected] = "_protected";
  const _override = 110608;
  TokenType2[TokenType2["_override"] = _override] = "_override";
  const _as = 112144;
  TokenType2[TokenType2["_as"] = _as] = "_as";
  const _enum = 113168;
  TokenType2[TokenType2["_enum"] = _enum] = "_enum";
  const _type = 114192;
  TokenType2[TokenType2["_type"] = _type] = "_type";
  const _implements = 115216;
  TokenType2[TokenType2["_implements"] = _implements] = "_implements";
})(TokenType || (TokenType = {}));
function formatTokenType(tokenType) {
  switch (tokenType) {
    case TokenType.num:
      return "num";
    case TokenType.bigint:
      return "bigint";
    case TokenType.decimal:
      return "decimal";
    case TokenType.regexp:
      return "regexp";
    case TokenType.string:
      return "string";
    case TokenType.name:
      return "name";
    case TokenType.eof:
      return "eof";
    case TokenType.bracketL:
      return "[";
    case TokenType.bracketR:
      return "]";
    case TokenType.braceL:
      return "{";
    case TokenType.braceBarL:
      return "{|";
    case TokenType.braceR:
      return "}";
    case TokenType.braceBarR:
      return "|}";
    case TokenType.parenL:
      return "(";
    case TokenType.parenR:
      return ")";
    case TokenType.comma:
      return ",";
    case TokenType.semi:
      return ";";
    case TokenType.colon:
      return ":";
    case TokenType.doubleColon:
      return "::";
    case TokenType.dot:
      return ".";
    case TokenType.question:
      return "?";
    case TokenType.questionDot:
      return "?.";
    case TokenType.arrow:
      return "=>";
    case TokenType.template:
      return "template";
    case TokenType.ellipsis:
      return "...";
    case TokenType.backQuote:
      return "`";
    case TokenType.dollarBraceL:
      return "${";
    case TokenType.at:
      return "@";
    case TokenType.hash:
      return "#";
    case TokenType.eq:
      return "=";
    case TokenType.assign:
      return "_=";
    case TokenType.preIncDec:
      return "++/--";
    case TokenType.postIncDec:
      return "++/--";
    case TokenType.bang:
      return "!";
    case TokenType.tilde:
      return "~";
    case TokenType.pipeline:
      return "|>";
    case TokenType.nullishCoalescing:
      return "??";
    case TokenType.logicalOR:
      return "||";
    case TokenType.logicalAND:
      return "&&";
    case TokenType.bitwiseOR:
      return "|";
    case TokenType.bitwiseXOR:
      return "^";
    case TokenType.bitwiseAND:
      return "&";
    case TokenType.equality:
      return "==/!=";
    case TokenType.lessThan:
      return "<";
    case TokenType.greaterThan:
      return ">";
    case TokenType.relationalOrEqual:
      return "<=/>=";
    case TokenType.bitShiftL:
      return "<<";
    case TokenType.bitShiftR:
      return ">>/>>>";
    case TokenType.plus:
      return "+";
    case TokenType.minus:
      return "-";
    case TokenType.modulo:
      return "%";
    case TokenType.star:
      return "*";
    case TokenType.slash:
      return "/";
    case TokenType.exponent:
      return "**";
    case TokenType.jsxName:
      return "jsxName";
    case TokenType.jsxText:
      return "jsxText";
    case TokenType.jsxEmptyText:
      return "jsxEmptyText";
    case TokenType.jsxTagStart:
      return "jsxTagStart";
    case TokenType.jsxTagEnd:
      return "jsxTagEnd";
    case TokenType.typeParameterStart:
      return "typeParameterStart";
    case TokenType.nonNullAssertion:
      return "nonNullAssertion";
    case TokenType._break:
      return "break";
    case TokenType._case:
      return "case";
    case TokenType._catch:
      return "catch";
    case TokenType._continue:
      return "continue";
    case TokenType._debugger:
      return "debugger";
    case TokenType._default:
      return "default";
    case TokenType._do:
      return "do";
    case TokenType._else:
      return "else";
    case TokenType._finally:
      return "finally";
    case TokenType._for:
      return "for";
    case TokenType._function:
      return "function";
    case TokenType._if:
      return "if";
    case TokenType._return:
      return "return";
    case TokenType._switch:
      return "switch";
    case TokenType._throw:
      return "throw";
    case TokenType._try:
      return "try";
    case TokenType._var:
      return "var";
    case TokenType._let:
      return "let";
    case TokenType._const:
      return "const";
    case TokenType._while:
      return "while";
    case TokenType._with:
      return "with";
    case TokenType._new:
      return "new";
    case TokenType._this:
      return "this";
    case TokenType._super:
      return "super";
    case TokenType._class:
      return "class";
    case TokenType._extends:
      return "extends";
    case TokenType._export:
      return "export";
    case TokenType._import:
      return "import";
    case TokenType._yield:
      return "yield";
    case TokenType._null:
      return "null";
    case TokenType._true:
      return "true";
    case TokenType._false:
      return "false";
    case TokenType._in:
      return "in";
    case TokenType._instanceof:
      return "instanceof";
    case TokenType._typeof:
      return "typeof";
    case TokenType._void:
      return "void";
    case TokenType._delete:
      return "delete";
    case TokenType._async:
      return "async";
    case TokenType._get:
      return "get";
    case TokenType._set:
      return "set";
    case TokenType._declare:
      return "declare";
    case TokenType._readonly:
      return "readonly";
    case TokenType._abstract:
      return "abstract";
    case TokenType._static:
      return "static";
    case TokenType._public:
      return "public";
    case TokenType._private:
      return "private";
    case TokenType._protected:
      return "protected";
    case TokenType._override:
      return "override";
    case TokenType._as:
      return "as";
    case TokenType._enum:
      return "enum";
    case TokenType._type:
      return "type";
    case TokenType._implements:
      return "implements";
    default:
      return "";
  }
}

// node_modules/sucrase/dist/esm/parser/tokenizer/state.js
var Scope = class {
  constructor(startTokenIndex, endTokenIndex, isFunctionScope) {
    this.startTokenIndex = startTokenIndex;
    this.endTokenIndex = endTokenIndex;
    this.isFunctionScope = isFunctionScope;
  }
};
var StateSnapshot = class {
  constructor(potentialArrowAt, noAnonFunctionType, inDisallowConditionalTypesContext, tokensLength, scopesLength, pos, type, contextualKeyword, start, end2, isType, scopeDepth, error) {
    ;
    this.potentialArrowAt = potentialArrowAt;
    this.noAnonFunctionType = noAnonFunctionType;
    this.inDisallowConditionalTypesContext = inDisallowConditionalTypesContext;
    this.tokensLength = tokensLength;
    this.scopesLength = scopesLength;
    this.pos = pos;
    this.type = type;
    this.contextualKeyword = contextualKeyword;
    this.start = start;
    this.end = end2;
    this.isType = isType;
    this.scopeDepth = scopeDepth;
    this.error = error;
  }
};
var State = class _State {
  constructor() {
    _State.prototype.__init.call(this);
    _State.prototype.__init2.call(this);
    _State.prototype.__init3.call(this);
    _State.prototype.__init4.call(this);
    _State.prototype.__init5.call(this);
    _State.prototype.__init6.call(this);
    _State.prototype.__init7.call(this);
    _State.prototype.__init8.call(this);
    _State.prototype.__init9.call(this);
    _State.prototype.__init10.call(this);
    _State.prototype.__init11.call(this);
    _State.prototype.__init12.call(this);
    _State.prototype.__init13.call(this);
  }
  // Used to signify the start of a potential arrow function
  __init() {
    this.potentialArrowAt = -1;
  }
  // Used by Flow to handle an edge case involving function type parsing.
  __init2() {
    this.noAnonFunctionType = false;
  }
  // Used by TypeScript to handle ambiguities when parsing conditional types.
  __init3() {
    this.inDisallowConditionalTypesContext = false;
  }
  // Token store.
  __init4() {
    this.tokens = [];
  }
  // Array of all observed scopes, ordered by their ending position.
  __init5() {
    this.scopes = [];
  }
  // The current position of the tokenizer in the input.
  __init6() {
    this.pos = 0;
  }
  // Information about the current token.
  __init7() {
    this.type = TokenType.eof;
  }
  __init8() {
    this.contextualKeyword = ContextualKeyword.NONE;
  }
  __init9() {
    this.start = 0;
  }
  __init10() {
    this.end = 0;
  }
  __init11() {
    this.isType = false;
  }
  __init12() {
    this.scopeDepth = 0;
  }
  /**
   * If the parser is in an error state, then the token is always tt.eof and all functions can
   * keep executing but should be written so they don't get into an infinite loop in this situation.
   *
   * This approach, combined with the ability to snapshot and restore state, allows us to implement
   * backtracking without exceptions and without needing to explicitly propagate error states
   * everywhere.
   */
  __init13() {
    this.error = null;
  }
  snapshot() {
    return new StateSnapshot(
      this.potentialArrowAt,
      this.noAnonFunctionType,
      this.inDisallowConditionalTypesContext,
      this.tokens.length,
      this.scopes.length,
      this.pos,
      this.type,
      this.contextualKeyword,
      this.start,
      this.end,
      this.isType,
      this.scopeDepth,
      this.error
    );
  }
  restoreFromSnapshot(snapshot) {
    this.potentialArrowAt = snapshot.potentialArrowAt;
    this.noAnonFunctionType = snapshot.noAnonFunctionType;
    this.inDisallowConditionalTypesContext = snapshot.inDisallowConditionalTypesContext;
    this.tokens.length = snapshot.tokensLength;
    this.scopes.length = snapshot.scopesLength;
    this.pos = snapshot.pos;
    this.type = snapshot.type;
    this.contextualKeyword = snapshot.contextualKeyword;
    this.start = snapshot.start;
    this.end = snapshot.end;
    this.isType = snapshot.isType;
    this.scopeDepth = snapshot.scopeDepth;
    this.error = snapshot.error;
  }
};

// node_modules/sucrase/dist/esm/parser/util/charcodes.js
var charCodes;
(function(charCodes2) {
  const backSpace = 8;
  charCodes2[charCodes2["backSpace"] = backSpace] = "backSpace";
  const lineFeed = 10;
  charCodes2[charCodes2["lineFeed"] = lineFeed] = "lineFeed";
  const tab = 9;
  charCodes2[charCodes2["tab"] = tab] = "tab";
  const carriageReturn = 13;
  charCodes2[charCodes2["carriageReturn"] = carriageReturn] = "carriageReturn";
  const shiftOut = 14;
  charCodes2[charCodes2["shiftOut"] = shiftOut] = "shiftOut";
  const space2 = 32;
  charCodes2[charCodes2["space"] = space2] = "space";
  const exclamationMark = 33;
  charCodes2[charCodes2["exclamationMark"] = exclamationMark] = "exclamationMark";
  const quotationMark = 34;
  charCodes2[charCodes2["quotationMark"] = quotationMark] = "quotationMark";
  const numberSign = 35;
  charCodes2[charCodes2["numberSign"] = numberSign] = "numberSign";
  const dollarSign = 36;
  charCodes2[charCodes2["dollarSign"] = dollarSign] = "dollarSign";
  const percentSign = 37;
  charCodes2[charCodes2["percentSign"] = percentSign] = "percentSign";
  const ampersand = 38;
  charCodes2[charCodes2["ampersand"] = ampersand] = "ampersand";
  const apostrophe = 39;
  charCodes2[charCodes2["apostrophe"] = apostrophe] = "apostrophe";
  const leftParenthesis = 40;
  charCodes2[charCodes2["leftParenthesis"] = leftParenthesis] = "leftParenthesis";
  const rightParenthesis = 41;
  charCodes2[charCodes2["rightParenthesis"] = rightParenthesis] = "rightParenthesis";
  const asterisk = 42;
  charCodes2[charCodes2["asterisk"] = asterisk] = "asterisk";
  const plusSign = 43;
  charCodes2[charCodes2["plusSign"] = plusSign] = "plusSign";
  const comma2 = 44;
  charCodes2[charCodes2["comma"] = comma2] = "comma";
  const dash = 45;
  charCodes2[charCodes2["dash"] = dash] = "dash";
  const dot2 = 46;
  charCodes2[charCodes2["dot"] = dot2] = "dot";
  const slash2 = 47;
  charCodes2[charCodes2["slash"] = slash2] = "slash";
  const digit0 = 48;
  charCodes2[charCodes2["digit0"] = digit0] = "digit0";
  const digit1 = 49;
  charCodes2[charCodes2["digit1"] = digit1] = "digit1";
  const digit2 = 50;
  charCodes2[charCodes2["digit2"] = digit2] = "digit2";
  const digit3 = 51;
  charCodes2[charCodes2["digit3"] = digit3] = "digit3";
  const digit4 = 52;
  charCodes2[charCodes2["digit4"] = digit4] = "digit4";
  const digit5 = 53;
  charCodes2[charCodes2["digit5"] = digit5] = "digit5";
  const digit6 = 54;
  charCodes2[charCodes2["digit6"] = digit6] = "digit6";
  const digit7 = 55;
  charCodes2[charCodes2["digit7"] = digit7] = "digit7";
  const digit8 = 56;
  charCodes2[charCodes2["digit8"] = digit8] = "digit8";
  const digit9 = 57;
  charCodes2[charCodes2["digit9"] = digit9] = "digit9";
  const colon = 58;
  charCodes2[charCodes2["colon"] = colon] = "colon";
  const semicolon3 = 59;
  charCodes2[charCodes2["semicolon"] = semicolon3] = "semicolon";
  const lessThan = 60;
  charCodes2[charCodes2["lessThan"] = lessThan] = "lessThan";
  const equalsTo = 61;
  charCodes2[charCodes2["equalsTo"] = equalsTo] = "equalsTo";
  const greaterThan = 62;
  charCodes2[charCodes2["greaterThan"] = greaterThan] = "greaterThan";
  const questionMark = 63;
  charCodes2[charCodes2["questionMark"] = questionMark] = "questionMark";
  const atSign = 64;
  charCodes2[charCodes2["atSign"] = atSign] = "atSign";
  const uppercaseA = 65;
  charCodes2[charCodes2["uppercaseA"] = uppercaseA] = "uppercaseA";
  const uppercaseB = 66;
  charCodes2[charCodes2["uppercaseB"] = uppercaseB] = "uppercaseB";
  const uppercaseC = 67;
  charCodes2[charCodes2["uppercaseC"] = uppercaseC] = "uppercaseC";
  const uppercaseD = 68;
  charCodes2[charCodes2["uppercaseD"] = uppercaseD] = "uppercaseD";
  const uppercaseE = 69;
  charCodes2[charCodes2["uppercaseE"] = uppercaseE] = "uppercaseE";
  const uppercaseF = 70;
  charCodes2[charCodes2["uppercaseF"] = uppercaseF] = "uppercaseF";
  const uppercaseG = 71;
  charCodes2[charCodes2["uppercaseG"] = uppercaseG] = "uppercaseG";
  const uppercaseH = 72;
  charCodes2[charCodes2["uppercaseH"] = uppercaseH] = "uppercaseH";
  const uppercaseI = 73;
  charCodes2[charCodes2["uppercaseI"] = uppercaseI] = "uppercaseI";
  const uppercaseJ = 74;
  charCodes2[charCodes2["uppercaseJ"] = uppercaseJ] = "uppercaseJ";
  const uppercaseK = 75;
  charCodes2[charCodes2["uppercaseK"] = uppercaseK] = "uppercaseK";
  const uppercaseL = 76;
  charCodes2[charCodes2["uppercaseL"] = uppercaseL] = "uppercaseL";
  const uppercaseM = 77;
  charCodes2[charCodes2["uppercaseM"] = uppercaseM] = "uppercaseM";
  const uppercaseN = 78;
  charCodes2[charCodes2["uppercaseN"] = uppercaseN] = "uppercaseN";
  const uppercaseO = 79;
  charCodes2[charCodes2["uppercaseO"] = uppercaseO] = "uppercaseO";
  const uppercaseP = 80;
  charCodes2[charCodes2["uppercaseP"] = uppercaseP] = "uppercaseP";
  const uppercaseQ = 81;
  charCodes2[charCodes2["uppercaseQ"] = uppercaseQ] = "uppercaseQ";
  const uppercaseR = 82;
  charCodes2[charCodes2["uppercaseR"] = uppercaseR] = "uppercaseR";
  const uppercaseS = 83;
  charCodes2[charCodes2["uppercaseS"] = uppercaseS] = "uppercaseS";
  const uppercaseT = 84;
  charCodes2[charCodes2["uppercaseT"] = uppercaseT] = "uppercaseT";
  const uppercaseU = 85;
  charCodes2[charCodes2["uppercaseU"] = uppercaseU] = "uppercaseU";
  const uppercaseV = 86;
  charCodes2[charCodes2["uppercaseV"] = uppercaseV] = "uppercaseV";
  const uppercaseW = 87;
  charCodes2[charCodes2["uppercaseW"] = uppercaseW] = "uppercaseW";
  const uppercaseX = 88;
  charCodes2[charCodes2["uppercaseX"] = uppercaseX] = "uppercaseX";
  const uppercaseY = 89;
  charCodes2[charCodes2["uppercaseY"] = uppercaseY] = "uppercaseY";
  const uppercaseZ = 90;
  charCodes2[charCodes2["uppercaseZ"] = uppercaseZ] = "uppercaseZ";
  const leftSquareBracket = 91;
  charCodes2[charCodes2["leftSquareBracket"] = leftSquareBracket] = "leftSquareBracket";
  const backslash = 92;
  charCodes2[charCodes2["backslash"] = backslash] = "backslash";
  const rightSquareBracket = 93;
  charCodes2[charCodes2["rightSquareBracket"] = rightSquareBracket] = "rightSquareBracket";
  const caret2 = 94;
  charCodes2[charCodes2["caret"] = caret2] = "caret";
  const underscore = 95;
  charCodes2[charCodes2["underscore"] = underscore] = "underscore";
  const graveAccent = 96;
  charCodes2[charCodes2["graveAccent"] = graveAccent] = "graveAccent";
  const lowercaseA = 97;
  charCodes2[charCodes2["lowercaseA"] = lowercaseA] = "lowercaseA";
  const lowercaseB = 98;
  charCodes2[charCodes2["lowercaseB"] = lowercaseB] = "lowercaseB";
  const lowercaseC = 99;
  charCodes2[charCodes2["lowercaseC"] = lowercaseC] = "lowercaseC";
  const lowercaseD = 100;
  charCodes2[charCodes2["lowercaseD"] = lowercaseD] = "lowercaseD";
  const lowercaseE = 101;
  charCodes2[charCodes2["lowercaseE"] = lowercaseE] = "lowercaseE";
  const lowercaseF = 102;
  charCodes2[charCodes2["lowercaseF"] = lowercaseF] = "lowercaseF";
  const lowercaseG = 103;
  charCodes2[charCodes2["lowercaseG"] = lowercaseG] = "lowercaseG";
  const lowercaseH = 104;
  charCodes2[charCodes2["lowercaseH"] = lowercaseH] = "lowercaseH";
  const lowercaseI = 105;
  charCodes2[charCodes2["lowercaseI"] = lowercaseI] = "lowercaseI";
  const lowercaseJ = 106;
  charCodes2[charCodes2["lowercaseJ"] = lowercaseJ] = "lowercaseJ";
  const lowercaseK = 107;
  charCodes2[charCodes2["lowercaseK"] = lowercaseK] = "lowercaseK";
  const lowercaseL = 108;
  charCodes2[charCodes2["lowercaseL"] = lowercaseL] = "lowercaseL";
  const lowercaseM = 109;
  charCodes2[charCodes2["lowercaseM"] = lowercaseM] = "lowercaseM";
  const lowercaseN = 110;
  charCodes2[charCodes2["lowercaseN"] = lowercaseN] = "lowercaseN";
  const lowercaseO = 111;
  charCodes2[charCodes2["lowercaseO"] = lowercaseO] = "lowercaseO";
  const lowercaseP = 112;
  charCodes2[charCodes2["lowercaseP"] = lowercaseP] = "lowercaseP";
  const lowercaseQ = 113;
  charCodes2[charCodes2["lowercaseQ"] = lowercaseQ] = "lowercaseQ";
  const lowercaseR = 114;
  charCodes2[charCodes2["lowercaseR"] = lowercaseR] = "lowercaseR";
  const lowercaseS = 115;
  charCodes2[charCodes2["lowercaseS"] = lowercaseS] = "lowercaseS";
  const lowercaseT = 116;
  charCodes2[charCodes2["lowercaseT"] = lowercaseT] = "lowercaseT";
  const lowercaseU = 117;
  charCodes2[charCodes2["lowercaseU"] = lowercaseU] = "lowercaseU";
  const lowercaseV = 118;
  charCodes2[charCodes2["lowercaseV"] = lowercaseV] = "lowercaseV";
  const lowercaseW = 119;
  charCodes2[charCodes2["lowercaseW"] = lowercaseW] = "lowercaseW";
  const lowercaseX = 120;
  charCodes2[charCodes2["lowercaseX"] = lowercaseX] = "lowercaseX";
  const lowercaseY = 121;
  charCodes2[charCodes2["lowercaseY"] = lowercaseY] = "lowercaseY";
  const lowercaseZ = 122;
  charCodes2[charCodes2["lowercaseZ"] = lowercaseZ] = "lowercaseZ";
  const leftCurlyBrace = 123;
  charCodes2[charCodes2["leftCurlyBrace"] = leftCurlyBrace] = "leftCurlyBrace";
  const verticalBar = 124;
  charCodes2[charCodes2["verticalBar"] = verticalBar] = "verticalBar";
  const rightCurlyBrace = 125;
  charCodes2[charCodes2["rightCurlyBrace"] = rightCurlyBrace] = "rightCurlyBrace";
  const tilde = 126;
  charCodes2[charCodes2["tilde"] = tilde] = "tilde";
  const nonBreakingSpace = 160;
  charCodes2[charCodes2["nonBreakingSpace"] = nonBreakingSpace] = "nonBreakingSpace";
  const oghamSpaceMark = 5760;
  charCodes2[charCodes2["oghamSpaceMark"] = oghamSpaceMark] = "oghamSpaceMark";
  const lineSeparator = 8232;
  charCodes2[charCodes2["lineSeparator"] = lineSeparator] = "lineSeparator";
  const paragraphSeparator = 8233;
  charCodes2[charCodes2["paragraphSeparator"] = paragraphSeparator] = "paragraphSeparator";
})(charCodes || (charCodes = {}));

// node_modules/sucrase/dist/esm/parser/traverser/base.js
var isJSXEnabled;
var isTypeScriptEnabled;
var isFlowEnabled;
var state;
var input;
var nextContextId;
function getNextContextId() {
  return nextContextId++;
}
function augmentError(error) {
  if ("pos" in error) {
    const loc = locationForIndex(error.pos);
    error.message += ` (${loc.line}:${loc.column})`;
    error.loc = loc;
  }
  return error;
}
var Loc = class {
  constructor(line2, column2) {
    this.line = line2;
    this.column = column2;
  }
};
function locationForIndex(pos) {
  let line2 = 1;
  let column2 = 1;
  for (let i4 = 0; i4 < pos; i4++) {
    if (input.charCodeAt(i4) === charCodes.lineFeed) {
      line2++;
      column2 = 1;
    } else {
      column2++;
    }
  }
  return new Loc(line2, column2);
}
function initParser(inputCode, isJSXEnabledArg, isTypeScriptEnabledArg, isFlowEnabledArg) {
  input = inputCode;
  state = new State();
  nextContextId = 1;
  isJSXEnabled = isJSXEnabledArg;
  isTypeScriptEnabled = isTypeScriptEnabledArg;
  isFlowEnabled = isFlowEnabledArg;
}

// node_modules/sucrase/dist/esm/parser/traverser/util.js
function isContextual(contextualKeyword) {
  return state.contextualKeyword === contextualKeyword;
}
function isLookaheadContextual(contextualKeyword) {
  const l4 = lookaheadTypeAndKeyword();
  return l4.type === TokenType.name && l4.contextualKeyword === contextualKeyword;
}
function eatContextual(contextualKeyword) {
  return state.contextualKeyword === contextualKeyword && eat(TokenType.name);
}
function expectContextual(contextualKeyword) {
  if (!eatContextual(contextualKeyword)) {
    unexpected();
  }
}
function canInsertSemicolon() {
  return match2(TokenType.eof) || match2(TokenType.braceR) || hasPrecedingLineBreak();
}
function hasPrecedingLineBreak() {
  const prevToken = state.tokens[state.tokens.length - 1];
  const lastTokEnd = prevToken ? prevToken.end : 0;
  for (let i4 = lastTokEnd; i4 < state.start; i4++) {
    const code = input.charCodeAt(i4);
    if (code === charCodes.lineFeed || code === charCodes.carriageReturn || code === 8232 || code === 8233) {
      return true;
    }
  }
  return false;
}
function hasFollowingLineBreak() {
  const nextStart = nextTokenStart();
  for (let i4 = state.end; i4 < nextStart; i4++) {
    const code = input.charCodeAt(i4);
    if (code === charCodes.lineFeed || code === charCodes.carriageReturn || code === 8232 || code === 8233) {
      return true;
    }
  }
  return false;
}
function isLineTerminator() {
  return eat(TokenType.semi) || canInsertSemicolon();
}
function semicolon() {
  if (!isLineTerminator()) {
    unexpected('Unexpected token, expected ";"');
  }
}
function expect(type) {
  const matched = eat(type);
  if (!matched) {
    unexpected(`Unexpected token, expected "${formatTokenType(type)}"`);
  }
}
function unexpected(message = "Unexpected token", pos = state.start) {
  if (state.error) {
    return;
  }
  const err = new SyntaxError(message);
  err.pos = pos;
  state.error = err;
  state.pos = input.length;
  finishToken(TokenType.eof);
}

// node_modules/sucrase/dist/esm/parser/util/whitespace.js
var WHITESPACE_CHARS = [
  9,
  11,
  12,
  charCodes.space,
  charCodes.nonBreakingSpace,
  charCodes.oghamSpaceMark,
  8192,
  // EN QUAD
  8193,
  // EM QUAD
  8194,
  // EN SPACE
  8195,
  // EM SPACE
  8196,
  // THREE-PER-EM SPACE
  8197,
  // FOUR-PER-EM SPACE
  8198,
  // SIX-PER-EM SPACE
  8199,
  // FIGURE SPACE
  8200,
  // PUNCTUATION SPACE
  8201,
  // THIN SPACE
  8202,
  // HAIR SPACE
  8239,
  // NARROW NO-BREAK SPACE
  8287,
  // MEDIUM MATHEMATICAL SPACE
  12288,
  // IDEOGRAPHIC SPACE
  65279
  // ZERO WIDTH NO-BREAK SPACE
];
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var IS_WHITESPACE = new Uint8Array(65536);
for (const char2 of WHITESPACE_CHARS) {
  IS_WHITESPACE[char2] = 1;
}

// node_modules/sucrase/dist/esm/parser/util/identifier.js
function computeIsIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code < 128) return false;
  throw new Error("Should not be called with non-ASCII char code.");
}
var IS_IDENTIFIER_CHAR = new Uint8Array(65536);
for (let i4 = 0; i4 < 128; i4++) {
  IS_IDENTIFIER_CHAR[i4] = computeIsIdentifierChar(i4) ? 1 : 0;
}
for (let i4 = 128; i4 < 65536; i4++) {
  IS_IDENTIFIER_CHAR[i4] = 1;
}
for (const whitespaceChar of WHITESPACE_CHARS) {
  IS_IDENTIFIER_CHAR[whitespaceChar] = 0;
}
IS_IDENTIFIER_CHAR[8232] = 0;
IS_IDENTIFIER_CHAR[8233] = 0;
var IS_IDENTIFIER_START = IS_IDENTIFIER_CHAR.slice();
for (let numChar = charCodes.digit0; numChar <= charCodes.digit9; numChar++) {
  IS_IDENTIFIER_START[numChar] = 0;
}

// node_modules/sucrase/dist/esm/parser/tokenizer/readWordTree.js
var READ_WORD_TREE = new Int32Array([
  // ""
  -1,
  27,
  783,
  918,
  1755,
  2376,
  2862,
  3483,
  -1,
  3699,
  -1,
  4617,
  4752,
  4833,
  5130,
  5508,
  5940,
  -1,
  6480,
  6939,
  7749,
  8181,
  8451,
  8613,
  -1,
  8829,
  -1,
  // "a"
  -1,
  -1,
  54,
  243,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  432,
  -1,
  -1,
  -1,
  675,
  -1,
  -1,
  -1,
  // "ab"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  81,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abs"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  108,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abst"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  135,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abstr"
  -1,
  162,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abstra"
  -1,
  -1,
  -1,
  189,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abstrac"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  216,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abstract"
  ContextualKeyword._abstract << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ac"
  -1,
  -1,
  -1,
  270,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "acc"
  -1,
  -1,
  -1,
  -1,
  -1,
  297,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "acce"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  324,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "acces"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  351,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "access"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  378,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "accesso"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  405,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "accessor"
  ContextualKeyword._accessor << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "as"
  ContextualKeyword._as << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  459,
  -1,
  -1,
  -1,
  -1,
  -1,
  594,
  -1,
  // "ass"
  -1,
  -1,
  -1,
  -1,
  -1,
  486,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asse"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  513,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asser"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  540,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "assert"
  ContextualKeyword._assert << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  567,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asserts"
  ContextualKeyword._asserts << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asy"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  621,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asyn"
  -1,
  -1,
  -1,
  648,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "async"
  ContextualKeyword._async << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "aw"
  -1,
  702,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "awa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  729,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "awai"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  756,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "await"
  ContextualKeyword._await << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "b"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  810,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "br"
  -1,
  -1,
  -1,
  -1,
  -1,
  837,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "bre"
  -1,
  864,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "brea"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  891,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "break"
  (TokenType._break << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "c"
  -1,
  945,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1107,
  -1,
  -1,
  -1,
  1242,
  -1,
  -1,
  1350,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ca"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  972,
  1026,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cas"
  -1,
  -1,
  -1,
  -1,
  -1,
  999,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "case"
  (TokenType._case << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cat"
  -1,
  -1,
  -1,
  1053,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "catc"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1080,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "catch"
  (TokenType._catch << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ch"
  -1,
  -1,
  -1,
  -1,
  -1,
  1134,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "che"
  -1,
  -1,
  -1,
  1161,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "chec"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1188,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "check"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1215,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "checks"
  ContextualKeyword._checks << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cl"
  -1,
  1269,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cla"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1296,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "clas"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1323,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "class"
  (TokenType._class << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "co"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1377,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "con"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1404,
  1620,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cons"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1431,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "const"
  (TokenType._const << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1458,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "constr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1485,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "constru"
  -1,
  -1,
  -1,
  1512,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "construc"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1539,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "construct"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1566,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "constructo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1593,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "constructor"
  ContextualKeyword._constructor << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cont"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1647,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "conti"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1674,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "contin"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1701,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "continu"
  -1,
  -1,
  -1,
  -1,
  -1,
  1728,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "continue"
  (TokenType._continue << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "d"
  -1,
  -1,
  -1,
  -1,
  -1,
  1782,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2349,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "de"
  -1,
  -1,
  1809,
  1971,
  -1,
  -1,
  2106,
  -1,
  -1,
  -1,
  -1,
  -1,
  2241,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "deb"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1836,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1863,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debug"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1890,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debugg"
  -1,
  -1,
  -1,
  -1,
  -1,
  1917,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debugge"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1944,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debugger"
  (TokenType._debugger << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "dec"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1998,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "decl"
  -1,
  2025,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "decla"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2052,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "declar"
  -1,
  -1,
  -1,
  -1,
  -1,
  2079,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "declare"
  ContextualKeyword._declare << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "def"
  -1,
  2133,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "defa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2160,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "defau"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2187,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "defaul"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2214,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "default"
  (TokenType._default << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "del"
  -1,
  -1,
  -1,
  -1,
  -1,
  2268,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "dele"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2295,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "delet"
  -1,
  -1,
  -1,
  -1,
  -1,
  2322,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "delete"
  (TokenType._delete << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "do"
  (TokenType._do << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "e"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2403,
  -1,
  2484,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2565,
  -1,
  -1,
  // "el"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2430,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "els"
  -1,
  -1,
  -1,
  -1,
  -1,
  2457,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "else"
  (TokenType._else << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "en"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2511,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "enu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2538,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "enum"
  ContextualKeyword._enum << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ex"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2592,
  -1,
  -1,
  -1,
  2727,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "exp"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2619,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "expo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2646,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "expor"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2673,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "export"
  (TokenType._export << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2700,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "exports"
  ContextualKeyword._exports << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ext"
  -1,
  -1,
  -1,
  -1,
  -1,
  2754,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "exte"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2781,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "exten"
  -1,
  -1,
  -1,
  -1,
  2808,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "extend"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2835,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "extends"
  (TokenType._extends << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "f"
  -1,
  2889,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2997,
  -1,
  -1,
  -1,
  -1,
  -1,
  3159,
  -1,
  -1,
  3213,
  -1,
  -1,
  3294,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2916,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fal"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2943,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fals"
  -1,
  -1,
  -1,
  -1,
  -1,
  2970,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "false"
  (TokenType._false << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3024,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fin"
  -1,
  3051,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fina"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3078,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "final"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3105,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "finall"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3132,
  -1,
  // "finally"
  (TokenType._finally << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3186,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "for"
  (TokenType._for << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3240,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fro"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3267,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "from"
  ContextualKeyword._from << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3321,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fun"
  -1,
  -1,
  -1,
  3348,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "func"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3375,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "funct"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3402,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "functi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3429,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "functio"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3456,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "function"
  (TokenType._function << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "g"
  -1,
  -1,
  -1,
  -1,
  -1,
  3510,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3564,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ge"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3537,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "get"
  ContextualKeyword._get << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "gl"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3591,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "glo"
  -1,
  -1,
  3618,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "glob"
  -1,
  3645,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "globa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3672,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "global"
  ContextualKeyword._global << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "i"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3726,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3753,
  4077,
  -1,
  -1,
  -1,
  -1,
  4590,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "if"
  (TokenType._if << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "im"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3780,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "imp"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3807,
  -1,
  -1,
  3996,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "impl"
  -1,
  -1,
  -1,
  -1,
  -1,
  3834,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "imple"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3861,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "implem"
  -1,
  -1,
  -1,
  -1,
  -1,
  3888,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "impleme"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3915,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "implemen"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3942,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "implement"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3969,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "implements"
  ContextualKeyword._implements << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "impo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4023,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "impor"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4050,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "import"
  (TokenType._import << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "in"
  (TokenType._in << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4104,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4185,
  4401,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "inf"
  -1,
  -1,
  -1,
  -1,
  -1,
  4131,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "infe"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4158,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "infer"
  ContextualKeyword._infer << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ins"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4212,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "inst"
  -1,
  4239,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "insta"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4266,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instan"
  -1,
  -1,
  -1,
  4293,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instanc"
  -1,
  -1,
  -1,
  -1,
  -1,
  4320,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instance"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4347,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instanceo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4374,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instanceof"
  (TokenType._instanceof << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "int"
  -1,
  -1,
  -1,
  -1,
  -1,
  4428,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "inte"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4455,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "inter"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4482,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "interf"
  -1,
  4509,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "interfa"
  -1,
  -1,
  -1,
  4536,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "interfac"
  -1,
  -1,
  -1,
  -1,
  -1,
  4563,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "interface"
  ContextualKeyword._interface << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "is"
  ContextualKeyword._is << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "k"
  -1,
  -1,
  -1,
  -1,
  -1,
  4644,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ke"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4671,
  -1,
  // "key"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4698,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "keyo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4725,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "keyof"
  ContextualKeyword._keyof << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "l"
  -1,
  -1,
  -1,
  -1,
  -1,
  4779,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "le"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4806,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "let"
  (TokenType._let << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "m"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4860,
  -1,
  -1,
  -1,
  -1,
  -1,
  4995,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4887,
  -1,
  -1,
  // "mix"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4914,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mixi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4941,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mixin"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4968,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mixins"
  ContextualKeyword._mixins << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mo"
  -1,
  -1,
  -1,
  -1,
  5022,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mod"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5049,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "modu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5076,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "modul"
  -1,
  -1,
  -1,
  -1,
  -1,
  5103,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "module"
  ContextualKeyword._module << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "n"
  -1,
  5157,
  -1,
  -1,
  -1,
  5373,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5427,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "na"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5184,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "nam"
  -1,
  -1,
  -1,
  -1,
  -1,
  5211,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "name"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5238,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "names"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5265,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "namesp"
  -1,
  5292,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "namespa"
  -1,
  -1,
  -1,
  5319,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "namespac"
  -1,
  -1,
  -1,
  -1,
  -1,
  5346,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "namespace"
  ContextualKeyword._namespace << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ne"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5400,
  -1,
  -1,
  -1,
  // "new"
  (TokenType._new << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "nu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5454,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "nul"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5481,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "null"
  (TokenType._null << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "o"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5535,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5562,
  -1,
  -1,
  -1,
  -1,
  5697,
  5751,
  -1,
  -1,
  -1,
  -1,
  // "of"
  ContextualKeyword._of << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "op"
  -1,
  5589,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "opa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5616,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "opaq"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5643,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "opaqu"
  -1,
  -1,
  -1,
  -1,
  -1,
  5670,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "opaque"
  ContextualKeyword._opaque << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ou"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5724,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "out"
  ContextualKeyword._out << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ov"
  -1,
  -1,
  -1,
  -1,
  -1,
  5778,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ove"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5805,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "over"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5832,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "overr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5859,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "overri"
  -1,
  -1,
  -1,
  -1,
  5886,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "overrid"
  -1,
  -1,
  -1,
  -1,
  -1,
  5913,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "override"
  ContextualKeyword._override << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "p"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5967,
  -1,
  -1,
  6345,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5994,
  -1,
  -1,
  -1,
  -1,
  -1,
  6129,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pri"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6021,
  -1,
  -1,
  -1,
  -1,
  // "priv"
  -1,
  6048,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "priva"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6075,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "privat"
  -1,
  -1,
  -1,
  -1,
  -1,
  6102,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "private"
  ContextualKeyword._private << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pro"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6156,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "prot"
  -1,
  -1,
  -1,
  -1,
  -1,
  6183,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6318,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "prote"
  -1,
  -1,
  -1,
  6210,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "protec"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6237,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "protect"
  -1,
  -1,
  -1,
  -1,
  -1,
  6264,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "protecte"
  -1,
  -1,
  -1,
  -1,
  6291,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "protected"
  ContextualKeyword._protected << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "proto"
  ContextualKeyword._proto << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pu"
  -1,
  -1,
  6372,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pub"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6399,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "publ"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6426,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "publi"
  -1,
  -1,
  -1,
  6453,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "public"
  ContextualKeyword._public << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "r"
  -1,
  -1,
  -1,
  -1,
  -1,
  6507,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "re"
  -1,
  6534,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6696,
  -1,
  -1,
  6831,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "rea"
  -1,
  -1,
  -1,
  -1,
  6561,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "read"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6588,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "reado"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6615,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "readon"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6642,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "readonl"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6669,
  -1,
  // "readonly"
  ContextualKeyword._readonly << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "req"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6723,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "requ"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6750,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "requi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6777,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "requir"
  -1,
  -1,
  -1,
  -1,
  -1,
  6804,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "require"
  ContextualKeyword._require << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ret"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6858,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "retu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6885,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "retur"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6912,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "return"
  (TokenType._return << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "s"
  -1,
  6966,
  -1,
  -1,
  -1,
  7182,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7236,
  7371,
  -1,
  7479,
  -1,
  7614,
  -1,
  // "sa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6993,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sat"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7020,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sati"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7047,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satis"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7074,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satisf"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7101,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satisfi"
  -1,
  -1,
  -1,
  -1,
  -1,
  7128,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satisfie"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7155,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satisfies"
  ContextualKeyword._satisfies << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "se"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7209,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "set"
  ContextualKeyword._set << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "st"
  -1,
  7263,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sta"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7290,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "stat"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7317,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "stati"
  -1,
  -1,
  -1,
  7344,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "static"
  ContextualKeyword._static << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "su"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7398,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sup"
  -1,
  -1,
  -1,
  -1,
  -1,
  7425,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "supe"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7452,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "super"
  (TokenType._super << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sw"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7506,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "swi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7533,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "swit"
  -1,
  -1,
  -1,
  7560,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "switc"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7587,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "switch"
  (TokenType._switch << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sy"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7641,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sym"
  -1,
  -1,
  7668,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "symb"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7695,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "symbo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7722,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "symbol"
  ContextualKeyword._symbol << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "t"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7776,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7938,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8046,
  -1,
  // "th"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7803,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7857,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "thi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7830,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "this"
  (TokenType._this << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "thr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7884,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "thro"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7911,
  -1,
  -1,
  -1,
  // "throw"
  (TokenType._throw << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "tr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7965,
  -1,
  -1,
  -1,
  8019,
  -1,
  // "tru"
  -1,
  -1,
  -1,
  -1,
  -1,
  7992,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "true"
  (TokenType._true << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "try"
  (TokenType._try << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ty"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8073,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "typ"
  -1,
  -1,
  -1,
  -1,
  -1,
  8100,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "type"
  ContextualKeyword._type << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8127,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "typeo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8154,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "typeof"
  (TokenType._typeof << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "u"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8208,
  -1,
  -1,
  -1,
  -1,
  8343,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "un"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8235,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "uni"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8262,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "uniq"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8289,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "uniqu"
  -1,
  -1,
  -1,
  -1,
  -1,
  8316,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "unique"
  ContextualKeyword._unique << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "us"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8370,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "usi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8397,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "usin"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8424,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "using"
  ContextualKeyword._using << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "v"
  -1,
  8478,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8532,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "va"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8505,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "var"
  (TokenType._var << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "vo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8559,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "voi"
  -1,
  -1,
  -1,
  -1,
  8586,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "void"
  (TokenType._void << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "w"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8640,
  8748,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "wh"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8667,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "whi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8694,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "whil"
  -1,
  -1,
  -1,
  -1,
  -1,
  8721,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "while"
  (TokenType._while << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "wi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8775,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "wit"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8802,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "with"
  (TokenType._with << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "y"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8856,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "yi"
  -1,
  -1,
  -1,
  -1,
  -1,
  8883,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "yie"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8910,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "yiel"
  -1,
  -1,
  -1,
  -1,
  8937,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "yield"
  (TokenType._yield << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
]);

// node_modules/sucrase/dist/esm/parser/tokenizer/readWord.js
function readWord() {
  let treePos = 0;
  let code = 0;
  let pos = state.pos;
  while (pos < input.length) {
    code = input.charCodeAt(pos);
    if (code < charCodes.lowercaseA || code > charCodes.lowercaseZ) {
      break;
    }
    const next3 = READ_WORD_TREE[treePos + (code - charCodes.lowercaseA) + 1];
    if (next3 === -1) {
      break;
    } else {
      treePos = next3;
      pos++;
    }
  }
  const keywordValue = READ_WORD_TREE[treePos];
  if (keywordValue > -1 && !IS_IDENTIFIER_CHAR[code]) {
    state.pos = pos;
    if (keywordValue & 1) {
      finishToken(keywordValue >>> 1);
    } else {
      finishToken(TokenType.name, keywordValue >>> 1);
    }
    return;
  }
  while (pos < input.length) {
    const ch = input.charCodeAt(pos);
    if (IS_IDENTIFIER_CHAR[ch]) {
      pos++;
    } else if (ch === charCodes.backslash) {
      pos += 2;
      if (input.charCodeAt(pos) === charCodes.leftCurlyBrace) {
        while (pos < input.length && input.charCodeAt(pos) !== charCodes.rightCurlyBrace) {
          pos++;
        }
        pos++;
      }
    } else if (ch === charCodes.atSign && input.charCodeAt(pos + 1) === charCodes.atSign) {
      pos += 2;
    } else {
      break;
    }
  }
  state.pos = pos;
  finishToken(TokenType.name);
}

// node_modules/sucrase/dist/esm/parser/tokenizer/index.js
var IdentifierRole;
(function(IdentifierRole2) {
  const Access = 0;
  IdentifierRole2[IdentifierRole2["Access"] = Access] = "Access";
  const ExportAccess = Access + 1;
  IdentifierRole2[IdentifierRole2["ExportAccess"] = ExportAccess] = "ExportAccess";
  const TopLevelDeclaration = ExportAccess + 1;
  IdentifierRole2[IdentifierRole2["TopLevelDeclaration"] = TopLevelDeclaration] = "TopLevelDeclaration";
  const FunctionScopedDeclaration = TopLevelDeclaration + 1;
  IdentifierRole2[IdentifierRole2["FunctionScopedDeclaration"] = FunctionScopedDeclaration] = "FunctionScopedDeclaration";
  const BlockScopedDeclaration = FunctionScopedDeclaration + 1;
  IdentifierRole2[IdentifierRole2["BlockScopedDeclaration"] = BlockScopedDeclaration] = "BlockScopedDeclaration";
  const ObjectShorthandTopLevelDeclaration = BlockScopedDeclaration + 1;
  IdentifierRole2[IdentifierRole2["ObjectShorthandTopLevelDeclaration"] = ObjectShorthandTopLevelDeclaration] = "ObjectShorthandTopLevelDeclaration";
  const ObjectShorthandFunctionScopedDeclaration = ObjectShorthandTopLevelDeclaration + 1;
  IdentifierRole2[IdentifierRole2["ObjectShorthandFunctionScopedDeclaration"] = ObjectShorthandFunctionScopedDeclaration] = "ObjectShorthandFunctionScopedDeclaration";
  const ObjectShorthandBlockScopedDeclaration = ObjectShorthandFunctionScopedDeclaration + 1;
  IdentifierRole2[IdentifierRole2["ObjectShorthandBlockScopedDeclaration"] = ObjectShorthandBlockScopedDeclaration] = "ObjectShorthandBlockScopedDeclaration";
  const ObjectShorthand = ObjectShorthandBlockScopedDeclaration + 1;
  IdentifierRole2[IdentifierRole2["ObjectShorthand"] = ObjectShorthand] = "ObjectShorthand";
  const ImportDeclaration = ObjectShorthand + 1;
  IdentifierRole2[IdentifierRole2["ImportDeclaration"] = ImportDeclaration] = "ImportDeclaration";
  const ObjectKey = ImportDeclaration + 1;
  IdentifierRole2[IdentifierRole2["ObjectKey"] = ObjectKey] = "ObjectKey";
  const ImportAccess = ObjectKey + 1;
  IdentifierRole2[IdentifierRole2["ImportAccess"] = ImportAccess] = "ImportAccess";
})(IdentifierRole || (IdentifierRole = {}));
var JSXRole;
(function(JSXRole2) {
  const NoChildren = 0;
  JSXRole2[JSXRole2["NoChildren"] = NoChildren] = "NoChildren";
  const OneChild = NoChildren + 1;
  JSXRole2[JSXRole2["OneChild"] = OneChild] = "OneChild";
  const StaticChildren = OneChild + 1;
  JSXRole2[JSXRole2["StaticChildren"] = StaticChildren] = "StaticChildren";
  const KeyAfterPropSpread = StaticChildren + 1;
  JSXRole2[JSXRole2["KeyAfterPropSpread"] = KeyAfterPropSpread] = "KeyAfterPropSpread";
})(JSXRole || (JSXRole = {}));
function isDeclaration(token2) {
  const role = token2.identifierRole;
  return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;
}
function isNonTopLevelDeclaration(token2) {
  const role = token2.identifierRole;
  return role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;
}
function isTopLevelDeclaration(token2) {
  const role = token2.identifierRole;
  return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ImportDeclaration;
}
function isBlockScopedDeclaration(token2) {
  const role = token2.identifierRole;
  return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;
}
function isFunctionScopedDeclaration(token2) {
  const role = token2.identifierRole;
  return role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
}
function isObjectShorthandDeclaration(token2) {
  return token2.identifierRole === IdentifierRole.ObjectShorthandTopLevelDeclaration || token2.identifierRole === IdentifierRole.ObjectShorthandBlockScopedDeclaration || token2.identifierRole === IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
}
var Token = class {
  constructor() {
    this.type = state.type;
    this.contextualKeyword = state.contextualKeyword;
    this.start = state.start;
    this.end = state.end;
    this.scopeDepth = state.scopeDepth;
    this.isType = state.isType;
    this.identifierRole = null;
    this.jsxRole = null;
    this.shadowsGlobal = false;
    this.isAsyncOperation = false;
    this.contextId = null;
    this.rhsEndIndex = null;
    this.isExpression = false;
    this.numNullishCoalesceStarts = 0;
    this.numNullishCoalesceEnds = 0;
    this.isOptionalChainStart = false;
    this.isOptionalChainEnd = false;
    this.subscriptStartIndex = null;
    this.nullishStartIndex = null;
  }
  // Initially false for all tokens, then may be computed in a follow-up step that does scope
  // analysis.
  // Initially false for all tokens, but may be set during transform to mark it as containing an
  // await operation.
  // For assignments, the index of the RHS. For export tokens, the end of the export.
  // For class tokens, records if the class is a class expression or a class statement.
  // Number of times to insert a `nullishCoalesce(` snippet before this token.
  // Number of times to insert a `)` snippet after this token.
  // If true, insert an `optionalChain([` snippet before this token.
  // If true, insert a `])` snippet after this token.
  // Tag for `.`, `?.`, `[`, `?.[`, `(`, and `?.(` to denote the "root" token for this
  // subscript chain. This can be used to determine if this chain is an optional chain.
  // Tag for `??` operators to denote the root token for this nullish coalescing call.
};
function next() {
  state.tokens.push(new Token());
  nextToken();
}
function nextTemplateToken() {
  state.tokens.push(new Token());
  state.start = state.pos;
  readTmplToken();
}
function retokenizeSlashAsRegex() {
  if (state.type === TokenType.assign) {
    --state.pos;
  }
  readRegexp();
}
function pushTypeContext(existingTokensInType) {
  for (let i4 = state.tokens.length - existingTokensInType; i4 < state.tokens.length; i4++) {
    state.tokens[i4].isType = true;
  }
  const oldIsType = state.isType;
  state.isType = true;
  return oldIsType;
}
function popTypeContext(oldIsType) {
  state.isType = oldIsType;
}
function eat(type) {
  if (match2(type)) {
    next();
    return true;
  } else {
    return false;
  }
}
function eatTypeToken(tokenType) {
  const oldIsType = state.isType;
  state.isType = true;
  eat(tokenType);
  state.isType = oldIsType;
}
function match2(type) {
  return state.type === type;
}
function lookaheadType() {
  const snapshot = state.snapshot();
  next();
  const type = state.type;
  state.restoreFromSnapshot(snapshot);
  return type;
}
var TypeAndKeyword = class {
  constructor(type, contextualKeyword) {
    this.type = type;
    this.contextualKeyword = contextualKeyword;
  }
};
function lookaheadTypeAndKeyword() {
  const snapshot = state.snapshot();
  next();
  const type = state.type;
  const contextualKeyword = state.contextualKeyword;
  state.restoreFromSnapshot(snapshot);
  return new TypeAndKeyword(type, contextualKeyword);
}
function nextTokenStart() {
  return nextTokenStartSince(state.pos);
}
function nextTokenStartSince(pos) {
  skipWhiteSpace.lastIndex = pos;
  const skip = skipWhiteSpace.exec(input);
  return pos + skip[0].length;
}
function lookaheadCharCode() {
  return input.charCodeAt(nextTokenStart());
}
function nextToken() {
  skipSpace();
  state.start = state.pos;
  if (state.pos >= input.length) {
    const tokens = state.tokens;
    if (tokens.length >= 2 && tokens[tokens.length - 1].start >= input.length && tokens[tokens.length - 2].start >= input.length) {
      unexpected("Unexpectedly reached the end of input.");
    }
    finishToken(TokenType.eof);
    return;
  }
  readToken(input.charCodeAt(state.pos));
}
function readToken(code) {
  if (IS_IDENTIFIER_START[code] || code === charCodes.backslash || code === charCodes.atSign && input.charCodeAt(state.pos + 1) === charCodes.atSign) {
    readWord();
  } else {
    getTokenFromCode(code);
  }
}
function skipBlockComment() {
  while (input.charCodeAt(state.pos) !== charCodes.asterisk || input.charCodeAt(state.pos + 1) !== charCodes.slash) {
    state.pos++;
    if (state.pos > input.length) {
      unexpected("Unterminated comment", state.pos - 2);
      return;
    }
  }
  state.pos += 2;
}
function skipLineComment(startSkip) {
  let ch = input.charCodeAt(state.pos += startSkip);
  if (state.pos < input.length) {
    while (ch !== charCodes.lineFeed && ch !== charCodes.carriageReturn && ch !== charCodes.lineSeparator && ch !== charCodes.paragraphSeparator && ++state.pos < input.length) {
      ch = input.charCodeAt(state.pos);
    }
  }
}
function skipSpace() {
  while (state.pos < input.length) {
    const ch = input.charCodeAt(state.pos);
    switch (ch) {
      case charCodes.carriageReturn:
        if (input.charCodeAt(state.pos + 1) === charCodes.lineFeed) {
          ++state.pos;
        }
      case charCodes.lineFeed:
      case charCodes.lineSeparator:
      case charCodes.paragraphSeparator:
        ++state.pos;
        break;
      case charCodes.slash:
        switch (input.charCodeAt(state.pos + 1)) {
          case charCodes.asterisk:
            state.pos += 2;
            skipBlockComment();
            break;
          case charCodes.slash:
            skipLineComment(2);
            break;
          default:
            return;
        }
        break;
      default:
        if (IS_WHITESPACE[ch]) {
          ++state.pos;
        } else {
          return;
        }
    }
  }
}
function finishToken(type, contextualKeyword = ContextualKeyword.NONE) {
  state.end = state.pos;
  state.type = type;
  state.contextualKeyword = contextualKeyword;
}
function readToken_dot() {
  const nextChar2 = input.charCodeAt(state.pos + 1);
  if (nextChar2 >= charCodes.digit0 && nextChar2 <= charCodes.digit9) {
    readNumber(true);
    return;
  }
  if (nextChar2 === charCodes.dot && input.charCodeAt(state.pos + 2) === charCodes.dot) {
    state.pos += 3;
    finishToken(TokenType.ellipsis);
  } else {
    ++state.pos;
    finishToken(TokenType.dot);
  }
}
function readToken_slash() {
  const nextChar2 = input.charCodeAt(state.pos + 1);
  if (nextChar2 === charCodes.equalsTo) {
    finishOp(TokenType.assign, 2);
  } else {
    finishOp(TokenType.slash, 1);
  }
}
function readToken_mult_modulo(code) {
  let tokenType = code === charCodes.asterisk ? TokenType.star : TokenType.modulo;
  let width = 1;
  let nextChar2 = input.charCodeAt(state.pos + 1);
  if (code === charCodes.asterisk && nextChar2 === charCodes.asterisk) {
    width++;
    nextChar2 = input.charCodeAt(state.pos + 2);
    tokenType = TokenType.exponent;
  }
  if (nextChar2 === charCodes.equalsTo && input.charCodeAt(state.pos + 2) !== charCodes.greaterThan) {
    width++;
    tokenType = TokenType.assign;
  }
  finishOp(tokenType, width);
}
function readToken_pipe_amp(code) {
  const nextChar2 = input.charCodeAt(state.pos + 1);
  if (nextChar2 === code) {
    if (input.charCodeAt(state.pos + 2) === charCodes.equalsTo) {
      finishOp(TokenType.assign, 3);
    } else {
      finishOp(code === charCodes.verticalBar ? TokenType.logicalOR : TokenType.logicalAND, 2);
    }
    return;
  }
  if (code === charCodes.verticalBar) {
    if (nextChar2 === charCodes.greaterThan) {
      finishOp(TokenType.pipeline, 2);
      return;
    } else if (nextChar2 === charCodes.rightCurlyBrace && isFlowEnabled) {
      finishOp(TokenType.braceBarR, 2);
      return;
    }
  }
  if (nextChar2 === charCodes.equalsTo) {
    finishOp(TokenType.assign, 2);
    return;
  }
  finishOp(code === charCodes.verticalBar ? TokenType.bitwiseOR : TokenType.bitwiseAND, 1);
}
function readToken_caret() {
  const nextChar2 = input.charCodeAt(state.pos + 1);
  if (nextChar2 === charCodes.equalsTo) {
    finishOp(TokenType.assign, 2);
  } else {
    finishOp(TokenType.bitwiseXOR, 1);
  }
}
function readToken_plus_min(code) {
  const nextChar2 = input.charCodeAt(state.pos + 1);
  if (nextChar2 === code) {
    finishOp(TokenType.preIncDec, 2);
    return;
  }
  if (nextChar2 === charCodes.equalsTo) {
    finishOp(TokenType.assign, 2);
  } else if (code === charCodes.plusSign) {
    finishOp(TokenType.plus, 1);
  } else {
    finishOp(TokenType.minus, 1);
  }
}
function readToken_lt() {
  const nextChar2 = input.charCodeAt(state.pos + 1);
  if (nextChar2 === charCodes.lessThan) {
    if (input.charCodeAt(state.pos + 2) === charCodes.equalsTo) {
      finishOp(TokenType.assign, 3);
      return;
    }
    if (state.isType) {
      finishOp(TokenType.lessThan, 1);
    } else {
      finishOp(TokenType.bitShiftL, 2);
    }
    return;
  }
  if (nextChar2 === charCodes.equalsTo) {
    finishOp(TokenType.relationalOrEqual, 2);
  } else {
    finishOp(TokenType.lessThan, 1);
  }
}
function readToken_gt() {
  if (state.isType) {
    finishOp(TokenType.greaterThan, 1);
    return;
  }
  const nextChar2 = input.charCodeAt(state.pos + 1);
  if (nextChar2 === charCodes.greaterThan) {
    const size2 = input.charCodeAt(state.pos + 2) === charCodes.greaterThan ? 3 : 2;
    if (input.charCodeAt(state.pos + size2) === charCodes.equalsTo) {
      finishOp(TokenType.assign, size2 + 1);
      return;
    }
    finishOp(TokenType.bitShiftR, size2);
    return;
  }
  if (nextChar2 === charCodes.equalsTo) {
    finishOp(TokenType.relationalOrEqual, 2);
  } else {
    finishOp(TokenType.greaterThan, 1);
  }
}
function rescan_gt() {
  if (state.type === TokenType.greaterThan) {
    state.pos -= 1;
    readToken_gt();
  }
}
function readToken_eq_excl(code) {
  const nextChar2 = input.charCodeAt(state.pos + 1);
  if (nextChar2 === charCodes.equalsTo) {
    finishOp(TokenType.equality, input.charCodeAt(state.pos + 2) === charCodes.equalsTo ? 3 : 2);
    return;
  }
  if (code === charCodes.equalsTo && nextChar2 === charCodes.greaterThan) {
    state.pos += 2;
    finishToken(TokenType.arrow);
    return;
  }
  finishOp(code === charCodes.equalsTo ? TokenType.eq : TokenType.bang, 1);
}
function readToken_question() {
  const nextChar2 = input.charCodeAt(state.pos + 1);
  const nextChar22 = input.charCodeAt(state.pos + 2);
  if (nextChar2 === charCodes.questionMark && // In Flow (but not TypeScript), ??string is a valid type that should be
  // tokenized as two individual ? tokens.
  !(isFlowEnabled && state.isType)) {
    if (nextChar22 === charCodes.equalsTo) {
      finishOp(TokenType.assign, 3);
    } else {
      finishOp(TokenType.nullishCoalescing, 2);
    }
  } else if (nextChar2 === charCodes.dot && !(nextChar22 >= charCodes.digit0 && nextChar22 <= charCodes.digit9)) {
    state.pos += 2;
    finishToken(TokenType.questionDot);
  } else {
    ++state.pos;
    finishToken(TokenType.question);
  }
}
function getTokenFromCode(code) {
  switch (code) {
    case charCodes.numberSign:
      ++state.pos;
      finishToken(TokenType.hash);
      return;
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case charCodes.dot:
      readToken_dot();
      return;
    // Punctuation tokens.
    case charCodes.leftParenthesis:
      ++state.pos;
      finishToken(TokenType.parenL);
      return;
    case charCodes.rightParenthesis:
      ++state.pos;
      finishToken(TokenType.parenR);
      return;
    case charCodes.semicolon:
      ++state.pos;
      finishToken(TokenType.semi);
      return;
    case charCodes.comma:
      ++state.pos;
      finishToken(TokenType.comma);
      return;
    case charCodes.leftSquareBracket:
      ++state.pos;
      finishToken(TokenType.bracketL);
      return;
    case charCodes.rightSquareBracket:
      ++state.pos;
      finishToken(TokenType.bracketR);
      return;
    case charCodes.leftCurlyBrace:
      if (isFlowEnabled && input.charCodeAt(state.pos + 1) === charCodes.verticalBar) {
        finishOp(TokenType.braceBarL, 2);
      } else {
        ++state.pos;
        finishToken(TokenType.braceL);
      }
      return;
    case charCodes.rightCurlyBrace:
      ++state.pos;
      finishToken(TokenType.braceR);
      return;
    case charCodes.colon:
      if (input.charCodeAt(state.pos + 1) === charCodes.colon) {
        finishOp(TokenType.doubleColon, 2);
      } else {
        ++state.pos;
        finishToken(TokenType.colon);
      }
      return;
    case charCodes.questionMark:
      readToken_question();
      return;
    case charCodes.atSign:
      ++state.pos;
      finishToken(TokenType.at);
      return;
    case charCodes.graveAccent:
      ++state.pos;
      finishToken(TokenType.backQuote);
      return;
    case charCodes.digit0: {
      const nextChar2 = input.charCodeAt(state.pos + 1);
      if (nextChar2 === charCodes.lowercaseX || nextChar2 === charCodes.uppercaseX || nextChar2 === charCodes.lowercaseO || nextChar2 === charCodes.uppercaseO || nextChar2 === charCodes.lowercaseB || nextChar2 === charCodes.uppercaseB) {
        readRadixNumber();
        return;
      }
    }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case charCodes.digit1:
    case charCodes.digit2:
    case charCodes.digit3:
    case charCodes.digit4:
    case charCodes.digit5:
    case charCodes.digit6:
    case charCodes.digit7:
    case charCodes.digit8:
    case charCodes.digit9:
      readNumber(false);
      return;
    // Quotes produce strings.
    case charCodes.quotationMark:
    case charCodes.apostrophe:
      readString(code);
      return;
    // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.
    case charCodes.slash:
      readToken_slash();
      return;
    case charCodes.percentSign:
    case charCodes.asterisk:
      readToken_mult_modulo(code);
      return;
    case charCodes.verticalBar:
    case charCodes.ampersand:
      readToken_pipe_amp(code);
      return;
    case charCodes.caret:
      readToken_caret();
      return;
    case charCodes.plusSign:
    case charCodes.dash:
      readToken_plus_min(code);
      return;
    case charCodes.lessThan:
      readToken_lt();
      return;
    case charCodes.greaterThan:
      readToken_gt();
      return;
    case charCodes.equalsTo:
    case charCodes.exclamationMark:
      readToken_eq_excl(code);
      return;
    case charCodes.tilde:
      finishOp(TokenType.tilde, 1);
      return;
    default:
      break;
  }
  unexpected(`Unexpected character '${String.fromCharCode(code)}'`, state.pos);
}
function finishOp(type, size2) {
  state.pos += size2;
  finishToken(type);
}
function readRegexp() {
  const start = state.pos;
  let escaped = false;
  let inClass = false;
  for (; ; ) {
    if (state.pos >= input.length) {
      unexpected("Unterminated regular expression", start);
      return;
    }
    const code = input.charCodeAt(state.pos);
    if (escaped) {
      escaped = false;
    } else {
      if (code === charCodes.leftSquareBracket) {
        inClass = true;
      } else if (code === charCodes.rightSquareBracket && inClass) {
        inClass = false;
      } else if (code === charCodes.slash && !inClass) {
        break;
      }
      escaped = code === charCodes.backslash;
    }
    ++state.pos;
  }
  ++state.pos;
  skipWord();
  finishToken(TokenType.regexp);
}
function readInt() {
  while (true) {
    const code = input.charCodeAt(state.pos);
    if (code >= charCodes.digit0 && code <= charCodes.digit9 || code === charCodes.underscore) {
      state.pos++;
    } else {
      break;
    }
  }
}
function readRadixNumber() {
  state.pos += 2;
  while (true) {
    const code = input.charCodeAt(state.pos);
    if (code >= charCodes.digit0 && code <= charCodes.digit9 || code >= charCodes.lowercaseA && code <= charCodes.lowercaseF || code >= charCodes.uppercaseA && code <= charCodes.uppercaseF || code === charCodes.underscore) {
      state.pos++;
    } else {
      break;
    }
  }
  const nextChar2 = input.charCodeAt(state.pos);
  if (nextChar2 === charCodes.lowercaseN) {
    ++state.pos;
    finishToken(TokenType.bigint);
  } else {
    finishToken(TokenType.num);
  }
}
function readNumber(startsWithDot) {
  let isBigInt = false;
  let isDecimal = false;
  if (!startsWithDot) {
    readInt();
  }
  let nextChar2 = input.charCodeAt(state.pos);
  if (nextChar2 === charCodes.dot) {
    ++state.pos;
    readInt();
    nextChar2 = input.charCodeAt(state.pos);
  }
  if (nextChar2 === charCodes.uppercaseE || nextChar2 === charCodes.lowercaseE) {
    nextChar2 = input.charCodeAt(++state.pos);
    if (nextChar2 === charCodes.plusSign || nextChar2 === charCodes.dash) {
      ++state.pos;
    }
    readInt();
    nextChar2 = input.charCodeAt(state.pos);
  }
  if (nextChar2 === charCodes.lowercaseN) {
    ++state.pos;
    isBigInt = true;
  } else if (nextChar2 === charCodes.lowercaseM) {
    ++state.pos;
    isDecimal = true;
  }
  if (isBigInt) {
    finishToken(TokenType.bigint);
    return;
  }
  if (isDecimal) {
    finishToken(TokenType.decimal);
    return;
  }
  finishToken(TokenType.num);
}
function readString(quote) {
  state.pos++;
  for (; ; ) {
    if (state.pos >= input.length) {
      unexpected("Unterminated string constant");
      return;
    }
    const ch = input.charCodeAt(state.pos);
    if (ch === charCodes.backslash) {
      state.pos++;
    } else if (ch === quote) {
      break;
    }
    state.pos++;
  }
  state.pos++;
  finishToken(TokenType.string);
}
function readTmplToken() {
  for (; ; ) {
    if (state.pos >= input.length) {
      unexpected("Unterminated template");
      return;
    }
    const ch = input.charCodeAt(state.pos);
    if (ch === charCodes.graveAccent || ch === charCodes.dollarSign && input.charCodeAt(state.pos + 1) === charCodes.leftCurlyBrace) {
      if (state.pos === state.start && match2(TokenType.template)) {
        if (ch === charCodes.dollarSign) {
          state.pos += 2;
          finishToken(TokenType.dollarBraceL);
          return;
        } else {
          ++state.pos;
          finishToken(TokenType.backQuote);
          return;
        }
      }
      finishToken(TokenType.template);
      return;
    }
    if (ch === charCodes.backslash) {
      state.pos++;
    }
    state.pos++;
  }
}
function skipWord() {
  while (state.pos < input.length) {
    const ch = input.charCodeAt(state.pos);
    if (IS_IDENTIFIER_CHAR[ch]) {
      state.pos++;
    } else if (ch === charCodes.backslash) {
      state.pos += 2;
      if (input.charCodeAt(state.pos) === charCodes.leftCurlyBrace) {
        while (state.pos < input.length && input.charCodeAt(state.pos) !== charCodes.rightCurlyBrace) {
          state.pos++;
        }
        state.pos++;
      }
    } else {
      break;
    }
  }
}

// node_modules/sucrase/dist/esm/util/getImportExportSpecifierInfo.js
function getImportExportSpecifierInfo(tokens, index2 = tokens.currentIndex()) {
  let endIndex = index2 + 1;
  if (isSpecifierEnd(tokens, endIndex)) {
    const name = tokens.identifierNameAtIndex(index2);
    return {
      isType: false,
      leftName: name,
      rightName: name,
      endIndex
    };
  }
  endIndex++;
  if (isSpecifierEnd(tokens, endIndex)) {
    return {
      isType: true,
      leftName: null,
      rightName: null,
      endIndex
    };
  }
  endIndex++;
  if (isSpecifierEnd(tokens, endIndex)) {
    return {
      isType: false,
      leftName: tokens.identifierNameAtIndex(index2),
      rightName: tokens.identifierNameAtIndex(index2 + 2),
      endIndex
    };
  }
  endIndex++;
  if (isSpecifierEnd(tokens, endIndex)) {
    return {
      isType: true,
      leftName: null,
      rightName: null,
      endIndex
    };
  }
  throw new Error(`Unexpected import/export specifier at ${index2}`);
}
function isSpecifierEnd(tokens, index2) {
  const token2 = tokens.tokens[index2];
  return token2.type === TokenType.braceR || token2.type === TokenType.comma;
}

// node_modules/sucrase/dist/esm/parser/plugins/jsx/xhtml.js
var xhtml_default = /* @__PURE__ */ new Map([
  ["quot", '"'],
  ["amp", "&"],
  ["apos", "'"],
  ["lt", "<"],
  ["gt", ">"],
  ["nbsp", "\xA0"],
  ["iexcl", "\xA1"],
  ["cent", "\xA2"],
  ["pound", "\xA3"],
  ["curren", "\xA4"],
  ["yen", "\xA5"],
  ["brvbar", "\xA6"],
  ["sect", "\xA7"],
  ["uml", "\xA8"],
  ["copy", "\xA9"],
  ["ordf", "\xAA"],
  ["laquo", "\xAB"],
  ["not", "\xAC"],
  ["shy", "\xAD"],
  ["reg", "\xAE"],
  ["macr", "\xAF"],
  ["deg", "\xB0"],
  ["plusmn", "\xB1"],
  ["sup2", "\xB2"],
  ["sup3", "\xB3"],
  ["acute", "\xB4"],
  ["micro", "\xB5"],
  ["para", "\xB6"],
  ["middot", "\xB7"],
  ["cedil", "\xB8"],
  ["sup1", "\xB9"],
  ["ordm", "\xBA"],
  ["raquo", "\xBB"],
  ["frac14", "\xBC"],
  ["frac12", "\xBD"],
  ["frac34", "\xBE"],
  ["iquest", "\xBF"],
  ["Agrave", "\xC0"],
  ["Aacute", "\xC1"],
  ["Acirc", "\xC2"],
  ["Atilde", "\xC3"],
  ["Auml", "\xC4"],
  ["Aring", "\xC5"],
  ["AElig", "\xC6"],
  ["Ccedil", "\xC7"],
  ["Egrave", "\xC8"],
  ["Eacute", "\xC9"],
  ["Ecirc", "\xCA"],
  ["Euml", "\xCB"],
  ["Igrave", "\xCC"],
  ["Iacute", "\xCD"],
  ["Icirc", "\xCE"],
  ["Iuml", "\xCF"],
  ["ETH", "\xD0"],
  ["Ntilde", "\xD1"],
  ["Ograve", "\xD2"],
  ["Oacute", "\xD3"],
  ["Ocirc", "\xD4"],
  ["Otilde", "\xD5"],
  ["Ouml", "\xD6"],
  ["times", "\xD7"],
  ["Oslash", "\xD8"],
  ["Ugrave", "\xD9"],
  ["Uacute", "\xDA"],
  ["Ucirc", "\xDB"],
  ["Uuml", "\xDC"],
  ["Yacute", "\xDD"],
  ["THORN", "\xDE"],
  ["szlig", "\xDF"],
  ["agrave", "\xE0"],
  ["aacute", "\xE1"],
  ["acirc", "\xE2"],
  ["atilde", "\xE3"],
  ["auml", "\xE4"],
  ["aring", "\xE5"],
  ["aelig", "\xE6"],
  ["ccedil", "\xE7"],
  ["egrave", "\xE8"],
  ["eacute", "\xE9"],
  ["ecirc", "\xEA"],
  ["euml", "\xEB"],
  ["igrave", "\xEC"],
  ["iacute", "\xED"],
  ["icirc", "\xEE"],
  ["iuml", "\xEF"],
  ["eth", "\xF0"],
  ["ntilde", "\xF1"],
  ["ograve", "\xF2"],
  ["oacute", "\xF3"],
  ["ocirc", "\xF4"],
  ["otilde", "\xF5"],
  ["ouml", "\xF6"],
  ["divide", "\xF7"],
  ["oslash", "\xF8"],
  ["ugrave", "\xF9"],
  ["uacute", "\xFA"],
  ["ucirc", "\xFB"],
  ["uuml", "\xFC"],
  ["yacute", "\xFD"],
  ["thorn", "\xFE"],
  ["yuml", "\xFF"],
  ["OElig", "\u0152"],
  ["oelig", "\u0153"],
  ["Scaron", "\u0160"],
  ["scaron", "\u0161"],
  ["Yuml", "\u0178"],
  ["fnof", "\u0192"],
  ["circ", "\u02C6"],
  ["tilde", "\u02DC"],
  ["Alpha", "\u0391"],
  ["Beta", "\u0392"],
  ["Gamma", "\u0393"],
  ["Delta", "\u0394"],
  ["Epsilon", "\u0395"],
  ["Zeta", "\u0396"],
  ["Eta", "\u0397"],
  ["Theta", "\u0398"],
  ["Iota", "\u0399"],
  ["Kappa", "\u039A"],
  ["Lambda", "\u039B"],
  ["Mu", "\u039C"],
  ["Nu", "\u039D"],
  ["Xi", "\u039E"],
  ["Omicron", "\u039F"],
  ["Pi", "\u03A0"],
  ["Rho", "\u03A1"],
  ["Sigma", "\u03A3"],
  ["Tau", "\u03A4"],
  ["Upsilon", "\u03A5"],
  ["Phi", "\u03A6"],
  ["Chi", "\u03A7"],
  ["Psi", "\u03A8"],
  ["Omega", "\u03A9"],
  ["alpha", "\u03B1"],
  ["beta", "\u03B2"],
  ["gamma", "\u03B3"],
  ["delta", "\u03B4"],
  ["epsilon", "\u03B5"],
  ["zeta", "\u03B6"],
  ["eta", "\u03B7"],
  ["theta", "\u03B8"],
  ["iota", "\u03B9"],
  ["kappa", "\u03BA"],
  ["lambda", "\u03BB"],
  ["mu", "\u03BC"],
  ["nu", "\u03BD"],
  ["xi", "\u03BE"],
  ["omicron", "\u03BF"],
  ["pi", "\u03C0"],
  ["rho", "\u03C1"],
  ["sigmaf", "\u03C2"],
  ["sigma", "\u03C3"],
  ["tau", "\u03C4"],
  ["upsilon", "\u03C5"],
  ["phi", "\u03C6"],
  ["chi", "\u03C7"],
  ["psi", "\u03C8"],
  ["omega", "\u03C9"],
  ["thetasym", "\u03D1"],
  ["upsih", "\u03D2"],
  ["piv", "\u03D6"],
  ["ensp", "\u2002"],
  ["emsp", "\u2003"],
  ["thinsp", "\u2009"],
  ["zwnj", "\u200C"],
  ["zwj", "\u200D"],
  ["lrm", "\u200E"],
  ["rlm", "\u200F"],
  ["ndash", "\u2013"],
  ["mdash", "\u2014"],
  ["lsquo", "\u2018"],
  ["rsquo", "\u2019"],
  ["sbquo", "\u201A"],
  ["ldquo", "\u201C"],
  ["rdquo", "\u201D"],
  ["bdquo", "\u201E"],
  ["dagger", "\u2020"],
  ["Dagger", "\u2021"],
  ["bull", "\u2022"],
  ["hellip", "\u2026"],
  ["permil", "\u2030"],
  ["prime", "\u2032"],
  ["Prime", "\u2033"],
  ["lsaquo", "\u2039"],
  ["rsaquo", "\u203A"],
  ["oline", "\u203E"],
  ["frasl", "\u2044"],
  ["euro", "\u20AC"],
  ["image", "\u2111"],
  ["weierp", "\u2118"],
  ["real", "\u211C"],
  ["trade", "\u2122"],
  ["alefsym", "\u2135"],
  ["larr", "\u2190"],
  ["uarr", "\u2191"],
  ["rarr", "\u2192"],
  ["darr", "\u2193"],
  ["harr", "\u2194"],
  ["crarr", "\u21B5"],
  ["lArr", "\u21D0"],
  ["uArr", "\u21D1"],
  ["rArr", "\u21D2"],
  ["dArr", "\u21D3"],
  ["hArr", "\u21D4"],
  ["forall", "\u2200"],
  ["part", "\u2202"],
  ["exist", "\u2203"],
  ["empty", "\u2205"],
  ["nabla", "\u2207"],
  ["isin", "\u2208"],
  ["notin", "\u2209"],
  ["ni", "\u220B"],
  ["prod", "\u220F"],
  ["sum", "\u2211"],
  ["minus", "\u2212"],
  ["lowast", "\u2217"],
  ["radic", "\u221A"],
  ["prop", "\u221D"],
  ["infin", "\u221E"],
  ["ang", "\u2220"],
  ["and", "\u2227"],
  ["or", "\u2228"],
  ["cap", "\u2229"],
  ["cup", "\u222A"],
  ["int", "\u222B"],
  ["there4", "\u2234"],
  ["sim", "\u223C"],
  ["cong", "\u2245"],
  ["asymp", "\u2248"],
  ["ne", "\u2260"],
  ["equiv", "\u2261"],
  ["le", "\u2264"],
  ["ge", "\u2265"],
  ["sub", "\u2282"],
  ["sup", "\u2283"],
  ["nsub", "\u2284"],
  ["sube", "\u2286"],
  ["supe", "\u2287"],
  ["oplus", "\u2295"],
  ["otimes", "\u2297"],
  ["perp", "\u22A5"],
  ["sdot", "\u22C5"],
  ["lceil", "\u2308"],
  ["rceil", "\u2309"],
  ["lfloor", "\u230A"],
  ["rfloor", "\u230B"],
  ["lang", "\u2329"],
  ["rang", "\u232A"],
  ["loz", "\u25CA"],
  ["spades", "\u2660"],
  ["clubs", "\u2663"],
  ["hearts", "\u2665"],
  ["diams", "\u2666"]
]);

// node_modules/sucrase/dist/esm/util/getJSXPragmaInfo.js
function getJSXPragmaInfo(options2) {
  const [base, suffix] = splitPragma(options2.jsxPragma || "React.createElement");
  const [fragmentBase, fragmentSuffix] = splitPragma(options2.jsxFragmentPragma || "React.Fragment");
  return { base, suffix, fragmentBase, fragmentSuffix };
}
function splitPragma(pragma) {
  let dotIndex = pragma.indexOf(".");
  if (dotIndex === -1) {
    dotIndex = pragma.length;
  }
  return [pragma.slice(0, dotIndex), pragma.slice(dotIndex)];
}

// node_modules/sucrase/dist/esm/transformers/Transformer.js
var Transformer = class {
  // Return true if anything was processed, false otherwise.
  getPrefixCode() {
    return "";
  }
  getHoistedCode() {
    return "";
  }
  getSuffixCode() {
    return "";
  }
};

// node_modules/sucrase/dist/esm/transformers/JSXTransformer.js
var JSXTransformer = class _JSXTransformer extends Transformer {
  // State for calculating the line number of each JSX tag in development.
  __init() {
    this.lastLineNumber = 1;
  }
  __init2() {
    this.lastIndex = 0;
  }
  // In development, variable name holding the name of the current file.
  __init3() {
    this.filenameVarName = null;
  }
  // Mapping of claimed names for imports in the automatic transform, e,g.
  // {jsx: "_jsx"}. This determines which imports to generate in the prefix.
  __init4() {
    this.esmAutomaticImportNameResolutions = {};
  }
  // When automatically adding imports in CJS mode, we store the variable name
  // holding the imported CJS module so we can require it in the prefix.
  __init5() {
    this.cjsAutomaticModuleNameResolutions = {};
  }
  constructor(rootTransformer, tokens, importProcessor, nameManager, options2) {
    super();
    this.rootTransformer = rootTransformer;
    this.tokens = tokens;
    this.importProcessor = importProcessor;
    this.nameManager = nameManager;
    this.options = options2;
    _JSXTransformer.prototype.__init.call(this);
    _JSXTransformer.prototype.__init2.call(this);
    _JSXTransformer.prototype.__init3.call(this);
    _JSXTransformer.prototype.__init4.call(this);
    _JSXTransformer.prototype.__init5.call(this);
    ;
    this.jsxPragmaInfo = getJSXPragmaInfo(options2);
    this.isAutomaticRuntime = options2.jsxRuntime === "automatic";
    this.jsxImportSource = options2.jsxImportSource || "react";
  }
  process() {
    if (this.tokens.matches1(TokenType.jsxTagStart)) {
      this.processJSXTag();
      return true;
    }
    return false;
  }
  getPrefixCode() {
    let prefix2 = "";
    if (this.filenameVarName) {
      prefix2 += `const ${this.filenameVarName} = ${JSON.stringify(this.options.filePath || "")};`;
    }
    if (this.isAutomaticRuntime) {
      if (this.importProcessor) {
        for (const [path, resolvedName] of Object.entries(this.cjsAutomaticModuleNameResolutions)) {
          prefix2 += `var ${resolvedName} = require("${path}");`;
        }
      } else {
        const { createElement: createElementResolution, ...otherResolutions } = this.esmAutomaticImportNameResolutions;
        if (createElementResolution) {
          prefix2 += `import {createElement as ${createElementResolution}} from "${this.jsxImportSource}";`;
        }
        const importSpecifiers = Object.entries(otherResolutions).map(([name, resolvedName]) => `${name} as ${resolvedName}`).join(", ");
        if (importSpecifiers) {
          const importPath = this.jsxImportSource + (this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime");
          prefix2 += `import {${importSpecifiers}} from "${importPath}";`;
        }
      }
    }
    return prefix2;
  }
  processJSXTag() {
    const { jsxRole, start } = this.tokens.currentToken();
    const elementLocationCode = this.options.production ? null : this.getElementLocationCode(start);
    if (this.isAutomaticRuntime && jsxRole !== JSXRole.KeyAfterPropSpread) {
      this.transformTagToJSXFunc(elementLocationCode, jsxRole);
    } else {
      this.transformTagToCreateElement(elementLocationCode);
    }
  }
  getElementLocationCode(firstTokenStart) {
    const lineNumber = this.getLineNumberForIndex(firstTokenStart);
    return `lineNumber: ${lineNumber}`;
  }
  /**
   * Get the line number for this source position. This is calculated lazily and
   * must be called in increasing order by index.
   */
  getLineNumberForIndex(index2) {
    const code = this.tokens.code;
    while (this.lastIndex < index2 && this.lastIndex < code.length) {
      if (code[this.lastIndex] === "\n") {
        this.lastLineNumber++;
      }
      this.lastIndex++;
    }
    return this.lastLineNumber;
  }
  /**
   * Convert the current JSX element to a call to jsx, jsxs, or jsxDEV. This is
   * the primary transformation for the automatic transform.
   *
   * Example:
   * <div a={1} key={2}>Hello{x}</div>
   * becomes
   * jsxs('div', {a: 1, children: ["Hello", x]}, 2)
   */
  transformTagToJSXFunc(elementLocationCode, jsxRole) {
    const isStatic = jsxRole === JSXRole.StaticChildren;
    this.tokens.replaceToken(this.getJSXFuncInvocationCode(isStatic));
    let keyCode = null;
    if (this.tokens.matches1(TokenType.jsxTagEnd)) {
      this.tokens.replaceToken(`${this.getFragmentCode()}, {`);
      this.processAutomaticChildrenAndEndProps(jsxRole);
    } else {
      this.processTagIntro();
      this.tokens.appendCode(", {");
      keyCode = this.processProps(true);
      if (this.tokens.matches2(TokenType.slash, TokenType.jsxTagEnd)) {
        this.tokens.appendCode("}");
      } else if (this.tokens.matches1(TokenType.jsxTagEnd)) {
        this.tokens.removeToken();
        this.processAutomaticChildrenAndEndProps(jsxRole);
      } else {
        throw new Error("Expected either /> or > at the end of the tag.");
      }
      if (keyCode) {
        this.tokens.appendCode(`, ${keyCode}`);
      }
    }
    if (!this.options.production) {
      if (keyCode === null) {
        this.tokens.appendCode(", void 0");
      }
      this.tokens.appendCode(`, ${isStatic}, ${this.getDevSource(elementLocationCode)}, this`);
    }
    this.tokens.removeInitialToken();
    while (!this.tokens.matches1(TokenType.jsxTagEnd)) {
      this.tokens.removeToken();
    }
    this.tokens.replaceToken(")");
  }
  /**
   * Convert the current JSX element to a createElement call. In the classic
   * runtime, this is the only case. In the automatic runtime, this is called
   * as a fallback in some situations.
   *
   * Example:
   * <div a={1} key={2}>Hello{x}</div>
   * becomes
   * React.createElement('div', {a: 1, key: 2}, "Hello", x)
   */
  transformTagToCreateElement(elementLocationCode) {
    this.tokens.replaceToken(this.getCreateElementInvocationCode());
    if (this.tokens.matches1(TokenType.jsxTagEnd)) {
      this.tokens.replaceToken(`${this.getFragmentCode()}, null`);
      this.processChildren(true);
    } else {
      this.processTagIntro();
      this.processPropsObjectWithDevInfo(elementLocationCode);
      if (this.tokens.matches2(TokenType.slash, TokenType.jsxTagEnd)) {
      } else if (this.tokens.matches1(TokenType.jsxTagEnd)) {
        this.tokens.removeToken();
        this.processChildren(true);
      } else {
        throw new Error("Expected either /> or > at the end of the tag.");
      }
    }
    this.tokens.removeInitialToken();
    while (!this.tokens.matches1(TokenType.jsxTagEnd)) {
      this.tokens.removeToken();
    }
    this.tokens.replaceToken(")");
  }
  /**
   * Get the code for the relevant function for this context: jsx, jsxs,
   * or jsxDEV. The following open-paren is included as well.
   *
   * These functions are only used for the automatic runtime, so they are always
   * auto-imported, but the auto-import will be either CJS or ESM based on the
   * target module format.
   */
  getJSXFuncInvocationCode(isStatic) {
    if (this.options.production) {
      if (isStatic) {
        return this.claimAutoImportedFuncInvocation("jsxs", "/jsx-runtime");
      } else {
        return this.claimAutoImportedFuncInvocation("jsx", "/jsx-runtime");
      }
    } else {
      return this.claimAutoImportedFuncInvocation("jsxDEV", "/jsx-dev-runtime");
    }
  }
  /**
   * Return the code to use for the createElement function, e.g.
   * `React.createElement`, including the following open-paren.
   *
   * This is the main function to use for the classic runtime. For the
   * automatic runtime, this function is used as a fallback function to
   * preserve behavior when there is a prop spread followed by an explicit
   * key. In that automatic runtime case, the function should be automatically
   * imported.
   */
  getCreateElementInvocationCode() {
    if (this.isAutomaticRuntime) {
      return this.claimAutoImportedFuncInvocation("createElement", "");
    } else {
      const { jsxPragmaInfo } = this;
      const resolvedPragmaBaseName = this.importProcessor ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.base) || jsxPragmaInfo.base : jsxPragmaInfo.base;
      return `${resolvedPragmaBaseName}${jsxPragmaInfo.suffix}(`;
    }
  }
  /**
   * Return the code to use as the component when compiling a shorthand
   * fragment, e.g. `React.Fragment`.
   *
   * This may be called from either the classic or automatic runtime, and
   * the value should be auto-imported for the automatic runtime.
   */
  getFragmentCode() {
    if (this.isAutomaticRuntime) {
      return this.claimAutoImportedName(
        "Fragment",
        this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime"
      );
    } else {
      const { jsxPragmaInfo } = this;
      const resolvedFragmentPragmaBaseName = this.importProcessor ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.fragmentBase) || jsxPragmaInfo.fragmentBase : jsxPragmaInfo.fragmentBase;
      return resolvedFragmentPragmaBaseName + jsxPragmaInfo.fragmentSuffix;
    }
  }
  /**
   * Return code that invokes the given function.
   *
   * When the imports transform is enabled, use the CJSImportTransformer
   * strategy of using `.call(void 0, ...` to avoid passing a `this` value in a
   * situation that would otherwise look like a method call.
   */
  claimAutoImportedFuncInvocation(funcName, importPathSuffix) {
    const funcCode = this.claimAutoImportedName(funcName, importPathSuffix);
    if (this.importProcessor) {
      return `${funcCode}.call(void 0, `;
    } else {
      return `${funcCode}(`;
    }
  }
  claimAutoImportedName(funcName, importPathSuffix) {
    if (this.importProcessor) {
      const path = this.jsxImportSource + importPathSuffix;
      if (!this.cjsAutomaticModuleNameResolutions[path]) {
        this.cjsAutomaticModuleNameResolutions[path] = this.importProcessor.getFreeIdentifierForPath(path);
      }
      return `${this.cjsAutomaticModuleNameResolutions[path]}.${funcName}`;
    } else {
      if (!this.esmAutomaticImportNameResolutions[funcName]) {
        this.esmAutomaticImportNameResolutions[funcName] = this.nameManager.claimFreeName(
          `_${funcName}`
        );
      }
      return this.esmAutomaticImportNameResolutions[funcName];
    }
  }
  /**
   * Process the first part of a tag, before any props.
   */
  processTagIntro() {
    let introEnd = this.tokens.currentIndex() + 1;
    while (this.tokens.tokens[introEnd].isType || !this.tokens.matches2AtIndex(introEnd - 1, TokenType.jsxName, TokenType.jsxName) && !this.tokens.matches2AtIndex(introEnd - 1, TokenType.greaterThan, TokenType.jsxName) && !this.tokens.matches1AtIndex(introEnd, TokenType.braceL) && !this.tokens.matches1AtIndex(introEnd, TokenType.jsxTagEnd) && !this.tokens.matches2AtIndex(introEnd, TokenType.slash, TokenType.jsxTagEnd)) {
      introEnd++;
    }
    if (introEnd === this.tokens.currentIndex() + 1) {
      const tagName = this.tokens.identifierName();
      if (startsWithLowerCase(tagName)) {
        this.tokens.replaceToken(`'${tagName}'`);
      }
    }
    while (this.tokens.currentIndex() < introEnd) {
      this.rootTransformer.processToken();
    }
  }
  /**
   * Starting at the beginning of the props, add the props argument to
   * React.createElement, including the comma before it.
   */
  processPropsObjectWithDevInfo(elementLocationCode) {
    const devProps = this.options.production ? "" : `__self: this, __source: ${this.getDevSource(elementLocationCode)}`;
    if (!this.tokens.matches1(TokenType.jsxName) && !this.tokens.matches1(TokenType.braceL)) {
      if (devProps) {
        this.tokens.appendCode(`, {${devProps}}`);
      } else {
        this.tokens.appendCode(`, null`);
      }
      return;
    }
    this.tokens.appendCode(`, {`);
    this.processProps(false);
    if (devProps) {
      this.tokens.appendCode(` ${devProps}}`);
    } else {
      this.tokens.appendCode("}");
    }
  }
  /**
   * Transform the core part of the props, assuming that a { has already been
   * inserted before us and that a } will be inserted after us.
   *
   * If extractKeyCode is true (i.e. when using any jsx... function), any prop
   * named "key" has its code captured and returned rather than being emitted to
   * the output code. This shifts line numbers, and emitting the code later will
   * correct line numbers again. If no key is found or if extractKeyCode is
   * false, this function returns null.
   */
  processProps(extractKeyCode) {
    let keyCode = null;
    while (true) {
      if (this.tokens.matches2(TokenType.jsxName, TokenType.eq)) {
        const propName = this.tokens.identifierName();
        if (extractKeyCode && propName === "key") {
          if (keyCode !== null) {
            this.tokens.appendCode(keyCode.replace(/[^\n]/g, ""));
          }
          this.tokens.removeToken();
          this.tokens.removeToken();
          const snapshot = this.tokens.snapshot();
          this.processPropValue();
          keyCode = this.tokens.dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot);
          continue;
        } else {
          this.processPropName(propName);
          this.tokens.replaceToken(": ");
          this.processPropValue();
        }
      } else if (this.tokens.matches1(TokenType.jsxName)) {
        const propName = this.tokens.identifierName();
        this.processPropName(propName);
        this.tokens.appendCode(": true");
      } else if (this.tokens.matches1(TokenType.braceL)) {
        this.tokens.replaceToken("");
        this.rootTransformer.processBalancedCode();
        this.tokens.replaceToken("");
      } else {
        break;
      }
      this.tokens.appendCode(",");
    }
    return keyCode;
  }
  processPropName(propName) {
    if (propName.includes("-")) {
      this.tokens.replaceToken(`'${propName}'`);
    } else {
      this.tokens.copyToken();
    }
  }
  processPropValue() {
    if (this.tokens.matches1(TokenType.braceL)) {
      this.tokens.replaceToken("");
      this.rootTransformer.processBalancedCode();
      this.tokens.replaceToken("");
    } else if (this.tokens.matches1(TokenType.jsxTagStart)) {
      this.processJSXTag();
    } else {
      this.processStringPropValue();
    }
  }
  processStringPropValue() {
    const token2 = this.tokens.currentToken();
    const valueCode = this.tokens.code.slice(token2.start + 1, token2.end - 1);
    const replacementCode = formatJSXTextReplacement(valueCode);
    const literalCode = formatJSXStringValueLiteral(valueCode);
    this.tokens.replaceToken(literalCode + replacementCode);
  }
  /**
   * Starting in the middle of the props object literal, produce an additional
   * prop for the children and close the object literal.
   */
  processAutomaticChildrenAndEndProps(jsxRole) {
    if (jsxRole === JSXRole.StaticChildren) {
      this.tokens.appendCode(" children: [");
      this.processChildren(false);
      this.tokens.appendCode("]}");
    } else {
      if (jsxRole === JSXRole.OneChild) {
        this.tokens.appendCode(" children: ");
      }
      this.processChildren(false);
      this.tokens.appendCode("}");
    }
  }
  /**
   * Transform children into a comma-separated list, which will be either
   * arguments to createElement or array elements of a children prop.
   */
  processChildren(needsInitialComma) {
    let needsComma = needsInitialComma;
    while (true) {
      if (this.tokens.matches2(TokenType.jsxTagStart, TokenType.slash)) {
        return;
      }
      let didEmitElement = false;
      if (this.tokens.matches1(TokenType.braceL)) {
        if (this.tokens.matches2(TokenType.braceL, TokenType.braceR)) {
          this.tokens.replaceToken("");
          this.tokens.replaceToken("");
        } else {
          this.tokens.replaceToken(needsComma ? ", " : "");
          this.rootTransformer.processBalancedCode();
          this.tokens.replaceToken("");
          didEmitElement = true;
        }
      } else if (this.tokens.matches1(TokenType.jsxTagStart)) {
        this.tokens.appendCode(needsComma ? ", " : "");
        this.processJSXTag();
        didEmitElement = true;
      } else if (this.tokens.matches1(TokenType.jsxText) || this.tokens.matches1(TokenType.jsxEmptyText)) {
        didEmitElement = this.processChildTextElement(needsComma);
      } else {
        throw new Error("Unexpected token when processing JSX children.");
      }
      if (didEmitElement) {
        needsComma = true;
      }
    }
  }
  /**
   * Turn a JSX text element into a string literal, or nothing at all if the JSX
   * text resolves to the empty string.
   *
   * Returns true if a string literal is emitted, false otherwise.
   */
  processChildTextElement(needsComma) {
    const token2 = this.tokens.currentToken();
    const valueCode = this.tokens.code.slice(token2.start, token2.end);
    const replacementCode = formatJSXTextReplacement(valueCode);
    const literalCode = formatJSXTextLiteral(valueCode);
    if (literalCode === '""') {
      this.tokens.replaceToken(replacementCode);
      return false;
    } else {
      this.tokens.replaceToken(`${needsComma ? ", " : ""}${literalCode}${replacementCode}`);
      return true;
    }
  }
  getDevSource(elementLocationCode) {
    return `{fileName: ${this.getFilenameVarName()}, ${elementLocationCode}}`;
  }
  getFilenameVarName() {
    if (!this.filenameVarName) {
      this.filenameVarName = this.nameManager.claimFreeName("_jsxFileName");
    }
    return this.filenameVarName;
  }
};
function startsWithLowerCase(s4) {
  const firstChar = s4.charCodeAt(0);
  return firstChar >= charCodes.lowercaseA && firstChar <= charCodes.lowercaseZ;
}
function formatJSXTextLiteral(text2) {
  let result = "";
  let whitespace3 = "";
  let isInInitialLineWhitespace = false;
  let seenNonWhitespace = false;
  for (let i4 = 0; i4 < text2.length; i4++) {
    const c4 = text2[i4];
    if (c4 === " " || c4 === "	" || c4 === "\r") {
      if (!isInInitialLineWhitespace) {
        whitespace3 += c4;
      }
    } else if (c4 === "\n") {
      whitespace3 = "";
      isInInitialLineWhitespace = true;
    } else {
      if (seenNonWhitespace && isInInitialLineWhitespace) {
        result += " ";
      }
      result += whitespace3;
      whitespace3 = "";
      if (c4 === "&") {
        const { entity, newI } = processEntity(text2, i4 + 1);
        i4 = newI - 1;
        result += entity;
      } else {
        result += c4;
      }
      seenNonWhitespace = true;
      isInInitialLineWhitespace = false;
    }
  }
  if (!isInInitialLineWhitespace) {
    result += whitespace3;
  }
  return JSON.stringify(result);
}
function formatJSXTextReplacement(text2) {
  let numNewlines = 0;
  let numSpaces = 0;
  for (const c4 of text2) {
    if (c4 === "\n") {
      numNewlines++;
      numSpaces = 0;
    } else if (c4 === " ") {
      numSpaces++;
    }
  }
  return "\n".repeat(numNewlines) + " ".repeat(numSpaces);
}
function formatJSXStringValueLiteral(text2) {
  let result = "";
  for (let i4 = 0; i4 < text2.length; i4++) {
    const c4 = text2[i4];
    if (c4 === "\n") {
      if (/\s/.test(text2[i4 + 1])) {
        result += " ";
        while (i4 < text2.length && /\s/.test(text2[i4 + 1])) {
          i4++;
        }
      } else {
        result += "\n";
      }
    } else if (c4 === "&") {
      const { entity, newI } = processEntity(text2, i4 + 1);
      result += entity;
      i4 = newI - 1;
    } else {
      result += c4;
    }
  }
  return JSON.stringify(result);
}
function processEntity(text2, indexAfterAmpersand) {
  let str = "";
  let count = 0;
  let entity;
  let i4 = indexAfterAmpersand;
  if (text2[i4] === "#") {
    let radix = 10;
    i4++;
    let numStart;
    if (text2[i4] === "x") {
      radix = 16;
      i4++;
      numStart = i4;
      while (i4 < text2.length && isHexDigit(text2.charCodeAt(i4))) {
        i4++;
      }
    } else {
      numStart = i4;
      while (i4 < text2.length && isDecimalDigit(text2.charCodeAt(i4))) {
        i4++;
      }
    }
    if (text2[i4] === ";") {
      const numStr = text2.slice(numStart, i4);
      if (numStr) {
        i4++;
        entity = String.fromCodePoint(parseInt(numStr, radix));
      }
    }
  } else {
    while (i4 < text2.length && count++ < 10) {
      const ch = text2[i4];
      i4++;
      if (ch === ";") {
        entity = xhtml_default.get(str);
        break;
      }
      str += ch;
    }
  }
  if (!entity) {
    return { entity: "&", newI: indexAfterAmpersand };
  }
  return { entity, newI: i4 };
}
function isDecimalDigit(code) {
  return code >= charCodes.digit0 && code <= charCodes.digit9;
}
function isHexDigit(code) {
  return code >= charCodes.digit0 && code <= charCodes.digit9 || code >= charCodes.lowercaseA && code <= charCodes.lowercaseF || code >= charCodes.uppercaseA && code <= charCodes.uppercaseF;
}

// node_modules/sucrase/dist/esm/util/getNonTypeIdentifiers.js
function getNonTypeIdentifiers(tokens, options2) {
  const jsxPragmaInfo = getJSXPragmaInfo(options2);
  const nonTypeIdentifiers = /* @__PURE__ */ new Set();
  for (let i4 = 0; i4 < tokens.tokens.length; i4++) {
    const token2 = tokens.tokens[i4];
    if (token2.type === TokenType.name && !token2.isType && (token2.identifierRole === IdentifierRole.Access || token2.identifierRole === IdentifierRole.ObjectShorthand || token2.identifierRole === IdentifierRole.ExportAccess) && !token2.shadowsGlobal) {
      nonTypeIdentifiers.add(tokens.identifierNameForToken(token2));
    }
    if (token2.type === TokenType.jsxTagStart) {
      nonTypeIdentifiers.add(jsxPragmaInfo.base);
    }
    if (token2.type === TokenType.jsxTagStart && i4 + 1 < tokens.tokens.length && tokens.tokens[i4 + 1].type === TokenType.jsxTagEnd) {
      nonTypeIdentifiers.add(jsxPragmaInfo.base);
      nonTypeIdentifiers.add(jsxPragmaInfo.fragmentBase);
    }
    if (token2.type === TokenType.jsxName && token2.identifierRole === IdentifierRole.Access) {
      const identifierName = tokens.identifierNameForToken(token2);
      if (!startsWithLowerCase(identifierName) || tokens.tokens[i4 + 1].type === TokenType.dot) {
        nonTypeIdentifiers.add(tokens.identifierNameForToken(token2));
      }
    }
  }
  return nonTypeIdentifiers;
}

// node_modules/sucrase/dist/esm/CJSImportProcessor.js
var CJSImportProcessor = class _CJSImportProcessor {
  __init() {
    this.nonTypeIdentifiers = /* @__PURE__ */ new Set();
  }
  __init2() {
    this.importInfoByPath = /* @__PURE__ */ new Map();
  }
  __init3() {
    this.importsToReplace = /* @__PURE__ */ new Map();
  }
  __init4() {
    this.identifierReplacements = /* @__PURE__ */ new Map();
  }
  __init5() {
    this.exportBindingsByLocalName = /* @__PURE__ */ new Map();
  }
  constructor(nameManager, tokens, enableLegacyTypeScriptModuleInterop, options2, isTypeScriptTransformEnabled, keepUnusedImports, helperManager) {
    ;
    this.nameManager = nameManager;
    this.tokens = tokens;
    this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;
    this.options = options2;
    this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;
    this.keepUnusedImports = keepUnusedImports;
    this.helperManager = helperManager;
    _CJSImportProcessor.prototype.__init.call(this);
    _CJSImportProcessor.prototype.__init2.call(this);
    _CJSImportProcessor.prototype.__init3.call(this);
    _CJSImportProcessor.prototype.__init4.call(this);
    _CJSImportProcessor.prototype.__init5.call(this);
  }
  preprocessTokens() {
    for (let i4 = 0; i4 < this.tokens.tokens.length; i4++) {
      if (this.tokens.matches1AtIndex(i4, TokenType._import) && !this.tokens.matches3AtIndex(i4, TokenType._import, TokenType.name, TokenType.eq)) {
        this.preprocessImportAtIndex(i4);
      }
      if (this.tokens.matches1AtIndex(i4, TokenType._export) && !this.tokens.matches2AtIndex(i4, TokenType._export, TokenType.eq)) {
        this.preprocessExportAtIndex(i4);
      }
    }
    this.generateImportReplacements();
  }
  /**
   * In TypeScript, import statements that only import types should be removed.
   * This includes `import {} from 'foo';`, but not `import 'foo';`.
   */
  pruneTypeOnlyImports() {
    this.nonTypeIdentifiers = getNonTypeIdentifiers(this.tokens, this.options);
    for (const [path, importInfo] of this.importInfoByPath.entries()) {
      if (importInfo.hasBareImport || importInfo.hasStarExport || importInfo.exportStarNames.length > 0 || importInfo.namedExports.length > 0) {
        continue;
      }
      const names = [
        ...importInfo.defaultNames,
        ...importInfo.wildcardNames,
        ...importInfo.namedImports.map(({ localName }) => localName)
      ];
      if (names.every((name) => this.shouldAutomaticallyElideImportedName(name))) {
        this.importsToReplace.set(path, "");
      }
    }
  }
  shouldAutomaticallyElideImportedName(name) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.nonTypeIdentifiers.has(name);
  }
  generateImportReplacements() {
    for (const [path, importInfo] of this.importInfoByPath.entries()) {
      const {
        defaultNames,
        wildcardNames,
        namedImports,
        namedExports,
        exportStarNames,
        hasStarExport
      } = importInfo;
      if (defaultNames.length === 0 && wildcardNames.length === 0 && namedImports.length === 0 && namedExports.length === 0 && exportStarNames.length === 0 && !hasStarExport) {
        this.importsToReplace.set(path, `require('${path}');`);
        continue;
      }
      const primaryImportName = this.getFreeIdentifierForPath(path);
      let secondaryImportName;
      if (this.enableLegacyTypeScriptModuleInterop) {
        secondaryImportName = primaryImportName;
      } else {
        secondaryImportName = wildcardNames.length > 0 ? wildcardNames[0] : this.getFreeIdentifierForPath(path);
      }
      let requireCode = `var ${primaryImportName} = require('${path}');`;
      if (wildcardNames.length > 0) {
        for (const wildcardName of wildcardNames) {
          const moduleExpr = this.enableLegacyTypeScriptModuleInterop ? primaryImportName : `${this.helperManager.getHelperName("interopRequireWildcard")}(${primaryImportName})`;
          requireCode += ` var ${wildcardName} = ${moduleExpr};`;
        }
      } else if (exportStarNames.length > 0 && secondaryImportName !== primaryImportName) {
        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(
          "interopRequireWildcard"
        )}(${primaryImportName});`;
      } else if (defaultNames.length > 0 && secondaryImportName !== primaryImportName) {
        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(
          "interopRequireDefault"
        )}(${primaryImportName});`;
      }
      for (const { importedName, localName } of namedExports) {
        requireCode += ` ${this.helperManager.getHelperName(
          "createNamedExportFrom"
        )}(${primaryImportName}, '${localName}', '${importedName}');`;
      }
      for (const exportStarName of exportStarNames) {
        requireCode += ` exports.${exportStarName} = ${secondaryImportName};`;
      }
      if (hasStarExport) {
        requireCode += ` ${this.helperManager.getHelperName(
          "createStarExport"
        )}(${primaryImportName});`;
      }
      this.importsToReplace.set(path, requireCode);
      for (const defaultName of defaultNames) {
        this.identifierReplacements.set(defaultName, `${secondaryImportName}.default`);
      }
      for (const { importedName, localName } of namedImports) {
        this.identifierReplacements.set(localName, `${primaryImportName}.${importedName}`);
      }
    }
  }
  getFreeIdentifierForPath(path) {
    const components2 = path.split("/");
    const lastComponent = components2[components2.length - 1];
    const baseName = lastComponent.replace(/\W/g, "");
    return this.nameManager.claimFreeName(`_${baseName}`);
  }
  preprocessImportAtIndex(index2) {
    const defaultNames = [];
    const wildcardNames = [];
    const namedImports = [];
    index2++;
    if ((this.tokens.matchesContextualAtIndex(index2, ContextualKeyword._type) || this.tokens.matches1AtIndex(index2, TokenType._typeof)) && !this.tokens.matches1AtIndex(index2 + 1, TokenType.comma) && !this.tokens.matchesContextualAtIndex(index2 + 1, ContextualKeyword._from)) {
      return;
    }
    if (this.tokens.matches1AtIndex(index2, TokenType.parenL)) {
      return;
    }
    if (this.tokens.matches1AtIndex(index2, TokenType.name)) {
      defaultNames.push(this.tokens.identifierNameAtIndex(index2));
      index2++;
      if (this.tokens.matches1AtIndex(index2, TokenType.comma)) {
        index2++;
      }
    }
    if (this.tokens.matches1AtIndex(index2, TokenType.star)) {
      index2 += 2;
      wildcardNames.push(this.tokens.identifierNameAtIndex(index2));
      index2++;
    }
    if (this.tokens.matches1AtIndex(index2, TokenType.braceL)) {
      const result = this.getNamedImports(index2 + 1);
      index2 = result.newIndex;
      for (const namedImport of result.namedImports) {
        if (namedImport.importedName === "default") {
          defaultNames.push(namedImport.localName);
        } else {
          namedImports.push(namedImport);
        }
      }
    }
    if (this.tokens.matchesContextualAtIndex(index2, ContextualKeyword._from)) {
      index2++;
    }
    if (!this.tokens.matches1AtIndex(index2, TokenType.string)) {
      throw new Error("Expected string token at the end of import statement.");
    }
    const path = this.tokens.stringValueAtIndex(index2);
    const importInfo = this.getImportInfo(path);
    importInfo.defaultNames.push(...defaultNames);
    importInfo.wildcardNames.push(...wildcardNames);
    importInfo.namedImports.push(...namedImports);
    if (defaultNames.length === 0 && wildcardNames.length === 0 && namedImports.length === 0) {
      importInfo.hasBareImport = true;
    }
  }
  preprocessExportAtIndex(index2) {
    if (this.tokens.matches2AtIndex(index2, TokenType._export, TokenType._var) || this.tokens.matches2AtIndex(index2, TokenType._export, TokenType._let) || this.tokens.matches2AtIndex(index2, TokenType._export, TokenType._const)) {
      this.preprocessVarExportAtIndex(index2);
    } else if (this.tokens.matches2AtIndex(index2, TokenType._export, TokenType._function) || this.tokens.matches2AtIndex(index2, TokenType._export, TokenType._class)) {
      const exportName = this.tokens.identifierNameAtIndex(index2 + 2);
      this.addExportBinding(exportName, exportName);
    } else if (this.tokens.matches3AtIndex(index2, TokenType._export, TokenType.name, TokenType._function)) {
      const exportName = this.tokens.identifierNameAtIndex(index2 + 3);
      this.addExportBinding(exportName, exportName);
    } else if (this.tokens.matches2AtIndex(index2, TokenType._export, TokenType.braceL)) {
      this.preprocessNamedExportAtIndex(index2);
    } else if (this.tokens.matches2AtIndex(index2, TokenType._export, TokenType.star)) {
      this.preprocessExportStarAtIndex(index2);
    }
  }
  preprocessVarExportAtIndex(index2) {
    let depth = 0;
    for (let i4 = index2 + 2; ; i4++) {
      if (this.tokens.matches1AtIndex(i4, TokenType.braceL) || this.tokens.matches1AtIndex(i4, TokenType.dollarBraceL) || this.tokens.matches1AtIndex(i4, TokenType.bracketL)) {
        depth++;
      } else if (this.tokens.matches1AtIndex(i4, TokenType.braceR) || this.tokens.matches1AtIndex(i4, TokenType.bracketR)) {
        depth--;
      } else if (depth === 0 && !this.tokens.matches1AtIndex(i4, TokenType.name)) {
        break;
      } else if (this.tokens.matches1AtIndex(1, TokenType.eq)) {
        const endIndex = this.tokens.currentToken().rhsEndIndex;
        if (endIndex == null) {
          throw new Error("Expected = token with an end index.");
        }
        i4 = endIndex - 1;
      } else {
        const token2 = this.tokens.tokens[i4];
        if (isDeclaration(token2)) {
          const exportName = this.tokens.identifierNameAtIndex(i4);
          this.identifierReplacements.set(exportName, `exports.${exportName}`);
        }
      }
    }
  }
  /**
   * Walk this export statement just in case it's an export...from statement.
   * If it is, combine it into the import info for that path. Otherwise, just
   * bail out; it'll be handled later.
   */
  preprocessNamedExportAtIndex(index2) {
    index2 += 2;
    const { newIndex, namedImports } = this.getNamedImports(index2);
    index2 = newIndex;
    if (this.tokens.matchesContextualAtIndex(index2, ContextualKeyword._from)) {
      index2++;
    } else {
      for (const { importedName: localName, localName: exportedName } of namedImports) {
        this.addExportBinding(localName, exportedName);
      }
      return;
    }
    if (!this.tokens.matches1AtIndex(index2, TokenType.string)) {
      throw new Error("Expected string token at the end of import statement.");
    }
    const path = this.tokens.stringValueAtIndex(index2);
    const importInfo = this.getImportInfo(path);
    importInfo.namedExports.push(...namedImports);
  }
  preprocessExportStarAtIndex(index2) {
    let exportedName = null;
    if (this.tokens.matches3AtIndex(index2, TokenType._export, TokenType.star, TokenType._as)) {
      index2 += 3;
      exportedName = this.tokens.identifierNameAtIndex(index2);
      index2 += 2;
    } else {
      index2 += 3;
    }
    if (!this.tokens.matches1AtIndex(index2, TokenType.string)) {
      throw new Error("Expected string token at the end of star export statement.");
    }
    const path = this.tokens.stringValueAtIndex(index2);
    const importInfo = this.getImportInfo(path);
    if (exportedName !== null) {
      importInfo.exportStarNames.push(exportedName);
    } else {
      importInfo.hasStarExport = true;
    }
  }
  getNamedImports(index2) {
    const namedImports = [];
    while (true) {
      if (this.tokens.matches1AtIndex(index2, TokenType.braceR)) {
        index2++;
        break;
      }
      const specifierInfo = getImportExportSpecifierInfo(this.tokens, index2);
      index2 = specifierInfo.endIndex;
      if (!specifierInfo.isType) {
        namedImports.push({
          importedName: specifierInfo.leftName,
          localName: specifierInfo.rightName
        });
      }
      if (this.tokens.matches2AtIndex(index2, TokenType.comma, TokenType.braceR)) {
        index2 += 2;
        break;
      } else if (this.tokens.matches1AtIndex(index2, TokenType.braceR)) {
        index2++;
        break;
      } else if (this.tokens.matches1AtIndex(index2, TokenType.comma)) {
        index2++;
      } else {
        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[index2])}`);
      }
    }
    return { newIndex: index2, namedImports };
  }
  /**
   * Get a mutable import info object for this path, creating one if it doesn't
   * exist yet.
   */
  getImportInfo(path) {
    const existingInfo = this.importInfoByPath.get(path);
    if (existingInfo) {
      return existingInfo;
    }
    const newInfo = {
      defaultNames: [],
      wildcardNames: [],
      namedImports: [],
      namedExports: [],
      hasBareImport: false,
      exportStarNames: [],
      hasStarExport: false
    };
    this.importInfoByPath.set(path, newInfo);
    return newInfo;
  }
  addExportBinding(localName, exportedName) {
    if (!this.exportBindingsByLocalName.has(localName)) {
      this.exportBindingsByLocalName.set(localName, []);
    }
    this.exportBindingsByLocalName.get(localName).push(exportedName);
  }
  /**
   * Return the code to use for the import for this path, or the empty string if
   * the code has already been "claimed" by a previous import.
   */
  claimImportCode(importPath) {
    const result = this.importsToReplace.get(importPath);
    this.importsToReplace.set(importPath, "");
    return result || "";
  }
  getIdentifierReplacement(identifierName) {
    return this.identifierReplacements.get(identifierName) || null;
  }
  /**
   * Return a string like `exports.foo = exports.bar`.
   */
  resolveExportBinding(assignedName) {
    const exportedNames = this.exportBindingsByLocalName.get(assignedName);
    if (!exportedNames || exportedNames.length === 0) {
      return null;
    }
    return exportedNames.map((exportedName) => `exports.${exportedName}`).join(" = ");
  }
  /**
   * Return all imported/exported names where we might be interested in whether usages of those
   * names are shadowed.
   */
  getGlobalNames() {
    return /* @__PURE__ */ new Set([
      ...this.identifierReplacements.keys(),
      ...this.exportBindingsByLocalName.keys()
    ]);
  }
};

// node_modules/sucrase/dist/esm/computeSourceMap.js
var import_gen_mapping = __toESM(require_gen_mapping_umd());
function computeSourceMap({ code: generatedCode, mappings: rawMappings }, filePath, options2, source, tokens) {
  const sourceColumns = computeSourceColumns(source, tokens);
  const map = new import_gen_mapping.GenMapping({ file: options2.compiledFilename });
  let tokenIndex = 0;
  let currentMapping = rawMappings[0];
  while (currentMapping === void 0 && tokenIndex < rawMappings.length - 1) {
    tokenIndex++;
    currentMapping = rawMappings[tokenIndex];
  }
  let line2 = 0;
  let lineStart = 0;
  if (currentMapping !== lineStart) {
    (0, import_gen_mapping.maybeAddSegment)(map, line2, 0, filePath, line2, 0);
  }
  for (let i4 = 0; i4 < generatedCode.length; i4++) {
    if (i4 === currentMapping) {
      const genColumn = currentMapping - lineStart;
      const sourceColumn = sourceColumns[tokenIndex];
      (0, import_gen_mapping.maybeAddSegment)(map, line2, genColumn, filePath, line2, sourceColumn);
      while ((currentMapping === i4 || currentMapping === void 0) && tokenIndex < rawMappings.length - 1) {
        tokenIndex++;
        currentMapping = rawMappings[tokenIndex];
      }
    }
    if (generatedCode.charCodeAt(i4) === charCodes.lineFeed) {
      line2++;
      lineStart = i4 + 1;
      if (currentMapping !== lineStart) {
        (0, import_gen_mapping.maybeAddSegment)(map, line2, 0, filePath, line2, 0);
      }
    }
  }
  const { sourceRoot, sourcesContent, ...sourceMap } = (0, import_gen_mapping.toEncodedMap)(map);
  return sourceMap;
}
function computeSourceColumns(code, tokens) {
  const sourceColumns = new Array(tokens.length);
  let tokenIndex = 0;
  let currentMapping = tokens[tokenIndex].start;
  let lineStart = 0;
  for (let i4 = 0; i4 < code.length; i4++) {
    if (i4 === currentMapping) {
      sourceColumns[tokenIndex] = currentMapping - lineStart;
      tokenIndex++;
      currentMapping = tokens[tokenIndex].start;
    }
    if (code.charCodeAt(i4) === charCodes.lineFeed) {
      lineStart = i4 + 1;
    }
  }
  return sourceColumns;
}

// node_modules/sucrase/dist/esm/HelperManager.js
var HELPERS = {
  require: `
    import {createRequire as CREATE_REQUIRE_NAME} from "module";
    const require = CREATE_REQUIRE_NAME(import.meta.url);
  `,
  interopRequireWildcard: `
    function interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
  `,
  interopRequireDefault: `
    function interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  `,
  createNamedExportFrom: `
    function createNamedExportFrom(obj, localName, importedName) {
      Object.defineProperty(exports, localName, {enumerable: true, configurable: true, get: () => obj[importedName]});
    }
  `,
  // Note that TypeScript and Babel do this differently; TypeScript does a simple existence
  // check in the exports object and does a plain assignment, whereas Babel uses
  // defineProperty and builds an object of explicitly-exported names so that star exports can
  // always take lower precedence. For now, we do the easier TypeScript thing.
  createStarExport: `
    function createStarExport(obj) {
      Object.keys(obj)
        .filter((key) => key !== "default" && key !== "__esModule")
        .forEach((key) => {
          if (exports.hasOwnProperty(key)) {
            return;
          }
          Object.defineProperty(exports, key, {enumerable: true, configurable: true, get: () => obj[key]});
        });
    }
  `,
  nullishCoalesce: `
    function nullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return rhsFn();
      }
    }
  `,
  asyncNullishCoalesce: `
    async function asyncNullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return await rhsFn();
      }
    }
  `,
  optionalChain: `
    function optionalChain(ops) {
      let lastAccessLHS = undefined;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
          return undefined;
        }
        if (op === 'access' || op === 'optionalAccess') {
          lastAccessLHS = value;
          value = fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
          value = fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = undefined;
        }
      }
      return value;
    }
  `,
  asyncOptionalChain: `
    async function asyncOptionalChain(ops) {
      let lastAccessLHS = undefined;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
          return undefined;
        }
        if (op === 'access' || op === 'optionalAccess') {
          lastAccessLHS = value;
          value = await fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
          value = await fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = undefined;
        }
      }
      return value;
    }
  `,
  optionalChainDelete: `
    function optionalChainDelete(ops) {
      const result = OPTIONAL_CHAIN_NAME(ops);
      return result == null ? true : result;
    }
  `,
  asyncOptionalChainDelete: `
    async function asyncOptionalChainDelete(ops) {
      const result = await ASYNC_OPTIONAL_CHAIN_NAME(ops);
      return result == null ? true : result;
    }
  `
};
var HelperManager = class _HelperManager {
  __init() {
    this.helperNames = {};
  }
  __init2() {
    this.createRequireName = null;
  }
  constructor(nameManager) {
    ;
    this.nameManager = nameManager;
    _HelperManager.prototype.__init.call(this);
    _HelperManager.prototype.__init2.call(this);
  }
  getHelperName(baseName) {
    let helperName = this.helperNames[baseName];
    if (helperName) {
      return helperName;
    }
    helperName = this.nameManager.claimFreeName(`_${baseName}`);
    this.helperNames[baseName] = helperName;
    return helperName;
  }
  emitHelpers() {
    let resultCode = "";
    if (this.helperNames.optionalChainDelete) {
      this.getHelperName("optionalChain");
    }
    if (this.helperNames.asyncOptionalChainDelete) {
      this.getHelperName("asyncOptionalChain");
    }
    for (const [baseName, helperCodeTemplate] of Object.entries(HELPERS)) {
      const helperName = this.helperNames[baseName];
      let helperCode = helperCodeTemplate;
      if (baseName === "optionalChainDelete") {
        helperCode = helperCode.replace("OPTIONAL_CHAIN_NAME", this.helperNames.optionalChain);
      } else if (baseName === "asyncOptionalChainDelete") {
        helperCode = helperCode.replace(
          "ASYNC_OPTIONAL_CHAIN_NAME",
          this.helperNames.asyncOptionalChain
        );
      } else if (baseName === "require") {
        if (this.createRequireName === null) {
          this.createRequireName = this.nameManager.claimFreeName("_createRequire");
        }
        helperCode = helperCode.replace(/CREATE_REQUIRE_NAME/g, this.createRequireName);
      }
      if (helperName) {
        resultCode += " ";
        resultCode += helperCode.replace(baseName, helperName).replace(/\s+/g, " ").trim();
      }
    }
    return resultCode;
  }
};

// node_modules/sucrase/dist/esm/identifyShadowedGlobals.js
function identifyShadowedGlobals(tokens, scopes, globalNames) {
  if (!hasShadowedGlobals(tokens, globalNames)) {
    return;
  }
  markShadowedGlobals(tokens, scopes, globalNames);
}
function hasShadowedGlobals(tokens, globalNames) {
  for (const token2 of tokens.tokens) {
    if (token2.type === TokenType.name && !token2.isType && isNonTopLevelDeclaration(token2) && globalNames.has(tokens.identifierNameForToken(token2))) {
      return true;
    }
  }
  return false;
}
function markShadowedGlobals(tokens, scopes, globalNames) {
  const scopeStack = [];
  let scopeIndex = scopes.length - 1;
  for (let i4 = tokens.tokens.length - 1; ; i4--) {
    while (scopeStack.length > 0 && scopeStack[scopeStack.length - 1].startTokenIndex === i4 + 1) {
      scopeStack.pop();
    }
    while (scopeIndex >= 0 && scopes[scopeIndex].endTokenIndex === i4 + 1) {
      scopeStack.push(scopes[scopeIndex]);
      scopeIndex--;
    }
    if (i4 < 0) {
      break;
    }
    const token2 = tokens.tokens[i4];
    const name = tokens.identifierNameForToken(token2);
    if (scopeStack.length > 1 && !token2.isType && token2.type === TokenType.name && globalNames.has(name)) {
      if (isBlockScopedDeclaration(token2)) {
        markShadowedForScope(scopeStack[scopeStack.length - 1], tokens, name);
      } else if (isFunctionScopedDeclaration(token2)) {
        let stackIndex = scopeStack.length - 1;
        while (stackIndex > 0 && !scopeStack[stackIndex].isFunctionScope) {
          stackIndex--;
        }
        if (stackIndex < 0) {
          throw new Error("Did not find parent function scope.");
        }
        markShadowedForScope(scopeStack[stackIndex], tokens, name);
      }
    }
  }
  if (scopeStack.length > 0) {
    throw new Error("Expected empty scope stack after processing file.");
  }
}
function markShadowedForScope(scope, tokens, name) {
  for (let i4 = scope.startTokenIndex; i4 < scope.endTokenIndex; i4++) {
    const token2 = tokens.tokens[i4];
    if ((token2.type === TokenType.name || token2.type === TokenType.jsxName) && tokens.identifierNameForToken(token2) === name) {
      token2.shadowsGlobal = true;
    }
  }
}

// node_modules/sucrase/dist/esm/util/getIdentifierNames.js
function getIdentifierNames(code, tokens) {
  const names = [];
  for (const token2 of tokens) {
    if (token2.type === TokenType.name) {
      names.push(code.slice(token2.start, token2.end));
    }
  }
  return names;
}

// node_modules/sucrase/dist/esm/NameManager.js
var NameManager = class _NameManager {
  __init() {
    this.usedNames = /* @__PURE__ */ new Set();
  }
  constructor(code, tokens) {
    ;
    _NameManager.prototype.__init.call(this);
    this.usedNames = new Set(getIdentifierNames(code, tokens));
  }
  claimFreeName(name) {
    const newName = this.findFreeName(name);
    this.usedNames.add(newName);
    return newName;
  }
  findFreeName(name) {
    if (!this.usedNames.has(name)) {
      return name;
    }
    let suffixNum = 2;
    while (this.usedNames.has(name + String(suffixNum))) {
      suffixNum++;
    }
    return name + String(suffixNum);
  }
};

// node_modules/sucrase/dist/esm/Options.js
var import_ts_interface_checker = __toESM(require_dist());

// node_modules/sucrase/dist/esm/Options-gen-types.js
var t3 = __toESM(require_dist());
var Transform = t3.union(
  t3.lit("jsx"),
  t3.lit("typescript"),
  t3.lit("flow"),
  t3.lit("imports"),
  t3.lit("react-hot-loader"),
  t3.lit("jest")
);
var SourceMapOptions = t3.iface([], {
  compiledFilename: "string"
});
var Options = t3.iface([], {
  transforms: t3.array("Transform"),
  disableESTransforms: t3.opt("boolean"),
  jsxRuntime: t3.opt(t3.union(t3.lit("classic"), t3.lit("automatic"), t3.lit("preserve"))),
  production: t3.opt("boolean"),
  jsxImportSource: t3.opt("string"),
  jsxPragma: t3.opt("string"),
  jsxFragmentPragma: t3.opt("string"),
  keepUnusedImports: t3.opt("boolean"),
  preserveDynamicImport: t3.opt("boolean"),
  injectCreateRequireForImportRequire: t3.opt("boolean"),
  enableLegacyTypeScriptModuleInterop: t3.opt("boolean"),
  enableLegacyBabel5ModuleInterop: t3.opt("boolean"),
  sourceMapOptions: t3.opt("SourceMapOptions"),
  filePath: t3.opt("string")
});
var exportedTypeSuite = {
  Transform,
  SourceMapOptions,
  Options
};
var Options_gen_types_default = exportedTypeSuite;

// node_modules/sucrase/dist/esm/Options.js
var { Options: OptionsChecker } = (0, import_ts_interface_checker.createCheckers)(Options_gen_types_default);
function validateOptions(options2) {
  OptionsChecker.strictCheck(options2);
}

// node_modules/sucrase/dist/esm/parser/traverser/lval.js
function parseSpread() {
  next();
  parseMaybeAssign(false);
}
function parseRest(isBlockScope) {
  next();
  parseBindingAtom(isBlockScope);
}
function parseBindingIdentifier(isBlockScope) {
  parseIdentifier();
  markPriorBindingIdentifier(isBlockScope);
}
function parseImportedIdentifier() {
  parseIdentifier();
  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;
}
function markPriorBindingIdentifier(isBlockScope) {
  let identifierRole;
  if (state.scopeDepth === 0) {
    identifierRole = IdentifierRole.TopLevelDeclaration;
  } else if (isBlockScope) {
    identifierRole = IdentifierRole.BlockScopedDeclaration;
  } else {
    identifierRole = IdentifierRole.FunctionScopedDeclaration;
  }
  state.tokens[state.tokens.length - 1].identifierRole = identifierRole;
}
function parseBindingAtom(isBlockScope) {
  switch (state.type) {
    case TokenType._this: {
      const oldIsType = pushTypeContext(0);
      next();
      popTypeContext(oldIsType);
      return;
    }
    case TokenType._yield:
    case TokenType.name: {
      state.type = TokenType.name;
      parseBindingIdentifier(isBlockScope);
      return;
    }
    case TokenType.bracketL: {
      next();
      parseBindingList(
        TokenType.bracketR,
        isBlockScope,
        true
        /* allowEmpty */
      );
      return;
    }
    case TokenType.braceL:
      parseObj(true, isBlockScope);
      return;
    default:
      unexpected();
  }
}
function parseBindingList(close, isBlockScope, allowEmpty = false, allowModifiers = false, contextId = 0) {
  let first = true;
  let hasRemovedComma = false;
  const firstItemTokenIndex = state.tokens.length;
  while (!eat(close) && !state.error) {
    if (first) {
      first = false;
    } else {
      expect(TokenType.comma);
      state.tokens[state.tokens.length - 1].contextId = contextId;
      if (!hasRemovedComma && state.tokens[firstItemTokenIndex].isType) {
        state.tokens[state.tokens.length - 1].isType = true;
        hasRemovedComma = true;
      }
    }
    if (allowEmpty && match2(TokenType.comma)) {
    } else if (eat(close)) {
      break;
    } else if (match2(TokenType.ellipsis)) {
      parseRest(isBlockScope);
      parseAssignableListItemTypes();
      eat(TokenType.comma);
      expect(close);
      break;
    } else {
      parseAssignableListItem(allowModifiers, isBlockScope);
    }
  }
}
function parseAssignableListItem(allowModifiers, isBlockScope) {
  if (allowModifiers) {
    tsParseModifiers([
      ContextualKeyword._public,
      ContextualKeyword._protected,
      ContextualKeyword._private,
      ContextualKeyword._readonly,
      ContextualKeyword._override
    ]);
  }
  parseMaybeDefault(isBlockScope);
  parseAssignableListItemTypes();
  parseMaybeDefault(
    isBlockScope,
    true
    /* leftAlreadyParsed */
  );
}
function parseAssignableListItemTypes() {
  if (isFlowEnabled) {
    flowParseAssignableListItemTypes();
  } else if (isTypeScriptEnabled) {
    tsParseAssignableListItemTypes();
  }
}
function parseMaybeDefault(isBlockScope, leftAlreadyParsed = false) {
  if (!leftAlreadyParsed) {
    parseBindingAtom(isBlockScope);
  }
  if (!eat(TokenType.eq)) {
    return;
  }
  const eqIndex = state.tokens.length - 1;
  parseMaybeAssign();
  state.tokens[eqIndex].rhsEndIndex = state.tokens.length;
}

// node_modules/sucrase/dist/esm/parser/plugins/typescript.js
function tsIsIdentifier() {
  return match2(TokenType.name);
}
function isLiteralPropertyName() {
  return match2(TokenType.name) || Boolean(state.type & TokenType.IS_KEYWORD) || match2(TokenType.string) || match2(TokenType.num) || match2(TokenType.bigint) || match2(TokenType.decimal);
}
function tsNextTokenCanFollowModifier() {
  const snapshot = state.snapshot();
  next();
  const canFollowModifier = (match2(TokenType.bracketL) || match2(TokenType.braceL) || match2(TokenType.star) || match2(TokenType.ellipsis) || match2(TokenType.hash) || isLiteralPropertyName()) && !hasPrecedingLineBreak();
  if (canFollowModifier) {
    return true;
  } else {
    state.restoreFromSnapshot(snapshot);
    return false;
  }
}
function tsParseModifiers(allowedModifiers) {
  while (true) {
    const modifier = tsParseModifier(allowedModifiers);
    if (modifier === null) {
      break;
    }
  }
}
function tsParseModifier(allowedModifiers) {
  if (!match2(TokenType.name)) {
    return null;
  }
  const modifier = state.contextualKeyword;
  if (allowedModifiers.indexOf(modifier) !== -1 && tsNextTokenCanFollowModifier()) {
    switch (modifier) {
      case ContextualKeyword._readonly:
        state.tokens[state.tokens.length - 1].type = TokenType._readonly;
        break;
      case ContextualKeyword._abstract:
        state.tokens[state.tokens.length - 1].type = TokenType._abstract;
        break;
      case ContextualKeyword._static:
        state.tokens[state.tokens.length - 1].type = TokenType._static;
        break;
      case ContextualKeyword._public:
        state.tokens[state.tokens.length - 1].type = TokenType._public;
        break;
      case ContextualKeyword._private:
        state.tokens[state.tokens.length - 1].type = TokenType._private;
        break;
      case ContextualKeyword._protected:
        state.tokens[state.tokens.length - 1].type = TokenType._protected;
        break;
      case ContextualKeyword._override:
        state.tokens[state.tokens.length - 1].type = TokenType._override;
        break;
      case ContextualKeyword._declare:
        state.tokens[state.tokens.length - 1].type = TokenType._declare;
        break;
      default:
        break;
    }
    return modifier;
  }
  return null;
}
function tsParseEntityName() {
  parseIdentifier();
  while (eat(TokenType.dot)) {
    parseIdentifier();
  }
}
function tsParseTypeReference() {
  tsParseEntityName();
  if (!hasPrecedingLineBreak() && match2(TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}
function tsParseThisTypePredicate() {
  next();
  tsParseTypeAnnotation();
}
function tsParseThisTypeNode() {
  next();
}
function tsParseTypeQuery() {
  expect(TokenType._typeof);
  if (match2(TokenType._import)) {
    tsParseImportType();
  } else {
    tsParseEntityName();
  }
  if (!hasPrecedingLineBreak() && match2(TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}
function tsParseImportType() {
  expect(TokenType._import);
  expect(TokenType.parenL);
  expect(TokenType.string);
  expect(TokenType.parenR);
  if (eat(TokenType.dot)) {
    tsParseEntityName();
  }
  if (match2(TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}
function tsParseTypeParameter() {
  eat(TokenType._const);
  const hadIn = eat(TokenType._in);
  const hadOut = eatContextual(ContextualKeyword._out);
  eat(TokenType._const);
  if ((hadIn || hadOut) && !match2(TokenType.name)) {
    state.tokens[state.tokens.length - 1].type = TokenType.name;
  } else {
    parseIdentifier();
  }
  if (eat(TokenType._extends)) {
    tsParseType();
  }
  if (eat(TokenType.eq)) {
    tsParseType();
  }
}
function tsTryParseTypeParameters() {
  if (match2(TokenType.lessThan)) {
    tsParseTypeParameters();
  }
}
function tsParseTypeParameters() {
  const oldIsType = pushTypeContext(0);
  if (match2(TokenType.lessThan) || match2(TokenType.typeParameterStart)) {
    next();
  } else {
    unexpected();
  }
  while (!eat(TokenType.greaterThan) && !state.error) {
    tsParseTypeParameter();
    eat(TokenType.comma);
  }
  popTypeContext(oldIsType);
}
function tsFillSignature(returnToken) {
  const returnTokenRequired = returnToken === TokenType.arrow;
  tsTryParseTypeParameters();
  expect(TokenType.parenL);
  state.scopeDepth++;
  tsParseBindingListForSignature(
    false
    /* isBlockScope */
  );
  state.scopeDepth--;
  if (returnTokenRequired) {
    tsParseTypeOrTypePredicateAnnotation(returnToken);
  } else if (match2(returnToken)) {
    tsParseTypeOrTypePredicateAnnotation(returnToken);
  }
}
function tsParseBindingListForSignature(isBlockScope) {
  parseBindingList(TokenType.parenR, isBlockScope);
}
function tsParseTypeMemberSemicolon() {
  if (!eat(TokenType.comma)) {
    semicolon();
  }
}
function tsParseSignatureMember() {
  tsFillSignature(TokenType.colon);
  tsParseTypeMemberSemicolon();
}
function tsIsUnambiguouslyIndexSignature() {
  const snapshot = state.snapshot();
  next();
  const isIndexSignature = eat(TokenType.name) && match2(TokenType.colon);
  state.restoreFromSnapshot(snapshot);
  return isIndexSignature;
}
function tsTryParseIndexSignature() {
  if (!(match2(TokenType.bracketL) && tsIsUnambiguouslyIndexSignature())) {
    return false;
  }
  const oldIsType = pushTypeContext(0);
  expect(TokenType.bracketL);
  parseIdentifier();
  tsParseTypeAnnotation();
  expect(TokenType.bracketR);
  tsTryParseTypeAnnotation();
  tsParseTypeMemberSemicolon();
  popTypeContext(oldIsType);
  return true;
}
function tsParsePropertyOrMethodSignature(isReadonly) {
  eat(TokenType.question);
  if (!isReadonly && (match2(TokenType.parenL) || match2(TokenType.lessThan))) {
    tsFillSignature(TokenType.colon);
    tsParseTypeMemberSemicolon();
  } else {
    tsTryParseTypeAnnotation();
    tsParseTypeMemberSemicolon();
  }
}
function tsParseTypeMember() {
  if (match2(TokenType.parenL) || match2(TokenType.lessThan)) {
    tsParseSignatureMember();
    return;
  }
  if (match2(TokenType._new)) {
    next();
    if (match2(TokenType.parenL) || match2(TokenType.lessThan)) {
      tsParseSignatureMember();
    } else {
      tsParsePropertyOrMethodSignature(false);
    }
    return;
  }
  const readonly = !!tsParseModifier([ContextualKeyword._readonly]);
  const found = tsTryParseIndexSignature();
  if (found) {
    return;
  }
  if ((isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) && tsNextTokenCanFollowModifier()) {
  }
  parsePropertyName(
    -1
    /* Types don't need context IDs. */
  );
  tsParsePropertyOrMethodSignature(readonly);
}
function tsParseTypeLiteral() {
  tsParseObjectTypeMembers();
}
function tsParseObjectTypeMembers() {
  expect(TokenType.braceL);
  while (!eat(TokenType.braceR) && !state.error) {
    tsParseTypeMember();
  }
}
function tsLookaheadIsStartOfMappedType() {
  const snapshot = state.snapshot();
  const isStartOfMappedType = tsIsStartOfMappedType();
  state.restoreFromSnapshot(snapshot);
  return isStartOfMappedType;
}
function tsIsStartOfMappedType() {
  next();
  if (eat(TokenType.plus) || eat(TokenType.minus)) {
    return isContextual(ContextualKeyword._readonly);
  }
  if (isContextual(ContextualKeyword._readonly)) {
    next();
  }
  if (!match2(TokenType.bracketL)) {
    return false;
  }
  next();
  if (!tsIsIdentifier()) {
    return false;
  }
  next();
  return match2(TokenType._in);
}
function tsParseMappedTypeParameter() {
  parseIdentifier();
  expect(TokenType._in);
  tsParseType();
}
function tsParseMappedType() {
  expect(TokenType.braceL);
  if (match2(TokenType.plus) || match2(TokenType.minus)) {
    next();
    expectContextual(ContextualKeyword._readonly);
  } else {
    eatContextual(ContextualKeyword._readonly);
  }
  expect(TokenType.bracketL);
  tsParseMappedTypeParameter();
  if (eatContextual(ContextualKeyword._as)) {
    tsParseType();
  }
  expect(TokenType.bracketR);
  if (match2(TokenType.plus) || match2(TokenType.minus)) {
    next();
    expect(TokenType.question);
  } else {
    eat(TokenType.question);
  }
  tsTryParseType();
  semicolon();
  expect(TokenType.braceR);
}
function tsParseTupleType() {
  expect(TokenType.bracketL);
  while (!eat(TokenType.bracketR) && !state.error) {
    tsParseTupleElementType();
    eat(TokenType.comma);
  }
}
function tsParseTupleElementType() {
  if (eat(TokenType.ellipsis)) {
    tsParseType();
  } else {
    tsParseType();
    eat(TokenType.question);
  }
  if (eat(TokenType.colon)) {
    tsParseType();
  }
}
function tsParseParenthesizedType() {
  expect(TokenType.parenL);
  tsParseType();
  expect(TokenType.parenR);
}
function tsParseTemplateLiteralType() {
  nextTemplateToken();
  nextTemplateToken();
  while (!match2(TokenType.backQuote) && !state.error) {
    expect(TokenType.dollarBraceL);
    tsParseType();
    nextTemplateToken();
    nextTemplateToken();
  }
  next();
}
var FunctionType;
(function(FunctionType2) {
  const TSFunctionType = 0;
  FunctionType2[FunctionType2["TSFunctionType"] = TSFunctionType] = "TSFunctionType";
  const TSConstructorType = TSFunctionType + 1;
  FunctionType2[FunctionType2["TSConstructorType"] = TSConstructorType] = "TSConstructorType";
  const TSAbstractConstructorType = TSConstructorType + 1;
  FunctionType2[FunctionType2["TSAbstractConstructorType"] = TSAbstractConstructorType] = "TSAbstractConstructorType";
})(FunctionType || (FunctionType = {}));
function tsParseFunctionOrConstructorType(type) {
  if (type === FunctionType.TSAbstractConstructorType) {
    expectContextual(ContextualKeyword._abstract);
  }
  if (type === FunctionType.TSConstructorType || type === FunctionType.TSAbstractConstructorType) {
    expect(TokenType._new);
  }
  const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;
  state.inDisallowConditionalTypesContext = false;
  tsFillSignature(TokenType.arrow);
  state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
}
function tsParseNonArrayType() {
  switch (state.type) {
    case TokenType.name:
      tsParseTypeReference();
      return;
    case TokenType._void:
    case TokenType._null:
      next();
      return;
    case TokenType.string:
    case TokenType.num:
    case TokenType.bigint:
    case TokenType.decimal:
    case TokenType._true:
    case TokenType._false:
      parseLiteral();
      return;
    case TokenType.minus:
      next();
      parseLiteral();
      return;
    case TokenType._this: {
      tsParseThisTypeNode();
      if (isContextual(ContextualKeyword._is) && !hasPrecedingLineBreak()) {
        tsParseThisTypePredicate();
      }
      return;
    }
    case TokenType._typeof:
      tsParseTypeQuery();
      return;
    case TokenType._import:
      tsParseImportType();
      return;
    case TokenType.braceL:
      if (tsLookaheadIsStartOfMappedType()) {
        tsParseMappedType();
      } else {
        tsParseTypeLiteral();
      }
      return;
    case TokenType.bracketL:
      tsParseTupleType();
      return;
    case TokenType.parenL:
      tsParseParenthesizedType();
      return;
    case TokenType.backQuote:
      tsParseTemplateLiteralType();
      return;
    default:
      if (state.type & TokenType.IS_KEYWORD) {
        next();
        state.tokens[state.tokens.length - 1].type = TokenType.name;
        return;
      }
      break;
  }
  unexpected();
}
function tsParseArrayTypeOrHigher() {
  tsParseNonArrayType();
  while (!hasPrecedingLineBreak() && eat(TokenType.bracketL)) {
    if (!eat(TokenType.bracketR)) {
      tsParseType();
      expect(TokenType.bracketR);
    }
  }
}
function tsParseInferType() {
  expectContextual(ContextualKeyword._infer);
  parseIdentifier();
  if (match2(TokenType._extends)) {
    const snapshot = state.snapshot();
    expect(TokenType._extends);
    const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;
    state.inDisallowConditionalTypesContext = true;
    tsParseType();
    state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
    if (state.error || !state.inDisallowConditionalTypesContext && match2(TokenType.question)) {
      state.restoreFromSnapshot(snapshot);
    }
  }
}
function tsParseTypeOperatorOrHigher() {
  if (isContextual(ContextualKeyword._keyof) || isContextual(ContextualKeyword._unique) || isContextual(ContextualKeyword._readonly)) {
    next();
    tsParseTypeOperatorOrHigher();
  } else if (isContextual(ContextualKeyword._infer)) {
    tsParseInferType();
  } else {
    const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;
    state.inDisallowConditionalTypesContext = false;
    tsParseArrayTypeOrHigher();
    state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
  }
}
function tsParseIntersectionTypeOrHigher() {
  eat(TokenType.bitwiseAND);
  tsParseTypeOperatorOrHigher();
  if (match2(TokenType.bitwiseAND)) {
    while (eat(TokenType.bitwiseAND)) {
      tsParseTypeOperatorOrHigher();
    }
  }
}
function tsParseUnionTypeOrHigher() {
  eat(TokenType.bitwiseOR);
  tsParseIntersectionTypeOrHigher();
  if (match2(TokenType.bitwiseOR)) {
    while (eat(TokenType.bitwiseOR)) {
      tsParseIntersectionTypeOrHigher();
    }
  }
}
function tsIsStartOfFunctionType() {
  if (match2(TokenType.lessThan)) {
    return true;
  }
  return match2(TokenType.parenL) && tsLookaheadIsUnambiguouslyStartOfFunctionType();
}
function tsSkipParameterStart() {
  if (match2(TokenType.name) || match2(TokenType._this)) {
    next();
    return true;
  }
  if (match2(TokenType.braceL) || match2(TokenType.bracketL)) {
    let depth = 1;
    next();
    while (depth > 0 && !state.error) {
      if (match2(TokenType.braceL) || match2(TokenType.bracketL)) {
        depth++;
      } else if (match2(TokenType.braceR) || match2(TokenType.bracketR)) {
        depth--;
      }
      next();
    }
    return true;
  }
  return false;
}
function tsLookaheadIsUnambiguouslyStartOfFunctionType() {
  const snapshot = state.snapshot();
  const isUnambiguouslyStartOfFunctionType = tsIsUnambiguouslyStartOfFunctionType();
  state.restoreFromSnapshot(snapshot);
  return isUnambiguouslyStartOfFunctionType;
}
function tsIsUnambiguouslyStartOfFunctionType() {
  next();
  if (match2(TokenType.parenR) || match2(TokenType.ellipsis)) {
    return true;
  }
  if (tsSkipParameterStart()) {
    if (match2(TokenType.colon) || match2(TokenType.comma) || match2(TokenType.question) || match2(TokenType.eq)) {
      return true;
    }
    if (match2(TokenType.parenR)) {
      next();
      if (match2(TokenType.arrow)) {
        return true;
      }
    }
  }
  return false;
}
function tsParseTypeOrTypePredicateAnnotation(returnToken) {
  const oldIsType = pushTypeContext(0);
  expect(returnToken);
  const finishedReturn = tsParseTypePredicateOrAssertsPrefix();
  if (!finishedReturn) {
    tsParseType();
  }
  popTypeContext(oldIsType);
}
function tsTryParseTypeOrTypePredicateAnnotation() {
  if (match2(TokenType.colon)) {
    tsParseTypeOrTypePredicateAnnotation(TokenType.colon);
  }
}
function tsTryParseTypeAnnotation() {
  if (match2(TokenType.colon)) {
    tsParseTypeAnnotation();
  }
}
function tsTryParseType() {
  if (eat(TokenType.colon)) {
    tsParseType();
  }
}
function tsParseTypePredicateOrAssertsPrefix() {
  const snapshot = state.snapshot();
  if (isContextual(ContextualKeyword._asserts)) {
    next();
    if (eatContextual(ContextualKeyword._is)) {
      tsParseType();
      return true;
    } else if (tsIsIdentifier() || match2(TokenType._this)) {
      next();
      if (eatContextual(ContextualKeyword._is)) {
        tsParseType();
      }
      return true;
    } else {
      state.restoreFromSnapshot(snapshot);
      return false;
    }
  } else if (tsIsIdentifier() || match2(TokenType._this)) {
    next();
    if (isContextual(ContextualKeyword._is) && !hasPrecedingLineBreak()) {
      next();
      tsParseType();
      return true;
    } else {
      state.restoreFromSnapshot(snapshot);
      return false;
    }
  }
  return false;
}
function tsParseTypeAnnotation() {
  const oldIsType = pushTypeContext(0);
  expect(TokenType.colon);
  tsParseType();
  popTypeContext(oldIsType);
}
function tsParseType() {
  tsParseNonConditionalType();
  if (state.inDisallowConditionalTypesContext || hasPrecedingLineBreak() || !eat(TokenType._extends)) {
    return;
  }
  const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;
  state.inDisallowConditionalTypesContext = true;
  tsParseNonConditionalType();
  state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
  expect(TokenType.question);
  tsParseType();
  expect(TokenType.colon);
  tsParseType();
}
function isAbstractConstructorSignature() {
  return isContextual(ContextualKeyword._abstract) && lookaheadType() === TokenType._new;
}
function tsParseNonConditionalType() {
  if (tsIsStartOfFunctionType()) {
    tsParseFunctionOrConstructorType(FunctionType.TSFunctionType);
    return;
  }
  if (match2(TokenType._new)) {
    tsParseFunctionOrConstructorType(FunctionType.TSConstructorType);
    return;
  } else if (isAbstractConstructorSignature()) {
    tsParseFunctionOrConstructorType(FunctionType.TSAbstractConstructorType);
    return;
  }
  tsParseUnionTypeOrHigher();
}
function tsParseTypeAssertion() {
  const oldIsType = pushTypeContext(1);
  tsParseType();
  expect(TokenType.greaterThan);
  popTypeContext(oldIsType);
  parseMaybeUnary();
}
function tsTryParseJSXTypeArgument() {
  if (eat(TokenType.jsxTagStart)) {
    state.tokens[state.tokens.length - 1].type = TokenType.typeParameterStart;
    const oldIsType = pushTypeContext(1);
    while (!match2(TokenType.greaterThan) && !state.error) {
      tsParseType();
      eat(TokenType.comma);
    }
    nextJSXTagToken();
    popTypeContext(oldIsType);
  }
}
function tsParseHeritageClause() {
  while (!match2(TokenType.braceL) && !state.error) {
    tsParseExpressionWithTypeArguments();
    eat(TokenType.comma);
  }
}
function tsParseExpressionWithTypeArguments() {
  tsParseEntityName();
  if (match2(TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}
function tsParseInterfaceDeclaration() {
  parseBindingIdentifier(false);
  tsTryParseTypeParameters();
  if (eat(TokenType._extends)) {
    tsParseHeritageClause();
  }
  tsParseObjectTypeMembers();
}
function tsParseTypeAliasDeclaration() {
  parseBindingIdentifier(false);
  tsTryParseTypeParameters();
  expect(TokenType.eq);
  tsParseType();
  semicolon();
}
function tsParseEnumMember() {
  if (match2(TokenType.string)) {
    parseLiteral();
  } else {
    parseIdentifier();
  }
  if (eat(TokenType.eq)) {
    const eqIndex = state.tokens.length - 1;
    parseMaybeAssign();
    state.tokens[eqIndex].rhsEndIndex = state.tokens.length;
  }
}
function tsParseEnumDeclaration() {
  parseBindingIdentifier(false);
  expect(TokenType.braceL);
  while (!eat(TokenType.braceR) && !state.error) {
    tsParseEnumMember();
    eat(TokenType.comma);
  }
}
function tsParseModuleBlock() {
  expect(TokenType.braceL);
  parseBlockBody(
    /* end */
    TokenType.braceR
  );
}
function tsParseModuleOrNamespaceDeclaration() {
  parseBindingIdentifier(false);
  if (eat(TokenType.dot)) {
    tsParseModuleOrNamespaceDeclaration();
  } else {
    tsParseModuleBlock();
  }
}
function tsParseAmbientExternalModuleDeclaration() {
  if (isContextual(ContextualKeyword._global)) {
    parseIdentifier();
  } else if (match2(TokenType.string)) {
    parseExprAtom();
  } else {
    unexpected();
  }
  if (match2(TokenType.braceL)) {
    tsParseModuleBlock();
  } else {
    semicolon();
  }
}
function tsParseImportEqualsDeclaration() {
  parseImportedIdentifier();
  expect(TokenType.eq);
  tsParseModuleReference();
  semicolon();
}
function tsIsExternalModuleReference() {
  return isContextual(ContextualKeyword._require) && lookaheadType() === TokenType.parenL;
}
function tsParseModuleReference() {
  if (tsIsExternalModuleReference()) {
    tsParseExternalModuleReference();
  } else {
    tsParseEntityName();
  }
}
function tsParseExternalModuleReference() {
  expectContextual(ContextualKeyword._require);
  expect(TokenType.parenL);
  if (!match2(TokenType.string)) {
    unexpected();
  }
  parseLiteral();
  expect(TokenType.parenR);
}
function tsTryParseDeclare() {
  if (isLineTerminator()) {
    return false;
  }
  switch (state.type) {
    case TokenType._function: {
      const oldIsType = pushTypeContext(1);
      next();
      const functionStart = state.start;
      parseFunction(
        functionStart,
        /* isStatement */
        true
      );
      popTypeContext(oldIsType);
      return true;
    }
    case TokenType._class: {
      const oldIsType = pushTypeContext(1);
      parseClass(
        /* isStatement */
        true,
        /* optionalId */
        false
      );
      popTypeContext(oldIsType);
      return true;
    }
    case TokenType._const: {
      if (match2(TokenType._const) && isLookaheadContextual(ContextualKeyword._enum)) {
        const oldIsType = pushTypeContext(1);
        expect(TokenType._const);
        expectContextual(ContextualKeyword._enum);
        state.tokens[state.tokens.length - 1].type = TokenType._enum;
        tsParseEnumDeclaration();
        popTypeContext(oldIsType);
        return true;
      }
    }
    // falls through
    case TokenType._var:
    case TokenType._let: {
      const oldIsType = pushTypeContext(1);
      parseVarStatement(state.type !== TokenType._var);
      popTypeContext(oldIsType);
      return true;
    }
    case TokenType.name: {
      const oldIsType = pushTypeContext(1);
      const contextualKeyword = state.contextualKeyword;
      let matched = false;
      if (contextualKeyword === ContextualKeyword._global) {
        tsParseAmbientExternalModuleDeclaration();
        matched = true;
      } else {
        matched = tsParseDeclaration(
          contextualKeyword,
          /* isBeforeToken */
          true
        );
      }
      popTypeContext(oldIsType);
      return matched;
    }
    default:
      return false;
  }
}
function tsTryParseExportDeclaration() {
  return tsParseDeclaration(
    state.contextualKeyword,
    /* isBeforeToken */
    true
  );
}
function tsParseExpressionStatement(contextualKeyword) {
  switch (contextualKeyword) {
    case ContextualKeyword._declare: {
      const declareTokenIndex = state.tokens.length - 1;
      const matched = tsTryParseDeclare();
      if (matched) {
        state.tokens[declareTokenIndex].type = TokenType._declare;
        return true;
      }
      break;
    }
    case ContextualKeyword._global:
      if (match2(TokenType.braceL)) {
        tsParseModuleBlock();
        return true;
      }
      break;
    default:
      return tsParseDeclaration(
        contextualKeyword,
        /* isBeforeToken */
        false
      );
  }
  return false;
}
function tsParseDeclaration(contextualKeyword, isBeforeToken) {
  switch (contextualKeyword) {
    case ContextualKeyword._abstract:
      if (tsCheckLineTerminator(isBeforeToken) && match2(TokenType._class)) {
        state.tokens[state.tokens.length - 1].type = TokenType._abstract;
        parseClass(
          /* isStatement */
          true,
          /* optionalId */
          false
        );
        return true;
      }
      break;
    case ContextualKeyword._enum:
      if (tsCheckLineTerminator(isBeforeToken) && match2(TokenType.name)) {
        state.tokens[state.tokens.length - 1].type = TokenType._enum;
        tsParseEnumDeclaration();
        return true;
      }
      break;
    case ContextualKeyword._interface:
      if (tsCheckLineTerminator(isBeforeToken) && match2(TokenType.name)) {
        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);
        tsParseInterfaceDeclaration();
        popTypeContext(oldIsType);
        return true;
      }
      break;
    case ContextualKeyword._module:
      if (tsCheckLineTerminator(isBeforeToken)) {
        if (match2(TokenType.string)) {
          const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);
          tsParseAmbientExternalModuleDeclaration();
          popTypeContext(oldIsType);
          return true;
        } else if (match2(TokenType.name)) {
          const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);
          tsParseModuleOrNamespaceDeclaration();
          popTypeContext(oldIsType);
          return true;
        }
      }
      break;
    case ContextualKeyword._namespace:
      if (tsCheckLineTerminator(isBeforeToken) && match2(TokenType.name)) {
        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);
        tsParseModuleOrNamespaceDeclaration();
        popTypeContext(oldIsType);
        return true;
      }
      break;
    case ContextualKeyword._type:
      if (tsCheckLineTerminator(isBeforeToken) && match2(TokenType.name)) {
        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);
        tsParseTypeAliasDeclaration();
        popTypeContext(oldIsType);
        return true;
      }
      break;
    default:
      break;
  }
  return false;
}
function tsCheckLineTerminator(isBeforeToken) {
  if (isBeforeToken) {
    next();
    return true;
  } else {
    return !isLineTerminator();
  }
}
function tsTryParseGenericAsyncArrowFunction() {
  const snapshot = state.snapshot();
  tsParseTypeParameters();
  parseFunctionParams();
  tsTryParseTypeOrTypePredicateAnnotation();
  expect(TokenType.arrow);
  if (state.error) {
    state.restoreFromSnapshot(snapshot);
    return false;
  }
  parseFunctionBody(true);
  return true;
}
function tsParseTypeArgumentsWithPossibleBitshift() {
  if (state.type === TokenType.bitShiftL) {
    state.pos -= 1;
    finishToken(TokenType.lessThan);
  }
  tsParseTypeArguments();
}
function tsParseTypeArguments() {
  const oldIsType = pushTypeContext(0);
  expect(TokenType.lessThan);
  while (!match2(TokenType.greaterThan) && !state.error) {
    tsParseType();
    eat(TokenType.comma);
  }
  if (!oldIsType) {
    popTypeContext(oldIsType);
    rescan_gt();
    expect(TokenType.greaterThan);
    state.tokens[state.tokens.length - 1].isType = true;
  } else {
    expect(TokenType.greaterThan);
    popTypeContext(oldIsType);
  }
}
function tsIsDeclarationStart() {
  if (match2(TokenType.name)) {
    switch (state.contextualKeyword) {
      case ContextualKeyword._abstract:
      case ContextualKeyword._declare:
      case ContextualKeyword._enum:
      case ContextualKeyword._interface:
      case ContextualKeyword._module:
      case ContextualKeyword._namespace:
      case ContextualKeyword._type:
        return true;
      default:
        break;
    }
  }
  return false;
}
function tsParseFunctionBodyAndFinish(functionStart, funcContextId) {
  if (match2(TokenType.colon)) {
    tsParseTypeOrTypePredicateAnnotation(TokenType.colon);
  }
  if (!match2(TokenType.braceL) && isLineTerminator()) {
    let i4 = state.tokens.length - 1;
    while (i4 >= 0 && (state.tokens[i4].start >= functionStart || state.tokens[i4].type === TokenType._default || state.tokens[i4].type === TokenType._export)) {
      state.tokens[i4].isType = true;
      i4--;
    }
    return;
  }
  parseFunctionBody(false, funcContextId);
}
function tsParseSubscript(startTokenIndex, noCalls, stopState) {
  if (!hasPrecedingLineBreak() && eat(TokenType.bang)) {
    state.tokens[state.tokens.length - 1].type = TokenType.nonNullAssertion;
    return;
  }
  if (match2(TokenType.lessThan) || match2(TokenType.bitShiftL)) {
    const snapshot = state.snapshot();
    if (!noCalls && atPossibleAsync()) {
      const asyncArrowFn = tsTryParseGenericAsyncArrowFunction();
      if (asyncArrowFn) {
        return;
      }
    }
    tsParseTypeArgumentsWithPossibleBitshift();
    if (!noCalls && eat(TokenType.parenL)) {
      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
      parseCallExpressionArguments();
    } else if (match2(TokenType.backQuote)) {
      parseTemplate();
    } else if (
      // The remaining possible case is an instantiation expression, e.g.
      // Array<number> . Check for a few cases that would disqualify it and
      // cause us to bail out.
      // a<b>>c is not (a<b>)>c, but a<(b>>c)
      state.type === TokenType.greaterThan || // a<b>c is (a<b)>c
      state.type !== TokenType.parenL && Boolean(state.type & TokenType.IS_EXPRESSION_START) && !hasPrecedingLineBreak()
    ) {
      unexpected();
    }
    if (state.error) {
      state.restoreFromSnapshot(snapshot);
    } else {
      return;
    }
  } else if (!noCalls && match2(TokenType.questionDot) && lookaheadType() === TokenType.lessThan) {
    next();
    state.tokens[startTokenIndex].isOptionalChainStart = true;
    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    tsParseTypeArguments();
    expect(TokenType.parenL);
    parseCallExpressionArguments();
  }
  baseParseSubscript(startTokenIndex, noCalls, stopState);
}
function tsTryParseExport() {
  if (eat(TokenType._import)) {
    if (isContextual(ContextualKeyword._type) && lookaheadType() !== TokenType.eq) {
      expectContextual(ContextualKeyword._type);
    }
    tsParseImportEqualsDeclaration();
    return true;
  } else if (eat(TokenType.eq)) {
    parseExpression();
    semicolon();
    return true;
  } else if (eatContextual(ContextualKeyword._as)) {
    expectContextual(ContextualKeyword._namespace);
    parseIdentifier();
    semicolon();
    return true;
  } else {
    if (isContextual(ContextualKeyword._type)) {
      const nextType = lookaheadType();
      if (nextType === TokenType.braceL || nextType === TokenType.star) {
        next();
      }
    }
    return false;
  }
}
function tsParseImportSpecifier() {
  parseIdentifier();
  if (match2(TokenType.comma) || match2(TokenType.braceR)) {
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;
    return;
  }
  parseIdentifier();
  if (match2(TokenType.comma) || match2(TokenType.braceR)) {
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;
    state.tokens[state.tokens.length - 2].isType = true;
    state.tokens[state.tokens.length - 1].isType = true;
    return;
  }
  parseIdentifier();
  if (match2(TokenType.comma) || match2(TokenType.braceR)) {
    state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ImportAccess;
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;
    return;
  }
  parseIdentifier();
  state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ImportAccess;
  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;
  state.tokens[state.tokens.length - 4].isType = true;
  state.tokens[state.tokens.length - 3].isType = true;
  state.tokens[state.tokens.length - 2].isType = true;
  state.tokens[state.tokens.length - 1].isType = true;
}
function tsParseExportSpecifier() {
  parseIdentifier();
  if (match2(TokenType.comma) || match2(TokenType.braceR)) {
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;
    return;
  }
  parseIdentifier();
  if (match2(TokenType.comma) || match2(TokenType.braceR)) {
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;
    state.tokens[state.tokens.length - 2].isType = true;
    state.tokens[state.tokens.length - 1].isType = true;
    return;
  }
  parseIdentifier();
  if (match2(TokenType.comma) || match2(TokenType.braceR)) {
    state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ExportAccess;
    return;
  }
  parseIdentifier();
  state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ExportAccess;
  state.tokens[state.tokens.length - 4].isType = true;
  state.tokens[state.tokens.length - 3].isType = true;
  state.tokens[state.tokens.length - 2].isType = true;
  state.tokens[state.tokens.length - 1].isType = true;
}
function tsTryParseExportDefaultExpression() {
  if (isContextual(ContextualKeyword._abstract) && lookaheadType() === TokenType._class) {
    state.type = TokenType._abstract;
    next();
    parseClass(true, true);
    return true;
  }
  if (isContextual(ContextualKeyword._interface)) {
    const oldIsType = pushTypeContext(2);
    tsParseDeclaration(ContextualKeyword._interface, true);
    popTypeContext(oldIsType);
    return true;
  }
  return false;
}
function tsTryParseStatementContent() {
  if (state.type === TokenType._const) {
    const ahead = lookaheadTypeAndKeyword();
    if (ahead.type === TokenType.name && ahead.contextualKeyword === ContextualKeyword._enum) {
      expect(TokenType._const);
      expectContextual(ContextualKeyword._enum);
      state.tokens[state.tokens.length - 1].type = TokenType._enum;
      tsParseEnumDeclaration();
      return true;
    }
  }
  return false;
}
function tsTryParseClassMemberWithIsStatic(isStatic) {
  const memberStartIndexAfterStatic = state.tokens.length;
  tsParseModifiers([
    ContextualKeyword._abstract,
    ContextualKeyword._readonly,
    ContextualKeyword._declare,
    ContextualKeyword._static,
    ContextualKeyword._override
  ]);
  const modifiersEndIndex = state.tokens.length;
  const found = tsTryParseIndexSignature();
  if (found) {
    const memberStartIndex = isStatic ? memberStartIndexAfterStatic - 1 : memberStartIndexAfterStatic;
    for (let i4 = memberStartIndex; i4 < modifiersEndIndex; i4++) {
      state.tokens[i4].isType = true;
    }
    return true;
  }
  return false;
}
function tsParseIdentifierStatement(contextualKeyword) {
  const matched = tsParseExpressionStatement(contextualKeyword);
  if (!matched) {
    semicolon();
  }
}
function tsParseExportDeclaration() {
  const isDeclare = eatContextual(ContextualKeyword._declare);
  if (isDeclare) {
    state.tokens[state.tokens.length - 1].type = TokenType._declare;
  }
  let matchedDeclaration = false;
  if (match2(TokenType.name)) {
    if (isDeclare) {
      const oldIsType = pushTypeContext(2);
      matchedDeclaration = tsTryParseExportDeclaration();
      popTypeContext(oldIsType);
    } else {
      matchedDeclaration = tsTryParseExportDeclaration();
    }
  }
  if (!matchedDeclaration) {
    if (isDeclare) {
      const oldIsType = pushTypeContext(2);
      parseStatement(true);
      popTypeContext(oldIsType);
    } else {
      parseStatement(true);
    }
  }
}
function tsAfterParseClassSuper(hasSuper) {
  if (hasSuper && (match2(TokenType.lessThan) || match2(TokenType.bitShiftL))) {
    tsParseTypeArgumentsWithPossibleBitshift();
  }
  if (eatContextual(ContextualKeyword._implements)) {
    state.tokens[state.tokens.length - 1].type = TokenType._implements;
    const oldIsType = pushTypeContext(1);
    tsParseHeritageClause();
    popTypeContext(oldIsType);
  }
}
function tsStartParseObjPropValue() {
  tsTryParseTypeParameters();
}
function tsStartParseFunctionParams() {
  tsTryParseTypeParameters();
}
function tsAfterParseVarHead() {
  const oldIsType = pushTypeContext(0);
  if (!hasPrecedingLineBreak()) {
    eat(TokenType.bang);
  }
  tsTryParseTypeAnnotation();
  popTypeContext(oldIsType);
}
function tsStartParseAsyncArrowFromCallExpression() {
  if (match2(TokenType.colon)) {
    tsParseTypeAnnotation();
  }
}
function tsParseMaybeAssign(noIn, isWithinParens) {
  if (isJSXEnabled) {
    return tsParseMaybeAssignWithJSX(noIn, isWithinParens);
  } else {
    return tsParseMaybeAssignWithoutJSX(noIn, isWithinParens);
  }
}
function tsParseMaybeAssignWithJSX(noIn, isWithinParens) {
  if (!match2(TokenType.lessThan)) {
    return baseParseMaybeAssign(noIn, isWithinParens);
  }
  const snapshot = state.snapshot();
  let wasArrow = baseParseMaybeAssign(noIn, isWithinParens);
  if (state.error) {
    state.restoreFromSnapshot(snapshot);
  } else {
    return wasArrow;
  }
  state.type = TokenType.typeParameterStart;
  tsParseTypeParameters();
  wasArrow = baseParseMaybeAssign(noIn, isWithinParens);
  if (!wasArrow) {
    unexpected();
  }
  return wasArrow;
}
function tsParseMaybeAssignWithoutJSX(noIn, isWithinParens) {
  if (!match2(TokenType.lessThan)) {
    return baseParseMaybeAssign(noIn, isWithinParens);
  }
  const snapshot = state.snapshot();
  tsParseTypeParameters();
  const wasArrow = baseParseMaybeAssign(noIn, isWithinParens);
  if (!wasArrow) {
    unexpected();
  }
  if (state.error) {
    state.restoreFromSnapshot(snapshot);
  } else {
    return wasArrow;
  }
  return baseParseMaybeAssign(noIn, isWithinParens);
}
function tsParseArrow() {
  if (match2(TokenType.colon)) {
    const snapshot = state.snapshot();
    tsParseTypeOrTypePredicateAnnotation(TokenType.colon);
    if (canInsertSemicolon()) unexpected();
    if (!match2(TokenType.arrow)) unexpected();
    if (state.error) {
      state.restoreFromSnapshot(snapshot);
    }
  }
  return eat(TokenType.arrow);
}
function tsParseAssignableListItemTypes() {
  const oldIsType = pushTypeContext(0);
  eat(TokenType.question);
  tsTryParseTypeAnnotation();
  popTypeContext(oldIsType);
}
function tsParseMaybeDecoratorArguments() {
  if (match2(TokenType.lessThan) || match2(TokenType.bitShiftL)) {
    tsParseTypeArgumentsWithPossibleBitshift();
  }
  baseParseMaybeDecoratorArguments();
}

// node_modules/sucrase/dist/esm/parser/plugins/jsx/index.js
function jsxReadToken() {
  let sawNewline = false;
  let sawNonWhitespace = false;
  while (true) {
    if (state.pos >= input.length) {
      unexpected("Unterminated JSX contents");
      return;
    }
    const ch = input.charCodeAt(state.pos);
    if (ch === charCodes.lessThan || ch === charCodes.leftCurlyBrace) {
      if (state.pos === state.start) {
        if (ch === charCodes.lessThan) {
          state.pos++;
          finishToken(TokenType.jsxTagStart);
          return;
        }
        getTokenFromCode(ch);
        return;
      }
      if (sawNewline && !sawNonWhitespace) {
        finishToken(TokenType.jsxEmptyText);
      } else {
        finishToken(TokenType.jsxText);
      }
      return;
    }
    if (ch === charCodes.lineFeed) {
      sawNewline = true;
    } else if (ch !== charCodes.space && ch !== charCodes.carriageReturn && ch !== charCodes.tab) {
      sawNonWhitespace = true;
    }
    state.pos++;
  }
}
function jsxReadString(quote) {
  state.pos++;
  for (; ; ) {
    if (state.pos >= input.length) {
      unexpected("Unterminated string constant");
      return;
    }
    const ch = input.charCodeAt(state.pos);
    if (ch === quote) {
      state.pos++;
      break;
    }
    state.pos++;
  }
  finishToken(TokenType.string);
}
function jsxReadWord() {
  let ch;
  do {
    if (state.pos > input.length) {
      unexpected("Unexpectedly reached the end of input.");
      return;
    }
    ch = input.charCodeAt(++state.pos);
  } while (IS_IDENTIFIER_CHAR[ch] || ch === charCodes.dash);
  finishToken(TokenType.jsxName);
}
function jsxParseIdentifier() {
  nextJSXTagToken();
}
function jsxParseNamespacedName(identifierRole) {
  jsxParseIdentifier();
  if (!eat(TokenType.colon)) {
    state.tokens[state.tokens.length - 1].identifierRole = identifierRole;
    return;
  }
  jsxParseIdentifier();
}
function jsxParseElementName() {
  const firstTokenIndex = state.tokens.length;
  jsxParseNamespacedName(IdentifierRole.Access);
  let hadDot = false;
  while (match2(TokenType.dot)) {
    hadDot = true;
    nextJSXTagToken();
    jsxParseIdentifier();
  }
  if (!hadDot) {
    const firstToken = state.tokens[firstTokenIndex];
    const firstChar = input.charCodeAt(firstToken.start);
    if (firstChar >= charCodes.lowercaseA && firstChar <= charCodes.lowercaseZ) {
      firstToken.identifierRole = null;
    }
  }
}
function jsxParseAttributeValue() {
  switch (state.type) {
    case TokenType.braceL:
      next();
      parseExpression();
      nextJSXTagToken();
      return;
    case TokenType.jsxTagStart:
      jsxParseElement();
      nextJSXTagToken();
      return;
    case TokenType.string:
      nextJSXTagToken();
      return;
    default:
      unexpected("JSX value should be either an expression or a quoted JSX text");
  }
}
function jsxParseSpreadChild() {
  expect(TokenType.ellipsis);
  parseExpression();
}
function jsxParseOpeningElement(initialTokenIndex) {
  if (match2(TokenType.jsxTagEnd)) {
    return false;
  }
  jsxParseElementName();
  if (isTypeScriptEnabled) {
    tsTryParseJSXTypeArgument();
  }
  let hasSeenPropSpread = false;
  while (!match2(TokenType.slash) && !match2(TokenType.jsxTagEnd) && !state.error) {
    if (eat(TokenType.braceL)) {
      hasSeenPropSpread = true;
      expect(TokenType.ellipsis);
      parseMaybeAssign();
      nextJSXTagToken();
      continue;
    }
    if (hasSeenPropSpread && state.end - state.start === 3 && input.charCodeAt(state.start) === charCodes.lowercaseK && input.charCodeAt(state.start + 1) === charCodes.lowercaseE && input.charCodeAt(state.start + 2) === charCodes.lowercaseY) {
      state.tokens[initialTokenIndex].jsxRole = JSXRole.KeyAfterPropSpread;
    }
    jsxParseNamespacedName(IdentifierRole.ObjectKey);
    if (match2(TokenType.eq)) {
      nextJSXTagToken();
      jsxParseAttributeValue();
    }
  }
  const isSelfClosing = match2(TokenType.slash);
  if (isSelfClosing) {
    nextJSXTagToken();
  }
  return isSelfClosing;
}
function jsxParseClosingElement() {
  if (match2(TokenType.jsxTagEnd)) {
    return;
  }
  jsxParseElementName();
}
function jsxParseElementAt() {
  const initialTokenIndex = state.tokens.length - 1;
  state.tokens[initialTokenIndex].jsxRole = JSXRole.NoChildren;
  let numExplicitChildren = 0;
  const isSelfClosing = jsxParseOpeningElement(initialTokenIndex);
  if (!isSelfClosing) {
    nextJSXExprToken();
    while (true) {
      switch (state.type) {
        case TokenType.jsxTagStart:
          nextJSXTagToken();
          if (match2(TokenType.slash)) {
            nextJSXTagToken();
            jsxParseClosingElement();
            if (state.tokens[initialTokenIndex].jsxRole !== JSXRole.KeyAfterPropSpread) {
              if (numExplicitChildren === 1) {
                state.tokens[initialTokenIndex].jsxRole = JSXRole.OneChild;
              } else if (numExplicitChildren > 1) {
                state.tokens[initialTokenIndex].jsxRole = JSXRole.StaticChildren;
              }
            }
            return;
          }
          numExplicitChildren++;
          jsxParseElementAt();
          nextJSXExprToken();
          break;
        case TokenType.jsxText:
          numExplicitChildren++;
          nextJSXExprToken();
          break;
        case TokenType.jsxEmptyText:
          nextJSXExprToken();
          break;
        case TokenType.braceL:
          next();
          if (match2(TokenType.ellipsis)) {
            jsxParseSpreadChild();
            nextJSXExprToken();
            numExplicitChildren += 2;
          } else {
            if (!match2(TokenType.braceR)) {
              numExplicitChildren++;
              parseExpression();
            }
            nextJSXExprToken();
          }
          break;
        // istanbul ignore next - should never happen
        default:
          unexpected();
          return;
      }
    }
  }
}
function jsxParseElement() {
  nextJSXTagToken();
  jsxParseElementAt();
}
function nextJSXTagToken() {
  state.tokens.push(new Token());
  skipSpace();
  state.start = state.pos;
  const code = input.charCodeAt(state.pos);
  if (IS_IDENTIFIER_START[code]) {
    jsxReadWord();
  } else if (code === charCodes.quotationMark || code === charCodes.apostrophe) {
    jsxReadString(code);
  } else {
    ++state.pos;
    switch (code) {
      case charCodes.greaterThan:
        finishToken(TokenType.jsxTagEnd);
        break;
      case charCodes.lessThan:
        finishToken(TokenType.jsxTagStart);
        break;
      case charCodes.slash:
        finishToken(TokenType.slash);
        break;
      case charCodes.equalsTo:
        finishToken(TokenType.eq);
        break;
      case charCodes.leftCurlyBrace:
        finishToken(TokenType.braceL);
        break;
      case charCodes.dot:
        finishToken(TokenType.dot);
        break;
      case charCodes.colon:
        finishToken(TokenType.colon);
        break;
      default:
        unexpected();
    }
  }
}
function nextJSXExprToken() {
  state.tokens.push(new Token());
  state.start = state.pos;
  jsxReadToken();
}

// node_modules/sucrase/dist/esm/parser/plugins/types.js
function typedParseConditional(noIn) {
  if (match2(TokenType.question)) {
    const nextType = lookaheadType();
    if (nextType === TokenType.colon || nextType === TokenType.comma || nextType === TokenType.parenR) {
      return;
    }
  }
  baseParseConditional(noIn);
}
function typedParseParenItem() {
  eatTypeToken(TokenType.question);
  if (match2(TokenType.colon)) {
    if (isTypeScriptEnabled) {
      tsParseTypeAnnotation();
    } else if (isFlowEnabled) {
      flowParseTypeAnnotation();
    }
  }
}

// node_modules/sucrase/dist/esm/parser/traverser/expression.js
var StopState = class {
  constructor(stop) {
    this.stop = stop;
  }
};
function parseExpression(noIn = false) {
  parseMaybeAssign(noIn);
  if (match2(TokenType.comma)) {
    while (eat(TokenType.comma)) {
      parseMaybeAssign(noIn);
    }
  }
}
function parseMaybeAssign(noIn = false, isWithinParens = false) {
  if (isTypeScriptEnabled) {
    return tsParseMaybeAssign(noIn, isWithinParens);
  } else if (isFlowEnabled) {
    return flowParseMaybeAssign(noIn, isWithinParens);
  } else {
    return baseParseMaybeAssign(noIn, isWithinParens);
  }
}
function baseParseMaybeAssign(noIn, isWithinParens) {
  if (match2(TokenType._yield)) {
    parseYield();
    return false;
  }
  if (match2(TokenType.parenL) || match2(TokenType.name) || match2(TokenType._yield)) {
    state.potentialArrowAt = state.start;
  }
  const wasArrow = parseMaybeConditional(noIn);
  if (isWithinParens) {
    parseParenItem();
  }
  if (state.type & TokenType.IS_ASSIGN) {
    next();
    parseMaybeAssign(noIn);
    return false;
  }
  return wasArrow;
}
function parseMaybeConditional(noIn) {
  const wasArrow = parseExprOps(noIn);
  if (wasArrow) {
    return true;
  }
  parseConditional(noIn);
  return false;
}
function parseConditional(noIn) {
  if (isTypeScriptEnabled || isFlowEnabled) {
    typedParseConditional(noIn);
  } else {
    baseParseConditional(noIn);
  }
}
function baseParseConditional(noIn) {
  if (eat(TokenType.question)) {
    parseMaybeAssign();
    expect(TokenType.colon);
    parseMaybeAssign(noIn);
  }
}
function parseExprOps(noIn) {
  const startTokenIndex = state.tokens.length;
  const wasArrow = parseMaybeUnary();
  if (wasArrow) {
    return true;
  }
  parseExprOp(startTokenIndex, -1, noIn);
  return false;
}
function parseExprOp(startTokenIndex, minPrec, noIn) {
  if (isTypeScriptEnabled && (TokenType._in & TokenType.PRECEDENCE_MASK) > minPrec && !hasPrecedingLineBreak() && (eatContextual(ContextualKeyword._as) || eatContextual(ContextualKeyword._satisfies))) {
    const oldIsType = pushTypeContext(1);
    tsParseType();
    popTypeContext(oldIsType);
    rescan_gt();
    parseExprOp(startTokenIndex, minPrec, noIn);
    return;
  }
  const prec = state.type & TokenType.PRECEDENCE_MASK;
  if (prec > 0 && (!noIn || !match2(TokenType._in))) {
    if (prec > minPrec) {
      const op = state.type;
      next();
      if (op === TokenType.nullishCoalescing) {
        state.tokens[state.tokens.length - 1].nullishStartIndex = startTokenIndex;
      }
      const rhsStartTokenIndex = state.tokens.length;
      parseMaybeUnary();
      parseExprOp(rhsStartTokenIndex, op & TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);
      if (op === TokenType.nullishCoalescing) {
        state.tokens[startTokenIndex].numNullishCoalesceStarts++;
        state.tokens[state.tokens.length - 1].numNullishCoalesceEnds++;
      }
      parseExprOp(startTokenIndex, minPrec, noIn);
    }
  }
}
function parseMaybeUnary() {
  if (isTypeScriptEnabled && !isJSXEnabled && eat(TokenType.lessThan)) {
    tsParseTypeAssertion();
    return false;
  }
  if (isContextual(ContextualKeyword._module) && lookaheadCharCode() === charCodes.leftCurlyBrace && !hasFollowingLineBreak()) {
    parseModuleExpression();
    return false;
  }
  if (state.type & TokenType.IS_PREFIX) {
    next();
    parseMaybeUnary();
    return false;
  }
  const wasArrow = parseExprSubscripts();
  if (wasArrow) {
    return true;
  }
  while (state.type & TokenType.IS_POSTFIX && !canInsertSemicolon()) {
    if (state.type === TokenType.preIncDec) {
      state.type = TokenType.postIncDec;
    }
    next();
  }
  return false;
}
function parseExprSubscripts() {
  const startTokenIndex = state.tokens.length;
  const wasArrow = parseExprAtom();
  if (wasArrow) {
    return true;
  }
  parseSubscripts(startTokenIndex);
  if (state.tokens.length > startTokenIndex && state.tokens[startTokenIndex].isOptionalChainStart) {
    state.tokens[state.tokens.length - 1].isOptionalChainEnd = true;
  }
  return false;
}
function parseSubscripts(startTokenIndex, noCalls = false) {
  if (isFlowEnabled) {
    flowParseSubscripts(startTokenIndex, noCalls);
  } else {
    baseParseSubscripts(startTokenIndex, noCalls);
  }
}
function baseParseSubscripts(startTokenIndex, noCalls = false) {
  const stopState = new StopState(false);
  do {
    parseSubscript(startTokenIndex, noCalls, stopState);
  } while (!stopState.stop && !state.error);
}
function parseSubscript(startTokenIndex, noCalls, stopState) {
  if (isTypeScriptEnabled) {
    tsParseSubscript(startTokenIndex, noCalls, stopState);
  } else if (isFlowEnabled) {
    flowParseSubscript(startTokenIndex, noCalls, stopState);
  } else {
    baseParseSubscript(startTokenIndex, noCalls, stopState);
  }
}
function baseParseSubscript(startTokenIndex, noCalls, stopState) {
  if (!noCalls && eat(TokenType.doubleColon)) {
    parseNoCallExpr();
    stopState.stop = true;
    parseSubscripts(startTokenIndex, noCalls);
  } else if (match2(TokenType.questionDot)) {
    state.tokens[startTokenIndex].isOptionalChainStart = true;
    if (noCalls && lookaheadType() === TokenType.parenL) {
      stopState.stop = true;
      return;
    }
    next();
    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    if (eat(TokenType.bracketL)) {
      parseExpression();
      expect(TokenType.bracketR);
    } else if (eat(TokenType.parenL)) {
      parseCallExpressionArguments();
    } else {
      parseMaybePrivateName();
    }
  } else if (eat(TokenType.dot)) {
    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    parseMaybePrivateName();
  } else if (eat(TokenType.bracketL)) {
    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    parseExpression();
    expect(TokenType.bracketR);
  } else if (!noCalls && match2(TokenType.parenL)) {
    if (atPossibleAsync()) {
      const snapshot = state.snapshot();
      const asyncStartTokenIndex = state.tokens.length;
      next();
      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
      const callContextId = getNextContextId();
      state.tokens[state.tokens.length - 1].contextId = callContextId;
      parseCallExpressionArguments();
      state.tokens[state.tokens.length - 1].contextId = callContextId;
      if (shouldParseAsyncArrow()) {
        state.restoreFromSnapshot(snapshot);
        stopState.stop = true;
        state.scopeDepth++;
        parseFunctionParams();
        parseAsyncArrowFromCallExpression(asyncStartTokenIndex);
      }
    } else {
      next();
      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
      const callContextId = getNextContextId();
      state.tokens[state.tokens.length - 1].contextId = callContextId;
      parseCallExpressionArguments();
      state.tokens[state.tokens.length - 1].contextId = callContextId;
    }
  } else if (match2(TokenType.backQuote)) {
    parseTemplate();
  } else {
    stopState.stop = true;
  }
}
function atPossibleAsync() {
  return state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async && !canInsertSemicolon();
}
function parseCallExpressionArguments() {
  let first = true;
  while (!eat(TokenType.parenR) && !state.error) {
    if (first) {
      first = false;
    } else {
      expect(TokenType.comma);
      if (eat(TokenType.parenR)) {
        break;
      }
    }
    parseExprListItem(false);
  }
}
function shouldParseAsyncArrow() {
  return match2(TokenType.colon) || match2(TokenType.arrow);
}
function parseAsyncArrowFromCallExpression(startTokenIndex) {
  if (isTypeScriptEnabled) {
    tsStartParseAsyncArrowFromCallExpression();
  } else if (isFlowEnabled) {
    flowStartParseAsyncArrowFromCallExpression();
  }
  expect(TokenType.arrow);
  parseArrowExpression(startTokenIndex);
}
function parseNoCallExpr() {
  const startTokenIndex = state.tokens.length;
  parseExprAtom();
  parseSubscripts(startTokenIndex, true);
}
function parseExprAtom() {
  if (eat(TokenType.modulo)) {
    parseIdentifier();
    return false;
  }
  if (match2(TokenType.jsxText) || match2(TokenType.jsxEmptyText)) {
    parseLiteral();
    return false;
  } else if (match2(TokenType.lessThan) && isJSXEnabled) {
    state.type = TokenType.jsxTagStart;
    jsxParseElement();
    next();
    return false;
  }
  const canBeArrow = state.potentialArrowAt === state.start;
  switch (state.type) {
    case TokenType.slash:
    case TokenType.assign:
      retokenizeSlashAsRegex();
    // Fall through.
    case TokenType._super:
    case TokenType._this:
    case TokenType.regexp:
    case TokenType.num:
    case TokenType.bigint:
    case TokenType.decimal:
    case TokenType.string:
    case TokenType._null:
    case TokenType._true:
    case TokenType._false:
      next();
      return false;
    case TokenType._import:
      next();
      if (match2(TokenType.dot)) {
        state.tokens[state.tokens.length - 1].type = TokenType.name;
        next();
        parseIdentifier();
      }
      return false;
    case TokenType.name: {
      const startTokenIndex = state.tokens.length;
      const functionStart = state.start;
      const contextualKeyword = state.contextualKeyword;
      parseIdentifier();
      if (contextualKeyword === ContextualKeyword._await) {
        parseAwait();
        return false;
      } else if (contextualKeyword === ContextualKeyword._async && match2(TokenType._function) && !canInsertSemicolon()) {
        next();
        parseFunction(functionStart, false);
        return false;
      } else if (canBeArrow && contextualKeyword === ContextualKeyword._async && !canInsertSemicolon() && match2(TokenType.name)) {
        state.scopeDepth++;
        parseBindingIdentifier(false);
        expect(TokenType.arrow);
        parseArrowExpression(startTokenIndex);
        return true;
      } else if (match2(TokenType._do) && !canInsertSemicolon()) {
        next();
        parseBlock();
        return false;
      }
      if (canBeArrow && !canInsertSemicolon() && match2(TokenType.arrow)) {
        state.scopeDepth++;
        markPriorBindingIdentifier(false);
        expect(TokenType.arrow);
        parseArrowExpression(startTokenIndex);
        return true;
      }
      state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.Access;
      return false;
    }
    case TokenType._do: {
      next();
      parseBlock();
      return false;
    }
    case TokenType.parenL: {
      const wasArrow = parseParenAndDistinguishExpression(canBeArrow);
      return wasArrow;
    }
    case TokenType.bracketL:
      next();
      parseExprList(TokenType.bracketR, true);
      return false;
    case TokenType.braceL:
      parseObj(false, false);
      return false;
    case TokenType._function:
      parseFunctionExpression();
      return false;
    case TokenType.at:
      parseDecorators();
    // Fall through.
    case TokenType._class:
      parseClass(false);
      return false;
    case TokenType._new:
      parseNew();
      return false;
    case TokenType.backQuote:
      parseTemplate();
      return false;
    case TokenType.doubleColon: {
      next();
      parseNoCallExpr();
      return false;
    }
    case TokenType.hash: {
      const code = lookaheadCharCode();
      if (IS_IDENTIFIER_START[code] || code === charCodes.backslash) {
        parseMaybePrivateName();
      } else {
        next();
      }
      return false;
    }
    default:
      unexpected();
      return false;
  }
}
function parseMaybePrivateName() {
  eat(TokenType.hash);
  parseIdentifier();
}
function parseFunctionExpression() {
  const functionStart = state.start;
  parseIdentifier();
  if (eat(TokenType.dot)) {
    parseIdentifier();
  }
  parseFunction(functionStart, false);
}
function parseLiteral() {
  next();
}
function parseParenExpression() {
  expect(TokenType.parenL);
  parseExpression();
  expect(TokenType.parenR);
}
function parseParenAndDistinguishExpression(canBeArrow) {
  const snapshot = state.snapshot();
  const startTokenIndex = state.tokens.length;
  expect(TokenType.parenL);
  let first = true;
  while (!match2(TokenType.parenR) && !state.error) {
    if (first) {
      first = false;
    } else {
      expect(TokenType.comma);
      if (match2(TokenType.parenR)) {
        break;
      }
    }
    if (match2(TokenType.ellipsis)) {
      parseRest(
        false
        /* isBlockScope */
      );
      parseParenItem();
      break;
    } else {
      parseMaybeAssign(false, true);
    }
  }
  expect(TokenType.parenR);
  if (canBeArrow && shouldParseArrow()) {
    const wasArrow = parseArrow();
    if (wasArrow) {
      state.restoreFromSnapshot(snapshot);
      state.scopeDepth++;
      parseFunctionParams();
      parseArrow();
      parseArrowExpression(startTokenIndex);
      if (state.error) {
        state.restoreFromSnapshot(snapshot);
        parseParenAndDistinguishExpression(false);
        return false;
      }
      return true;
    }
  }
  return false;
}
function shouldParseArrow() {
  return match2(TokenType.colon) || !canInsertSemicolon();
}
function parseArrow() {
  if (isTypeScriptEnabled) {
    return tsParseArrow();
  } else if (isFlowEnabled) {
    return flowParseArrow();
  } else {
    return eat(TokenType.arrow);
  }
}
function parseParenItem() {
  if (isTypeScriptEnabled || isFlowEnabled) {
    typedParseParenItem();
  }
}
function parseNew() {
  expect(TokenType._new);
  if (eat(TokenType.dot)) {
    parseIdentifier();
    return;
  }
  parseNewCallee();
  if (isFlowEnabled) {
    flowStartParseNewArguments();
  }
  if (eat(TokenType.parenL)) {
    parseExprList(TokenType.parenR);
  }
}
function parseNewCallee() {
  parseNoCallExpr();
  eat(TokenType.questionDot);
}
function parseTemplate() {
  nextTemplateToken();
  nextTemplateToken();
  while (!match2(TokenType.backQuote) && !state.error) {
    expect(TokenType.dollarBraceL);
    parseExpression();
    nextTemplateToken();
    nextTemplateToken();
  }
  next();
}
function parseObj(isPattern, isBlockScope) {
  const contextId = getNextContextId();
  let first = true;
  next();
  state.tokens[state.tokens.length - 1].contextId = contextId;
  while (!eat(TokenType.braceR) && !state.error) {
    if (first) {
      first = false;
    } else {
      expect(TokenType.comma);
      if (eat(TokenType.braceR)) {
        break;
      }
    }
    let isGenerator = false;
    if (match2(TokenType.ellipsis)) {
      const previousIndex = state.tokens.length;
      parseSpread();
      if (isPattern) {
        if (state.tokens.length === previousIndex + 2) {
          markPriorBindingIdentifier(isBlockScope);
        }
        if (eat(TokenType.braceR)) {
          break;
        }
      }
      continue;
    }
    if (!isPattern) {
      isGenerator = eat(TokenType.star);
    }
    if (!isPattern && isContextual(ContextualKeyword._async)) {
      if (isGenerator) unexpected();
      parseIdentifier();
      if (match2(TokenType.colon) || match2(TokenType.parenL) || match2(TokenType.braceR) || match2(TokenType.eq) || match2(TokenType.comma)) {
      } else {
        if (match2(TokenType.star)) {
          next();
          isGenerator = true;
        }
        parsePropertyName(contextId);
      }
    } else {
      parsePropertyName(contextId);
    }
    parseObjPropValue(isPattern, isBlockScope, contextId);
  }
  state.tokens[state.tokens.length - 1].contextId = contextId;
}
function isGetterOrSetterMethod(isPattern) {
  return !isPattern && (match2(TokenType.string) || // get "string"() {}
  match2(TokenType.num) || // get 1() {}
  match2(TokenType.bracketL) || // get ["string"]() {}
  match2(TokenType.name) || // get foo() {}
  !!(state.type & TokenType.IS_KEYWORD));
}
function parseObjectMethod(isPattern, objectContextId) {
  const functionStart = state.start;
  if (match2(TokenType.parenL)) {
    if (isPattern) unexpected();
    parseMethod(
      functionStart,
      /* isConstructor */
      false
    );
    return true;
  }
  if (isGetterOrSetterMethod(isPattern)) {
    parsePropertyName(objectContextId);
    parseMethod(
      functionStart,
      /* isConstructor */
      false
    );
    return true;
  }
  return false;
}
function parseObjectProperty(isPattern, isBlockScope) {
  if (eat(TokenType.colon)) {
    if (isPattern) {
      parseMaybeDefault(isBlockScope);
    } else {
      parseMaybeAssign(false);
    }
    return;
  }
  let identifierRole;
  if (isPattern) {
    if (state.scopeDepth === 0) {
      identifierRole = IdentifierRole.ObjectShorthandTopLevelDeclaration;
    } else if (isBlockScope) {
      identifierRole = IdentifierRole.ObjectShorthandBlockScopedDeclaration;
    } else {
      identifierRole = IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
    }
  } else {
    identifierRole = IdentifierRole.ObjectShorthand;
  }
  state.tokens[state.tokens.length - 1].identifierRole = identifierRole;
  parseMaybeDefault(isBlockScope, true);
}
function parseObjPropValue(isPattern, isBlockScope, objectContextId) {
  if (isTypeScriptEnabled) {
    tsStartParseObjPropValue();
  } else if (isFlowEnabled) {
    flowStartParseObjPropValue();
  }
  const wasMethod = parseObjectMethod(isPattern, objectContextId);
  if (!wasMethod) {
    parseObjectProperty(isPattern, isBlockScope);
  }
}
function parsePropertyName(objectContextId) {
  if (isFlowEnabled) {
    flowParseVariance();
  }
  if (eat(TokenType.bracketL)) {
    state.tokens[state.tokens.length - 1].contextId = objectContextId;
    parseMaybeAssign();
    expect(TokenType.bracketR);
    state.tokens[state.tokens.length - 1].contextId = objectContextId;
  } else {
    if (match2(TokenType.num) || match2(TokenType.string) || match2(TokenType.bigint) || match2(TokenType.decimal)) {
      parseExprAtom();
    } else {
      parseMaybePrivateName();
    }
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ObjectKey;
    state.tokens[state.tokens.length - 1].contextId = objectContextId;
  }
}
function parseMethod(functionStart, isConstructor) {
  const funcContextId = getNextContextId();
  state.scopeDepth++;
  const startTokenIndex = state.tokens.length;
  const allowModifiers = isConstructor;
  parseFunctionParams(allowModifiers, funcContextId);
  parseFunctionBodyAndFinish(functionStart, funcContextId);
  const endTokenIndex = state.tokens.length;
  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));
  state.scopeDepth--;
}
function parseArrowExpression(startTokenIndex) {
  parseFunctionBody(true);
  const endTokenIndex = state.tokens.length;
  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));
  state.scopeDepth--;
}
function parseFunctionBodyAndFinish(functionStart, funcContextId = 0) {
  if (isTypeScriptEnabled) {
    tsParseFunctionBodyAndFinish(functionStart, funcContextId);
  } else if (isFlowEnabled) {
    flowParseFunctionBodyAndFinish(funcContextId);
  } else {
    parseFunctionBody(false, funcContextId);
  }
}
function parseFunctionBody(allowExpression, funcContextId = 0) {
  const isExpression = allowExpression && !match2(TokenType.braceL);
  if (isExpression) {
    parseMaybeAssign();
  } else {
    parseBlock(true, funcContextId);
  }
}
function parseExprList(close, allowEmpty = false) {
  let first = true;
  while (!eat(close) && !state.error) {
    if (first) {
      first = false;
    } else {
      expect(TokenType.comma);
      if (eat(close)) break;
    }
    parseExprListItem(allowEmpty);
  }
}
function parseExprListItem(allowEmpty) {
  if (allowEmpty && match2(TokenType.comma)) {
  } else if (match2(TokenType.ellipsis)) {
    parseSpread();
    parseParenItem();
  } else if (match2(TokenType.question)) {
    next();
  } else {
    parseMaybeAssign(false, true);
  }
}
function parseIdentifier() {
  next();
  state.tokens[state.tokens.length - 1].type = TokenType.name;
}
function parseAwait() {
  parseMaybeUnary();
}
function parseYield() {
  next();
  if (!match2(TokenType.semi) && !canInsertSemicolon()) {
    eat(TokenType.star);
    parseMaybeAssign();
  }
}
function parseModuleExpression() {
  expectContextual(ContextualKeyword._module);
  expect(TokenType.braceL);
  parseBlockBody(TokenType.braceR);
}

// node_modules/sucrase/dist/esm/parser/plugins/flow.js
function isMaybeDefaultImport(lookahead) {
  return (lookahead.type === TokenType.name || !!(lookahead.type & TokenType.IS_KEYWORD)) && lookahead.contextualKeyword !== ContextualKeyword._from;
}
function flowParseTypeInitialiser(tok) {
  const oldIsType = pushTypeContext(0);
  expect(tok || TokenType.colon);
  flowParseType();
  popTypeContext(oldIsType);
}
function flowParsePredicate() {
  expect(TokenType.modulo);
  expectContextual(ContextualKeyword._checks);
  if (eat(TokenType.parenL)) {
    parseExpression();
    expect(TokenType.parenR);
  }
}
function flowParseTypeAndPredicateInitialiser() {
  const oldIsType = pushTypeContext(0);
  expect(TokenType.colon);
  if (match2(TokenType.modulo)) {
    flowParsePredicate();
  } else {
    flowParseType();
    if (match2(TokenType.modulo)) {
      flowParsePredicate();
    }
  }
  popTypeContext(oldIsType);
}
function flowParseDeclareClass() {
  next();
  flowParseInterfaceish(
    /* isClass */
    true
  );
}
function flowParseDeclareFunction() {
  next();
  parseIdentifier();
  if (match2(TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }
  expect(TokenType.parenL);
  flowParseFunctionTypeParams();
  expect(TokenType.parenR);
  flowParseTypeAndPredicateInitialiser();
  semicolon();
}
function flowParseDeclare() {
  if (match2(TokenType._class)) {
    flowParseDeclareClass();
  } else if (match2(TokenType._function)) {
    flowParseDeclareFunction();
  } else if (match2(TokenType._var)) {
    flowParseDeclareVariable();
  } else if (eatContextual(ContextualKeyword._module)) {
    if (eat(TokenType.dot)) {
      flowParseDeclareModuleExports();
    } else {
      flowParseDeclareModule();
    }
  } else if (isContextual(ContextualKeyword._type)) {
    flowParseDeclareTypeAlias();
  } else if (isContextual(ContextualKeyword._opaque)) {
    flowParseDeclareOpaqueType();
  } else if (isContextual(ContextualKeyword._interface)) {
    flowParseDeclareInterface();
  } else if (match2(TokenType._export)) {
    flowParseDeclareExportDeclaration();
  } else {
    unexpected();
  }
}
function flowParseDeclareVariable() {
  next();
  flowParseTypeAnnotatableIdentifier();
  semicolon();
}
function flowParseDeclareModule() {
  if (match2(TokenType.string)) {
    parseExprAtom();
  } else {
    parseIdentifier();
  }
  expect(TokenType.braceL);
  while (!match2(TokenType.braceR) && !state.error) {
    if (match2(TokenType._import)) {
      next();
      parseImport();
    } else {
      unexpected();
    }
  }
  expect(TokenType.braceR);
}
function flowParseDeclareExportDeclaration() {
  expect(TokenType._export);
  if (eat(TokenType._default)) {
    if (match2(TokenType._function) || match2(TokenType._class)) {
      flowParseDeclare();
    } else {
      flowParseType();
      semicolon();
    }
  } else if (match2(TokenType._var) || // declare export var ...
  match2(TokenType._function) || // declare export function ...
  match2(TokenType._class) || // declare export class ...
  isContextual(ContextualKeyword._opaque)) {
    flowParseDeclare();
  } else if (match2(TokenType.star) || // declare export * from ''
  match2(TokenType.braceL) || // declare export {} ...
  isContextual(ContextualKeyword._interface) || // declare export interface ...
  isContextual(ContextualKeyword._type) || // declare export type ...
  isContextual(ContextualKeyword._opaque)) {
    parseExport();
  } else {
    unexpected();
  }
}
function flowParseDeclareModuleExports() {
  expectContextual(ContextualKeyword._exports);
  flowParseTypeAnnotation();
  semicolon();
}
function flowParseDeclareTypeAlias() {
  next();
  flowParseTypeAlias();
}
function flowParseDeclareOpaqueType() {
  next();
  flowParseOpaqueType(true);
}
function flowParseDeclareInterface() {
  next();
  flowParseInterfaceish();
}
function flowParseInterfaceish(isClass = false) {
  flowParseRestrictedIdentifier();
  if (match2(TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }
  if (eat(TokenType._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (!isClass && eat(TokenType.comma));
  }
  if (isContextual(ContextualKeyword._mixins)) {
    next();
    do {
      flowParseInterfaceExtends();
    } while (eat(TokenType.comma));
  }
  if (isContextual(ContextualKeyword._implements)) {
    next();
    do {
      flowParseInterfaceExtends();
    } while (eat(TokenType.comma));
  }
  flowParseObjectType(isClass, false, isClass);
}
function flowParseInterfaceExtends() {
  flowParseQualifiedTypeIdentifier(false);
  if (match2(TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}
function flowParseInterface() {
  flowParseInterfaceish();
}
function flowParseRestrictedIdentifier() {
  parseIdentifier();
}
function flowParseTypeAlias() {
  flowParseRestrictedIdentifier();
  if (match2(TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }
  flowParseTypeInitialiser(TokenType.eq);
  semicolon();
}
function flowParseOpaqueType(declare) {
  expectContextual(ContextualKeyword._type);
  flowParseRestrictedIdentifier();
  if (match2(TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }
  if (match2(TokenType.colon)) {
    flowParseTypeInitialiser(TokenType.colon);
  }
  if (!declare) {
    flowParseTypeInitialiser(TokenType.eq);
  }
  semicolon();
}
function flowParseTypeParameter() {
  flowParseVariance();
  flowParseTypeAnnotatableIdentifier();
  if (eat(TokenType.eq)) {
    flowParseType();
  }
}
function flowParseTypeParameterDeclaration() {
  const oldIsType = pushTypeContext(0);
  if (match2(TokenType.lessThan) || match2(TokenType.typeParameterStart)) {
    next();
  } else {
    unexpected();
  }
  do {
    flowParseTypeParameter();
    if (!match2(TokenType.greaterThan)) {
      expect(TokenType.comma);
    }
  } while (!match2(TokenType.greaterThan) && !state.error);
  expect(TokenType.greaterThan);
  popTypeContext(oldIsType);
}
function flowParseTypeParameterInstantiation() {
  const oldIsType = pushTypeContext(0);
  expect(TokenType.lessThan);
  while (!match2(TokenType.greaterThan) && !state.error) {
    flowParseType();
    if (!match2(TokenType.greaterThan)) {
      expect(TokenType.comma);
    }
  }
  expect(TokenType.greaterThan);
  popTypeContext(oldIsType);
}
function flowParseInterfaceType() {
  expectContextual(ContextualKeyword._interface);
  if (eat(TokenType._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (eat(TokenType.comma));
  }
  flowParseObjectType(false, false, false);
}
function flowParseObjectPropertyKey() {
  if (match2(TokenType.num) || match2(TokenType.string)) {
    parseExprAtom();
  } else {
    parseIdentifier();
  }
}
function flowParseObjectTypeIndexer() {
  if (lookaheadType() === TokenType.colon) {
    flowParseObjectPropertyKey();
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
  expect(TokenType.bracketR);
  flowParseTypeInitialiser();
}
function flowParseObjectTypeInternalSlot() {
  flowParseObjectPropertyKey();
  expect(TokenType.bracketR);
  expect(TokenType.bracketR);
  if (match2(TokenType.lessThan) || match2(TokenType.parenL)) {
    flowParseObjectTypeMethodish();
  } else {
    eat(TokenType.question);
    flowParseTypeInitialiser();
  }
}
function flowParseObjectTypeMethodish() {
  if (match2(TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }
  expect(TokenType.parenL);
  while (!match2(TokenType.parenR) && !match2(TokenType.ellipsis) && !state.error) {
    flowParseFunctionTypeParam();
    if (!match2(TokenType.parenR)) {
      expect(TokenType.comma);
    }
  }
  if (eat(TokenType.ellipsis)) {
    flowParseFunctionTypeParam();
  }
  expect(TokenType.parenR);
  flowParseTypeInitialiser();
}
function flowParseObjectTypeCallProperty() {
  flowParseObjectTypeMethodish();
}
function flowParseObjectType(allowStatic, allowExact, allowProto) {
  let endDelim;
  if (allowExact && match2(TokenType.braceBarL)) {
    expect(TokenType.braceBarL);
    endDelim = TokenType.braceBarR;
  } else {
    expect(TokenType.braceL);
    endDelim = TokenType.braceR;
  }
  while (!match2(endDelim) && !state.error) {
    if (allowProto && isContextual(ContextualKeyword._proto)) {
      const lookahead = lookaheadType();
      if (lookahead !== TokenType.colon && lookahead !== TokenType.question) {
        next();
        allowStatic = false;
      }
    }
    if (allowStatic && isContextual(ContextualKeyword._static)) {
      const lookahead = lookaheadType();
      if (lookahead !== TokenType.colon && lookahead !== TokenType.question) {
        next();
      }
    }
    flowParseVariance();
    if (eat(TokenType.bracketL)) {
      if (eat(TokenType.bracketL)) {
        flowParseObjectTypeInternalSlot();
      } else {
        flowParseObjectTypeIndexer();
      }
    } else if (match2(TokenType.parenL) || match2(TokenType.lessThan)) {
      flowParseObjectTypeCallProperty();
    } else {
      if (isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) {
        const lookahead = lookaheadType();
        if (lookahead === TokenType.name || lookahead === TokenType.string || lookahead === TokenType.num) {
          next();
        }
      }
      flowParseObjectTypeProperty();
    }
    flowObjectTypeSemicolon();
  }
  expect(endDelim);
}
function flowParseObjectTypeProperty() {
  if (match2(TokenType.ellipsis)) {
    expect(TokenType.ellipsis);
    if (!eat(TokenType.comma)) {
      eat(TokenType.semi);
    }
    if (match2(TokenType.braceR)) {
      return;
    }
    flowParseType();
  } else {
    flowParseObjectPropertyKey();
    if (match2(TokenType.lessThan) || match2(TokenType.parenL)) {
      flowParseObjectTypeMethodish();
    } else {
      eat(TokenType.question);
      flowParseTypeInitialiser();
    }
  }
}
function flowObjectTypeSemicolon() {
  if (!eat(TokenType.semi) && !eat(TokenType.comma) && !match2(TokenType.braceR) && !match2(TokenType.braceBarR)) {
    unexpected();
  }
}
function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {
  if (!initialIdAlreadyParsed) {
    parseIdentifier();
  }
  while (eat(TokenType.dot)) {
    parseIdentifier();
  }
}
function flowParseGenericType() {
  flowParseQualifiedTypeIdentifier(true);
  if (match2(TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}
function flowParseTypeofType() {
  expect(TokenType._typeof);
  flowParsePrimaryType();
}
function flowParseTupleType() {
  expect(TokenType.bracketL);
  while (state.pos < input.length && !match2(TokenType.bracketR)) {
    flowParseType();
    if (match2(TokenType.bracketR)) {
      break;
    }
    expect(TokenType.comma);
  }
  expect(TokenType.bracketR);
}
function flowParseFunctionTypeParam() {
  const lookahead = lookaheadType();
  if (lookahead === TokenType.colon || lookahead === TokenType.question) {
    parseIdentifier();
    eat(TokenType.question);
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
}
function flowParseFunctionTypeParams() {
  while (!match2(TokenType.parenR) && !match2(TokenType.ellipsis) && !state.error) {
    flowParseFunctionTypeParam();
    if (!match2(TokenType.parenR)) {
      expect(TokenType.comma);
    }
  }
  if (eat(TokenType.ellipsis)) {
    flowParseFunctionTypeParam();
  }
}
function flowParsePrimaryType() {
  let isGroupedType = false;
  const oldNoAnonFunctionType = state.noAnonFunctionType;
  switch (state.type) {
    case TokenType.name: {
      if (isContextual(ContextualKeyword._interface)) {
        flowParseInterfaceType();
        return;
      }
      parseIdentifier();
      flowParseGenericType();
      return;
    }
    case TokenType.braceL:
      flowParseObjectType(false, false, false);
      return;
    case TokenType.braceBarL:
      flowParseObjectType(false, true, false);
      return;
    case TokenType.bracketL:
      flowParseTupleType();
      return;
    case TokenType.lessThan:
      flowParseTypeParameterDeclaration();
      expect(TokenType.parenL);
      flowParseFunctionTypeParams();
      expect(TokenType.parenR);
      expect(TokenType.arrow);
      flowParseType();
      return;
    case TokenType.parenL:
      next();
      if (!match2(TokenType.parenR) && !match2(TokenType.ellipsis)) {
        if (match2(TokenType.name)) {
          const token2 = lookaheadType();
          isGroupedType = token2 !== TokenType.question && token2 !== TokenType.colon;
        } else {
          isGroupedType = true;
        }
      }
      if (isGroupedType) {
        state.noAnonFunctionType = false;
        flowParseType();
        state.noAnonFunctionType = oldNoAnonFunctionType;
        if (state.noAnonFunctionType || !(match2(TokenType.comma) || match2(TokenType.parenR) && lookaheadType() === TokenType.arrow)) {
          expect(TokenType.parenR);
          return;
        } else {
          eat(TokenType.comma);
        }
      }
      flowParseFunctionTypeParams();
      expect(TokenType.parenR);
      expect(TokenType.arrow);
      flowParseType();
      return;
    case TokenType.minus:
      next();
      parseLiteral();
      return;
    case TokenType.string:
    case TokenType.num:
    case TokenType._true:
    case TokenType._false:
    case TokenType._null:
    case TokenType._this:
    case TokenType._void:
    case TokenType.star:
      next();
      return;
    default:
      if (state.type === TokenType._typeof) {
        flowParseTypeofType();
        return;
      } else if (state.type & TokenType.IS_KEYWORD) {
        next();
        state.tokens[state.tokens.length - 1].type = TokenType.name;
        return;
      }
  }
  unexpected();
}
function flowParsePostfixType() {
  flowParsePrimaryType();
  while (!canInsertSemicolon() && (match2(TokenType.bracketL) || match2(TokenType.questionDot))) {
    eat(TokenType.questionDot);
    expect(TokenType.bracketL);
    if (eat(TokenType.bracketR)) {
    } else {
      flowParseType();
      expect(TokenType.bracketR);
    }
  }
}
function flowParsePrefixType() {
  if (eat(TokenType.question)) {
    flowParsePrefixType();
  } else {
    flowParsePostfixType();
  }
}
function flowParseAnonFunctionWithoutParens() {
  flowParsePrefixType();
  if (!state.noAnonFunctionType && eat(TokenType.arrow)) {
    flowParseType();
  }
}
function flowParseIntersectionType() {
  eat(TokenType.bitwiseAND);
  flowParseAnonFunctionWithoutParens();
  while (eat(TokenType.bitwiseAND)) {
    flowParseAnonFunctionWithoutParens();
  }
}
function flowParseUnionType() {
  eat(TokenType.bitwiseOR);
  flowParseIntersectionType();
  while (eat(TokenType.bitwiseOR)) {
    flowParseIntersectionType();
  }
}
function flowParseType() {
  flowParseUnionType();
}
function flowParseTypeAnnotation() {
  flowParseTypeInitialiser();
}
function flowParseTypeAnnotatableIdentifier() {
  parseIdentifier();
  if (match2(TokenType.colon)) {
    flowParseTypeAnnotation();
  }
}
function flowParseVariance() {
  if (match2(TokenType.plus) || match2(TokenType.minus)) {
    next();
    state.tokens[state.tokens.length - 1].isType = true;
  }
}
function flowParseFunctionBodyAndFinish(funcContextId) {
  if (match2(TokenType.colon)) {
    flowParseTypeAndPredicateInitialiser();
  }
  parseFunctionBody(false, funcContextId);
}
function flowParseSubscript(startTokenIndex, noCalls, stopState) {
  if (match2(TokenType.questionDot) && lookaheadType() === TokenType.lessThan) {
    if (noCalls) {
      stopState.stop = true;
      return;
    }
    next();
    flowParseTypeParameterInstantiation();
    expect(TokenType.parenL);
    parseCallExpressionArguments();
    return;
  } else if (!noCalls && match2(TokenType.lessThan)) {
    const snapshot = state.snapshot();
    flowParseTypeParameterInstantiation();
    expect(TokenType.parenL);
    parseCallExpressionArguments();
    if (state.error) {
      state.restoreFromSnapshot(snapshot);
    } else {
      return;
    }
  }
  baseParseSubscript(startTokenIndex, noCalls, stopState);
}
function flowStartParseNewArguments() {
  if (match2(TokenType.lessThan)) {
    const snapshot = state.snapshot();
    flowParseTypeParameterInstantiation();
    if (state.error) {
      state.restoreFromSnapshot(snapshot);
    }
  }
}
function flowTryParseStatement() {
  if (match2(TokenType.name) && state.contextualKeyword === ContextualKeyword._interface) {
    const oldIsType = pushTypeContext(0);
    next();
    flowParseInterface();
    popTypeContext(oldIsType);
    return true;
  } else if (isContextual(ContextualKeyword._enum)) {
    flowParseEnumDeclaration();
    return true;
  }
  return false;
}
function flowTryParseExportDefaultExpression() {
  if (isContextual(ContextualKeyword._enum)) {
    flowParseEnumDeclaration();
    return true;
  }
  return false;
}
function flowParseIdentifierStatement(contextualKeyword) {
  if (contextualKeyword === ContextualKeyword._declare) {
    if (match2(TokenType._class) || match2(TokenType.name) || match2(TokenType._function) || match2(TokenType._var) || match2(TokenType._export)) {
      const oldIsType = pushTypeContext(1);
      flowParseDeclare();
      popTypeContext(oldIsType);
    }
  } else if (match2(TokenType.name)) {
    if (contextualKeyword === ContextualKeyword._interface) {
      const oldIsType = pushTypeContext(1);
      flowParseInterface();
      popTypeContext(oldIsType);
    } else if (contextualKeyword === ContextualKeyword._type) {
      const oldIsType = pushTypeContext(1);
      flowParseTypeAlias();
      popTypeContext(oldIsType);
    } else if (contextualKeyword === ContextualKeyword._opaque) {
      const oldIsType = pushTypeContext(1);
      flowParseOpaqueType(false);
      popTypeContext(oldIsType);
    }
  }
  semicolon();
}
function flowShouldParseExportDeclaration() {
  return isContextual(ContextualKeyword._type) || isContextual(ContextualKeyword._interface) || isContextual(ContextualKeyword._opaque) || isContextual(ContextualKeyword._enum);
}
function flowShouldDisallowExportDefaultSpecifier() {
  return match2(TokenType.name) && (state.contextualKeyword === ContextualKeyword._type || state.contextualKeyword === ContextualKeyword._interface || state.contextualKeyword === ContextualKeyword._opaque || state.contextualKeyword === ContextualKeyword._enum);
}
function flowParseExportDeclaration() {
  if (isContextual(ContextualKeyword._type)) {
    const oldIsType = pushTypeContext(1);
    next();
    if (match2(TokenType.braceL)) {
      parseExportSpecifiers();
      parseExportFrom();
    } else {
      flowParseTypeAlias();
    }
    popTypeContext(oldIsType);
  } else if (isContextual(ContextualKeyword._opaque)) {
    const oldIsType = pushTypeContext(1);
    next();
    flowParseOpaqueType(false);
    popTypeContext(oldIsType);
  } else if (isContextual(ContextualKeyword._interface)) {
    const oldIsType = pushTypeContext(1);
    next();
    flowParseInterface();
    popTypeContext(oldIsType);
  } else {
    parseStatement(true);
  }
}
function flowShouldParseExportStar() {
  return match2(TokenType.star) || isContextual(ContextualKeyword._type) && lookaheadType() === TokenType.star;
}
function flowParseExportStar() {
  if (eatContextual(ContextualKeyword._type)) {
    const oldIsType = pushTypeContext(2);
    baseParseExportStar();
    popTypeContext(oldIsType);
  } else {
    baseParseExportStar();
  }
}
function flowAfterParseClassSuper(hasSuper) {
  if (hasSuper && match2(TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
  if (isContextual(ContextualKeyword._implements)) {
    const oldIsType = pushTypeContext(0);
    next();
    state.tokens[state.tokens.length - 1].type = TokenType._implements;
    do {
      flowParseRestrictedIdentifier();
      if (match2(TokenType.lessThan)) {
        flowParseTypeParameterInstantiation();
      }
    } while (eat(TokenType.comma));
    popTypeContext(oldIsType);
  }
}
function flowStartParseObjPropValue() {
  if (match2(TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
    if (!match2(TokenType.parenL)) unexpected();
  }
}
function flowParseAssignableListItemTypes() {
  const oldIsType = pushTypeContext(0);
  eat(TokenType.question);
  if (match2(TokenType.colon)) {
    flowParseTypeAnnotation();
  }
  popTypeContext(oldIsType);
}
function flowStartParseImportSpecifiers() {
  if (match2(TokenType._typeof) || isContextual(ContextualKeyword._type)) {
    const lh = lookaheadTypeAndKeyword();
    if (isMaybeDefaultImport(lh) || lh.type === TokenType.braceL || lh.type === TokenType.star) {
      next();
    }
  }
}
function flowParseImportSpecifier() {
  const isTypeKeyword = state.contextualKeyword === ContextualKeyword._type || state.type === TokenType._typeof;
  if (isTypeKeyword) {
    next();
  } else {
    parseIdentifier();
  }
  if (isContextual(ContextualKeyword._as) && !isLookaheadContextual(ContextualKeyword._as)) {
    parseIdentifier();
    if (isTypeKeyword && !match2(TokenType.name) && !(state.type & TokenType.IS_KEYWORD)) {
    } else {
      parseIdentifier();
    }
  } else {
    if (isTypeKeyword && (match2(TokenType.name) || !!(state.type & TokenType.IS_KEYWORD))) {
      parseIdentifier();
    }
    if (eatContextual(ContextualKeyword._as)) {
      parseIdentifier();
    }
  }
}
function flowStartParseFunctionParams() {
  if (match2(TokenType.lessThan)) {
    const oldIsType = pushTypeContext(0);
    flowParseTypeParameterDeclaration();
    popTypeContext(oldIsType);
  }
}
function flowAfterParseVarHead() {
  if (match2(TokenType.colon)) {
    flowParseTypeAnnotation();
  }
}
function flowStartParseAsyncArrowFromCallExpression() {
  if (match2(TokenType.colon)) {
    const oldNoAnonFunctionType = state.noAnonFunctionType;
    state.noAnonFunctionType = true;
    flowParseTypeAnnotation();
    state.noAnonFunctionType = oldNoAnonFunctionType;
  }
}
function flowParseMaybeAssign(noIn, isWithinParens) {
  if (match2(TokenType.lessThan)) {
    const snapshot = state.snapshot();
    let wasArrow = baseParseMaybeAssign(noIn, isWithinParens);
    if (state.error) {
      state.restoreFromSnapshot(snapshot);
      state.type = TokenType.typeParameterStart;
    } else {
      return wasArrow;
    }
    const oldIsType = pushTypeContext(0);
    flowParseTypeParameterDeclaration();
    popTypeContext(oldIsType);
    wasArrow = baseParseMaybeAssign(noIn, isWithinParens);
    if (wasArrow) {
      return true;
    }
    unexpected();
  }
  return baseParseMaybeAssign(noIn, isWithinParens);
}
function flowParseArrow() {
  if (match2(TokenType.colon)) {
    const oldIsType = pushTypeContext(0);
    const snapshot = state.snapshot();
    const oldNoAnonFunctionType = state.noAnonFunctionType;
    state.noAnonFunctionType = true;
    flowParseTypeAndPredicateInitialiser();
    state.noAnonFunctionType = oldNoAnonFunctionType;
    if (canInsertSemicolon()) unexpected();
    if (!match2(TokenType.arrow)) unexpected();
    if (state.error) {
      state.restoreFromSnapshot(snapshot);
    }
    popTypeContext(oldIsType);
  }
  return eat(TokenType.arrow);
}
function flowParseSubscripts(startTokenIndex, noCalls = false) {
  if (state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async && match2(TokenType.lessThan)) {
    const snapshot = state.snapshot();
    const wasArrow = parseAsyncArrowWithTypeParameters();
    if (wasArrow && !state.error) {
      return;
    }
    state.restoreFromSnapshot(snapshot);
  }
  baseParseSubscripts(startTokenIndex, noCalls);
}
function parseAsyncArrowWithTypeParameters() {
  state.scopeDepth++;
  const startTokenIndex = state.tokens.length;
  parseFunctionParams();
  if (!parseArrow()) {
    return false;
  }
  parseArrowExpression(startTokenIndex);
  return true;
}
function flowParseEnumDeclaration() {
  expectContextual(ContextualKeyword._enum);
  state.tokens[state.tokens.length - 1].type = TokenType._enum;
  parseIdentifier();
  flowParseEnumBody();
}
function flowParseEnumBody() {
  if (eatContextual(ContextualKeyword._of)) {
    next();
  }
  expect(TokenType.braceL);
  flowParseEnumMembers();
  expect(TokenType.braceR);
}
function flowParseEnumMembers() {
  while (!match2(TokenType.braceR) && !state.error) {
    if (eat(TokenType.ellipsis)) {
      break;
    }
    flowParseEnumMember();
    if (!match2(TokenType.braceR)) {
      expect(TokenType.comma);
    }
  }
}
function flowParseEnumMember() {
  parseIdentifier();
  if (eat(TokenType.eq)) {
    next();
  }
}

// node_modules/sucrase/dist/esm/parser/traverser/statement.js
function parseTopLevel() {
  parseBlockBody(TokenType.eof);
  state.scopes.push(new Scope(0, state.tokens.length, true));
  if (state.scopeDepth !== 0) {
    throw new Error(`Invalid scope depth at end of file: ${state.scopeDepth}`);
  }
  return new File(state.tokens, state.scopes);
}
function parseStatement(declaration2) {
  if (isFlowEnabled) {
    if (flowTryParseStatement()) {
      return;
    }
  }
  if (match2(TokenType.at)) {
    parseDecorators();
  }
  parseStatementContent(declaration2);
}
function parseStatementContent(declaration2) {
  if (isTypeScriptEnabled) {
    if (tsTryParseStatementContent()) {
      return;
    }
  }
  const starttype = state.type;
  switch (starttype) {
    case TokenType._break:
    case TokenType._continue:
      parseBreakContinueStatement();
      return;
    case TokenType._debugger:
      parseDebuggerStatement();
      return;
    case TokenType._do:
      parseDoStatement();
      return;
    case TokenType._for:
      parseForStatement();
      return;
    case TokenType._function:
      if (lookaheadType() === TokenType.dot) break;
      if (!declaration2) unexpected();
      parseFunctionStatement();
      return;
    case TokenType._class:
      if (!declaration2) unexpected();
      parseClass(true);
      return;
    case TokenType._if:
      parseIfStatement();
      return;
    case TokenType._return:
      parseReturnStatement();
      return;
    case TokenType._switch:
      parseSwitchStatement();
      return;
    case TokenType._throw:
      parseThrowStatement();
      return;
    case TokenType._try:
      parseTryStatement();
      return;
    case TokenType._let:
    case TokenType._const:
      if (!declaration2) unexpected();
    // NOTE: falls through to _var
    case TokenType._var:
      parseVarStatement(starttype !== TokenType._var);
      return;
    case TokenType._while:
      parseWhileStatement();
      return;
    case TokenType.braceL:
      parseBlock();
      return;
    case TokenType.semi:
      parseEmptyStatement();
      return;
    case TokenType._export:
    case TokenType._import: {
      const nextType = lookaheadType();
      if (nextType === TokenType.parenL || nextType === TokenType.dot) {
        break;
      }
      next();
      if (starttype === TokenType._import) {
        parseImport();
      } else {
        parseExport();
      }
      return;
    }
    case TokenType.name:
      if (state.contextualKeyword === ContextualKeyword._async) {
        const functionStart = state.start;
        const snapshot = state.snapshot();
        next();
        if (match2(TokenType._function) && !canInsertSemicolon()) {
          expect(TokenType._function);
          parseFunction(functionStart, true);
          return;
        } else {
          state.restoreFromSnapshot(snapshot);
        }
      } else if (state.contextualKeyword === ContextualKeyword._using && !hasFollowingLineBreak() && // Statements like `using[0]` and `using in foo` aren't actual using
      // declarations.
      lookaheadType() === TokenType.name) {
        parseVarStatement(true);
        return;
      } else if (startsAwaitUsing()) {
        expectContextual(ContextualKeyword._await);
        parseVarStatement(true);
        return;
      }
    default:
      break;
  }
  const initialTokensLength = state.tokens.length;
  parseExpression();
  let simpleName = null;
  if (state.tokens.length === initialTokensLength + 1) {
    const token2 = state.tokens[state.tokens.length - 1];
    if (token2.type === TokenType.name) {
      simpleName = token2.contextualKeyword;
    }
  }
  if (simpleName == null) {
    semicolon();
    return;
  }
  if (eat(TokenType.colon)) {
    parseLabeledStatement();
  } else {
    parseIdentifierStatement(simpleName);
  }
}
function startsAwaitUsing() {
  if (!isContextual(ContextualKeyword._await)) {
    return false;
  }
  const snapshot = state.snapshot();
  next();
  if (!isContextual(ContextualKeyword._using) || hasPrecedingLineBreak()) {
    state.restoreFromSnapshot(snapshot);
    return false;
  }
  next();
  if (!match2(TokenType.name) || hasPrecedingLineBreak()) {
    state.restoreFromSnapshot(snapshot);
    return false;
  }
  state.restoreFromSnapshot(snapshot);
  return true;
}
function parseDecorators() {
  while (match2(TokenType.at)) {
    parseDecorator();
  }
}
function parseDecorator() {
  next();
  if (eat(TokenType.parenL)) {
    parseExpression();
    expect(TokenType.parenR);
  } else {
    parseIdentifier();
    while (eat(TokenType.dot)) {
      parseIdentifier();
    }
    parseMaybeDecoratorArguments();
  }
}
function parseMaybeDecoratorArguments() {
  if (isTypeScriptEnabled) {
    tsParseMaybeDecoratorArguments();
  } else {
    baseParseMaybeDecoratorArguments();
  }
}
function baseParseMaybeDecoratorArguments() {
  if (eat(TokenType.parenL)) {
    parseCallExpressionArguments();
  }
}
function parseBreakContinueStatement() {
  next();
  if (!isLineTerminator()) {
    parseIdentifier();
    semicolon();
  }
}
function parseDebuggerStatement() {
  next();
  semicolon();
}
function parseDoStatement() {
  next();
  parseStatement(false);
  expect(TokenType._while);
  parseParenExpression();
  eat(TokenType.semi);
}
function parseForStatement() {
  state.scopeDepth++;
  const startTokenIndex = state.tokens.length;
  parseAmbiguousForStatement();
  const endTokenIndex = state.tokens.length;
  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));
  state.scopeDepth--;
}
function isUsingInLoop() {
  if (!isContextual(ContextualKeyword._using)) {
    return false;
  }
  if (isLookaheadContextual(ContextualKeyword._of)) {
    return false;
  }
  return true;
}
function parseAmbiguousForStatement() {
  next();
  let forAwait = false;
  if (isContextual(ContextualKeyword._await)) {
    forAwait = true;
    next();
  }
  expect(TokenType.parenL);
  if (match2(TokenType.semi)) {
    if (forAwait) {
      unexpected();
    }
    parseFor();
    return;
  }
  const isAwaitUsing = startsAwaitUsing();
  if (isAwaitUsing || match2(TokenType._var) || match2(TokenType._let) || match2(TokenType._const) || isUsingInLoop()) {
    if (isAwaitUsing) {
      expectContextual(ContextualKeyword._await);
    }
    next();
    parseVar(true, state.type !== TokenType._var);
    if (match2(TokenType._in) || isContextual(ContextualKeyword._of)) {
      parseForIn(forAwait);
      return;
    }
    parseFor();
    return;
  }
  parseExpression(true);
  if (match2(TokenType._in) || isContextual(ContextualKeyword._of)) {
    parseForIn(forAwait);
    return;
  }
  if (forAwait) {
    unexpected();
  }
  parseFor();
}
function parseFunctionStatement() {
  const functionStart = state.start;
  next();
  parseFunction(functionStart, true);
}
function parseIfStatement() {
  next();
  parseParenExpression();
  parseStatement(false);
  if (eat(TokenType._else)) {
    parseStatement(false);
  }
}
function parseReturnStatement() {
  next();
  if (!isLineTerminator()) {
    parseExpression();
    semicolon();
  }
}
function parseSwitchStatement() {
  next();
  parseParenExpression();
  state.scopeDepth++;
  const startTokenIndex = state.tokens.length;
  expect(TokenType.braceL);
  while (!match2(TokenType.braceR) && !state.error) {
    if (match2(TokenType._case) || match2(TokenType._default)) {
      const isCase = match2(TokenType._case);
      next();
      if (isCase) {
        parseExpression();
      }
      expect(TokenType.colon);
    } else {
      parseStatement(true);
    }
  }
  next();
  const endTokenIndex = state.tokens.length;
  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));
  state.scopeDepth--;
}
function parseThrowStatement() {
  next();
  parseExpression();
  semicolon();
}
function parseCatchClauseParam() {
  parseBindingAtom(
    true
    /* isBlockScope */
  );
  if (isTypeScriptEnabled) {
    tsTryParseTypeAnnotation();
  }
}
function parseTryStatement() {
  next();
  parseBlock();
  if (match2(TokenType._catch)) {
    next();
    let catchBindingStartTokenIndex = null;
    if (match2(TokenType.parenL)) {
      state.scopeDepth++;
      catchBindingStartTokenIndex = state.tokens.length;
      expect(TokenType.parenL);
      parseCatchClauseParam();
      expect(TokenType.parenR);
    }
    parseBlock();
    if (catchBindingStartTokenIndex != null) {
      const endTokenIndex = state.tokens.length;
      state.scopes.push(new Scope(catchBindingStartTokenIndex, endTokenIndex, false));
      state.scopeDepth--;
    }
  }
  if (eat(TokenType._finally)) {
    parseBlock();
  }
}
function parseVarStatement(isBlockScope) {
  next();
  parseVar(false, isBlockScope);
  semicolon();
}
function parseWhileStatement() {
  next();
  parseParenExpression();
  parseStatement(false);
}
function parseEmptyStatement() {
  next();
}
function parseLabeledStatement() {
  parseStatement(true);
}
function parseIdentifierStatement(contextualKeyword) {
  if (isTypeScriptEnabled) {
    tsParseIdentifierStatement(contextualKeyword);
  } else if (isFlowEnabled) {
    flowParseIdentifierStatement(contextualKeyword);
  } else {
    semicolon();
  }
}
function parseBlock(isFunctionScope = false, contextId = 0) {
  const startTokenIndex = state.tokens.length;
  state.scopeDepth++;
  expect(TokenType.braceL);
  if (contextId) {
    state.tokens[state.tokens.length - 1].contextId = contextId;
  }
  parseBlockBody(TokenType.braceR);
  if (contextId) {
    state.tokens[state.tokens.length - 1].contextId = contextId;
  }
  const endTokenIndex = state.tokens.length;
  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, isFunctionScope));
  state.scopeDepth--;
}
function parseBlockBody(end2) {
  while (!eat(end2) && !state.error) {
    parseStatement(true);
  }
}
function parseFor() {
  expect(TokenType.semi);
  if (!match2(TokenType.semi)) {
    parseExpression();
  }
  expect(TokenType.semi);
  if (!match2(TokenType.parenR)) {
    parseExpression();
  }
  expect(TokenType.parenR);
  parseStatement(false);
}
function parseForIn(forAwait) {
  if (forAwait) {
    eatContextual(ContextualKeyword._of);
  } else {
    next();
  }
  parseExpression();
  expect(TokenType.parenR);
  parseStatement(false);
}
function parseVar(isFor, isBlockScope) {
  while (true) {
    parseVarHead(isBlockScope);
    if (eat(TokenType.eq)) {
      const eqIndex = state.tokens.length - 1;
      parseMaybeAssign(isFor);
      state.tokens[eqIndex].rhsEndIndex = state.tokens.length;
    }
    if (!eat(TokenType.comma)) {
      break;
    }
  }
}
function parseVarHead(isBlockScope) {
  parseBindingAtom(isBlockScope);
  if (isTypeScriptEnabled) {
    tsAfterParseVarHead();
  } else if (isFlowEnabled) {
    flowAfterParseVarHead();
  }
}
function parseFunction(functionStart, isStatement, optionalId = false) {
  if (match2(TokenType.star)) {
    next();
  }
  if (isStatement && !optionalId && !match2(TokenType.name) && !match2(TokenType._yield)) {
    unexpected();
  }
  let nameScopeStartTokenIndex = null;
  if (match2(TokenType.name)) {
    if (!isStatement) {
      nameScopeStartTokenIndex = state.tokens.length;
      state.scopeDepth++;
    }
    parseBindingIdentifier(false);
  }
  const startTokenIndex = state.tokens.length;
  state.scopeDepth++;
  parseFunctionParams();
  parseFunctionBodyAndFinish(functionStart);
  const endTokenIndex = state.tokens.length;
  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));
  state.scopeDepth--;
  if (nameScopeStartTokenIndex !== null) {
    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, true));
    state.scopeDepth--;
  }
}
function parseFunctionParams(allowModifiers = false, funcContextId = 0) {
  if (isTypeScriptEnabled) {
    tsStartParseFunctionParams();
  } else if (isFlowEnabled) {
    flowStartParseFunctionParams();
  }
  expect(TokenType.parenL);
  if (funcContextId) {
    state.tokens[state.tokens.length - 1].contextId = funcContextId;
  }
  parseBindingList(
    TokenType.parenR,
    false,
    false,
    allowModifiers,
    funcContextId
  );
  if (funcContextId) {
    state.tokens[state.tokens.length - 1].contextId = funcContextId;
  }
}
function parseClass(isStatement, optionalId = false) {
  const contextId = getNextContextId();
  next();
  state.tokens[state.tokens.length - 1].contextId = contextId;
  state.tokens[state.tokens.length - 1].isExpression = !isStatement;
  let nameScopeStartTokenIndex = null;
  if (!isStatement) {
    nameScopeStartTokenIndex = state.tokens.length;
    state.scopeDepth++;
  }
  parseClassId(isStatement, optionalId);
  parseClassSuper();
  const openBraceIndex = state.tokens.length;
  parseClassBody(contextId);
  if (state.error) {
    return;
  }
  state.tokens[openBraceIndex].contextId = contextId;
  state.tokens[state.tokens.length - 1].contextId = contextId;
  if (nameScopeStartTokenIndex !== null) {
    const endTokenIndex = state.tokens.length;
    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, false));
    state.scopeDepth--;
  }
}
function isClassProperty() {
  return match2(TokenType.eq) || match2(TokenType.semi) || match2(TokenType.braceR) || match2(TokenType.bang) || match2(TokenType.colon);
}
function isClassMethod() {
  return match2(TokenType.parenL) || match2(TokenType.lessThan);
}
function parseClassBody(classContextId) {
  expect(TokenType.braceL);
  while (!eat(TokenType.braceR) && !state.error) {
    if (eat(TokenType.semi)) {
      continue;
    }
    if (match2(TokenType.at)) {
      parseDecorator();
      continue;
    }
    const memberStart = state.start;
    parseClassMember(memberStart, classContextId);
  }
}
function parseClassMember(memberStart, classContextId) {
  if (isTypeScriptEnabled) {
    tsParseModifiers([
      ContextualKeyword._declare,
      ContextualKeyword._public,
      ContextualKeyword._protected,
      ContextualKeyword._private,
      ContextualKeyword._override
    ]);
  }
  let isStatic = false;
  if (match2(TokenType.name) && state.contextualKeyword === ContextualKeyword._static) {
    parseIdentifier();
    if (isClassMethod()) {
      parseClassMethod(
        memberStart,
        /* isConstructor */
        false
      );
      return;
    } else if (isClassProperty()) {
      parseClassProperty();
      return;
    }
    state.tokens[state.tokens.length - 1].type = TokenType._static;
    isStatic = true;
    if (match2(TokenType.braceL)) {
      state.tokens[state.tokens.length - 1].contextId = classContextId;
      parseBlock();
      return;
    }
  }
  parseClassMemberWithIsStatic(memberStart, isStatic, classContextId);
}
function parseClassMemberWithIsStatic(memberStart, isStatic, classContextId) {
  if (isTypeScriptEnabled) {
    if (tsTryParseClassMemberWithIsStatic(isStatic)) {
      return;
    }
  }
  if (eat(TokenType.star)) {
    parseClassPropertyName(classContextId);
    parseClassMethod(
      memberStart,
      /* isConstructor */
      false
    );
    return;
  }
  parseClassPropertyName(classContextId);
  let isConstructor = false;
  const token2 = state.tokens[state.tokens.length - 1];
  if (token2.contextualKeyword === ContextualKeyword._constructor) {
    isConstructor = true;
  }
  parsePostMemberNameModifiers();
  if (isClassMethod()) {
    parseClassMethod(memberStart, isConstructor);
  } else if (isClassProperty()) {
    parseClassProperty();
  } else if (token2.contextualKeyword === ContextualKeyword._async && !isLineTerminator()) {
    state.tokens[state.tokens.length - 1].type = TokenType._async;
    const isGenerator = match2(TokenType.star);
    if (isGenerator) {
      next();
    }
    parseClassPropertyName(classContextId);
    parsePostMemberNameModifiers();
    parseClassMethod(
      memberStart,
      false
      /* isConstructor */
    );
  } else if ((token2.contextualKeyword === ContextualKeyword._get || token2.contextualKeyword === ContextualKeyword._set) && !(isLineTerminator() && match2(TokenType.star))) {
    if (token2.contextualKeyword === ContextualKeyword._get) {
      state.tokens[state.tokens.length - 1].type = TokenType._get;
    } else {
      state.tokens[state.tokens.length - 1].type = TokenType._set;
    }
    parseClassPropertyName(classContextId);
    parseClassMethod(
      memberStart,
      /* isConstructor */
      false
    );
  } else if (token2.contextualKeyword === ContextualKeyword._accessor && !isLineTerminator()) {
    parseClassPropertyName(classContextId);
    parseClassProperty();
  } else if (isLineTerminator()) {
    parseClassProperty();
  } else {
    unexpected();
  }
}
function parseClassMethod(functionStart, isConstructor) {
  if (isTypeScriptEnabled) {
    tsTryParseTypeParameters();
  } else if (isFlowEnabled) {
    if (match2(TokenType.lessThan)) {
      flowParseTypeParameterDeclaration();
    }
  }
  parseMethod(functionStart, isConstructor);
}
function parseClassPropertyName(classContextId) {
  parsePropertyName(classContextId);
}
function parsePostMemberNameModifiers() {
  if (isTypeScriptEnabled) {
    const oldIsType = pushTypeContext(0);
    eat(TokenType.question);
    popTypeContext(oldIsType);
  }
}
function parseClassProperty() {
  if (isTypeScriptEnabled) {
    eatTypeToken(TokenType.bang);
    tsTryParseTypeAnnotation();
  } else if (isFlowEnabled) {
    if (match2(TokenType.colon)) {
      flowParseTypeAnnotation();
    }
  }
  if (match2(TokenType.eq)) {
    const equalsTokenIndex = state.tokens.length;
    next();
    parseMaybeAssign();
    state.tokens[equalsTokenIndex].rhsEndIndex = state.tokens.length;
  }
  semicolon();
}
function parseClassId(isStatement, optionalId = false) {
  if (isTypeScriptEnabled && (!isStatement || optionalId) && isContextual(ContextualKeyword._implements)) {
    return;
  }
  if (match2(TokenType.name)) {
    parseBindingIdentifier(true);
  }
  if (isTypeScriptEnabled) {
    tsTryParseTypeParameters();
  } else if (isFlowEnabled) {
    if (match2(TokenType.lessThan)) {
      flowParseTypeParameterDeclaration();
    }
  }
}
function parseClassSuper() {
  let hasSuper = false;
  if (eat(TokenType._extends)) {
    parseExprSubscripts();
    hasSuper = true;
  } else {
    hasSuper = false;
  }
  if (isTypeScriptEnabled) {
    tsAfterParseClassSuper(hasSuper);
  } else if (isFlowEnabled) {
    flowAfterParseClassSuper(hasSuper);
  }
}
function parseExport() {
  const exportIndex = state.tokens.length - 1;
  if (isTypeScriptEnabled) {
    if (tsTryParseExport()) {
      return;
    }
  }
  if (shouldParseExportStar()) {
    parseExportStar();
  } else if (isExportDefaultSpecifier()) {
    parseIdentifier();
    if (match2(TokenType.comma) && lookaheadType() === TokenType.star) {
      expect(TokenType.comma);
      expect(TokenType.star);
      expectContextual(ContextualKeyword._as);
      parseIdentifier();
    } else {
      parseExportSpecifiersMaybe();
    }
    parseExportFrom();
  } else if (eat(TokenType._default)) {
    parseExportDefaultExpression();
  } else if (shouldParseExportDeclaration()) {
    parseExportDeclaration();
  } else {
    parseExportSpecifiers();
    parseExportFrom();
  }
  state.tokens[exportIndex].rhsEndIndex = state.tokens.length;
}
function parseExportDefaultExpression() {
  if (isTypeScriptEnabled) {
    if (tsTryParseExportDefaultExpression()) {
      return;
    }
  }
  if (isFlowEnabled) {
    if (flowTryParseExportDefaultExpression()) {
      return;
    }
  }
  const functionStart = state.start;
  if (eat(TokenType._function)) {
    parseFunction(functionStart, true, true);
  } else if (isContextual(ContextualKeyword._async) && lookaheadType() === TokenType._function) {
    eatContextual(ContextualKeyword._async);
    eat(TokenType._function);
    parseFunction(functionStart, true, true);
  } else if (match2(TokenType._class)) {
    parseClass(true, true);
  } else if (match2(TokenType.at)) {
    parseDecorators();
    parseClass(true, true);
  } else {
    parseMaybeAssign();
    semicolon();
  }
}
function parseExportDeclaration() {
  if (isTypeScriptEnabled) {
    tsParseExportDeclaration();
  } else if (isFlowEnabled) {
    flowParseExportDeclaration();
  } else {
    parseStatement(true);
  }
}
function isExportDefaultSpecifier() {
  if (isTypeScriptEnabled && tsIsDeclarationStart()) {
    return false;
  } else if (isFlowEnabled && flowShouldDisallowExportDefaultSpecifier()) {
    return false;
  }
  if (match2(TokenType.name)) {
    return state.contextualKeyword !== ContextualKeyword._async;
  }
  if (!match2(TokenType._default)) {
    return false;
  }
  const _next = nextTokenStart();
  const lookahead = lookaheadTypeAndKeyword();
  const hasFrom = lookahead.type === TokenType.name && lookahead.contextualKeyword === ContextualKeyword._from;
  if (lookahead.type === TokenType.comma) {
    return true;
  }
  if (hasFrom) {
    const nextAfterFrom = input.charCodeAt(nextTokenStartSince(_next + 4));
    return nextAfterFrom === charCodes.quotationMark || nextAfterFrom === charCodes.apostrophe;
  }
  return false;
}
function parseExportSpecifiersMaybe() {
  if (eat(TokenType.comma)) {
    parseExportSpecifiers();
  }
}
function parseExportFrom() {
  if (eatContextual(ContextualKeyword._from)) {
    parseExprAtom();
    maybeParseImportAttributes();
  }
  semicolon();
}
function shouldParseExportStar() {
  if (isFlowEnabled) {
    return flowShouldParseExportStar();
  } else {
    return match2(TokenType.star);
  }
}
function parseExportStar() {
  if (isFlowEnabled) {
    flowParseExportStar();
  } else {
    baseParseExportStar();
  }
}
function baseParseExportStar() {
  expect(TokenType.star);
  if (isContextual(ContextualKeyword._as)) {
    parseExportNamespace();
  } else {
    parseExportFrom();
  }
}
function parseExportNamespace() {
  next();
  state.tokens[state.tokens.length - 1].type = TokenType._as;
  parseIdentifier();
  parseExportSpecifiersMaybe();
  parseExportFrom();
}
function shouldParseExportDeclaration() {
  return isTypeScriptEnabled && tsIsDeclarationStart() || isFlowEnabled && flowShouldParseExportDeclaration() || state.type === TokenType._var || state.type === TokenType._const || state.type === TokenType._let || state.type === TokenType._function || state.type === TokenType._class || isContextual(ContextualKeyword._async) || match2(TokenType.at);
}
function parseExportSpecifiers() {
  let first = true;
  expect(TokenType.braceL);
  while (!eat(TokenType.braceR) && !state.error) {
    if (first) {
      first = false;
    } else {
      expect(TokenType.comma);
      if (eat(TokenType.braceR)) {
        break;
      }
    }
    parseExportSpecifier();
  }
}
function parseExportSpecifier() {
  if (isTypeScriptEnabled) {
    tsParseExportSpecifier();
    return;
  }
  parseIdentifier();
  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;
  if (eatContextual(ContextualKeyword._as)) {
    parseIdentifier();
  }
}
function isImportReflection() {
  const snapshot = state.snapshot();
  expectContextual(ContextualKeyword._module);
  if (eatContextual(ContextualKeyword._from)) {
    if (isContextual(ContextualKeyword._from)) {
      state.restoreFromSnapshot(snapshot);
      return true;
    } else {
      state.restoreFromSnapshot(snapshot);
      return false;
    }
  } else if (match2(TokenType.comma)) {
    state.restoreFromSnapshot(snapshot);
    return false;
  } else {
    state.restoreFromSnapshot(snapshot);
    return true;
  }
}
function parseMaybeImportReflection() {
  if (isContextual(ContextualKeyword._module) && isImportReflection()) {
    next();
  }
}
function parseImport() {
  if (isTypeScriptEnabled && match2(TokenType.name) && lookaheadType() === TokenType.eq) {
    tsParseImportEqualsDeclaration();
    return;
  }
  if (isTypeScriptEnabled && isContextual(ContextualKeyword._type)) {
    const lookahead = lookaheadTypeAndKeyword();
    if (lookahead.type === TokenType.name && lookahead.contextualKeyword !== ContextualKeyword._from) {
      expectContextual(ContextualKeyword._type);
      if (lookaheadType() === TokenType.eq) {
        tsParseImportEqualsDeclaration();
        return;
      }
    } else if (lookahead.type === TokenType.star || lookahead.type === TokenType.braceL) {
      expectContextual(ContextualKeyword._type);
    }
  }
  if (match2(TokenType.string)) {
    parseExprAtom();
  } else {
    parseMaybeImportReflection();
    parseImportSpecifiers();
    expectContextual(ContextualKeyword._from);
    parseExprAtom();
  }
  maybeParseImportAttributes();
  semicolon();
}
function shouldParseDefaultImport() {
  return match2(TokenType.name);
}
function parseImportSpecifierLocal() {
  parseImportedIdentifier();
}
function parseImportSpecifiers() {
  if (isFlowEnabled) {
    flowStartParseImportSpecifiers();
  }
  let first = true;
  if (shouldParseDefaultImport()) {
    parseImportSpecifierLocal();
    if (!eat(TokenType.comma)) return;
  }
  if (match2(TokenType.star)) {
    next();
    expectContextual(ContextualKeyword._as);
    parseImportSpecifierLocal();
    return;
  }
  expect(TokenType.braceL);
  while (!eat(TokenType.braceR) && !state.error) {
    if (first) {
      first = false;
    } else {
      if (eat(TokenType.colon)) {
        unexpected(
          "ES2015 named imports do not destructure. Use another statement for destructuring after the import."
        );
      }
      expect(TokenType.comma);
      if (eat(TokenType.braceR)) {
        break;
      }
    }
    parseImportSpecifier();
  }
}
function parseImportSpecifier() {
  if (isTypeScriptEnabled) {
    tsParseImportSpecifier();
    return;
  }
  if (isFlowEnabled) {
    flowParseImportSpecifier();
    return;
  }
  parseImportedIdentifier();
  if (isContextual(ContextualKeyword._as)) {
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportAccess;
    next();
    parseImportedIdentifier();
  }
}
function maybeParseImportAttributes() {
  if (match2(TokenType._with) || isContextual(ContextualKeyword._assert) && !hasPrecedingLineBreak()) {
    next();
    parseObj(false, false);
  }
}

// node_modules/sucrase/dist/esm/parser/traverser/index.js
function parseFile() {
  if (state.pos === 0 && input.charCodeAt(0) === charCodes.numberSign && input.charCodeAt(1) === charCodes.exclamationMark) {
    skipLineComment(2);
  }
  nextToken();
  return parseTopLevel();
}

// node_modules/sucrase/dist/esm/parser/index.js
var File = class {
  constructor(tokens, scopes) {
    this.tokens = tokens;
    this.scopes = scopes;
  }
};
function parse2(input2, isJSXEnabled2, isTypeScriptEnabled2, isFlowEnabled2) {
  if (isFlowEnabled2 && isTypeScriptEnabled2) {
    throw new Error("Cannot combine flow and typescript plugins.");
  }
  initParser(input2, isJSXEnabled2, isTypeScriptEnabled2, isFlowEnabled2);
  const result = parseFile();
  if (state.error) {
    throw augmentError(state.error);
  }
  return result;
}

// node_modules/sucrase/dist/esm/util/isAsyncOperation.js
function isAsyncOperation(tokens) {
  let index2 = tokens.currentIndex();
  let depth = 0;
  const startToken = tokens.currentToken();
  do {
    const token2 = tokens.tokens[index2];
    if (token2.isOptionalChainStart) {
      depth++;
    }
    if (token2.isOptionalChainEnd) {
      depth--;
    }
    depth += token2.numNullishCoalesceStarts;
    depth -= token2.numNullishCoalesceEnds;
    if (token2.contextualKeyword === ContextualKeyword._await && token2.identifierRole == null && token2.scopeDepth === startToken.scopeDepth) {
      return true;
    }
    index2 += 1;
  } while (depth > 0 && index2 < tokens.tokens.length);
  return false;
}

// node_modules/sucrase/dist/esm/TokenProcessor.js
var TokenProcessor = class _TokenProcessor {
  __init() {
    this.resultCode = "";
  }
  // Array mapping input token index to optional string index position in the
  // output code.
  __init2() {
    this.resultMappings = new Array(this.tokens.length);
  }
  __init3() {
    this.tokenIndex = 0;
  }
  constructor(code, tokens, isFlowEnabled2, disableESTransforms, helperManager) {
    ;
    this.code = code;
    this.tokens = tokens;
    this.isFlowEnabled = isFlowEnabled2;
    this.disableESTransforms = disableESTransforms;
    this.helperManager = helperManager;
    _TokenProcessor.prototype.__init.call(this);
    _TokenProcessor.prototype.__init2.call(this);
    _TokenProcessor.prototype.__init3.call(this);
  }
  /**
   * Snapshot the token state in a way that can be restored later, useful for
   * things like lookahead.
   *
   * resultMappings do not need to be copied since in all use cases, they will
   * be overwritten anyway after restore.
   */
  snapshot() {
    return {
      resultCode: this.resultCode,
      tokenIndex: this.tokenIndex
    };
  }
  restoreToSnapshot(snapshot) {
    this.resultCode = snapshot.resultCode;
    this.tokenIndex = snapshot.tokenIndex;
  }
  /**
   * Remove and return the code generated since the snapshot, leaving the
   * current token position in-place. Unlike most TokenProcessor operations,
   * this operation can result in input/output line number mismatches because
   * the removed code may contain newlines, so this operation should be used
   * sparingly.
   */
  dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot) {
    const result = this.resultCode.slice(snapshot.resultCode.length);
    this.resultCode = snapshot.resultCode;
    return result;
  }
  reset() {
    this.resultCode = "";
    this.resultMappings = new Array(this.tokens.length);
    this.tokenIndex = 0;
  }
  matchesContextualAtIndex(index2, contextualKeyword) {
    return this.matches1AtIndex(index2, TokenType.name) && this.tokens[index2].contextualKeyword === contextualKeyword;
  }
  identifierNameAtIndex(index2) {
    return this.identifierNameForToken(this.tokens[index2]);
  }
  identifierNameAtRelativeIndex(relativeIndex) {
    return this.identifierNameForToken(this.tokenAtRelativeIndex(relativeIndex));
  }
  identifierName() {
    return this.identifierNameForToken(this.currentToken());
  }
  identifierNameForToken(token2) {
    return this.code.slice(token2.start, token2.end);
  }
  rawCodeForToken(token2) {
    return this.code.slice(token2.start, token2.end);
  }
  stringValueAtIndex(index2) {
    return this.stringValueForToken(this.tokens[index2]);
  }
  stringValue() {
    return this.stringValueForToken(this.currentToken());
  }
  stringValueForToken(token2) {
    return this.code.slice(token2.start + 1, token2.end - 1);
  }
  matches1AtIndex(index2, t1) {
    return this.tokens[index2].type === t1;
  }
  matches2AtIndex(index2, t1, t22) {
    return this.tokens[index2].type === t1 && this.tokens[index2 + 1].type === t22;
  }
  matches3AtIndex(index2, t1, t22, t32) {
    return this.tokens[index2].type === t1 && this.tokens[index2 + 1].type === t22 && this.tokens[index2 + 2].type === t32;
  }
  matches1(t1) {
    return this.tokens[this.tokenIndex].type === t1;
  }
  matches2(t1, t22) {
    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t22;
  }
  matches3(t1, t22, t32) {
    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t22 && this.tokens[this.tokenIndex + 2].type === t32;
  }
  matches4(t1, t22, t32, t42) {
    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t22 && this.tokens[this.tokenIndex + 2].type === t32 && this.tokens[this.tokenIndex + 3].type === t42;
  }
  matches5(t1, t22, t32, t42, t5) {
    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t22 && this.tokens[this.tokenIndex + 2].type === t32 && this.tokens[this.tokenIndex + 3].type === t42 && this.tokens[this.tokenIndex + 4].type === t5;
  }
  matchesContextual(contextualKeyword) {
    return this.matchesContextualAtIndex(this.tokenIndex, contextualKeyword);
  }
  matchesContextIdAndLabel(type, contextId) {
    return this.matches1(type) && this.currentToken().contextId === contextId;
  }
  previousWhitespaceAndComments() {
    let whitespaceAndComments = this.code.slice(
      this.tokenIndex > 0 ? this.tokens[this.tokenIndex - 1].end : 0,
      this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex].start : this.code.length
    );
    if (this.isFlowEnabled) {
      whitespaceAndComments = whitespaceAndComments.replace(/@flow/g, "");
    }
    return whitespaceAndComments;
  }
  replaceToken(newCode) {
    this.resultCode += this.previousWhitespaceAndComments();
    this.appendTokenPrefix();
    this.resultMappings[this.tokenIndex] = this.resultCode.length;
    this.resultCode += newCode;
    this.appendTokenSuffix();
    this.tokenIndex++;
  }
  replaceTokenTrimmingLeftWhitespace(newCode) {
    this.resultCode += this.previousWhitespaceAndComments().replace(/[^\r\n]/g, "");
    this.appendTokenPrefix();
    this.resultMappings[this.tokenIndex] = this.resultCode.length;
    this.resultCode += newCode;
    this.appendTokenSuffix();
    this.tokenIndex++;
  }
  removeInitialToken() {
    this.replaceToken("");
  }
  removeToken() {
    this.replaceTokenTrimmingLeftWhitespace("");
  }
  /**
   * Remove all code until the next }, accounting for balanced braces.
   */
  removeBalancedCode() {
    let braceDepth = 0;
    while (!this.isAtEnd()) {
      if (this.matches1(TokenType.braceL)) {
        braceDepth++;
      } else if (this.matches1(TokenType.braceR)) {
        if (braceDepth === 0) {
          return;
        }
        braceDepth--;
      }
      this.removeToken();
    }
  }
  copyExpectedToken(tokenType) {
    if (this.tokens[this.tokenIndex].type !== tokenType) {
      throw new Error(`Expected token ${tokenType}`);
    }
    this.copyToken();
  }
  copyToken() {
    this.resultCode += this.previousWhitespaceAndComments();
    this.appendTokenPrefix();
    this.resultMappings[this.tokenIndex] = this.resultCode.length;
    this.resultCode += this.code.slice(
      this.tokens[this.tokenIndex].start,
      this.tokens[this.tokenIndex].end
    );
    this.appendTokenSuffix();
    this.tokenIndex++;
  }
  copyTokenWithPrefix(prefix2) {
    this.resultCode += this.previousWhitespaceAndComments();
    this.appendTokenPrefix();
    this.resultCode += prefix2;
    this.resultMappings[this.tokenIndex] = this.resultCode.length;
    this.resultCode += this.code.slice(
      this.tokens[this.tokenIndex].start,
      this.tokens[this.tokenIndex].end
    );
    this.appendTokenSuffix();
    this.tokenIndex++;
  }
  appendTokenPrefix() {
    const token2 = this.currentToken();
    if (token2.numNullishCoalesceStarts || token2.isOptionalChainStart) {
      token2.isAsyncOperation = isAsyncOperation(this);
    }
    if (this.disableESTransforms) {
      return;
    }
    if (token2.numNullishCoalesceStarts) {
      for (let i4 = 0; i4 < token2.numNullishCoalesceStarts; i4++) {
        if (token2.isAsyncOperation) {
          this.resultCode += "await ";
          this.resultCode += this.helperManager.getHelperName("asyncNullishCoalesce");
        } else {
          this.resultCode += this.helperManager.getHelperName("nullishCoalesce");
        }
        this.resultCode += "(";
      }
    }
    if (token2.isOptionalChainStart) {
      if (token2.isAsyncOperation) {
        this.resultCode += "await ";
      }
      if (this.tokenIndex > 0 && this.tokenAtRelativeIndex(-1).type === TokenType._delete) {
        if (token2.isAsyncOperation) {
          this.resultCode += this.helperManager.getHelperName("asyncOptionalChainDelete");
        } else {
          this.resultCode += this.helperManager.getHelperName("optionalChainDelete");
        }
      } else if (token2.isAsyncOperation) {
        this.resultCode += this.helperManager.getHelperName("asyncOptionalChain");
      } else {
        this.resultCode += this.helperManager.getHelperName("optionalChain");
      }
      this.resultCode += "([";
    }
  }
  appendTokenSuffix() {
    const token2 = this.currentToken();
    if (token2.isOptionalChainEnd && !this.disableESTransforms) {
      this.resultCode += "])";
    }
    if (token2.numNullishCoalesceEnds && !this.disableESTransforms) {
      for (let i4 = 0; i4 < token2.numNullishCoalesceEnds; i4++) {
        this.resultCode += "))";
      }
    }
  }
  appendCode(code) {
    this.resultCode += code;
  }
  currentToken() {
    return this.tokens[this.tokenIndex];
  }
  currentTokenCode() {
    const token2 = this.currentToken();
    return this.code.slice(token2.start, token2.end);
  }
  tokenAtRelativeIndex(relativeIndex) {
    return this.tokens[this.tokenIndex + relativeIndex];
  }
  currentIndex() {
    return this.tokenIndex;
  }
  /**
   * Move to the next token. Only suitable in preprocessing steps. When
   * generating new code, you should use copyToken or removeToken.
   */
  nextToken() {
    if (this.tokenIndex === this.tokens.length) {
      throw new Error("Unexpectedly reached end of input.");
    }
    this.tokenIndex++;
  }
  previousToken() {
    this.tokenIndex--;
  }
  finish() {
    if (this.tokenIndex !== this.tokens.length) {
      throw new Error("Tried to finish processing tokens before reaching the end.");
    }
    this.resultCode += this.previousWhitespaceAndComments();
    return { code: this.resultCode, mappings: this.resultMappings };
  }
  isAtEnd() {
    return this.tokenIndex === this.tokens.length;
  }
};

// node_modules/sucrase/dist/esm/util/getClassInfo.js
function getClassInfo(rootTransformer, tokens, nameManager, disableESTransforms) {
  const snapshot = tokens.snapshot();
  const headerInfo = processClassHeader(tokens);
  let constructorInitializerStatements = [];
  const instanceInitializerNames = [];
  const staticInitializerNames = [];
  let constructorInsertPos = null;
  const fields = [];
  const rangesToRemove = [];
  const classContextId = tokens.currentToken().contextId;
  if (classContextId == null) {
    throw new Error("Expected non-null class context ID on class open-brace.");
  }
  tokens.nextToken();
  while (!tokens.matchesContextIdAndLabel(TokenType.braceR, classContextId)) {
    if (tokens.matchesContextual(ContextualKeyword._constructor) && !tokens.currentToken().isType) {
      ({ constructorInitializerStatements, constructorInsertPos } = processConstructor(tokens));
    } else if (tokens.matches1(TokenType.semi)) {
      if (!disableESTransforms) {
        rangesToRemove.push({ start: tokens.currentIndex(), end: tokens.currentIndex() + 1 });
      }
      tokens.nextToken();
    } else if (tokens.currentToken().isType) {
      tokens.nextToken();
    } else {
      const statementStartIndex = tokens.currentIndex();
      let isStatic = false;
      let isESPrivate = false;
      let isDeclareOrAbstract = false;
      while (isAccessModifier(tokens.currentToken())) {
        if (tokens.matches1(TokenType._static)) {
          isStatic = true;
        }
        if (tokens.matches1(TokenType.hash)) {
          isESPrivate = true;
        }
        if (tokens.matches1(TokenType._declare) || tokens.matches1(TokenType._abstract)) {
          isDeclareOrAbstract = true;
        }
        tokens.nextToken();
      }
      if (isStatic && tokens.matches1(TokenType.braceL)) {
        skipToNextClassElement(tokens, classContextId);
        continue;
      }
      if (isESPrivate) {
        skipToNextClassElement(tokens, classContextId);
        continue;
      }
      if (tokens.matchesContextual(ContextualKeyword._constructor) && !tokens.currentToken().isType) {
        ({ constructorInitializerStatements, constructorInsertPos } = processConstructor(tokens));
        continue;
      }
      const nameStartIndex = tokens.currentIndex();
      skipFieldName(tokens);
      if (tokens.matches1(TokenType.lessThan) || tokens.matches1(TokenType.parenL)) {
        skipToNextClassElement(tokens, classContextId);
        continue;
      }
      while (tokens.currentToken().isType) {
        tokens.nextToken();
      }
      if (tokens.matches1(TokenType.eq)) {
        const equalsIndex = tokens.currentIndex();
        const valueEnd = tokens.currentToken().rhsEndIndex;
        if (valueEnd == null) {
          throw new Error("Expected rhsEndIndex on class field assignment.");
        }
        tokens.nextToken();
        while (tokens.currentIndex() < valueEnd) {
          rootTransformer.processToken();
        }
        let initializerName;
        if (isStatic) {
          initializerName = nameManager.claimFreeName("__initStatic");
          staticInitializerNames.push(initializerName);
        } else {
          initializerName = nameManager.claimFreeName("__init");
          instanceInitializerNames.push(initializerName);
        }
        fields.push({
          initializerName,
          equalsIndex,
          start: nameStartIndex,
          end: tokens.currentIndex()
        });
      } else if (!disableESTransforms || isDeclareOrAbstract) {
        rangesToRemove.push({ start: statementStartIndex, end: tokens.currentIndex() });
      }
    }
  }
  tokens.restoreToSnapshot(snapshot);
  if (disableESTransforms) {
    return {
      headerInfo,
      constructorInitializerStatements,
      instanceInitializerNames: [],
      staticInitializerNames: [],
      constructorInsertPos,
      fields: [],
      rangesToRemove
    };
  } else {
    return {
      headerInfo,
      constructorInitializerStatements,
      instanceInitializerNames,
      staticInitializerNames,
      constructorInsertPos,
      fields,
      rangesToRemove
    };
  }
}
function skipToNextClassElement(tokens, classContextId) {
  tokens.nextToken();
  while (tokens.currentToken().contextId !== classContextId) {
    tokens.nextToken();
  }
  while (isAccessModifier(tokens.tokenAtRelativeIndex(-1))) {
    tokens.previousToken();
  }
}
function processClassHeader(tokens) {
  const classToken = tokens.currentToken();
  const contextId = classToken.contextId;
  if (contextId == null) {
    throw new Error("Expected context ID on class token.");
  }
  const isExpression = classToken.isExpression;
  if (isExpression == null) {
    throw new Error("Expected isExpression on class token.");
  }
  let className = null;
  let hasSuperclass = false;
  tokens.nextToken();
  if (tokens.matches1(TokenType.name)) {
    className = tokens.identifierName();
  }
  while (!tokens.matchesContextIdAndLabel(TokenType.braceL, contextId)) {
    if (tokens.matches1(TokenType._extends) && !tokens.currentToken().isType) {
      hasSuperclass = true;
    }
    tokens.nextToken();
  }
  return { isExpression, className, hasSuperclass };
}
function processConstructor(tokens) {
  const constructorInitializerStatements = [];
  tokens.nextToken();
  const constructorContextId = tokens.currentToken().contextId;
  if (constructorContextId == null) {
    throw new Error("Expected context ID on open-paren starting constructor params.");
  }
  while (!tokens.matchesContextIdAndLabel(TokenType.parenR, constructorContextId)) {
    if (tokens.currentToken().contextId === constructorContextId) {
      tokens.nextToken();
      if (isAccessModifier(tokens.currentToken())) {
        tokens.nextToken();
        while (isAccessModifier(tokens.currentToken())) {
          tokens.nextToken();
        }
        const token2 = tokens.currentToken();
        if (token2.type !== TokenType.name) {
          throw new Error("Expected identifier after access modifiers in constructor arg.");
        }
        const name = tokens.identifierNameForToken(token2);
        constructorInitializerStatements.push(`this.${name} = ${name}`);
      }
    } else {
      tokens.nextToken();
    }
  }
  tokens.nextToken();
  while (tokens.currentToken().isType) {
    tokens.nextToken();
  }
  let constructorInsertPos = tokens.currentIndex();
  let foundSuperCall = false;
  while (!tokens.matchesContextIdAndLabel(TokenType.braceR, constructorContextId)) {
    if (!foundSuperCall && tokens.matches2(TokenType._super, TokenType.parenL)) {
      tokens.nextToken();
      const superCallContextId = tokens.currentToken().contextId;
      if (superCallContextId == null) {
        throw new Error("Expected a context ID on the super call");
      }
      while (!tokens.matchesContextIdAndLabel(TokenType.parenR, superCallContextId)) {
        tokens.nextToken();
      }
      constructorInsertPos = tokens.currentIndex();
      foundSuperCall = true;
    }
    tokens.nextToken();
  }
  tokens.nextToken();
  return { constructorInitializerStatements, constructorInsertPos };
}
function isAccessModifier(token2) {
  return [
    TokenType._async,
    TokenType._get,
    TokenType._set,
    TokenType.plus,
    TokenType.minus,
    TokenType._readonly,
    TokenType._static,
    TokenType._public,
    TokenType._private,
    TokenType._protected,
    TokenType._override,
    TokenType._abstract,
    TokenType.star,
    TokenType._declare,
    TokenType.hash
  ].includes(token2.type);
}
function skipFieldName(tokens) {
  if (tokens.matches1(TokenType.bracketL)) {
    const startToken = tokens.currentToken();
    const classContextId = startToken.contextId;
    if (classContextId == null) {
      throw new Error("Expected class context ID on computed name open bracket.");
    }
    while (!tokens.matchesContextIdAndLabel(TokenType.bracketR, classContextId)) {
      tokens.nextToken();
    }
    tokens.nextToken();
  } else {
    tokens.nextToken();
  }
}

// node_modules/sucrase/dist/esm/util/elideImportEquals.js
function elideImportEquals(tokens) {
  tokens.removeInitialToken();
  tokens.removeToken();
  tokens.removeToken();
  tokens.removeToken();
  if (tokens.matches1(TokenType.parenL)) {
    tokens.removeToken();
    tokens.removeToken();
    tokens.removeToken();
  } else {
    while (tokens.matches1(TokenType.dot)) {
      tokens.removeToken();
      tokens.removeToken();
    }
  }
}

// node_modules/sucrase/dist/esm/util/getDeclarationInfo.js
var EMPTY_DECLARATION_INFO = {
  typeDeclarations: /* @__PURE__ */ new Set(),
  valueDeclarations: /* @__PURE__ */ new Set()
};
function getDeclarationInfo(tokens) {
  const typeDeclarations = /* @__PURE__ */ new Set();
  const valueDeclarations = /* @__PURE__ */ new Set();
  for (let i4 = 0; i4 < tokens.tokens.length; i4++) {
    const token2 = tokens.tokens[i4];
    if (token2.type === TokenType.name && isTopLevelDeclaration(token2)) {
      if (token2.isType) {
        typeDeclarations.add(tokens.identifierNameForToken(token2));
      } else {
        valueDeclarations.add(tokens.identifierNameForToken(token2));
      }
    }
  }
  return { typeDeclarations, valueDeclarations };
}

// node_modules/sucrase/dist/esm/util/isExportFrom.js
function isExportFrom(tokens) {
  let closeBraceIndex = tokens.currentIndex();
  while (!tokens.matches1AtIndex(closeBraceIndex, TokenType.braceR)) {
    closeBraceIndex++;
  }
  return tokens.matchesContextualAtIndex(closeBraceIndex + 1, ContextualKeyword._from) && tokens.matches1AtIndex(closeBraceIndex + 2, TokenType.string);
}

// node_modules/sucrase/dist/esm/util/removeMaybeImportAttributes.js
function removeMaybeImportAttributes(tokens) {
  if (tokens.matches2(TokenType._with, TokenType.braceL) || tokens.matches2(TokenType.name, TokenType.braceL) && tokens.matchesContextual(ContextualKeyword._assert)) {
    tokens.removeToken();
    tokens.removeToken();
    tokens.removeBalancedCode();
    tokens.removeToken();
  }
}

// node_modules/sucrase/dist/esm/util/shouldElideDefaultExport.js
function shouldElideDefaultExport(isTypeScriptTransformEnabled, keepUnusedImports, tokens, declarationInfo) {
  if (!isTypeScriptTransformEnabled || keepUnusedImports) {
    return false;
  }
  const exportToken = tokens.currentToken();
  if (exportToken.rhsEndIndex == null) {
    throw new Error("Expected non-null rhsEndIndex on export token.");
  }
  const numTokens = exportToken.rhsEndIndex - tokens.currentIndex();
  if (numTokens !== 3 && !(numTokens === 4 && tokens.matches1AtIndex(exportToken.rhsEndIndex - 1, TokenType.semi))) {
    return false;
  }
  const identifierToken = tokens.tokenAtRelativeIndex(2);
  if (identifierToken.type !== TokenType.name) {
    return false;
  }
  const exportedName = tokens.identifierNameForToken(identifierToken);
  return declarationInfo.typeDeclarations.has(exportedName) && !declarationInfo.valueDeclarations.has(exportedName);
}

// node_modules/sucrase/dist/esm/transformers/CJSImportTransformer.js
var CJSImportTransformer = class _CJSImportTransformer extends Transformer {
  __init() {
    this.hadExport = false;
  }
  __init2() {
    this.hadNamedExport = false;
  }
  __init3() {
    this.hadDefaultExport = false;
  }
  constructor(rootTransformer, tokens, importProcessor, nameManager, helperManager, reactHotLoaderTransformer, enableLegacyBabel5ModuleInterop, enableLegacyTypeScriptModuleInterop, isTypeScriptTransformEnabled, isFlowTransformEnabled, preserveDynamicImport, keepUnusedImports) {
    super();
    this.rootTransformer = rootTransformer;
    this.tokens = tokens;
    this.importProcessor = importProcessor;
    this.nameManager = nameManager;
    this.helperManager = helperManager;
    this.reactHotLoaderTransformer = reactHotLoaderTransformer;
    this.enableLegacyBabel5ModuleInterop = enableLegacyBabel5ModuleInterop;
    this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;
    this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;
    this.isFlowTransformEnabled = isFlowTransformEnabled;
    this.preserveDynamicImport = preserveDynamicImport;
    this.keepUnusedImports = keepUnusedImports;
    _CJSImportTransformer.prototype.__init.call(this);
    _CJSImportTransformer.prototype.__init2.call(this);
    _CJSImportTransformer.prototype.__init3.call(this);
    ;
    this.declarationInfo = isTypeScriptTransformEnabled ? getDeclarationInfo(tokens) : EMPTY_DECLARATION_INFO;
  }
  getPrefixCode() {
    let prefix2 = "";
    if (this.hadExport) {
      prefix2 += 'Object.defineProperty(exports, "__esModule", {value: true});';
    }
    return prefix2;
  }
  getSuffixCode() {
    if (this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport) {
      return "\nmodule.exports = exports.default;\n";
    }
    return "";
  }
  process() {
    if (this.tokens.matches3(TokenType._import, TokenType.name, TokenType.eq)) {
      return this.processImportEquals();
    }
    if (this.tokens.matches1(TokenType._import)) {
      this.processImport();
      return true;
    }
    if (this.tokens.matches2(TokenType._export, TokenType.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (this.tokens.matches1(TokenType._export) && !this.tokens.currentToken().isType) {
      this.hadExport = true;
      return this.processExport();
    }
    if (this.tokens.matches2(TokenType.name, TokenType.postIncDec)) {
      if (this.processPostIncDec()) {
        return true;
      }
    }
    if (this.tokens.matches1(TokenType.name) || this.tokens.matches1(TokenType.jsxName)) {
      return this.processIdentifier();
    }
    if (this.tokens.matches1(TokenType.eq)) {
      return this.processAssignment();
    }
    if (this.tokens.matches1(TokenType.assign)) {
      return this.processComplexAssignment();
    }
    if (this.tokens.matches1(TokenType.preIncDec)) {
      return this.processPreIncDec();
    }
    return false;
  }
  processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.importProcessor.shouldAutomaticallyElideImportedName(importName)) {
      elideImportEquals(this.tokens);
    } else {
      this.tokens.replaceToken("const");
    }
    return true;
  }
  /**
   * Transform this:
   * import foo, {bar} from 'baz';
   * into
   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);
   *
   * The import code was already generated in the import preprocessing step, so
   * we just need to look it up.
   */
  processImport() {
    if (this.tokens.matches2(TokenType._import, TokenType.parenL)) {
      if (this.preserveDynamicImport) {
        this.tokens.copyToken();
        return;
      }
      const requireWrapper = this.enableLegacyTypeScriptModuleInterop ? "" : `${this.helperManager.getHelperName("interopRequireWildcard")}(`;
      this.tokens.replaceToken(`Promise.resolve().then(() => ${requireWrapper}require`);
      const contextId = this.tokens.currentToken().contextId;
      if (contextId == null) {
        throw new Error("Expected context ID on dynamic import invocation.");
      }
      this.tokens.copyToken();
      while (!this.tokens.matchesContextIdAndLabel(TokenType.parenR, contextId)) {
        this.rootTransformer.processToken();
      }
      this.tokens.replaceToken(requireWrapper ? ")))" : "))");
      return;
    }
    const shouldElideImport = this.removeImportAndDetectIfShouldElide();
    if (shouldElideImport) {
      this.tokens.removeToken();
    } else {
      const path = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
      this.tokens.appendCode(this.importProcessor.claimImportCode(path));
    }
    removeMaybeImportAttributes(this.tokens);
    if (this.tokens.matches1(TokenType.semi)) {
      this.tokens.removeToken();
    }
  }
  /**
   * Erase this import (since any CJS output would be completely different), and
   * return true if this import is should be elided due to being a type-only
   * import. Such imports will not be emitted at all to avoid side effects.
   *
   * Import elision only happens with the TypeScript or Flow transforms enabled.
   *
   * TODO: This function has some awkward overlap with
   *  CJSImportProcessor.pruneTypeOnlyImports , and the two should be unified.
   *  That function handles TypeScript implicit import name elision, and removes
   *  an import if all typical imported names (without `type`) are removed due
   *  to being type-only imports. This function handles Flow import removal and
   *  properly distinguishes `import 'foo'` from `import {} from 'foo'` for TS
   *  purposes.
   *
   * The position should end at the import string.
   */
  removeImportAndDetectIfShouldElide() {
    this.tokens.removeInitialToken();
    if (this.tokens.matchesContextual(ContextualKeyword._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, TokenType.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)) {
      this.removeRemainingImport();
      return true;
    }
    if (this.tokens.matches1(TokenType.name) || this.tokens.matches1(TokenType.star)) {
      this.removeRemainingImport();
      return false;
    }
    if (this.tokens.matches1(TokenType.string)) {
      return false;
    }
    let foundNonTypeImport = false;
    let foundAnyNamedImport = false;
    while (!this.tokens.matches1(TokenType.string)) {
      if (!foundNonTypeImport && this.tokens.matches1(TokenType.braceL) || this.tokens.matches1(TokenType.comma)) {
        this.tokens.removeToken();
        if (!this.tokens.matches1(TokenType.braceR)) {
          foundAnyNamedImport = true;
        }
        if (this.tokens.matches2(TokenType.name, TokenType.comma) || this.tokens.matches2(TokenType.name, TokenType.braceR) || this.tokens.matches4(TokenType.name, TokenType.name, TokenType.name, TokenType.comma) || this.tokens.matches4(TokenType.name, TokenType.name, TokenType.name, TokenType.braceR)) {
          foundNonTypeImport = true;
        }
      }
      this.tokens.removeToken();
    }
    if (this.keepUnusedImports) {
      return false;
    }
    if (this.isTypeScriptTransformEnabled) {
      return !foundNonTypeImport;
    } else if (this.isFlowTransformEnabled) {
      return foundAnyNamedImport && !foundNonTypeImport;
    } else {
      return false;
    }
  }
  removeRemainingImport() {
    while (!this.tokens.matches1(TokenType.string)) {
      this.tokens.removeToken();
    }
  }
  processIdentifier() {
    const token2 = this.tokens.currentToken();
    if (token2.shadowsGlobal) {
      return false;
    }
    if (token2.identifierRole === IdentifierRole.ObjectShorthand) {
      return this.processObjectShorthand();
    }
    if (token2.identifierRole !== IdentifierRole.Access) {
      return false;
    }
    const replacement = this.importProcessor.getIdentifierReplacement(
      this.tokens.identifierNameForToken(token2)
    );
    if (!replacement) {
      return false;
    }
    let possibleOpenParenIndex = this.tokens.currentIndex() + 1;
    while (possibleOpenParenIndex < this.tokens.tokens.length && this.tokens.tokens[possibleOpenParenIndex].type === TokenType.parenR) {
      possibleOpenParenIndex++;
    }
    if (this.tokens.tokens[possibleOpenParenIndex].type === TokenType.parenL) {
      if (this.tokens.tokenAtRelativeIndex(1).type === TokenType.parenL && this.tokens.tokenAtRelativeIndex(-1).type !== TokenType._new) {
        this.tokens.replaceToken(`${replacement}.call(void 0, `);
        this.tokens.removeToken();
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(TokenType.parenR);
      } else {
        this.tokens.replaceToken(`(0, ${replacement})`);
      }
    } else {
      this.tokens.replaceToken(replacement);
    }
    return true;
  }
  processObjectShorthand() {
    const identifier2 = this.tokens.identifierName();
    const replacement = this.importProcessor.getIdentifierReplacement(identifier2);
    if (!replacement) {
      return false;
    }
    this.tokens.replaceToken(`${identifier2}: ${replacement}`);
    return true;
  }
  processExport() {
    if (this.tokens.matches2(TokenType._export, TokenType._enum) || this.tokens.matches3(TokenType._export, TokenType._const, TokenType._enum)) {
      this.hadNamedExport = true;
      return false;
    }
    if (this.tokens.matches2(TokenType._export, TokenType._default)) {
      if (this.tokens.matches3(TokenType._export, TokenType._default, TokenType._enum)) {
        this.hadDefaultExport = true;
        return false;
      }
      this.processExportDefault();
      return true;
    } else if (this.tokens.matches2(TokenType._export, TokenType.braceL)) {
      this.processExportBindings();
      return true;
    } else if (this.tokens.matches2(TokenType._export, TokenType.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      if (this.tokens.matches1(TokenType.braceL)) {
        while (!this.tokens.matches1(TokenType.braceR)) {
          this.tokens.removeToken();
        }
        this.tokens.removeToken();
      } else {
        this.tokens.removeToken();
        if (this.tokens.matches1(TokenType._as)) {
          this.tokens.removeToken();
          this.tokens.removeToken();
        }
      }
      if (this.tokens.matchesContextual(ContextualKeyword._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, TokenType.string)) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        removeMaybeImportAttributes(this.tokens);
      }
      return true;
    }
    this.hadNamedExport = true;
    if (this.tokens.matches2(TokenType._export, TokenType._var) || this.tokens.matches2(TokenType._export, TokenType._let) || this.tokens.matches2(TokenType._export, TokenType._const)) {
      this.processExportVar();
      return true;
    } else if (this.tokens.matches2(TokenType._export, TokenType._function) || // export async function
    this.tokens.matches3(TokenType._export, TokenType.name, TokenType._function)) {
      this.processExportFunction();
      return true;
    } else if (this.tokens.matches2(TokenType._export, TokenType._class) || this.tokens.matches3(TokenType._export, TokenType._abstract, TokenType._class) || this.tokens.matches2(TokenType._export, TokenType.at)) {
      this.processExportClass();
      return true;
    } else if (this.tokens.matches2(TokenType._export, TokenType.star)) {
      this.processExportStar();
      return true;
    } else {
      throw new Error("Unrecognized export syntax.");
    }
  }
  processAssignment() {
    const index2 = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index2 - 1];
    if (identifierToken.isType || identifierToken.type !== TokenType.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index2 >= 2 && this.tokens.matches1AtIndex(index2 - 2, TokenType.dot)) {
      return false;
    }
    if (index2 >= 2 && [TokenType._var, TokenType._let, TokenType._const].includes(this.tokens.tokens[index2 - 2].type)) {
      return false;
    }
    const assignmentSnippet = this.importProcessor.resolveExportBinding(
      this.tokens.identifierNameForToken(identifierToken)
    );
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.copyToken();
    this.tokens.appendCode(` ${assignmentSnippet} =`);
    return true;
  }
  /**
   * Process something like `a += 3`, where `a` might be an exported value.
   */
  processComplexAssignment() {
    const index2 = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index2 - 1];
    if (identifierToken.type !== TokenType.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index2 >= 2 && this.tokens.matches1AtIndex(index2 - 2, TokenType.dot)) {
      return false;
    }
    const assignmentSnippet = this.importProcessor.resolveExportBinding(
      this.tokens.identifierNameForToken(identifierToken)
    );
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.appendCode(` = ${assignmentSnippet}`);
    this.tokens.copyToken();
    return true;
  }
  /**
   * Process something like `++a`, where `a` might be an exported value.
   */
  processPreIncDec() {
    const index2 = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index2 + 1];
    if (identifierToken.type !== TokenType.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index2 + 2 < this.tokens.tokens.length && (this.tokens.matches1AtIndex(index2 + 2, TokenType.dot) || this.tokens.matches1AtIndex(index2 + 2, TokenType.bracketL) || this.tokens.matches1AtIndex(index2 + 2, TokenType.parenL))) {
      return false;
    }
    const identifierName = this.tokens.identifierNameForToken(identifierToken);
    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.appendCode(`${assignmentSnippet} = `);
    this.tokens.copyToken();
    return true;
  }
  /**
   * Process something like `a++`, where `a` might be an exported value.
   * This starts at the `a`, not at the `++`.
   */
  processPostIncDec() {
    const index2 = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index2];
    const operatorToken2 = this.tokens.tokens[index2 + 1];
    if (identifierToken.type !== TokenType.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index2 >= 1 && this.tokens.matches1AtIndex(index2 - 1, TokenType.dot)) {
      return false;
    }
    const identifierName = this.tokens.identifierNameForToken(identifierToken);
    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);
    if (!assignmentSnippet) {
      return false;
    }
    const operatorCode = this.tokens.rawCodeForToken(operatorToken2);
    const base = this.importProcessor.getIdentifierReplacement(identifierName) || identifierName;
    if (operatorCode === "++") {
      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} + 1, ${base} - 1)`);
    } else if (operatorCode === "--") {
      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} - 1, ${base} + 1)`);
    } else {
      throw new Error(`Unexpected operator: ${operatorCode}`);
    }
    this.tokens.removeToken();
    return true;
  }
  processExportDefault() {
    let exportedRuntimeValue = true;
    if (this.tokens.matches4(TokenType._export, TokenType._default, TokenType._function, TokenType.name) || // export default async function
    this.tokens.matches5(TokenType._export, TokenType._default, TokenType.name, TokenType._function, TokenType.name) && this.tokens.matchesContextualAtIndex(
      this.tokens.currentIndex() + 2,
      ContextualKeyword._async
    )) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      const name = this.processNamedFunction();
      this.tokens.appendCode(` exports.default = ${name};`);
    } else if (this.tokens.matches4(TokenType._export, TokenType._default, TokenType._class, TokenType.name) || this.tokens.matches5(TokenType._export, TokenType._default, TokenType._abstract, TokenType._class, TokenType.name) || this.tokens.matches3(TokenType._export, TokenType._default, TokenType.at)) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.copyDecorators();
      if (this.tokens.matches1(TokenType._abstract)) {
        this.tokens.removeToken();
      }
      const name = this.rootTransformer.processNamedClass();
      this.tokens.appendCode(` exports.default = ${name};`);
    } else if (shouldElideDefaultExport(
      this.isTypeScriptTransformEnabled,
      this.keepUnusedImports,
      this.tokens,
      this.declarationInfo
    )) {
      exportedRuntimeValue = false;
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.tokens.removeToken();
    } else if (this.reactHotLoaderTransformer) {
      const defaultVarName = this.nameManager.claimFreeName("_default");
      this.tokens.replaceToken(`let ${defaultVarName}; exports.`);
      this.tokens.copyToken();
      this.tokens.appendCode(` = ${defaultVarName} =`);
      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);
    } else {
      this.tokens.replaceToken("exports.");
      this.tokens.copyToken();
      this.tokens.appendCode(" =");
    }
    if (exportedRuntimeValue) {
      this.hadDefaultExport = true;
    }
  }
  copyDecorators() {
    while (this.tokens.matches1(TokenType.at)) {
      this.tokens.copyToken();
      if (this.tokens.matches1(TokenType.parenL)) {
        this.tokens.copyExpectedToken(TokenType.parenL);
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(TokenType.parenR);
      } else {
        this.tokens.copyExpectedToken(TokenType.name);
        while (this.tokens.matches1(TokenType.dot)) {
          this.tokens.copyExpectedToken(TokenType.dot);
          this.tokens.copyExpectedToken(TokenType.name);
        }
        if (this.tokens.matches1(TokenType.parenL)) {
          this.tokens.copyExpectedToken(TokenType.parenL);
          this.rootTransformer.processBalancedCode();
          this.tokens.copyExpectedToken(TokenType.parenR);
        }
      }
    }
  }
  /**
   * Transform a declaration like `export var`, `export let`, or `export const`.
   */
  processExportVar() {
    if (this.isSimpleExportVar()) {
      this.processSimpleExportVar();
    } else {
      this.processComplexExportVar();
    }
  }
  /**
   * Determine if the export is of the form:
   * export var/let/const [varName] = [expr];
   * In other words, determine if function name inference might apply.
   */
  isSimpleExportVar() {
    let tokenIndex = this.tokens.currentIndex();
    tokenIndex++;
    tokenIndex++;
    if (!this.tokens.matches1AtIndex(tokenIndex, TokenType.name)) {
      return false;
    }
    tokenIndex++;
    while (tokenIndex < this.tokens.tokens.length && this.tokens.tokens[tokenIndex].isType) {
      tokenIndex++;
    }
    if (!this.tokens.matches1AtIndex(tokenIndex, TokenType.eq)) {
      return false;
    }
    return true;
  }
  /**
   * Transform an `export var` declaration initializing a single variable.
   *
   * For example, this:
   * export const f = () => {};
   * becomes this:
   * const f = () => {}; exports.f = f;
   *
   * The variable is unused (e.g. exports.f has the true value of the export).
   * We need to produce an assignment of this form so that the function will
   * have an inferred name of "f", which wouldn't happen in the more general
   * case below.
   */
  processSimpleExportVar() {
    this.tokens.removeInitialToken();
    this.tokens.copyToken();
    const varName = this.tokens.identifierName();
    while (!this.tokens.matches1(TokenType.eq)) {
      this.rootTransformer.processToken();
    }
    const endIndex = this.tokens.currentToken().rhsEndIndex;
    if (endIndex == null) {
      throw new Error("Expected = token with an end index.");
    }
    while (this.tokens.currentIndex() < endIndex) {
      this.rootTransformer.processToken();
    }
    this.tokens.appendCode(`; exports.${varName} = ${varName}`);
  }
  /**
   * Transform normal declaration exports, including handling destructuring.
   * For example, this:
   * export const {x: [a = 2, b], c} = d;
   * becomes this:
   * ({x: [exports.a = 2, exports.b], c: exports.c} = d;)
   */
  processComplexExportVar() {
    this.tokens.removeInitialToken();
    this.tokens.removeToken();
    const needsParens = this.tokens.matches1(TokenType.braceL);
    if (needsParens) {
      this.tokens.appendCode("(");
    }
    let depth = 0;
    while (true) {
      if (this.tokens.matches1(TokenType.braceL) || this.tokens.matches1(TokenType.dollarBraceL) || this.tokens.matches1(TokenType.bracketL)) {
        depth++;
        this.tokens.copyToken();
      } else if (this.tokens.matches1(TokenType.braceR) || this.tokens.matches1(TokenType.bracketR)) {
        depth--;
        this.tokens.copyToken();
      } else if (depth === 0 && !this.tokens.matches1(TokenType.name) && !this.tokens.currentToken().isType) {
        break;
      } else if (this.tokens.matches1(TokenType.eq)) {
        const endIndex = this.tokens.currentToken().rhsEndIndex;
        if (endIndex == null) {
          throw new Error("Expected = token with an end index.");
        }
        while (this.tokens.currentIndex() < endIndex) {
          this.rootTransformer.processToken();
        }
      } else {
        const token2 = this.tokens.currentToken();
        if (isDeclaration(token2)) {
          const name = this.tokens.identifierName();
          let replacement = this.importProcessor.getIdentifierReplacement(name);
          if (replacement === null) {
            throw new Error(`Expected a replacement for ${name} in \`export var\` syntax.`);
          }
          if (isObjectShorthandDeclaration(token2)) {
            replacement = `${name}: ${replacement}`;
          }
          this.tokens.replaceToken(replacement);
        } else {
          this.rootTransformer.processToken();
        }
      }
    }
    if (needsParens) {
      const endIndex = this.tokens.currentToken().rhsEndIndex;
      if (endIndex == null) {
        throw new Error("Expected = token with an end index.");
      }
      while (this.tokens.currentIndex() < endIndex) {
        this.rootTransformer.processToken();
      }
      this.tokens.appendCode(")");
    }
  }
  /**
   * Transform this:
   * export function foo() {}
   * into this:
   * function foo() {} exports.foo = foo;
   */
  processExportFunction() {
    this.tokens.replaceToken("");
    const name = this.processNamedFunction();
    this.tokens.appendCode(` exports.${name} = ${name};`);
  }
  /**
   * Skip past a function with a name and return that name.
   */
  processNamedFunction() {
    if (this.tokens.matches1(TokenType._function)) {
      this.tokens.copyToken();
    } else if (this.tokens.matches2(TokenType.name, TokenType._function)) {
      if (!this.tokens.matchesContextual(ContextualKeyword._async)) {
        throw new Error("Expected async keyword in function export.");
      }
      this.tokens.copyToken();
      this.tokens.copyToken();
    }
    if (this.tokens.matches1(TokenType.star)) {
      this.tokens.copyToken();
    }
    if (!this.tokens.matches1(TokenType.name)) {
      throw new Error("Expected identifier for exported function name.");
    }
    const name = this.tokens.identifierName();
    this.tokens.copyToken();
    if (this.tokens.currentToken().isType) {
      this.tokens.removeInitialToken();
      while (this.tokens.currentToken().isType) {
        this.tokens.removeToken();
      }
    }
    this.tokens.copyExpectedToken(TokenType.parenL);
    this.rootTransformer.processBalancedCode();
    this.tokens.copyExpectedToken(TokenType.parenR);
    this.rootTransformer.processPossibleTypeRange();
    this.tokens.copyExpectedToken(TokenType.braceL);
    this.rootTransformer.processBalancedCode();
    this.tokens.copyExpectedToken(TokenType.braceR);
    return name;
  }
  /**
   * Transform this:
   * export class A {}
   * into this:
   * class A {} exports.A = A;
   */
  processExportClass() {
    this.tokens.removeInitialToken();
    this.copyDecorators();
    if (this.tokens.matches1(TokenType._abstract)) {
      this.tokens.removeToken();
    }
    const name = this.rootTransformer.processNamedClass();
    this.tokens.appendCode(` exports.${name} = ${name};`);
  }
  /**
   * Transform this:
   * export {a, b as c};
   * into this:
   * exports.a = a; exports.c = b;
   *
   * OR
   *
   * Transform this:
   * export {a, b as c} from './foo';
   * into the pre-generated Object.defineProperty code from the ImportProcessor.
   *
   * For the first case, if the TypeScript transform is enabled, we need to skip
   * exports that are only defined as types.
   */
  processExportBindings() {
    this.tokens.removeInitialToken();
    this.tokens.removeToken();
    const isReExport = isExportFrom(this.tokens);
    const exportStatements = [];
    while (true) {
      if (this.tokens.matches1(TokenType.braceR)) {
        this.tokens.removeToken();
        break;
      }
      const specifierInfo = getImportExportSpecifierInfo(this.tokens);
      while (this.tokens.currentIndex() < specifierInfo.endIndex) {
        this.tokens.removeToken();
      }
      const shouldRemoveExport = specifierInfo.isType || !isReExport && this.shouldElideExportedIdentifier(specifierInfo.leftName);
      if (!shouldRemoveExport) {
        const exportedName = specifierInfo.rightName;
        if (exportedName === "default") {
          this.hadDefaultExport = true;
        } else {
          this.hadNamedExport = true;
        }
        const localName = specifierInfo.leftName;
        const newLocalName = this.importProcessor.getIdentifierReplacement(localName);
        exportStatements.push(`exports.${exportedName} = ${newLocalName || localName};`);
      }
      if (this.tokens.matches1(TokenType.braceR)) {
        this.tokens.removeToken();
        break;
      }
      if (this.tokens.matches2(TokenType.comma, TokenType.braceR)) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        break;
      } else if (this.tokens.matches1(TokenType.comma)) {
        this.tokens.removeToken();
      } else {
        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`);
      }
    }
    if (this.tokens.matchesContextual(ContextualKeyword._from)) {
      this.tokens.removeToken();
      const path = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
      removeMaybeImportAttributes(this.tokens);
    } else {
      this.tokens.appendCode(exportStatements.join(" "));
    }
    if (this.tokens.matches1(TokenType.semi)) {
      this.tokens.removeToken();
    }
  }
  processExportStar() {
    this.tokens.removeInitialToken();
    while (!this.tokens.matches1(TokenType.string)) {
      this.tokens.removeToken();
    }
    const path = this.tokens.stringValue();
    this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
    removeMaybeImportAttributes(this.tokens);
    if (this.tokens.matches1(TokenType.semi)) {
      this.tokens.removeToken();
    }
  }
  shouldElideExportedIdentifier(name) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.declarationInfo.valueDeclarations.has(name);
  }
};

// node_modules/sucrase/dist/esm/transformers/ESMImportTransformer.js
var ESMImportTransformer = class extends Transformer {
  constructor(tokens, nameManager, helperManager, reactHotLoaderTransformer, isTypeScriptTransformEnabled, isFlowTransformEnabled, keepUnusedImports, options2) {
    super();
    this.tokens = tokens;
    this.nameManager = nameManager;
    this.helperManager = helperManager;
    this.reactHotLoaderTransformer = reactHotLoaderTransformer;
    this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;
    this.isFlowTransformEnabled = isFlowTransformEnabled;
    this.keepUnusedImports = keepUnusedImports;
    ;
    this.nonTypeIdentifiers = isTypeScriptTransformEnabled && !keepUnusedImports ? getNonTypeIdentifiers(tokens, options2) : /* @__PURE__ */ new Set();
    this.declarationInfo = isTypeScriptTransformEnabled && !keepUnusedImports ? getDeclarationInfo(tokens) : EMPTY_DECLARATION_INFO;
    this.injectCreateRequireForImportRequire = Boolean(options2.injectCreateRequireForImportRequire);
  }
  process() {
    if (this.tokens.matches3(TokenType._import, TokenType.name, TokenType.eq)) {
      return this.processImportEquals();
    }
    if (this.tokens.matches4(TokenType._import, TokenType.name, TokenType.name, TokenType.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)) {
      this.tokens.removeInitialToken();
      for (let i4 = 0; i4 < 7; i4++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches2(TokenType._export, TokenType.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (this.tokens.matches5(TokenType._export, TokenType._import, TokenType.name, TokenType.name, TokenType.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._type)) {
      this.tokens.removeInitialToken();
      for (let i4 = 0; i4 < 8; i4++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches1(TokenType._import)) {
      return this.processImport();
    }
    if (this.tokens.matches2(TokenType._export, TokenType._default)) {
      return this.processExportDefault();
    }
    if (this.tokens.matches2(TokenType._export, TokenType.braceL)) {
      return this.processNamedExports();
    }
    if (this.tokens.matches2(TokenType._export, TokenType.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      if (this.tokens.matches1(TokenType.braceL)) {
        while (!this.tokens.matches1(TokenType.braceR)) {
          this.tokens.removeToken();
        }
        this.tokens.removeToken();
      } else {
        this.tokens.removeToken();
        if (this.tokens.matches1(TokenType._as)) {
          this.tokens.removeToken();
          this.tokens.removeToken();
        }
      }
      if (this.tokens.matchesContextual(ContextualKeyword._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, TokenType.string)) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        removeMaybeImportAttributes(this.tokens);
      }
      return true;
    }
    return false;
  }
  processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.shouldAutomaticallyElideImportedName(importName)) {
      elideImportEquals(this.tokens);
    } else if (this.injectCreateRequireForImportRequire) {
      this.tokens.replaceToken("const");
      this.tokens.copyToken();
      this.tokens.copyToken();
      this.tokens.replaceToken(this.helperManager.getHelperName("require"));
    } else {
      this.tokens.replaceToken("const");
    }
    return true;
  }
  processImport() {
    if (this.tokens.matches2(TokenType._import, TokenType.parenL)) {
      return false;
    }
    const snapshot = this.tokens.snapshot();
    const allImportsRemoved = this.removeImportTypeBindings();
    if (allImportsRemoved) {
      this.tokens.restoreToSnapshot(snapshot);
      while (!this.tokens.matches1(TokenType.string)) {
        this.tokens.removeToken();
      }
      this.tokens.removeToken();
      removeMaybeImportAttributes(this.tokens);
      if (this.tokens.matches1(TokenType.semi)) {
        this.tokens.removeToken();
      }
    }
    return true;
  }
  /**
   * Remove type bindings from this import, leaving the rest of the import intact.
   *
   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out
   * of the replacement operation, so we can return early here.
   */
  removeImportTypeBindings() {
    this.tokens.copyExpectedToken(TokenType._import);
    if (this.tokens.matchesContextual(ContextualKeyword._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, TokenType.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)) {
      return true;
    }
    if (this.tokens.matches1(TokenType.string)) {
      this.tokens.copyToken();
      return false;
    }
    if (this.tokens.matchesContextual(ContextualKeyword._module) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._from)) {
      this.tokens.copyToken();
    }
    let foundNonTypeImport = false;
    let foundAnyNamedImport = false;
    let needsComma = false;
    if (this.tokens.matches1(TokenType.name)) {
      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierName())) {
        this.tokens.removeToken();
        if (this.tokens.matches1(TokenType.comma)) {
          this.tokens.removeToken();
        }
      } else {
        foundNonTypeImport = true;
        this.tokens.copyToken();
        if (this.tokens.matches1(TokenType.comma)) {
          needsComma = true;
          this.tokens.removeToken();
        }
      }
    }
    if (this.tokens.matches1(TokenType.star)) {
      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierNameAtRelativeIndex(2))) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        this.tokens.removeToken();
      } else {
        if (needsComma) {
          this.tokens.appendCode(",");
        }
        foundNonTypeImport = true;
        this.tokens.copyExpectedToken(TokenType.star);
        this.tokens.copyExpectedToken(TokenType.name);
        this.tokens.copyExpectedToken(TokenType.name);
      }
    } else if (this.tokens.matches1(TokenType.braceL)) {
      if (needsComma) {
        this.tokens.appendCode(",");
      }
      this.tokens.copyToken();
      while (!this.tokens.matches1(TokenType.braceR)) {
        foundAnyNamedImport = true;
        const specifierInfo = getImportExportSpecifierInfo(this.tokens);
        if (specifierInfo.isType || this.shouldAutomaticallyElideImportedName(specifierInfo.rightName)) {
          while (this.tokens.currentIndex() < specifierInfo.endIndex) {
            this.tokens.removeToken();
          }
          if (this.tokens.matches1(TokenType.comma)) {
            this.tokens.removeToken();
          }
        } else {
          foundNonTypeImport = true;
          while (this.tokens.currentIndex() < specifierInfo.endIndex) {
            this.tokens.copyToken();
          }
          if (this.tokens.matches1(TokenType.comma)) {
            this.tokens.copyToken();
          }
        }
      }
      this.tokens.copyExpectedToken(TokenType.braceR);
    }
    if (this.keepUnusedImports) {
      return false;
    }
    if (this.isTypeScriptTransformEnabled) {
      return !foundNonTypeImport;
    } else if (this.isFlowTransformEnabled) {
      return foundAnyNamedImport && !foundNonTypeImport;
    } else {
      return false;
    }
  }
  shouldAutomaticallyElideImportedName(name) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.nonTypeIdentifiers.has(name);
  }
  processExportDefault() {
    if (shouldElideDefaultExport(
      this.isTypeScriptTransformEnabled,
      this.keepUnusedImports,
      this.tokens,
      this.declarationInfo
    )) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.tokens.removeToken();
      return true;
    }
    const alreadyHasName = this.tokens.matches4(TokenType._export, TokenType._default, TokenType._function, TokenType.name) || // export default async function
    this.tokens.matches5(TokenType._export, TokenType._default, TokenType.name, TokenType._function, TokenType.name) && this.tokens.matchesContextualAtIndex(
      this.tokens.currentIndex() + 2,
      ContextualKeyword._async
    ) || this.tokens.matches4(TokenType._export, TokenType._default, TokenType._class, TokenType.name) || this.tokens.matches5(TokenType._export, TokenType._default, TokenType._abstract, TokenType._class, TokenType.name);
    if (!alreadyHasName && this.reactHotLoaderTransformer) {
      const defaultVarName = this.nameManager.claimFreeName("_default");
      this.tokens.replaceToken(`let ${defaultVarName}; export`);
      this.tokens.copyToken();
      this.tokens.appendCode(` ${defaultVarName} =`);
      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);
      return true;
    }
    return false;
  }
  /**
   * Handle a statement with one of these forms:
   * export {a, type b};
   * export {c, type d} from 'foo';
   *
   * In both cases, any explicit type exports should be removed. In the first
   * case, we also need to handle implicit export elision for names declared as
   * types. In the second case, we must NOT do implicit named export elision,
   * but we must remove the runtime import if all exports are type exports.
   */
  processNamedExports() {
    if (!this.isTypeScriptTransformEnabled) {
      return false;
    }
    this.tokens.copyExpectedToken(TokenType._export);
    this.tokens.copyExpectedToken(TokenType.braceL);
    const isReExport = isExportFrom(this.tokens);
    let foundNonTypeExport = false;
    while (!this.tokens.matches1(TokenType.braceR)) {
      const specifierInfo = getImportExportSpecifierInfo(this.tokens);
      if (specifierInfo.isType || !isReExport && this.shouldElideExportedName(specifierInfo.leftName)) {
        while (this.tokens.currentIndex() < specifierInfo.endIndex) {
          this.tokens.removeToken();
        }
        if (this.tokens.matches1(TokenType.comma)) {
          this.tokens.removeToken();
        }
      } else {
        foundNonTypeExport = true;
        while (this.tokens.currentIndex() < specifierInfo.endIndex) {
          this.tokens.copyToken();
        }
        if (this.tokens.matches1(TokenType.comma)) {
          this.tokens.copyToken();
        }
      }
    }
    this.tokens.copyExpectedToken(TokenType.braceR);
    if (!this.keepUnusedImports && isReExport && !foundNonTypeExport) {
      this.tokens.removeToken();
      this.tokens.removeToken();
      removeMaybeImportAttributes(this.tokens);
    }
    return true;
  }
  /**
   * ESM elides all imports with the rule that we only elide if we see that it's
   * a type and never see it as a value. This is in contrast to CJS, which
   * elides imports that are completely unknown.
   */
  shouldElideExportedName(name) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && this.declarationInfo.typeDeclarations.has(name) && !this.declarationInfo.valueDeclarations.has(name);
  }
};

// node_modules/sucrase/dist/esm/transformers/FlowTransformer.js
var FlowTransformer = class extends Transformer {
  constructor(rootTransformer, tokens, isImportsTransformEnabled) {
    super();
    this.rootTransformer = rootTransformer;
    this.tokens = tokens;
    this.isImportsTransformEnabled = isImportsTransformEnabled;
    ;
  }
  process() {
    if (this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange()) {
      return true;
    }
    if (this.tokens.matches1(TokenType._enum)) {
      this.processEnum();
      return true;
    }
    if (this.tokens.matches2(TokenType._export, TokenType._enum)) {
      this.processNamedExportEnum();
      return true;
    }
    if (this.tokens.matches3(TokenType._export, TokenType._default, TokenType._enum)) {
      this.processDefaultExportEnum();
      return true;
    }
    return false;
  }
  /**
   * Handle a declaration like:
   * export enum E ...
   *
   * With this imports transform, this becomes:
   * const E = [[enum]]; exports.E = E;
   *
   * otherwise, it becomes:
   * export const E = [[enum]];
   */
  processNamedExportEnum() {
    if (this.isImportsTransformEnabled) {
      this.tokens.removeInitialToken();
      const enumName = this.tokens.identifierNameAtRelativeIndex(1);
      this.processEnum();
      this.tokens.appendCode(` exports.${enumName} = ${enumName};`);
    } else {
      this.tokens.copyToken();
      this.processEnum();
    }
  }
  /**
   * Handle a declaration like:
   * export default enum E
   *
   * With the imports transform, this becomes:
   * const E = [[enum]]; exports.default = E;
   *
   * otherwise, it becomes:
   * const E = [[enum]]; export default E;
   */
  processDefaultExportEnum() {
    this.tokens.removeInitialToken();
    this.tokens.removeToken();
    const enumName = this.tokens.identifierNameAtRelativeIndex(1);
    this.processEnum();
    if (this.isImportsTransformEnabled) {
      this.tokens.appendCode(` exports.default = ${enumName};`);
    } else {
      this.tokens.appendCode(` export default ${enumName};`);
    }
  }
  /**
   * Transpile flow enums to invoke the "flow-enums-runtime" library.
   *
   * Currently, the transpiled code always uses `require("flow-enums-runtime")`,
   * but if future flexibility is needed, we could expose a config option for
   * this string (similar to configurable JSX). Even when targeting ESM, the
   * default behavior of babel-plugin-transform-flow-enums is to use require
   * rather than injecting an import.
   *
   * Flow enums are quite a bit simpler than TS enums and have some convenient
   * constraints:
   * - Element initializers must be either always present or always absent. That
   *   means that we can use fixed lookahead on the first element (if any) and
   *   assume that all elements are like that.
   * - The right-hand side of an element initializer must be a literal value,
   *   not a complex expression and not referencing other elements. That means
   *   we can simply copy a single token.
   *
   * Enums can be broken up into three basic cases:
   *
   * Mirrored enums:
   * enum E {A, B}
   *   ->
   * const E = require("flow-enums-runtime").Mirrored(["A", "B"]);
   *
   * Initializer enums:
   * enum E {A = 1, B = 2}
   *   ->
   * const E = require("flow-enums-runtime")({A: 1, B: 2});
   *
   * Symbol enums:
   * enum E of symbol {A, B}
   *   ->
   * const E = require("flow-enums-runtime")({A: Symbol("A"), B: Symbol("B")});
   *
   * We can statically detect which of the three cases this is by looking at the
   * "of" declaration (if any) and seeing if the first element has an initializer.
   * Since the other transform details are so similar between the three cases, we
   * use a single implementation and vary the transform within processEnumElement
   * based on case.
   */
  processEnum() {
    this.tokens.replaceToken("const");
    this.tokens.copyExpectedToken(TokenType.name);
    let isSymbolEnum = false;
    if (this.tokens.matchesContextual(ContextualKeyword._of)) {
      this.tokens.removeToken();
      isSymbolEnum = this.tokens.matchesContextual(ContextualKeyword._symbol);
      this.tokens.removeToken();
    }
    const hasInitializers = this.tokens.matches3(TokenType.braceL, TokenType.name, TokenType.eq);
    this.tokens.appendCode(' = require("flow-enums-runtime")');
    const isMirrored = !isSymbolEnum && !hasInitializers;
    this.tokens.replaceTokenTrimmingLeftWhitespace(isMirrored ? ".Mirrored([" : "({");
    while (!this.tokens.matches1(TokenType.braceR)) {
      if (this.tokens.matches1(TokenType.ellipsis)) {
        this.tokens.removeToken();
        break;
      }
      this.processEnumElement(isSymbolEnum, hasInitializers);
      if (this.tokens.matches1(TokenType.comma)) {
        this.tokens.copyToken();
      }
    }
    this.tokens.replaceToken(isMirrored ? "]);" : "});");
  }
  /**
   * Process an individual enum element, producing either an array element or an
   * object element based on what type of enum this is.
   */
  processEnumElement(isSymbolEnum, hasInitializers) {
    if (isSymbolEnum) {
      const elementName2 = this.tokens.identifierName();
      this.tokens.copyToken();
      this.tokens.appendCode(`: Symbol("${elementName2}")`);
    } else if (hasInitializers) {
      this.tokens.copyToken();
      this.tokens.replaceTokenTrimmingLeftWhitespace(":");
      this.tokens.copyToken();
    } else {
      this.tokens.replaceToken(`"${this.tokens.identifierName()}"`);
    }
  }
};

// node_modules/sucrase/dist/esm/transformers/JestHoistTransformer.js
function _optionalChain(ops) {
  let lastAccessLHS = void 0;
  let value = ops[0];
  let i4 = 1;
  while (i4 < ops.length) {
    const op = ops[i4];
    const fn2 = ops[i4 + 1];
    i4 += 2;
    if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
      return void 0;
    }
    if (op === "access" || op === "optionalAccess") {
      lastAccessLHS = value;
      value = fn2(value);
    } else if (op === "call" || op === "optionalCall") {
      value = fn2((...args) => value.call(lastAccessLHS, ...args));
      lastAccessLHS = void 0;
    }
  }
  return value;
}
var JEST_GLOBAL_NAME = "jest";
var HOISTED_METHODS = ["mock", "unmock", "enableAutomock", "disableAutomock"];
var JestHoistTransformer = class _JestHoistTransformer extends Transformer {
  __init() {
    this.hoistedFunctionNames = [];
  }
  constructor(rootTransformer, tokens, nameManager, importProcessor) {
    super();
    this.rootTransformer = rootTransformer;
    this.tokens = tokens;
    this.nameManager = nameManager;
    this.importProcessor = importProcessor;
    _JestHoistTransformer.prototype.__init.call(this);
    ;
  }
  process() {
    if (this.tokens.currentToken().scopeDepth === 0 && this.tokens.matches4(TokenType.name, TokenType.dot, TokenType.name, TokenType.parenL) && this.tokens.identifierName() === JEST_GLOBAL_NAME) {
      if (_optionalChain([this, "access", (_3) => _3.importProcessor, "optionalAccess", (_22) => _22.getGlobalNames, "call", (_3) => _3(), "optionalAccess", (_4) => _4.has, "call", (_5) => _5(JEST_GLOBAL_NAME)])) {
        return false;
      }
      return this.extractHoistedCalls();
    }
    return false;
  }
  getHoistedCode() {
    if (this.hoistedFunctionNames.length > 0) {
      return this.hoistedFunctionNames.map((name) => `${name}();`).join("");
    }
    return "";
  }
  /**
   * Extracts any methods calls on the jest-object that should be hoisted.
   *
   * According to the jest docs, https://jestjs.io/docs/en/jest-object#jestmockmodulename-factory-options,
   * mock, unmock, enableAutomock, disableAutomock, are the methods that should be hoisted.
   *
   * We do not apply the same checks of the arguments as babel-plugin-jest-hoist does.
   */
  extractHoistedCalls() {
    this.tokens.removeToken();
    let followsNonHoistedJestCall = false;
    while (this.tokens.matches3(TokenType.dot, TokenType.name, TokenType.parenL)) {
      const methodName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
      const shouldHoist = HOISTED_METHODS.includes(methodName);
      if (shouldHoist) {
        const hoistedFunctionName = this.nameManager.claimFreeName("__jestHoist");
        this.hoistedFunctionNames.push(hoistedFunctionName);
        this.tokens.replaceToken(`function ${hoistedFunctionName}(){${JEST_GLOBAL_NAME}.`);
        this.tokens.copyToken();
        this.tokens.copyToken();
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(TokenType.parenR);
        this.tokens.appendCode(";}");
        followsNonHoistedJestCall = false;
      } else {
        if (followsNonHoistedJestCall) {
          this.tokens.copyToken();
        } else {
          this.tokens.replaceToken(`${JEST_GLOBAL_NAME}.`);
        }
        this.tokens.copyToken();
        this.tokens.copyToken();
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(TokenType.parenR);
        followsNonHoistedJestCall = true;
      }
    }
    return true;
  }
};

// node_modules/sucrase/dist/esm/transformers/NumericSeparatorTransformer.js
var NumericSeparatorTransformer = class extends Transformer {
  constructor(tokens) {
    super();
    this.tokens = tokens;
    ;
  }
  process() {
    if (this.tokens.matches1(TokenType.num)) {
      const code = this.tokens.currentTokenCode();
      if (code.includes("_")) {
        this.tokens.replaceToken(code.replace(/_/g, ""));
        return true;
      }
    }
    return false;
  }
};

// node_modules/sucrase/dist/esm/transformers/OptionalCatchBindingTransformer.js
var OptionalCatchBindingTransformer = class extends Transformer {
  constructor(tokens, nameManager) {
    super();
    this.tokens = tokens;
    this.nameManager = nameManager;
    ;
  }
  process() {
    if (this.tokens.matches2(TokenType._catch, TokenType.braceL)) {
      this.tokens.copyToken();
      this.tokens.appendCode(` (${this.nameManager.claimFreeName("e")})`);
      return true;
    }
    return false;
  }
};

// node_modules/sucrase/dist/esm/transformers/OptionalChainingNullishTransformer.js
var OptionalChainingNullishTransformer = class extends Transformer {
  constructor(tokens, nameManager) {
    super();
    this.tokens = tokens;
    this.nameManager = nameManager;
    ;
  }
  process() {
    if (this.tokens.matches1(TokenType.nullishCoalescing)) {
      const token3 = this.tokens.currentToken();
      if (this.tokens.tokens[token3.nullishStartIndex].isAsyncOperation) {
        this.tokens.replaceTokenTrimmingLeftWhitespace(", async () => (");
      } else {
        this.tokens.replaceTokenTrimmingLeftWhitespace(", () => (");
      }
      return true;
    }
    if (this.tokens.matches1(TokenType._delete)) {
      const nextToken2 = this.tokens.tokenAtRelativeIndex(1);
      if (nextToken2.isOptionalChainStart) {
        this.tokens.removeInitialToken();
        return true;
      }
    }
    const token2 = this.tokens.currentToken();
    const chainStart = token2.subscriptStartIndex;
    if (chainStart != null && this.tokens.tokens[chainStart].isOptionalChainStart && // Super subscripts can't be optional (since super is never null/undefined), and the syntax
    // relies on the subscript being intact, so leave this token alone.
    this.tokens.tokenAtRelativeIndex(-1).type !== TokenType._super) {
      const param = this.nameManager.claimFreeName("_");
      let arrowStartSnippet;
      if (chainStart > 0 && this.tokens.matches1AtIndex(chainStart - 1, TokenType._delete) && this.isLastSubscriptInChain()) {
        arrowStartSnippet = `${param} => delete ${param}`;
      } else {
        arrowStartSnippet = `${param} => ${param}`;
      }
      if (this.tokens.tokens[chainStart].isAsyncOperation) {
        arrowStartSnippet = `async ${arrowStartSnippet}`;
      }
      if (this.tokens.matches2(TokenType.questionDot, TokenType.parenL) || this.tokens.matches2(TokenType.questionDot, TokenType.lessThan)) {
        if (this.justSkippedSuper()) {
          this.tokens.appendCode(".bind(this)");
        }
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalCall', ${arrowStartSnippet}`);
      } else if (this.tokens.matches2(TokenType.questionDot, TokenType.bracketL)) {
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}`);
      } else if (this.tokens.matches1(TokenType.questionDot)) {
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}.`);
      } else if (this.tokens.matches1(TokenType.dot)) {
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}.`);
      } else if (this.tokens.matches1(TokenType.bracketL)) {
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}[`);
      } else if (this.tokens.matches1(TokenType.parenL)) {
        if (this.justSkippedSuper()) {
          this.tokens.appendCode(".bind(this)");
        }
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'call', ${arrowStartSnippet}(`);
      } else {
        throw new Error("Unexpected subscript operator in optional chain.");
      }
      return true;
    }
    return false;
  }
  /**
   * Determine if the current token is the last of its chain, so that we know whether it's eligible
   * to have a delete op inserted.
   *
   * We can do this by walking forward until we determine one way or another. Each
   * isOptionalChainStart token must be paired with exactly one isOptionalChainEnd token after it in
   * a nesting way, so we can track depth and walk to the end of the chain (the point where the
   * depth goes negative) and see if any other subscript token is after us in the chain.
   */
  isLastSubscriptInChain() {
    let depth = 0;
    for (let i4 = this.tokens.currentIndex() + 1; ; i4++) {
      if (i4 >= this.tokens.tokens.length) {
        throw new Error("Reached the end of the code while finding the end of the access chain.");
      }
      if (this.tokens.tokens[i4].isOptionalChainStart) {
        depth++;
      } else if (this.tokens.tokens[i4].isOptionalChainEnd) {
        depth--;
      }
      if (depth < 0) {
        return true;
      }
      if (depth === 0 && this.tokens.tokens[i4].subscriptStartIndex != null) {
        return false;
      }
    }
  }
  /**
   * Determine if we are the open-paren in an expression like super.a()?.b.
   *
   * We can do this by walking backward to find the previous subscript. If that subscript was
   * preceded by a super, then we must be the subscript after it, so if this is a call expression,
   * we'll need to attach the right context.
   */
  justSkippedSuper() {
    let depth = 0;
    let index2 = this.tokens.currentIndex() - 1;
    while (true) {
      if (index2 < 0) {
        throw new Error(
          "Reached the start of the code while finding the start of the access chain."
        );
      }
      if (this.tokens.tokens[index2].isOptionalChainStart) {
        depth--;
      } else if (this.tokens.tokens[index2].isOptionalChainEnd) {
        depth++;
      }
      if (depth < 0) {
        return false;
      }
      if (depth === 0 && this.tokens.tokens[index2].subscriptStartIndex != null) {
        return this.tokens.tokens[index2 - 1].type === TokenType._super;
      }
      index2--;
    }
  }
};

// node_modules/sucrase/dist/esm/transformers/ReactDisplayNameTransformer.js
var ReactDisplayNameTransformer = class extends Transformer {
  constructor(rootTransformer, tokens, importProcessor, options2) {
    super();
    this.rootTransformer = rootTransformer;
    this.tokens = tokens;
    this.importProcessor = importProcessor;
    this.options = options2;
    ;
  }
  process() {
    const startIndex = this.tokens.currentIndex();
    if (this.tokens.identifierName() === "createReactClass") {
      const newName = this.importProcessor && this.importProcessor.getIdentifierReplacement("createReactClass");
      if (newName) {
        this.tokens.replaceToken(`(0, ${newName})`);
      } else {
        this.tokens.copyToken();
      }
      this.tryProcessCreateClassCall(startIndex);
      return true;
    }
    if (this.tokens.matches3(TokenType.name, TokenType.dot, TokenType.name) && this.tokens.identifierName() === "React" && this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2) === "createClass") {
      const newName = this.importProcessor ? this.importProcessor.getIdentifierReplacement("React") || "React" : "React";
      if (newName) {
        this.tokens.replaceToken(newName);
        this.tokens.copyToken();
        this.tokens.copyToken();
      } else {
        this.tokens.copyToken();
        this.tokens.copyToken();
        this.tokens.copyToken();
      }
      this.tryProcessCreateClassCall(startIndex);
      return true;
    }
    return false;
  }
  /**
   * This is called with the token position at the open-paren.
   */
  tryProcessCreateClassCall(startIndex) {
    const displayName = this.findDisplayName(startIndex);
    if (!displayName) {
      return;
    }
    if (this.classNeedsDisplayName()) {
      this.tokens.copyExpectedToken(TokenType.parenL);
      this.tokens.copyExpectedToken(TokenType.braceL);
      this.tokens.appendCode(`displayName: '${displayName}',`);
      this.rootTransformer.processBalancedCode();
      this.tokens.copyExpectedToken(TokenType.braceR);
      this.tokens.copyExpectedToken(TokenType.parenR);
    }
  }
  findDisplayName(startIndex) {
    if (startIndex < 2) {
      return null;
    }
    if (this.tokens.matches2AtIndex(startIndex - 2, TokenType.name, TokenType.eq)) {
      return this.tokens.identifierNameAtIndex(startIndex - 2);
    }
    if (startIndex >= 2 && this.tokens.tokens[startIndex - 2].identifierRole === IdentifierRole.ObjectKey) {
      return this.tokens.identifierNameAtIndex(startIndex - 2);
    }
    if (this.tokens.matches2AtIndex(startIndex - 2, TokenType._export, TokenType._default)) {
      return this.getDisplayNameFromFilename();
    }
    return null;
  }
  getDisplayNameFromFilename() {
    const filePath = this.options.filePath || "unknown";
    const pathSegments = filePath.split("/");
    const filename = pathSegments[pathSegments.length - 1];
    const dotIndex = filename.lastIndexOf(".");
    const baseFilename = dotIndex === -1 ? filename : filename.slice(0, dotIndex);
    if (baseFilename === "index" && pathSegments[pathSegments.length - 2]) {
      return pathSegments[pathSegments.length - 2];
    } else {
      return baseFilename;
    }
  }
  /**
   * We only want to add a display name when this is a function call containing
   * one argument, which is an object literal without `displayName` as an
   * existing key.
   */
  classNeedsDisplayName() {
    let index2 = this.tokens.currentIndex();
    if (!this.tokens.matches2(TokenType.parenL, TokenType.braceL)) {
      return false;
    }
    const objectStartIndex = index2 + 1;
    const objectContextId = this.tokens.tokens[objectStartIndex].contextId;
    if (objectContextId == null) {
      throw new Error("Expected non-null context ID on object open-brace.");
    }
    for (; index2 < this.tokens.tokens.length; index2++) {
      const token2 = this.tokens.tokens[index2];
      if (token2.type === TokenType.braceR && token2.contextId === objectContextId) {
        index2++;
        break;
      }
      if (this.tokens.identifierNameAtIndex(index2) === "displayName" && this.tokens.tokens[index2].identifierRole === IdentifierRole.ObjectKey && token2.contextId === objectContextId) {
        return false;
      }
    }
    if (index2 === this.tokens.tokens.length) {
      throw new Error("Unexpected end of input when processing React class.");
    }
    return this.tokens.matches1AtIndex(index2, TokenType.parenR) || this.tokens.matches2AtIndex(index2, TokenType.comma, TokenType.parenR);
  }
};

// node_modules/sucrase/dist/esm/transformers/ReactHotLoaderTransformer.js
var ReactHotLoaderTransformer = class _ReactHotLoaderTransformer extends Transformer {
  __init() {
    this.extractedDefaultExportName = null;
  }
  constructor(tokens, filePath) {
    super();
    this.tokens = tokens;
    this.filePath = filePath;
    _ReactHotLoaderTransformer.prototype.__init.call(this);
    ;
  }
  setExtractedDefaultExportName(extractedDefaultExportName) {
    this.extractedDefaultExportName = extractedDefaultExportName;
  }
  getPrefixCode() {
    return `
      (function () {
        var enterModule = require('react-hot-loader').enterModule;
        enterModule && enterModule(module);
      })();`.replace(/\s+/g, " ").trim();
  }
  getSuffixCode() {
    const topLevelNames = /* @__PURE__ */ new Set();
    for (const token2 of this.tokens.tokens) {
      if (!token2.isType && isTopLevelDeclaration(token2) && token2.identifierRole !== IdentifierRole.ImportDeclaration) {
        topLevelNames.add(this.tokens.identifierNameForToken(token2));
      }
    }
    const namesToRegister = Array.from(topLevelNames).map((name) => ({
      variableName: name,
      uniqueLocalName: name
    }));
    if (this.extractedDefaultExportName) {
      namesToRegister.push({
        variableName: this.extractedDefaultExportName,
        uniqueLocalName: "default"
      });
    }
    return `
;(function () {
  var reactHotLoader = require('react-hot-loader').default;
  var leaveModule = require('react-hot-loader').leaveModule;
  if (!reactHotLoader) {
    return;
  }
${namesToRegister.map(
      ({ variableName, uniqueLocalName }) => `  reactHotLoader.register(${variableName}, "${uniqueLocalName}", ${JSON.stringify(
        this.filePath || ""
      )});`
    ).join("\n")}
  leaveModule(module);
})();`;
  }
  process() {
    return false;
  }
};

// node_modules/sucrase/dist/esm/util/isIdentifier.js
var RESERVED_WORDS = /* @__PURE__ */ new Set([
  // Reserved keywords as of ECMAScript 2015
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "export",
  "extends",
  "finally",
  "for",
  "function",
  "if",
  "import",
  "in",
  "instanceof",
  "new",
  "return",
  "super",
  "switch",
  "this",
  "throw",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield",
  // Future reserved keywords
  "enum",
  "implements",
  "interface",
  "let",
  "package",
  "private",
  "protected",
  "public",
  "static",
  "await",
  // Literals that cannot be used as identifiers
  "false",
  "null",
  "true"
]);
function isIdentifier(name) {
  if (name.length === 0) {
    return false;
  }
  if (!IS_IDENTIFIER_START[name.charCodeAt(0)]) {
    return false;
  }
  for (let i4 = 1; i4 < name.length; i4++) {
    if (!IS_IDENTIFIER_CHAR[name.charCodeAt(i4)]) {
      return false;
    }
  }
  return !RESERVED_WORDS.has(name);
}

// node_modules/sucrase/dist/esm/transformers/TypeScriptTransformer.js
var TypeScriptTransformer = class extends Transformer {
  constructor(rootTransformer, tokens, isImportsTransformEnabled) {
    super();
    this.rootTransformer = rootTransformer;
    this.tokens = tokens;
    this.isImportsTransformEnabled = isImportsTransformEnabled;
    ;
  }
  process() {
    if (this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange()) {
      return true;
    }
    if (this.tokens.matches1(TokenType._public) || this.tokens.matches1(TokenType._protected) || this.tokens.matches1(TokenType._private) || this.tokens.matches1(TokenType._abstract) || this.tokens.matches1(TokenType._readonly) || this.tokens.matches1(TokenType._override) || this.tokens.matches1(TokenType.nonNullAssertion)) {
      this.tokens.removeInitialToken();
      return true;
    }
    if (this.tokens.matches1(TokenType._enum) || this.tokens.matches2(TokenType._const, TokenType._enum)) {
      this.processEnum();
      return true;
    }
    if (this.tokens.matches2(TokenType._export, TokenType._enum) || this.tokens.matches3(TokenType._export, TokenType._const, TokenType._enum)) {
      this.processEnum(true);
      return true;
    }
    return false;
  }
  processEnum(isExport = false) {
    this.tokens.removeInitialToken();
    while (this.tokens.matches1(TokenType._const) || this.tokens.matches1(TokenType._enum)) {
      this.tokens.removeToken();
    }
    const enumName = this.tokens.identifierName();
    this.tokens.removeToken();
    if (isExport && !this.isImportsTransformEnabled) {
      this.tokens.appendCode("export ");
    }
    this.tokens.appendCode(`var ${enumName}; (function (${enumName})`);
    this.tokens.copyExpectedToken(TokenType.braceL);
    this.processEnumBody(enumName);
    this.tokens.copyExpectedToken(TokenType.braceR);
    if (isExport && this.isImportsTransformEnabled) {
      this.tokens.appendCode(`)(${enumName} || (exports.${enumName} = ${enumName} = {}));`);
    } else {
      this.tokens.appendCode(`)(${enumName} || (${enumName} = {}));`);
    }
  }
  /**
   * Transform an enum into equivalent JS. This has complexity in a few places:
   * - TS allows string enums, numeric enums, and a mix of the two styles within an enum.
   * - Enum keys are allowed to be referenced in later enum values.
   * - Enum keys are allowed to be strings.
   * - When enum values are omitted, they should follow an auto-increment behavior.
   */
  processEnumBody(enumName) {
    let previousValueCode = null;
    while (true) {
      if (this.tokens.matches1(TokenType.braceR)) {
        break;
      }
      const { nameStringCode, variableName } = this.extractEnumKeyInfo(this.tokens.currentToken());
      this.tokens.removeInitialToken();
      if (this.tokens.matches3(TokenType.eq, TokenType.string, TokenType.comma) || this.tokens.matches3(TokenType.eq, TokenType.string, TokenType.braceR)) {
        this.processStringLiteralEnumMember(enumName, nameStringCode, variableName);
      } else if (this.tokens.matches1(TokenType.eq)) {
        this.processExplicitValueEnumMember(enumName, nameStringCode, variableName);
      } else {
        this.processImplicitValueEnumMember(
          enumName,
          nameStringCode,
          variableName,
          previousValueCode
        );
      }
      if (this.tokens.matches1(TokenType.comma)) {
        this.tokens.removeToken();
      }
      if (variableName != null) {
        previousValueCode = variableName;
      } else {
        previousValueCode = `${enumName}[${nameStringCode}]`;
      }
    }
  }
  /**
   * Detect name information about this enum key, which will be used to determine which code to emit
   * and whether we should declare a variable as part of this declaration.
   *
   * Some cases to keep in mind:
   * - Enum keys can be implicitly referenced later, e.g. `X = 1, Y = X`. In Sucrase, we implement
   *   this by declaring a variable `X` so that later expressions can use it.
   * - In addition to the usual identifier key syntax, enum keys are allowed to be string literals,
   *   e.g. `"hello world" = 3,`. Template literal syntax is NOT allowed.
   * - Even if the enum key is defined as a string literal, it may still be referenced by identifier
   *   later, e.g. `"X" = 1, Y = X`. That means that we need to detect whether or not a string
   *   literal is identifier-like and emit a variable if so, even if the declaration did not use an
   *   identifier.
   * - Reserved keywords like `break` are valid enum keys, but are not valid to be referenced later
   *   and would be a syntax error if we emitted a variable, so we need to skip the variable
   *   declaration in those cases.
   *
   * The variableName return value captures these nuances: if non-null, we can and must emit a
   * variable declaration, and if null, we can't and shouldn't.
   */
  extractEnumKeyInfo(nameToken) {
    if (nameToken.type === TokenType.name) {
      const name = this.tokens.identifierNameForToken(nameToken);
      return {
        nameStringCode: `"${name}"`,
        variableName: isIdentifier(name) ? name : null
      };
    } else if (nameToken.type === TokenType.string) {
      const name = this.tokens.stringValueForToken(nameToken);
      return {
        nameStringCode: this.tokens.code.slice(nameToken.start, nameToken.end),
        variableName: isIdentifier(name) ? name : null
      };
    } else {
      throw new Error("Expected name or string at beginning of enum element.");
    }
  }
  /**
   * Handle an enum member where the RHS is just a string literal (not omitted, not a number, and
   * not a complex expression). This is the typical form for TS string enums, and in this case, we
   * do *not* create a reverse mapping.
   *
   * This is called after deleting the key token, when the token processor is at the equals sign.
   *
   * Example 1:
   * someKey = "some value"
   * ->
   * const someKey = "some value"; MyEnum["someKey"] = someKey;
   *
   * Example 2:
   * "some key" = "some value"
   * ->
   * MyEnum["some key"] = "some value";
   */
  processStringLiteralEnumMember(enumName, nameStringCode, variableName) {
    if (variableName != null) {
      this.tokens.appendCode(`const ${variableName}`);
      this.tokens.copyToken();
      this.tokens.copyToken();
      this.tokens.appendCode(`; ${enumName}[${nameStringCode}] = ${variableName};`);
    } else {
      this.tokens.appendCode(`${enumName}[${nameStringCode}]`);
      this.tokens.copyToken();
      this.tokens.copyToken();
      this.tokens.appendCode(";");
    }
  }
  /**
   * Handle an enum member initialized with an expression on the right-hand side (other than a
   * string literal). In these cases, we should transform the expression and emit code that sets up
   * a reverse mapping.
   *
   * The TypeScript implementation of this operation distinguishes between expressions that can be
   * "constant folded" at compile time (i.e. consist of number literals and simple math operations
   * on those numbers) and ones that are dynamic. For constant expressions, it emits the resolved
   * numeric value, and auto-incrementing is only allowed in that case. Evaluating expressions at
   * compile time would add significant complexity to Sucrase, so Sucrase instead leaves the
   * expression as-is, and will later emit something like `MyEnum["previousKey"] + 1` to implement
   * auto-incrementing.
   *
   * This is called after deleting the key token, when the token processor is at the equals sign.
   *
   * Example 1:
   * someKey = 1 + 1
   * ->
   * const someKey = 1 + 1; MyEnum[MyEnum["someKey"] = someKey] = "someKey";
   *
   * Example 2:
   * "some key" = 1 + 1
   * ->
   * MyEnum[MyEnum["some key"] = 1 + 1] = "some key";
   */
  processExplicitValueEnumMember(enumName, nameStringCode, variableName) {
    const rhsEndIndex = this.tokens.currentToken().rhsEndIndex;
    if (rhsEndIndex == null) {
      throw new Error("Expected rhsEndIndex on enum assign.");
    }
    if (variableName != null) {
      this.tokens.appendCode(`const ${variableName}`);
      this.tokens.copyToken();
      while (this.tokens.currentIndex() < rhsEndIndex) {
        this.rootTransformer.processToken();
      }
      this.tokens.appendCode(
        `; ${enumName}[${enumName}[${nameStringCode}] = ${variableName}] = ${nameStringCode};`
      );
    } else {
      this.tokens.appendCode(`${enumName}[${enumName}[${nameStringCode}]`);
      this.tokens.copyToken();
      while (this.tokens.currentIndex() < rhsEndIndex) {
        this.rootTransformer.processToken();
      }
      this.tokens.appendCode(`] = ${nameStringCode};`);
    }
  }
  /**
   * Handle an enum member with no right-hand side expression. In this case, the value is the
   * previous value plus 1, or 0 if there was no previous value. We should also always emit a
   * reverse mapping.
   *
   * Example 1:
   * someKey2
   * ->
   * const someKey2 = someKey1 + 1; MyEnum[MyEnum["someKey2"] = someKey2] = "someKey2";
   *
   * Example 2:
   * "some key 2"
   * ->
   * MyEnum[MyEnum["some key 2"] = someKey1 + 1] = "some key 2";
   */
  processImplicitValueEnumMember(enumName, nameStringCode, variableName, previousValueCode) {
    let valueCode = previousValueCode != null ? `${previousValueCode} + 1` : "0";
    if (variableName != null) {
      this.tokens.appendCode(`const ${variableName} = ${valueCode}; `);
      valueCode = variableName;
    }
    this.tokens.appendCode(
      `${enumName}[${enumName}[${nameStringCode}] = ${valueCode}] = ${nameStringCode};`
    );
  }
};

// node_modules/sucrase/dist/esm/transformers/RootTransformer.js
var RootTransformer = class _RootTransformer {
  __init() {
    this.transformers = [];
  }
  __init2() {
    this.generatedVariables = [];
  }
  constructor(sucraseContext, transforms, enableLegacyBabel5ModuleInterop, options2) {
    ;
    _RootTransformer.prototype.__init.call(this);
    _RootTransformer.prototype.__init2.call(this);
    this.nameManager = sucraseContext.nameManager;
    this.helperManager = sucraseContext.helperManager;
    const { tokenProcessor, importProcessor } = sucraseContext;
    this.tokens = tokenProcessor;
    this.isImportsTransformEnabled = transforms.includes("imports");
    this.isReactHotLoaderTransformEnabled = transforms.includes("react-hot-loader");
    this.disableESTransforms = Boolean(options2.disableESTransforms);
    if (!options2.disableESTransforms) {
      this.transformers.push(
        new OptionalChainingNullishTransformer(tokenProcessor, this.nameManager)
      );
      this.transformers.push(new NumericSeparatorTransformer(tokenProcessor));
      this.transformers.push(new OptionalCatchBindingTransformer(tokenProcessor, this.nameManager));
    }
    if (transforms.includes("jsx")) {
      if (options2.jsxRuntime !== "preserve") {
        this.transformers.push(
          new JSXTransformer(this, tokenProcessor, importProcessor, this.nameManager, options2)
        );
      }
      this.transformers.push(
        new ReactDisplayNameTransformer(this, tokenProcessor, importProcessor, options2)
      );
    }
    let reactHotLoaderTransformer = null;
    if (transforms.includes("react-hot-loader")) {
      if (!options2.filePath) {
        throw new Error("filePath is required when using the react-hot-loader transform.");
      }
      reactHotLoaderTransformer = new ReactHotLoaderTransformer(tokenProcessor, options2.filePath);
      this.transformers.push(reactHotLoaderTransformer);
    }
    if (transforms.includes("imports")) {
      if (importProcessor === null) {
        throw new Error("Expected non-null importProcessor with imports transform enabled.");
      }
      this.transformers.push(
        new CJSImportTransformer(
          this,
          tokenProcessor,
          importProcessor,
          this.nameManager,
          this.helperManager,
          reactHotLoaderTransformer,
          enableLegacyBabel5ModuleInterop,
          Boolean(options2.enableLegacyTypeScriptModuleInterop),
          transforms.includes("typescript"),
          transforms.includes("flow"),
          Boolean(options2.preserveDynamicImport),
          Boolean(options2.keepUnusedImports)
        )
      );
    } else {
      this.transformers.push(
        new ESMImportTransformer(
          tokenProcessor,
          this.nameManager,
          this.helperManager,
          reactHotLoaderTransformer,
          transforms.includes("typescript"),
          transforms.includes("flow"),
          Boolean(options2.keepUnusedImports),
          options2
        )
      );
    }
    if (transforms.includes("flow")) {
      this.transformers.push(
        new FlowTransformer(this, tokenProcessor, transforms.includes("imports"))
      );
    }
    if (transforms.includes("typescript")) {
      this.transformers.push(
        new TypeScriptTransformer(this, tokenProcessor, transforms.includes("imports"))
      );
    }
    if (transforms.includes("jest")) {
      this.transformers.push(
        new JestHoistTransformer(this, tokenProcessor, this.nameManager, importProcessor)
      );
    }
  }
  transform() {
    this.tokens.reset();
    this.processBalancedCode();
    const shouldAddUseStrict = this.isImportsTransformEnabled;
    let prefix2 = shouldAddUseStrict ? '"use strict";' : "";
    for (const transformer of this.transformers) {
      prefix2 += transformer.getPrefixCode();
    }
    prefix2 += this.helperManager.emitHelpers();
    prefix2 += this.generatedVariables.map((v3) => ` var ${v3};`).join("");
    for (const transformer of this.transformers) {
      prefix2 += transformer.getHoistedCode();
    }
    let suffix = "";
    for (const transformer of this.transformers) {
      suffix += transformer.getSuffixCode();
    }
    const result = this.tokens.finish();
    let { code } = result;
    if (code.startsWith("#!")) {
      let newlineIndex = code.indexOf("\n");
      if (newlineIndex === -1) {
        newlineIndex = code.length;
        code += "\n";
      }
      return {
        code: code.slice(0, newlineIndex + 1) + prefix2 + code.slice(newlineIndex + 1) + suffix,
        // The hashbang line has no tokens, so shifting the tokens to account
        // for prefix can happen normally.
        mappings: this.shiftMappings(result.mappings, prefix2.length)
      };
    } else {
      return {
        code: prefix2 + code + suffix,
        mappings: this.shiftMappings(result.mappings, prefix2.length)
      };
    }
  }
  processBalancedCode() {
    let braceDepth = 0;
    let parenDepth = 0;
    while (!this.tokens.isAtEnd()) {
      if (this.tokens.matches1(TokenType.braceL) || this.tokens.matches1(TokenType.dollarBraceL)) {
        braceDepth++;
      } else if (this.tokens.matches1(TokenType.braceR)) {
        if (braceDepth === 0) {
          return;
        }
        braceDepth--;
      }
      if (this.tokens.matches1(TokenType.parenL)) {
        parenDepth++;
      } else if (this.tokens.matches1(TokenType.parenR)) {
        if (parenDepth === 0) {
          return;
        }
        parenDepth--;
      }
      this.processToken();
    }
  }
  processToken() {
    if (this.tokens.matches1(TokenType._class)) {
      this.processClass();
      return;
    }
    for (const transformer of this.transformers) {
      const wasProcessed = transformer.process();
      if (wasProcessed) {
        return;
      }
    }
    this.tokens.copyToken();
  }
  /**
   * Skip past a class with a name and return that name.
   */
  processNamedClass() {
    if (!this.tokens.matches2(TokenType._class, TokenType.name)) {
      throw new Error("Expected identifier for exported class name.");
    }
    const name = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    this.processClass();
    return name;
  }
  processClass() {
    const classInfo = getClassInfo(this, this.tokens, this.nameManager, this.disableESTransforms);
    const needsCommaExpression = (classInfo.headerInfo.isExpression || !classInfo.headerInfo.className) && classInfo.staticInitializerNames.length + classInfo.instanceInitializerNames.length > 0;
    let className = classInfo.headerInfo.className;
    if (needsCommaExpression) {
      className = this.nameManager.claimFreeName("_class");
      this.generatedVariables.push(className);
      this.tokens.appendCode(` (${className} =`);
    }
    const classToken = this.tokens.currentToken();
    const contextId = classToken.contextId;
    if (contextId == null) {
      throw new Error("Expected class to have a context ID.");
    }
    this.tokens.copyExpectedToken(TokenType._class);
    while (!this.tokens.matchesContextIdAndLabel(TokenType.braceL, contextId)) {
      this.processToken();
    }
    this.processClassBody(classInfo, className);
    const staticInitializerStatements = classInfo.staticInitializerNames.map(
      (name) => `${className}.${name}()`
    );
    if (needsCommaExpression) {
      this.tokens.appendCode(
        `, ${staticInitializerStatements.map((s4) => `${s4}, `).join("")}${className})`
      );
    } else if (classInfo.staticInitializerNames.length > 0) {
      this.tokens.appendCode(` ${staticInitializerStatements.map((s4) => `${s4};`).join(" ")}`);
    }
  }
  /**
   * We want to just handle class fields in all contexts, since TypeScript supports them. Later,
   * when some JS implementations support class fields, this should be made optional.
   */
  processClassBody(classInfo, className) {
    const {
      headerInfo,
      constructorInsertPos,
      constructorInitializerStatements,
      fields,
      instanceInitializerNames,
      rangesToRemove
    } = classInfo;
    let fieldIndex = 0;
    let rangeToRemoveIndex = 0;
    const classContextId = this.tokens.currentToken().contextId;
    if (classContextId == null) {
      throw new Error("Expected non-null context ID on class.");
    }
    this.tokens.copyExpectedToken(TokenType.braceL);
    if (this.isReactHotLoaderTransformEnabled) {
      this.tokens.appendCode(
        "__reactstandin__regenerateByEval(key, code) {this[key] = eval(code);}"
      );
    }
    const needsConstructorInit = constructorInitializerStatements.length + instanceInitializerNames.length > 0;
    if (constructorInsertPos === null && needsConstructorInit) {
      const constructorInitializersCode = this.makeConstructorInitCode(
        constructorInitializerStatements,
        instanceInitializerNames,
        className
      );
      if (headerInfo.hasSuperclass) {
        const argsName = this.nameManager.claimFreeName("args");
        this.tokens.appendCode(
          `constructor(...${argsName}) { super(...${argsName}); ${constructorInitializersCode}; }`
        );
      } else {
        this.tokens.appendCode(`constructor() { ${constructorInitializersCode}; }`);
      }
    }
    while (!this.tokens.matchesContextIdAndLabel(TokenType.braceR, classContextId)) {
      if (fieldIndex < fields.length && this.tokens.currentIndex() === fields[fieldIndex].start) {
        let needsCloseBrace = false;
        if (this.tokens.matches1(TokenType.bracketL)) {
          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this`);
        } else if (this.tokens.matches1(TokenType.string) || this.tokens.matches1(TokenType.num)) {
          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this[`);
          needsCloseBrace = true;
        } else {
          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this.`);
        }
        while (this.tokens.currentIndex() < fields[fieldIndex].end) {
          if (needsCloseBrace && this.tokens.currentIndex() === fields[fieldIndex].equalsIndex) {
            this.tokens.appendCode("]");
          }
          this.processToken();
        }
        this.tokens.appendCode("}");
        fieldIndex++;
      } else if (rangeToRemoveIndex < rangesToRemove.length && this.tokens.currentIndex() >= rangesToRemove[rangeToRemoveIndex].start) {
        if (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {
          this.tokens.removeInitialToken();
        }
        while (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {
          this.tokens.removeToken();
        }
        rangeToRemoveIndex++;
      } else if (this.tokens.currentIndex() === constructorInsertPos) {
        this.tokens.copyToken();
        if (needsConstructorInit) {
          this.tokens.appendCode(
            `;${this.makeConstructorInitCode(
              constructorInitializerStatements,
              instanceInitializerNames,
              className
            )};`
          );
        }
        this.processToken();
      } else {
        this.processToken();
      }
    }
    this.tokens.copyExpectedToken(TokenType.braceR);
  }
  makeConstructorInitCode(constructorInitializerStatements, instanceInitializerNames, className) {
    return [
      ...constructorInitializerStatements,
      ...instanceInitializerNames.map((name) => `${className}.prototype.${name}.call(this)`)
    ].join(";");
  }
  /**
   * Normally it's ok to simply remove type tokens, but we need to be more careful when dealing with
   * arrow function return types since they can confuse the parser. In that case, we want to move
   * the close-paren to the same line as the arrow.
   *
   * See https://github.com/alangpierce/sucrase/issues/391 for more details.
   */
  processPossibleArrowParamEnd() {
    if (this.tokens.matches2(TokenType.parenR, TokenType.colon) && this.tokens.tokenAtRelativeIndex(1).isType) {
      let nextNonTypeIndex = this.tokens.currentIndex() + 1;
      while (this.tokens.tokens[nextNonTypeIndex].isType) {
        nextNonTypeIndex++;
      }
      if (this.tokens.matches1AtIndex(nextNonTypeIndex, TokenType.arrow)) {
        this.tokens.removeInitialToken();
        while (this.tokens.currentIndex() < nextNonTypeIndex) {
          this.tokens.removeToken();
        }
        this.tokens.replaceTokenTrimmingLeftWhitespace(") =>");
        return true;
      }
    }
    return false;
  }
  /**
   * An async arrow function might be of the form:
   *
   * async <
   *   T
   * >() => {}
   *
   * in which case, removing the type parameters will cause a syntax error. Detect this case and
   * move the open-paren earlier.
   */
  processPossibleAsyncArrowWithTypeParams() {
    if (!this.tokens.matchesContextual(ContextualKeyword._async) && !this.tokens.matches1(TokenType._async)) {
      return false;
    }
    const nextToken2 = this.tokens.tokenAtRelativeIndex(1);
    if (nextToken2.type !== TokenType.lessThan || !nextToken2.isType) {
      return false;
    }
    let nextNonTypeIndex = this.tokens.currentIndex() + 1;
    while (this.tokens.tokens[nextNonTypeIndex].isType) {
      nextNonTypeIndex++;
    }
    if (this.tokens.matches1AtIndex(nextNonTypeIndex, TokenType.parenL)) {
      this.tokens.replaceToken("async (");
      this.tokens.removeInitialToken();
      while (this.tokens.currentIndex() < nextNonTypeIndex) {
        this.tokens.removeToken();
      }
      this.tokens.removeToken();
      this.processBalancedCode();
      this.processToken();
      return true;
    }
    return false;
  }
  processPossibleTypeRange() {
    if (this.tokens.currentToken().isType) {
      this.tokens.removeInitialToken();
      while (this.tokens.currentToken().isType) {
        this.tokens.removeToken();
      }
      return true;
    }
    return false;
  }
  shiftMappings(mappings, prefixLength) {
    for (let i4 = 0; i4 < mappings.length; i4++) {
      const mapping = mappings[i4];
      if (mapping !== void 0) {
        mappings[i4] = mapping + prefixLength;
      }
    }
    return mappings;
  }
};

// node_modules/sucrase/dist/esm/util/formatTokens.js
var import_lines_and_columns = __toESM(require_build());

// node_modules/sucrase/dist/esm/util/getTSImportedNames.js
function getTSImportedNames(tokens) {
  const importedNames = /* @__PURE__ */ new Set();
  for (let i4 = 0; i4 < tokens.tokens.length; i4++) {
    if (tokens.matches1AtIndex(i4, TokenType._import) && !tokens.matches3AtIndex(i4, TokenType._import, TokenType.name, TokenType.eq)) {
      collectNamesForImport(tokens, i4, importedNames);
    }
  }
  return importedNames;
}
function collectNamesForImport(tokens, index2, importedNames) {
  index2++;
  if (tokens.matches1AtIndex(index2, TokenType.parenL)) {
    return;
  }
  if (tokens.matches1AtIndex(index2, TokenType.name)) {
    importedNames.add(tokens.identifierNameAtIndex(index2));
    index2++;
    if (tokens.matches1AtIndex(index2, TokenType.comma)) {
      index2++;
    }
  }
  if (tokens.matches1AtIndex(index2, TokenType.star)) {
    index2 += 2;
    importedNames.add(tokens.identifierNameAtIndex(index2));
    index2++;
  }
  if (tokens.matches1AtIndex(index2, TokenType.braceL)) {
    index2++;
    collectNamesForNamedImport(tokens, index2, importedNames);
  }
}
function collectNamesForNamedImport(tokens, index2, importedNames) {
  while (true) {
    if (tokens.matches1AtIndex(index2, TokenType.braceR)) {
      return;
    }
    const specifierInfo = getImportExportSpecifierInfo(tokens, index2);
    index2 = specifierInfo.endIndex;
    if (!specifierInfo.isType) {
      importedNames.add(specifierInfo.rightName);
    }
    if (tokens.matches2AtIndex(index2, TokenType.comma, TokenType.braceR)) {
      return;
    } else if (tokens.matches1AtIndex(index2, TokenType.braceR)) {
      return;
    } else if (tokens.matches1AtIndex(index2, TokenType.comma)) {
      index2++;
    } else {
      throw new Error(`Unexpected token: ${JSON.stringify(tokens.tokens[index2])}`);
    }
  }
}

// node_modules/sucrase/dist/esm/index.js
function transform(code, options2) {
  validateOptions(options2);
  try {
    const sucraseContext = getSucraseContext(code, options2);
    const transformer = new RootTransformer(
      sucraseContext,
      options2.transforms,
      Boolean(options2.enableLegacyBabel5ModuleInterop),
      options2
    );
    const transformerResult = transformer.transform();
    let result = { code: transformerResult.code };
    if (options2.sourceMapOptions) {
      if (!options2.filePath) {
        throw new Error("filePath must be specified when generating a source map.");
      }
      result = {
        ...result,
        sourceMap: computeSourceMap(
          transformerResult,
          options2.filePath,
          options2.sourceMapOptions,
          code,
          sucraseContext.tokenProcessor.tokens
        )
      };
    }
    return result;
  } catch (e3) {
    if (options2.filePath) {
      e3.message = `Error transforming ${options2.filePath}: ${e3.message}`;
    }
    throw e3;
  }
}
function getSucraseContext(code, options2) {
  const isJSXEnabled2 = options2.transforms.includes("jsx");
  const isTypeScriptEnabled2 = options2.transforms.includes("typescript");
  const isFlowEnabled2 = options2.transforms.includes("flow");
  const disableESTransforms = options2.disableESTransforms === true;
  const file = parse2(code, isJSXEnabled2, isTypeScriptEnabled2, isFlowEnabled2);
  const tokens = file.tokens;
  const scopes = file.scopes;
  const nameManager = new NameManager(code, tokens);
  const helperManager = new HelperManager(nameManager);
  const tokenProcessor = new TokenProcessor(
    code,
    tokens,
    isFlowEnabled2,
    disableESTransforms,
    helperManager
  );
  const enableLegacyTypeScriptModuleInterop = Boolean(options2.enableLegacyTypeScriptModuleInterop);
  let importProcessor = null;
  if (options2.transforms.includes("imports")) {
    importProcessor = new CJSImportProcessor(
      nameManager,
      tokenProcessor,
      enableLegacyTypeScriptModuleInterop,
      options2,
      options2.transforms.includes("typescript"),
      Boolean(options2.keepUnusedImports),
      helperManager
    );
    importProcessor.preprocessTokens();
    identifyShadowedGlobals(tokenProcessor, scopes, importProcessor.getGlobalNames());
    if (options2.transforms.includes("typescript") && !options2.keepUnusedImports) {
      importProcessor.pruneTypeOnlyImports();
    }
  } else if (options2.transforms.includes("typescript") && !options2.keepUnusedImports) {
    identifyShadowedGlobals(tokenProcessor, scopes, getTSImportedNames(tokenProcessor));
  }
  return { tokenProcessor, scopes, nameManager, importProcessor, helperManager };
}

// src/utils/javascript.ts
function transpile(script, language) {
  switch (language) {
    case "js":
      return script;
    case "jsx":
      return transform(script, { transforms: ["jsx"], jsxPragma: "h", jsxFragmentPragma: "Fragment" }).code;
    case "ts":
      return transform(script, { transforms: ["typescript"] }).code;
    case "tsx":
      return transform(script, {
        transforms: ["typescript", "jsx"],
        jsxPragma: "h",
        jsxFragmentPragma: "Fragment"
      }).code;
  }
}
function evalInContext(script, variables) {
  const pairs = Object.entries(variables);
  const keys2 = pairs.map(([key, _3]) => key);
  const values = pairs.map(([_3, value]) => value);
  return new Function(...keys2, script)(...values);
}
async function asyncEvalInContext(script, variables) {
  if (script.includes("await")) {
    return evalInContext("return (async () => { " + script + " })()", variables);
  } else {
    return Promise.resolve(evalInContext(script, variables));
  }
}

// src/ui/hooks.ts
var import_obsidian2 = require("obsidian");
function useIndexUpdates(datacore, settings) {
  const [revision, setRevision] = h2(datacore.datastore.revision);
  const debouncedRevision = T2(() => {
    var _a;
    if ((settings == null ? void 0 : settings.debounce) && settings.debounce == 0) return setRevision;
    else return (0, import_obsidian2.debounce)(setRevision, (_a = settings == null ? void 0 : settings.debounce) != null ? _a : 500);
  }, [setRevision, settings == null ? void 0 : settings.debounce]);
  y2(() => {
    const ref = datacore.on("update", debouncedRevision);
    return () => datacore.offref(ref);
  }, []);
  return revision;
}
function useFileMetadata(datacore, path, settings) {
  const indexRevision = useIndexUpdates(datacore, settings);
  return T2(() => datacore.datastore.load(path), [indexRevision, path]);
}
function tryUseFullQuery(datacore, query, settings) {
  const indexRevision = useIndexUpdates(datacore, settings);
  const internedQuery = useInterning(query, Literals.equals);
  const internedResult = A2(void 0);
  return T2(() => {
    const newResult = datacore.datastore.search(query);
    if (!newResult.successful) {
      internedResult.current = Result.failure(newResult.error);
      return internedResult.current;
    }
    if (internedResult.current === void 0) {
      internedResult.current = Result.success(newResult.value);
      return internedResult.current;
    }
    const oldResult = internedResult.current;
    if (!oldResult.successful) {
      internedResult.current = Result.success(newResult.value);
      return internedResult.current;
    }
    if (oldResult.value.revision != newResult.value.revision || !sameObjects(oldResult.value.results, newResult.value.results)) {
      return internedResult.current = Result.success(newResult.value);
    }
    return internedResult.current;
  }, [internedQuery, indexRevision]);
}
function useFullQuery(datacore, query, settings) {
  return tryUseFullQuery(datacore, query, settings).orElseThrow((e3) => "Failed to search: " + e3);
}
function useQuery(datacore, query, settings) {
  return useFullQuery(datacore, query, settings).results;
}
function sameObjects(old, incoming) {
  if (old.length != incoming.length) return false;
  const olds = {};
  for (const indexable of old) {
    olds[indexable.$id] = indexable.$revision;
  }
  for (const indexable of incoming) {
    const value = olds[indexable.$id];
    if (value == void 0) return false;
    if (value != indexable.$revision) return false;
  }
  return true;
}
function useInterning(value, equality) {
  const ref = A2();
  if (ref.current === void 0 || !equality(ref.current, value)) {
    ref.current = value;
  }
  return ref.current;
}
function useStableCallback(callback, deps) {
  const ref = A2();
  y2(() => {
    ref.current = callback;
  }, [callback, ...deps]);
  return q2(
    (...args) => {
      ref.current(...args);
    },
    [ref]
  );
}
var NO_OP_UPDATE = (x4) => {
};
function useControlledState(initialState, override, update) {
  const [state2, setState] = h2(override != null ? override : initialState);
  if (override !== void 0) {
    if (state2 != override) setState(override);
    return [override, update != null ? update : NO_OP_UPDATE];
  }
  const setStateWithUpdate = q2(
    (value) => {
      setState(value);
      if (update) update(value);
    },
    [setState, update]
  );
  return [state2, setStateWithUpdate];
}

// src/ui/loading-boundary.tsx
function LoadingProgress({ datacore }) {
  var _a, _b, _c, _d;
  useIndexUpdates(datacore, { debounce: 250 });
  return /* @__PURE__ */ u3("p", { children: [
    (_b = (_a = datacore.initializer) == null ? void 0 : _a.initialized) != null ? _b : 0,
    " / ",
    (_d = (_c = datacore.initializer) == null ? void 0 : _c.targetTotal) != null ? _d : 0
  ] });
}
function LoadingBoundary({ children, datacore }) {
  const [initialized, setInitialized] = h2(datacore.initialized);
  y2(() => {
    if (initialized) return;
    const ref = datacore.on("initialized", () => setInitialized(true));
    return () => datacore.offref(ref);
  }, [initialized, datacore]);
  if (initialized) {
    return /* @__PURE__ */ u3(b, { children });
  } else {
    return /* @__PURE__ */ u3("div", { className: "datacore-loading-boundary", children: [
      /* @__PURE__ */ u3("h4", { className: "datacore-loading-title", children: "Datacore is getting ready..." }),
      /* @__PURE__ */ u3("div", { className: "datacore-loading-content", children: /* @__PURE__ */ u3(LoadingProgress, { datacore }) })
    ] });
  }
}
function ScriptContainer({
  executor,
  sourcePath
}) {
  const [element, setElement] = h2(void 0);
  const [error, setError] = h2(void 0);
  y2(() => {
    setElement(void 0);
    setError(void 0);
    executor().then((result) => setElement(makeRenderableElement(result, sourcePath))).catch((error2) => setError(error2));
  }, [executor]);
  if (error) {
    throw error;
  }
  return /* @__PURE__ */ u3(b, { children: element != null ? element : /* @__PURE__ */ u3(ErrorMessage, { message: "< View is rendering >" }) });
}
function makeRenderableElement(object, sourcePath) {
  if (typeof object === "function") {
    return _(object, {});
  } else if (Array.isArray(object)) {
    return _(
      "div",
      {},
      object.map((x4) => makeRenderableElement(x4, sourcePath))
    );
  } else if (t(object)) {
    return object;
  } else {
    return /* @__PURE__ */ u3(Lit, { value: object, sourcePath });
  }
}

// src/ui/javascript.tsx
var DatacoreJSRenderer = class extends import_obsidian3.MarkdownRenderChild {
  constructor(api2, container, path, script, language) {
    super(container);
    this.api = api2;
    this.container = container;
    this.path = path;
    this.script = script;
    this.language = language;
    this.loaded = false;
  }
  async onload() {
    this.loaded = true;
    try {
      const primitiveScript = transpile(this.script, this.language);
      const renderer = async () => {
        return await asyncEvalInContext(primitiveScript, {
          dc: this.api,
          h: _,
          Fragment: b
        });
      };
      B(
        /* @__PURE__ */ u3(
          DatacoreContextProvider,
          {
            app: this.api.app,
            component: this,
            datacore: this.api.core,
            settings: this.api.core.settings,
            children: /* @__PURE__ */ u3(CURRENT_FILE_CONTEXT.Provider, { value: this.path, children: /* @__PURE__ */ u3(SimpleErrorBoundary, { message: "The datacore script failed to execute.", children: /* @__PURE__ */ u3(LoadingBoundary, { datacore: this.api.core, children: /* @__PURE__ */ u3(ScriptContainer, { executor: renderer, sourcePath: this.path }) }) }) })
          }
        ),
        this.container
      );
    } catch (ex) {
      B(
        /* @__PURE__ */ u3(ErrorMessage, { message: "Datacore failed to render the code block.", error: "" + ex }),
        this.container
      );
    }
  }
  onunload() {
    if (this.loaded) hn(this.container);
    this.loaded = false;
  }
};
var ReactRenderer = class extends import_obsidian3.MarkdownRenderChild {
  constructor(app, datacore, container, sourcePath, element) {
    super(container);
    this.app = app;
    this.datacore = datacore;
    this.container = container;
    this.sourcePath = sourcePath;
    this.element = element;
  }
  onload() {
    B(
      /* @__PURE__ */ u3(
        DatacoreContextProvider,
        {
          app: this.app,
          component: this,
          datacore: this.datacore,
          settings: this.datacore.settings,
          children: /* @__PURE__ */ u3(CURRENT_FILE_CONTEXT.Provider, { value: this.sourcePath, children: /* @__PURE__ */ u3(LoadingBoundary, { datacore: this.datacore, children: this.element }) })
        }
      ),
      this.container
    );
  }
  onunload() {
    hn(this.container);
  }
};

// src/api/ui/layout.tsx
function Stack(props) {
  const { className, justify, align, style, children, ...rest } = props;
  const extraStyle = T2(() => {
    let style2 = "";
    if (justify) style2 += `justify-content: ${justify};`;
    if (align) style2 += `align-items: ${align};`;
    return style2.length == 0 ? void 0 : style2;
  }, [justify, align]);
  return /* @__PURE__ */ u3(
    "div",
    {
      className: className ? className + " dc-stack" : "dc-stack",
      style: style ? extraStyle + style : extraStyle,
      ...rest,
      children
    }
  );
}
function Group(props) {
  const { className, justify, align, style, children, ...rest } = props;
  const extraStyle = T2(() => {
    let style2 = "";
    if (justify) style2 += `justify-content: ${justify};`;
    if (align) style2 += `align-items: ${align};`;
    return style2.length == 0 ? void 0 : style2;
  }, [justify, align]);
  return /* @__PURE__ */ u3(
    "div",
    {
      className: className ? className + " dc-group" : "dc-group",
      style: style ? extraStyle + style : extraStyle,
      ...rest,
      children
    }
  );
}

// src/api/ui/basics.tsx
var import_obsidian4 = require("obsidian");
var INTENT_CLASSES = {
  error: "dc-intent-error",
  warn: "dc-intent-warn",
  info: "dc-intent-info",
  success: "dc-intent-success"
};
function Button(props) {
  const { className, intent, children, ...forwardingProps } = props;
  return /* @__PURE__ */ u3(
    "button",
    {
      className: combineClasses("dc-button", intent ? INTENT_CLASSES[intent] : void 0, className),
      ...forwardingProps,
      children
    }
  );
}
function Textbox(props) {
  var _a, _b;
  const { className, children, inline: inline2 = false, ...forwardingProps } = props;
  return inline2 ? /* @__PURE__ */ u3("input", { type: (_a = props.type) != null ? _a : "text", className: combineClasses("dc-textbox", className), ...forwardingProps }) : /* @__PURE__ */ u3("textarea", { className: combineClasses("dc-textbox", className), children: (_b = props.value) != null ? _b : "" });
}
function Checkbox(props) {
  const {
    className,
    disabled: disabled2,
    defaultChecked,
    checked: isChecked,
    onCheckChange,
    children,
    ...forwardingProps
  } = props;
  const [checked, setChecked] = useControlledState(defaultChecked != null ? defaultChecked : false, isChecked, onCheckChange);
  const onChange3 = q2((event) => setChecked(event.currentTarget.checked), [setChecked]);
  return /* @__PURE__ */ u3("label", { className: combineClasses("dc-checkbox", disabled2 ? "dc-checkbox-disabled" : void 0, className), children: [
    /* @__PURE__ */ u3(
      "input",
      {
        type: "checkbox",
        defaultChecked,
        checked,
        disabled: disabled2,
        onChange: onChange3,
        ...forwardingProps
      }
    ),
    children
  ] });
}
function Slider(props) {
  const { className, min: min2 = 0, max: max2 = 10, step = 1, value, defaultValue, onValueChange, ...forwardingProps } = props;
  const [slider, setSlider] = useControlledState(defaultValue != null ? defaultValue : 0, value, onValueChange);
  const onChange3 = q2((event) => setSlider(parseFloat(event.currentTarget.value)), [setSlider]);
  return /* @__PURE__ */ u3(
    "input",
    {
      type: "range",
      "aria-label": slider.toString(),
      className: combineClasses("dc-slider", className),
      min: min2,
      max: max2,
      step,
      value: slider,
      onChange: onChange3,
      ...forwardingProps
    }
  );
}
function Switch(props) {
  const { className, disabled: disabled2, defaultChecked, checked, onToggleChange, ...forwardingProps } = props;
  const [toggled, setToggled] = useControlledState(defaultChecked != null ? defaultChecked : false, checked, onToggleChange);
  const onChange3 = q2((event) => setToggled(event.currentTarget.checked), [setToggled]);
  return /* @__PURE__ */ u3(
    "label",
    {
      className: combineClasses(
        "dc-switch checkbox-container",
        toggled ? "is-enabled" : void 0,
        disabled2 ? "dc-switch-disabled" : void 0,
        className
      ),
      children: /* @__PURE__ */ u3(
        "input",
        {
          type: "checkbox",
          className: "dc-switch-input",
          defaultChecked,
          checked: toggled,
          disabled: disabled2,
          onChange: onChange3,
          ...forwardingProps
        }
      )
    }
  );
}
function VanillaSelect(props) {
  var _a;
  const { className, options: options2 = [], value, defaultValue, onValueChange, ...forwardingProps } = props;
  const [selectedValue, setSelectedValue] = xn.useState((_a = value != null ? value : defaultValue) != null ? _a : "");
  xn.useEffect(() => {
    if (typeof value === "string") setSelectedValue(value);
  }, [value]);
  return /* @__PURE__ */ u3(
    "select",
    {
      className: combineClasses("dc-select dropdown", className),
      value: selectedValue,
      onChange: (e3) => {
        setSelectedValue(e3.currentTarget.value);
        onValueChange && onValueChange(e3.currentTarget.value);
      },
      ...forwardingProps,
      children: options2.map((option) => /* @__PURE__ */ u3("option", { value: option.value, children: option.label }, option.value))
    }
  );
}
function Icon(props) {
  const { className, icon: icon2 } = props;
  const ref = xn.createRef();
  xn.useEffect(() => {
    if (ref.current) {
      (0, import_obsidian4.setIcon)(ref.current, icon2);
    }
  }, [ref]);
  return /* @__PURE__ */ u3("span", { ref, className: combineClasses("dc-icon", className), "data-icon": icon2 });
}
function combineClasses(fixed, ...rest) {
  const nonempty = rest.filter((c4) => c4 !== void 0);
  if (nonempty.length === 0) return fixed;
  return [fixed, ...nonempty].join(" ");
}

// src/index/types/indexable.ts
var LINKABLE_TYPE = "linkable";
var FILE_TYPE = "file";
var TAGGABLE_TYPE = "taggable";
var LINKBEARING_TYPE = "links";
var INDEXABLE_EXTENSIONS = /* @__PURE__ */ new Set(["md", "markdown", "canvas"]);

// src/expression/field.ts
var FIELDBEARING_TYPE = "fields";
var Fieldbearings;
((Fieldbearings2) => {
  function isFieldbearing(object) {
    return object != null && typeof object === "object" && "field" in object && typeof object["field"] == "function";
  }
  Fieldbearings2.isFieldbearing = isFieldbearing;
  function get(object, key) {
    var _a;
    if (isFieldbearing(object)) return (_a = object.field(key)) == null ? void 0 : _a.value;
    else return object[key];
  }
  Fieldbearings2.get = get;
  function getWithDefault(object, key, defaultValue) {
    return {
      key,
      value: defaultValue != null ? defaultValue : null,
      provenance: {
        type: "inline-field",
        file: object.$file,
        key,
        line: object.$position.end
      }
    };
  }
  Fieldbearings2.getWithDefault = getWithDefault;
})(Fieldbearings || (Fieldbearings = {}));
var Extractors;
((Extractors2) => {
  function isValidIntrinsic(object, key, exclude) {
    if ((exclude == null ? void 0 : exclude.has(key)) || !key.startsWith("$")) return false;
    const value = object[key];
    if (Literals.isFunction(value)) return false;
    return true;
  }
  function* prototypeKeys(object) {
    for (const key of Object.keys(object)) yield key;
    let proto = Object.getPrototypeOf(object);
    while (proto) {
      for (const key of Object.getOwnPropertyNames(proto)) yield key;
      proto = Object.getPrototypeOf(proto);
    }
  }
  function intrinsics(except) {
    return (object, key) => {
      if (key == null) {
        const fields = [];
        for (const key2 of prototypeKeys(object)) {
          if (!isValidIntrinsic(object, key2, except)) continue;
          fields.push({
            key: key2,
            value: object[key2]
          });
        }
        return fields;
      } else {
        if (key in object && isValidIntrinsic(object, key, except)) {
          return [
            {
              key,
              value: object[key]
            }
          ];
        }
        return [];
      }
    };
  }
  Extractors2.intrinsics = intrinsics;
  function frontmatter(front) {
    return (object, key) => {
      const frontmatter2 = front(object);
      if (!frontmatter2) return [];
      if (key == null) {
        const fields = [];
        for (const key2 of Object.keys(frontmatter2)) {
          const entry = frontmatter2[key2];
          fields.push({
            key: entry.key.toLowerCase(),
            value: entry.value,
            raw: entry.raw,
            provenance: { type: "frontmatter", file: object.$file, key: entry.key }
          });
        }
        return fields;
      } else {
        key = key.toLowerCase();
        if (!(key in frontmatter2)) return [];
        const entry = frontmatter2[key];
        return [
          {
            key,
            value: entry.value,
            raw: entry.raw,
            provenance: { type: "frontmatter", file: object.$file, key }
          }
        ];
      }
    };
  }
  Extractors2.frontmatter = frontmatter;
  function inlineFields(inlineMap) {
    return (object, key) => {
      const map = inlineMap(object);
      if (!map) return [];
      if (key == null) {
        const fields = [];
        for (const field of Object.values(map)) {
          fields.push({
            key: field.key.toLowerCase(),
            value: field.value,
            raw: field.raw,
            provenance: {
              type: "inline-field",
              file: object.$file,
              line: field.position.line,
              key: field.key
            }
          });
        }
        return fields;
      } else {
        key = key.toLowerCase();
        if (!(key in map)) return [];
        const field = map[key];
        return [
          {
            key,
            value: field.value,
            raw: field.raw,
            provenance: {
              type: "inline-field",
              file: object.$file,
              line: field.position.line,
              key: field.key
            }
          }
        ];
      }
    };
  }
  Extractors2.inlineFields = inlineFields;
  function merge(...extractors) {
    return (object, key) => {
      if (key == null) {
        const used = /* @__PURE__ */ new Set();
        const fields = [];
        for (const extractor of extractors) {
          for (const field of extractor(object, void 0)) {
            if (used.has(field.key.toLowerCase())) continue;
            used.add(field.key.toLowerCase());
            fields.push(field);
          }
        }
        return fields;
      } else {
        for (const extractor of extractors) {
          const field = extractor(object, key);
          if (field && field.length > 0) return field;
        }
        return [];
      }
    };
  }
  Extractors2.merge = merge;
})(Extractors || (Extractors = {}));

// src/index/import/inline-field.ts
var P6 = __toESM(require_parsimmon_umd_min());

// src/utils/data.ts
function mapObjectValues(object, func) {
  const result = {};
  for (const [key, value] of Object.entries(object)) {
    result[key] = func(value);
  }
  return result;
}

// src/index/types/json/common.ts
var JsonConversion;
((JsonConversion2) => {
  JsonConversion2.NOOP_NORMALIZER = (input2) => input2;
  function json(literal) {
    const wrapped = Literals.wrapValue(literal);
    if (!wrapped) return null;
    switch (wrapped == null ? void 0 : wrapped.type) {
      case "array":
        return wrapped.value.map(JsonConversion2.json);
      case "object":
        return mapObjectValues(wrapped.value, JsonConversion2.json);
      case "date":
        return { $_type: "date", value: wrapped.value.toISO({ extendedZone: true, includeOffset: true }) };
      case "link":
        return { $_type: "link", value: wrapped.value.toObject() };
      case "duration":
        return { $_type: "duration", value: wrapped.value.toISO() };
      case "boolean":
      case "number":
      case "string":
        return wrapped.value;
      case "function":
      case "null":
        return null;
    }
  }
  JsonConversion2.json = json;
  function value(json2, normalizer = JsonConversion2.NOOP_NORMALIZER) {
    if (json2 === null || json2 === void 0) return null;
    if (Array.isArray(json2)) {
      return normalizer(json2.map((input2) => JsonConversion2.value(input2, normalizer)));
    } else if (typeof json2 === "object") {
      if (!("$_type" in json2))
        return mapObjectValues(json2, (v3) => JsonConversion2.value(v3, normalizer));
      const type = json2["$_type"];
      switch (type) {
        case "date":
          return normalizer(DateTime.fromISO(json2.value));
        case "duration":
          return normalizer(Duration.fromISO(json2.value));
        case "link":
          return normalizer(Link.fromObject(json2.value));
        default:
          throw new Error(`Unrecognized serialized type '${type}'!`);
      }
    }
    return normalizer(json2);
  }
  JsonConversion2.value = value;
})(JsonConversion || (JsonConversion = {}));

// src/index/import/inline-field.ts
function jsonInlineField(field) {
  return Object.assign({}, field, { value: JsonConversion.json(field.value) });
}
function valueInlineField(field) {
  return Object.assign({}, field, { value: JsonConversion.value(field.value) });
}
var INLINE_FIELD_WRAPPERS = Object.freeze({
  "[": "]",
  "(": ")"
});
function findClosing(line2, start, open, close) {
  let nesting = 0;
  let escaped = false;
  for (let index2 = start; index2 < line2.length; index2++) {
    let char2 = line2.charAt(index2);
    if (char2 == "\\") {
      escaped = !escaped;
      continue;
    }
    if (escaped) {
      escaped = false;
      continue;
    }
    if (char2 == open) nesting++;
    else if (char2 == close) nesting--;
    if (nesting < 0) return { value: line2.substring(start, index2).trim(), endIndex: index2 + 1 };
    escaped = false;
  }
  return void 0;
}
function findSeparator(line2, start) {
  let sep = line2.indexOf("::", start);
  if (sep < 0) return void 0;
  return { key: line2.substring(start, sep).trim(), valueIndex: sep + 2 };
}
function findSpecificInlineField(line2, start) {
  let open = line2.charAt(start);
  let key = findSeparator(line2, start + 1);
  if (key === void 0) return void 0;
  for (let sep of Object.keys(INLINE_FIELD_WRAPPERS).concat(Object.values(INLINE_FIELD_WRAPPERS))) {
    if (key.key.includes(sep)) return void 0;
  }
  let value = findClosing(line2, key.valueIndex, open, INLINE_FIELD_WRAPPERS[open]);
  if (value === void 0) return void 0;
  return {
    key: key.key,
    value: value.value,
    start,
    startValue: key.valueIndex,
    end: value.endIndex,
    wrapping: open
  };
}
function extractInlineFields(line2, includeTaskFields = false) {
  let fields = [];
  for (let wrapper of Object.keys(INLINE_FIELD_WRAPPERS)) {
    let foundIndex = line2.indexOf(wrapper);
    while (foundIndex >= 0) {
      let parsedField = findSpecificInlineField(line2, foundIndex);
      if (!parsedField) {
        foundIndex = line2.indexOf(wrapper, foundIndex + 1);
        continue;
      }
      fields.push(parsedField);
      foundIndex = line2.indexOf(wrapper, parsedField.end);
    }
  }
  if (includeTaskFields) fields = fields.concat(extractSpecialTaskFields(line2));
  fields.sort((a4, b3) => a4.start - b3.start);
  let filteredFields = [];
  for (let i4 = 0; i4 < fields.length; i4++) {
    if (i4 == 0 || filteredFields[filteredFields.length - 1].end < fields[i4].start) {
      filteredFields.push(fields[i4]);
    }
  }
  return filteredFields;
}
var FULL_LINE_KEY_PART = P6.alt(
  P6.regexp(new RegExp(emoji_regex_default(), "u")),
  P6.regexp(/[0-9\p{Letter}\w\s_/-]+/u)
).many().map((parts) => parts.join(""));
var FULL_LINE_KEY_PARSER = P6.regexp(/[^0-9\w\p{Letter}]*/u).then(FULL_LINE_KEY_PART).skip(P6.regexp(/[_\*~`]*/u));
var CREATED_DATE_REGEX = /\u{2795}\s*(\d{4}-\d{2}-\d{2})/u;
var DUE_DATE_REGEX = /(?:\u{1F4C5}|\u{1F4C6}|\u{1F5D3}\u{FE0F}?)\s*(\d{4}-\d{2}-\d{2})/u;
var DONE_DATE_REGEX = /\u{2705}\s*(\d{4}-\d{2}-\d{2})/u;
var SCHEDULED_DATE_REGEX = /[\u{23F3}\u{231B}]\s*(\d{4}-\d{2}-\d{2})/u;
var START_DATE_REGEX = /\u{1F6EB}\s*(\d{4}-\d{2}-\d{2})/u;
var EMOJI_REGEXES = [
  { regex: CREATED_DATE_REGEX, key: "created" },
  { regex: START_DATE_REGEX, key: "start" },
  { regex: SCHEDULED_DATE_REGEX, key: "scheduled" },
  { regex: DUE_DATE_REGEX, key: "due" },
  { regex: DONE_DATE_REGEX, key: "completion" }
];
function extractSpecialTaskFields(line2) {
  let results = [];
  for (let { regex: regex2, key } of EMOJI_REGEXES) {
    const match4 = regex2.exec(line2);
    if (!match4) continue;
    results.push({
      key,
      value: match4[1],
      start: match4.index,
      startValue: match4.index + 1,
      end: match4.index + match4[0].length,
      wrapping: "emoji-shorthand"
    });
  }
  return results;
}
function setInlineField(source, key, value) {
  let existing = extractInlineFields(source);
  let existingKeys = existing.filter((f4) => f4.key == key);
  if (existingKeys.length > 2 || existingKeys.length == 0 && !value) return source;
  let existingKey = existingKeys[0];
  let annotation = value ? `[${key}:: ${value}]` : "";
  if (existingKey) {
    let prefix2 = source.substring(0, existingKey.start);
    let suffix = source.substring(existingKey.end);
    if (annotation) return `${prefix2}${annotation}${suffix}`;
    else return `${prefix2}${suffix.trimStart()}`;
  } else if (annotation) {
    return `${source.trimEnd()} ${annotation}`;
  }
  return source;
}
function setEmojiShorthandCompletionField(source, value) {
  const existing = extractInlineFields(source, true);
  const existingKeys = existing.filter((f4) => f4.key === "completion" && f4.wrapping === "emoji-shorthand");
  if (existingKeys.length > 2 || existingKeys.length == 0 && !value) return source;
  const annotation = value ? ` \u2705 ${value}` : "";
  let existingKey = existingKeys[0];
  if (existingKey) {
    const prefix2 = source.substring(0, existingKey.start);
    const suffix = source.substring(existingKey.end);
    return `${prefix2.trimEnd()}${annotation}${suffix}`;
  } else {
    return `${source.trimEnd()}${annotation}`;
  }
}

// src/index/types/markdown.ts
var _MarkdownPage = class _MarkdownPage {
  constructor(init) {
    // Use static types for all markdown files.
    this.$types = _MarkdownPage.TYPES;
    this.$typename = "Page";
    /** Obsidian-provided size of this page in bytes. */
    this.$size = 0;
    /**
     * All child markdown sections of this markdown file. The initial section before any content is special and is
     * named with the title of the file.
     */
    this.$sections = [];
    Object.assign(this, init);
  }
  // Markdown file IDs are always just the full path.
  get $id() {
    return this.$path;
  }
  // The file of a file is... it's file.
  get $file() {
    return this.$path;
  }
  /** Create a markdown file from the given raw values. */
  static from(raw, normalizer = NOOP_NORMALIZER) {
    const sections = raw.$sections.map((sect) => MarkdownSection.from(sect, raw.$path, normalizer));
    return new _MarkdownPage({
      $path: raw.$path,
      $frontmatter: raw.$frontmatter ? mapObjectValues(raw.$frontmatter, (fm) => normalizeLinks(valueFrontmatterEntry(fm), normalizer)) : void 0,
      $infields: mapObjectValues(raw.$infields, (field) => normalizeLinks(valueInlineField(field), normalizer)),
      $ctime: DateTime.fromMillis(raw.$ctime),
      $mtime: DateTime.fromMillis(raw.$mtime),
      $extension: raw.$extension,
      $size: raw.$size,
      $position: raw.$position,
      $tags: raw.$tags,
      $links: raw.$links.map((link) => normalizer(Link.fromObject(link))),
      $sections: sections
    });
  }
  /** Return the number of lines in the document. */
  get $lineCount() {
    return this.$position.end;
  }
  /** The name of the file. */
  get $name() {
    return getFileTitle(this.$path);
  }
  /** A link to this file. */
  get $link() {
    return Link.file(this.$path);
  }
  /** All of the indexed fields in this object. */
  get fields() {
    return _MarkdownPage.FIELD_DEF(this);
  }
  /** Get the full field definition for the given field. */
  field(key) {
    var _a;
    return (_a = _MarkdownPage.FIELD_DEF(this, key)) == null ? void 0 : _a[0];
  }
  /** Get the value for the given field. */
  value(key) {
    var _a;
    return (_a = this.field(key)) == null ? void 0 : _a.value;
  }
  /** Convert this page into it's partial representation for saving. */
  json() {
    return {
      $path: this.$path,
      $frontmatter: this.$frontmatter ? mapObjectValues(this.$frontmatter, jsonFrontmatterEntry) : void 0,
      $infields: mapObjectValues(this.$infields, jsonInlineField),
      $ctime: this.$ctime.toMillis(),
      $mtime: this.$mtime.toMillis(),
      $extension: this.$extension,
      $size: this.$size,
      $position: this.$position,
      $tags: this.$tags,
      $links: this.$links.map((link) => link.toObject()),
      $sections: this.$sections.map((sect) => sect.json())
    };
  }
};
/** All of the types that a markdown file is. */
_MarkdownPage.TYPES = [FILE_TYPE, "markdown", "page", TAGGABLE_TYPE, LINKABLE_TYPE, LINKBEARING_TYPE, FIELDBEARING_TYPE];
_MarkdownPage.FIELD_DEF = Extractors.merge(
  Extractors.intrinsics(),
  Extractors.frontmatter((f4) => f4.$frontmatter),
  Extractors.inlineFields((f4) => f4.$infields)
);
var MarkdownPage = _MarkdownPage;
var _MarkdownSection = class _MarkdownSection {
  constructor(init) {
    /** Path of the file that this section is in. */
    this.$types = _MarkdownSection.TYPES;
    this.$typename = "Section";
    Object.assign(this, init);
  }
  /** Convert raw markdown section data to the appropriate class. */
  static from(raw, file, normalizer = NOOP_NORMALIZER) {
    const blocks = raw.$blocks.map((block) => MarkdownBlock.from(block, file, normalizer));
    return new _MarkdownSection({
      $file: file,
      $id: _MarkdownSection.readableId(file, raw.$title, raw.$ordinal),
      $ordinal: raw.$ordinal,
      $title: raw.$title,
      $level: raw.$level,
      $position: raw.$position,
      $tags: raw.$tags,
      $links: raw.$links.map((l4) => normalizer(Link.fromObject(l4))),
      $blocks: blocks,
      $infields: mapObjectValues(raw.$infields, (i4) => normalizeLinks(valueInlineField(i4), normalizer))
    });
  }
  /** Obtain the number of lines in the section. */
  get $lineCount() {
    return this.$position.end - this.$position.start;
  }
  /** Alias for title which allows searching over pages and sections by 'name'. */
  get $name() {
    return this.$title;
  }
  /** Return a link to this section. */
  get $link() {
    return Link.header(this.$file, this.$title);
  }
  /** All of the indexed fields in this object. */
  get fields() {
    return _MarkdownSection.FIELD_DEF(this);
  }
  /** Fetch a specific field by key. */
  field(key) {
    var _a, _b;
    return (_b = (_a = _MarkdownSection.FIELD_DEF(this, key)) == null ? void 0 : _a[0]) != null ? _b : Fieldbearings.getWithDefault(this, key);
  }
  value(key) {
    var _a;
    return (_a = this.field(key)) == null ? void 0 : _a.value;
  }
  json() {
    return {
      $ordinal: this.$ordinal,
      $title: this.$title,
      $level: this.$level,
      $position: this.$position,
      $tags: this.$tags,
      $links: this.$links.map((link) => link.toObject()),
      $blocks: this.$blocks.map((block) => block.json()),
      $infields: mapObjectValues(this.$infields, jsonInlineField)
    };
  }
  /** Generate a readable ID for this section using the first 8 characters of the string and the ordinal. */
  static readableId(file, title, ordinal) {
    const first8 = title.substring(0, Math.min(title.length, 8)).replace(/[^A-Za-z0-9-_]+/gi, "-");
    return `${file}/section${ordinal}/${first8}`;
  }
};
/** All of the types that a markdown section is. */
_MarkdownSection.TYPES = ["markdown", "section", TAGGABLE_TYPE, LINKABLE_TYPE, LINKBEARING_TYPE, FIELDBEARING_TYPE];
_MarkdownSection.FIELD_DEF = Extractors.merge(
  Extractors.intrinsics(),
  Extractors.inlineFields((f4) => f4.$infields)
);
var MarkdownSection = _MarkdownSection;
var _MarkdownBlock = class _MarkdownBlock {
  constructor(init) {
    this.$types = _MarkdownBlock.TYPES;
    this.$typename = "Block";
    Object.assign(this, init);
  }
  static from(object, file, normalizer = NOOP_NORMALIZER) {
    if (object.$type === "list") {
      return MarkdownListBlock.from(object, file, normalizer);
    } else if (object.$type === "datablock") {
      return MarkdownDatablock.from(object, file, normalizer);
    } else if (object.$type === "codeblock") {
      return MarkdownCodeblock.from(object, file, normalizer);
    }
    return new _MarkdownBlock({
      $file: file,
      $id: _MarkdownBlock.readableId(file, object.$ordinal),
      $ordinal: object.$ordinal,
      $position: object.$position,
      $tags: object.$tags,
      $links: object.$links.map((l4) => normalizer(Link.fromObject(l4))),
      $infields: mapObjectValues(object.$infields, (i4) => normalizeLinks(valueInlineField(i4), normalizer)),
      $blockId: object.$blockId,
      $type: object.$type
    });
  }
  /** If this block has a block ID, the link to this block. */
  get $link() {
    if (this.$blockId) return Link.block(this.$file, this.$blockId);
    else return void 0;
  }
  /** All of the indexed fields in this object. */
  get fields() {
    return _MarkdownBlock.FIELD_DEF(this);
  }
  /** Fetch a specific field by key. */
  field(key) {
    var _a, _b;
    return (_b = (_a = _MarkdownBlock.FIELD_DEF(this, key)) == null ? void 0 : _a[0]) != null ? _b : Fieldbearings.getWithDefault(this, key);
  }
  value(key) {
    var _a;
    return (_a = this.field(key)) == null ? void 0 : _a.value;
  }
  json() {
    return {
      $ordinal: this.$ordinal,
      $position: this.$position,
      $tags: this.$tags,
      $links: this.$links.map((l4) => l4.toObject()),
      $infields: mapObjectValues(this.$infields, jsonInlineField),
      $blockId: this.$blockId,
      $type: this.$type
    };
  }
  /** Generate a readable ID for this block using the ordinal of the block. */
  static readableId(file, ordinal) {
    return `${file}/block${ordinal}`;
  }
};
_MarkdownBlock.TYPES = ["markdown", "block", LINKBEARING_TYPE, TAGGABLE_TYPE, FIELDBEARING_TYPE];
_MarkdownBlock.FIELD_DEF = Extractors.merge(
  Extractors.intrinsics(),
  Extractors.inlineFields((f4) => f4.$infields)
);
var MarkdownBlock = _MarkdownBlock;
var _MarkdownListBlock = class _MarkdownListBlock extends MarkdownBlock {
  constructor(init) {
    super(init);
    this.$types = _MarkdownListBlock.TYPES;
    this.$typename = "List Block";
  }
  /** Create a list block from a serialized value. */
  static from(object, file, normalizer = NOOP_NORMALIZER) {
    const elements = object.$elements.map((elem) => MarkdownListItem.from(elem, file, normalizer));
    return new _MarkdownListBlock({
      // TODO: This is shared with other blocks, should probably be fixed.
      $file: file,
      $id: MarkdownBlock.readableId(file, object.$ordinal),
      $ordinal: object.$ordinal,
      $position: object.$position,
      $tags: object.$tags,
      $links: object.$links.map((l4) => normalizer(Link.fromObject(l4))),
      $infields: mapObjectValues(object.$infields, (i4) => normalizeLinks(valueInlineField(i4), normalizer)),
      $blockId: object.$blockId,
      $elements: elements,
      $type: "list"
    });
  }
  json() {
    return Object.assign(super.json(), {
      $elements: this.$elements.map((elem) => elem.json())
    });
  }
};
_MarkdownListBlock.TYPES = ["markdown", "block", "block-list", TAGGABLE_TYPE, LINKBEARING_TYPE];
var MarkdownListBlock = _MarkdownListBlock;
var _MarkdownCodeblock = class _MarkdownCodeblock extends MarkdownBlock {
  constructor(init) {
    super(init);
    this.$types = _MarkdownCodeblock.TYPES;
  }
  static from(object, file, normalizer = NOOP_NORMALIZER) {
    return new _MarkdownCodeblock({
      $file: file,
      $id: _MarkdownCodeblock.readableId(file, object.$position.start),
      $position: object.$position,
      $ordinal: object.$ordinal,
      $typename: "Codeblock",
      $type: "codeblock",
      $blockId: object.$blockId,
      $languages: object.$languages,
      $links: object.$links.map((link) => normalizer(Link.fromObject(link))),
      $tags: object.$tags,
      $infields: mapObjectValues(object.$infields, valueInlineField),
      $contentPosition: object.$contentPosition,
      $style: object.$style
    });
  }
  /** All of the indexed fields in this object. */
  get fields() {
    return _MarkdownCodeblock.SUB_FIELD_DEF(this);
  }
  /** Fetch a specific field by key. */
  field(key) {
    var _a, _b;
    return (_b = (_a = _MarkdownCodeblock.SUB_FIELD_DEF(this, key)) == null ? void 0 : _a[0]) != null ? _b : Fieldbearings.getWithDefault(this, key);
  }
  value(key) {
    var _a;
    return (_a = this.field(key)) == null ? void 0 : _a.value;
  }
  json() {
    return Object.assign(super.json(), {
      $languages: this.$languages,
      $contentPosition: this.$contentPosition,
      $style: this.$style
    });
  }
  static readableId(file, line2) {
    return `${file}/codeblock${line2}`;
  }
};
_MarkdownCodeblock.TYPES = ["markdown", "block", "codeblock", TAGGABLE_TYPE, LINKBEARING_TYPE, FIELDBEARING_TYPE];
_MarkdownCodeblock.SUB_FIELD_DEF = Extractors.merge(
  MarkdownBlock.FIELD_DEF
);
var MarkdownCodeblock = _MarkdownCodeblock;
var _MarkdownDatablock = class _MarkdownDatablock extends MarkdownBlock {
  constructor(init) {
    super(init);
    this.$types = _MarkdownDatablock.TYPES;
  }
  static from(object, file, normalizer = NOOP_NORMALIZER) {
    const normdata = normalizeLinks(mapObjectValues(object.$data, valueFrontmatterEntry), normalizer);
    const links = gatherLinks(normdata);
    const tags3 = gatherTags(normdata);
    return new _MarkdownDatablock({
      $file: file,
      $id: _MarkdownDatablock.readableId(file, object.$position.start),
      $position: object.$position,
      $infields: {},
      $ordinal: object.$ordinal,
      $data: normdata,
      $links: links,
      $typename: "Datablock",
      $tags: tags3,
      $type: "datablock",
      $blockId: object.$blockId
    });
  }
  /** All of the indexed fields in this object. */
  get fields() {
    return _MarkdownDatablock.SUB_FIELD_DEF(this);
  }
  /** Fetch a specific field by key. */
  field(key) {
    var _a, _b;
    return (_b = (_a = _MarkdownDatablock.SUB_FIELD_DEF(this, key)) == null ? void 0 : _a[0]) != null ? _b : Fieldbearings.getWithDefault(this, key);
  }
  value(key) {
    var _a;
    return (_a = this.field(key)) == null ? void 0 : _a.value;
  }
  json() {
    return Object.assign(super.json(), {
      $data: mapObjectValues(this.$data, jsonFrontmatterEntry)
    });
  }
  static readableId(file, line2) {
    return `${file}/datablock${line2}`;
  }
};
_MarkdownDatablock.TYPES = ["markdown", "block", "datablock", TAGGABLE_TYPE, LINKBEARING_TYPE, FIELDBEARING_TYPE];
_MarkdownDatablock.SUB_FIELD_DEF = Extractors.merge(
  MarkdownBlock.FIELD_DEF,
  Extractors.frontmatter((f4) => f4.$data)
);
var MarkdownDatablock = _MarkdownDatablock;
var _MarkdownListItem = class _MarkdownListItem {
  constructor(init) {
    this.$types = _MarkdownListItem.TYPES;
    this.$typename = "List Item";
    Object.assign(this, init);
  }
  /** Create a list item from a serialized object. */
  static from(object, file, normalizer = NOOP_NORMALIZER) {
    if (object.$type === "task") return MarkdownTaskItem.from(object, file, normalizer);
    const elements = object.$elements.map((elem) => _MarkdownListItem.from(elem, file, normalizer));
    return new _MarkdownListItem({
      $file: file,
      $id: _MarkdownListItem.readableId(file, object.$position.start),
      $position: object.$position,
      $elements: elements,
      $type: object.$type,
      $tags: object.$tags,
      $infields: mapObjectValues(object.$infields, (i4) => normalizeLinks(valueInlineField(i4), normalizer)),
      $links: object.$links.map((l4) => normalizer(Link.fromObject(l4))),
      $blockId: object.$blockId,
      $parentLine: object.$parentLine,
      $text: object.$text,
      $symbol: object.$symbol
    });
  }
  /** Get the line that this list item starts on. */
  get $line() {
    return this.$position.start;
  }
  /** The number of lines in this list item. */
  get $lineCount() {
    return this.$position.end - this.$position.start + 1;
  }
  /** Cleaned text that is garaunteed to be non-null and has indenation and inline fields removed. */
  get $cleantext() {
    if (!this.$text) return "";
    return this.$text.replace(/(.*?)([\[\(][^:(\[]+::\s*.*?[\]\)]\s*)$/gm, "$1").trim();
  }
  /** All of the indexed fields in this object. */
  get fields() {
    return _MarkdownListItem.FIELD_DEF(this);
  }
  /** Fetch a specific field by key. */
  field(key) {
    var _a, _b;
    return (_b = (_a = _MarkdownListItem.FIELD_DEF(this, key)) == null ? void 0 : _a[0]) != null ? _b : Fieldbearings.getWithDefault(this, key);
  }
  value(key) {
    var _a;
    return (_a = this.field(key)) == null ? void 0 : _a.value;
  }
  json() {
    return {
      $position: this.$position,
      $elements: this.$elements.map((elem) => elem.json()),
      $type: this.$type,
      $tags: this.$tags,
      $infields: mapObjectValues(this.$infields, jsonInlineField),
      $links: this.$links,
      $blockId: this.$blockId,
      $parentLine: this.$parentLine,
      $symbol: this.$symbol,
      $text: this.$text
    };
  }
  /** Generate a readable ID for this item using the line number. */
  static readableId(file, line2) {
    return `${file}/list${line2}`;
  }
};
_MarkdownListItem.TYPES = ["markdown", "list-item", LINKBEARING_TYPE, TAGGABLE_TYPE, FIELDBEARING_TYPE];
_MarkdownListItem.FIELD_DEF = Extractors.merge(
  Extractors.intrinsics(),
  Extractors.inlineFields((f4) => f4.$infields)
);
var MarkdownListItem = _MarkdownListItem;
var _MarkdownTaskItem = class _MarkdownTaskItem extends MarkdownListItem {
  constructor(init) {
    super(init);
    this.$types = _MarkdownTaskItem.TYPES;
    this.$typename = "Task";
  }
  static from(object, file, normalizer) {
    const elements = object.$elements.map((elem) => MarkdownListItem.from(elem, file, normalizer));
    return new _MarkdownTaskItem({
      $file: file,
      $id: MarkdownListItem.readableId(file, object.$position.start),
      $position: object.$position,
      $elements: elements,
      $type: object.$type,
      $tags: object.$tags,
      $infields: mapObjectValues(object.$infields, (i4) => normalizeLinks(valueInlineField(i4), normalizer)),
      $links: object.$links.map((l4) => normalizer(Link.fromObject(l4))),
      $blockId: object.$blockId,
      $parentLine: object.$parentLine,
      $status: object.$status,
      $symbol: object.$symbol,
      $text: object.$text
    });
  }
  json() {
    return Object.assign(super.json(), {
      $status: this.$status
    });
  }
  /** Determine if the given task is completed. */
  get $completed() {
    return this.$status === "x" || this.$status === "X";
  }
};
_MarkdownTaskItem.TYPES = ["markdown", "list-item", "task", LINKBEARING_TYPE, TAGGABLE_TYPE, FIELDBEARING_TYPE];
var MarkdownTaskItem = _MarkdownTaskItem;
function jsonFrontmatterEntry(raw) {
  return {
    key: raw.key,
    value: JsonConversion.json(raw.value),
    raw: raw.raw
  };
}
function valueFrontmatterEntry(raw) {
  return {
    key: raw.key,
    value: JsonConversion.value(raw.value),
    raw: raw.raw
  };
}
function normalizeLinks(input2, normalizer) {
  return Literals.mapLeaves(input2, (value) => {
    if (Literals.isLink(value)) return normalizer(value);
    else return value;
  });
}
function gatherLinks(input2) {
  const result = [];
  Literals.mapLeaves(input2, (value) => {
    if (Literals.isLink(value)) result.push(value);
    return null;
  });
  return result;
}
function gatherTags(data) {
  function recurse(input2) {
    if (Literals.isString(input2)) return [input2.startsWith("#") ? input2 : "#" + input2];
    else if (Literals.isArray(input2)) return input2.flatMap(recurse);
    else return [];
  }
  let tags3 = [];
  if ("tag" in data) tags3 = tags3.concat(recurse(data["tags"]));
  if ("tags" in data) tags3 = tags3.concat(recurse(data["tags"]));
  return tags3;
}
var NOOP_NORMALIZER = (x4) => x4;

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o4) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o5) {
    return typeof o5;
  } : function(o5) {
    return o5 && "function" == typeof Symbol && o5.constructor === Symbol && o5 !== Symbol.prototype ? "symbol" : typeof o5;
  }, _typeof(o4);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t5, r4) {
  if ("object" != _typeof(t5) || !t5) return t5;
  var e3 = t5[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i4 = e3.call(t5, r4 || "default");
    if ("object" != _typeof(i4)) return i4;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r4 ? String : Number)(t5);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t5) {
  var i4 = toPrimitive(t5, "string");
  return "symbol" == _typeof(i4) ? i4 : i4 + "";
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e3, r4, t5) {
  return (r4 = toPropertyKey(r4)) in e3 ? Object.defineProperty(e3, r4, {
    value: t5,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e3[r4] = t5, e3;
}

// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys(e3, r4) {
  var t5 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e3);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e3, r5).enumerable;
    })), t5.push.apply(t5, o4);
  }
  return t5;
}
function _objectSpread2(e3) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t5 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys(Object(t5), true).forEach(function(r5) {
      _defineProperty(e3, r5, t5[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t5)) : ownKeys(Object(t5)).forEach(function(r5) {
      Object.defineProperty(e3, r5, Object.getOwnPropertyDescriptor(t5, r5));
    });
  }
  return e3;
}

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(r4) {
  if (Array.isArray(r4)) return r4;
}

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r4, l4) {
  var t5 = null == r4 ? null : "undefined" != typeof Symbol && r4[Symbol.iterator] || r4["@@iterator"];
  if (null != t5) {
    var e3, n3, i4, u4, a4 = [], f4 = true, o4 = false;
    try {
      if (i4 = (t5 = t5.call(r4)).next, 0 === l4) {
        if (Object(t5) !== t5) return;
        f4 = false;
      } else for (; !(f4 = (e3 = i4.call(t5)).done) && (a4.push(e3.value), a4.length !== l4); f4 = true) ;
    } catch (r5) {
      o4 = true, n3 = r5;
    } finally {
      try {
        if (!f4 && null != t5["return"] && (u4 = t5["return"](), Object(u4) !== u4)) return;
      } finally {
        if (o4) throw n3;
      }
    }
    return a4;
  }
}

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(r4, a4) {
  (null == a4 || a4 > r4.length) && (a4 = r4.length);
  for (var e3 = 0, n3 = Array(a4); e3 < a4; e3++) n3[e3] = r4[e3];
  return n3;
}

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(r4, a4) {
  if (r4) {
    if ("string" == typeof r4) return _arrayLikeToArray(r4, a4);
    var t5 = {}.toString.call(r4).slice(8, -1);
    return "Object" === t5 && r4.constructor && (t5 = r4.constructor.name), "Map" === t5 || "Set" === t5 ? Array.from(r4) : "Arguments" === t5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t5) ? _arrayLikeToArray(r4, a4) : void 0;
  }
}

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(r4, e3) {
  return _arrayWithHoles(r4) || _iterableToArrayLimit(r4, e3) || _unsupportedIterableToArray(r4, e3) || _nonIterableRest();
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r4, e3) {
  if (null == r4) return {};
  var t5 = {};
  for (var n3 in r4) if ({}.hasOwnProperty.call(r4, n3)) {
    if (e3.includes(n3)) continue;
    t5[n3] = r4[n3];
  }
  return t5;
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(e3, t5) {
  if (null == e3) return {};
  var o4, r4, i4 = _objectWithoutPropertiesLoose(e3, t5);
  if (Object.getOwnPropertySymbols) {
    var s4 = Object.getOwnPropertySymbols(e3);
    for (r4 = 0; r4 < s4.length; r4++) o4 = s4[r4], t5.includes(o4) || {}.propertyIsEnumerable.call(e3, o4) && (i4[o4] = e3[o4]);
  }
  return i4;
}

// node_modules/react-select/dist/useStateManager-7e1e8489.esm.js
var _excluded = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function useStateManager(_ref3) {
  var _ref$defaultInputValu = _ref3.defaultInputValue, defaultInputValue = _ref$defaultInputValu === void 0 ? "" : _ref$defaultInputValu, _ref$defaultMenuIsOpe = _ref3.defaultMenuIsOpen, defaultMenuIsOpen = _ref$defaultMenuIsOpe === void 0 ? false : _ref$defaultMenuIsOpe, _ref$defaultValue = _ref3.defaultValue, defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue, propsInputValue = _ref3.inputValue, propsMenuIsOpen = _ref3.menuIsOpen, propsOnChange = _ref3.onChange, propsOnInputChange = _ref3.onInputChange, propsOnMenuClose = _ref3.onMenuClose, propsOnMenuOpen = _ref3.onMenuOpen, propsValue = _ref3.value, restSelectProps = _objectWithoutProperties(_ref3, _excluded);
  var _useState = h2(propsInputValue !== void 0 ? propsInputValue : defaultInputValue), _useState2 = _slicedToArray(_useState, 2), stateInputValue = _useState2[0], setStateInputValue = _useState2[1];
  var _useState3 = h2(propsMenuIsOpen !== void 0 ? propsMenuIsOpen : defaultMenuIsOpen), _useState4 = _slicedToArray(_useState3, 2), stateMenuIsOpen = _useState4[0], setStateMenuIsOpen = _useState4[1];
  var _useState5 = h2(propsValue !== void 0 ? propsValue : defaultValue), _useState6 = _slicedToArray(_useState5, 2), stateValue = _useState6[0], setStateValue = _useState6[1];
  var onChange3 = q2(function(value2, actionMeta) {
    if (typeof propsOnChange === "function") {
      propsOnChange(value2, actionMeta);
    }
    setStateValue(value2);
  }, [propsOnChange]);
  var onInputChange = q2(function(value2, actionMeta) {
    var newValue;
    if (typeof propsOnInputChange === "function") {
      newValue = propsOnInputChange(value2, actionMeta);
    }
    setStateInputValue(newValue !== void 0 ? newValue : value2);
  }, [propsOnInputChange]);
  var onMenuOpen = q2(function() {
    if (typeof propsOnMenuOpen === "function") {
      propsOnMenuOpen();
    }
    setStateMenuIsOpen(true);
  }, [propsOnMenuOpen]);
  var onMenuClose = q2(function() {
    if (typeof propsOnMenuClose === "function") {
      propsOnMenuClose();
    }
    setStateMenuIsOpen(false);
  }, [propsOnMenuClose]);
  var inputValue = propsInputValue !== void 0 ? propsInputValue : stateInputValue;
  var menuIsOpen = propsMenuIsOpen !== void 0 ? propsMenuIsOpen : stateMenuIsOpen;
  var value = propsValue !== void 0 ? propsValue : stateValue;
  return _objectSpread2(_objectSpread2({}, restSelectProps), {}, {
    inputValue,
    menuIsOpen,
    onChange: onChange3,
    onInputChange,
    onMenuClose,
    onMenuOpen,
    value
  });
}

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n3) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t5 = arguments[e3];
      for (var r4 in t5) ({}).hasOwnProperty.call(t5, r4) && (n3[r4] = t5[r4]);
    }
    return n3;
  }, _extends.apply(null, arguments);
}

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(a4, n3) {
  if (!(a4 instanceof n3)) throw new TypeError("Cannot call a class as a function");
}

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(e3, r4) {
  for (var t5 = 0; t5 < r4.length; t5++) {
    var o4 = r4[t5];
    o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(e3, toPropertyKey(o4.key), o4);
  }
}
function _createClass(e3, r4, t5) {
  return r4 && _defineProperties(e3.prototype, r4), t5 && _defineProperties(e3, t5), Object.defineProperty(e3, "prototype", {
    writable: false
  }), e3;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t5, e3) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t6, e4) {
    return t6.__proto__ = e4, t6;
  }, _setPrototypeOf(t5, e3);
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(t5, e3) {
  if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function");
  t5.prototype = Object.create(e3 && e3.prototype, {
    constructor: {
      value: t5,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t5, "prototype", {
    writable: false
  }), e3 && _setPrototypeOf(t5, e3);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t5) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t6) {
    return t6.__proto__ || Object.getPrototypeOf(t6);
  }, _getPrototypeOf(t5);
}

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    var t5 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t6) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t5;
  })();
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e3) {
  if (void 0 === e3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e3;
}

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(t5, e3) {
  if (e3 && ("object" == _typeof(e3) || "function" == typeof e3)) return e3;
  if (void 0 !== e3) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t5);
}

// node_modules/@babel/runtime/helpers/esm/createSuper.js
function _createSuper(t5) {
  var r4 = _isNativeReflectConstruct();
  return function() {
    var e3, o4 = _getPrototypeOf(t5);
    if (r4) {
      var s4 = _getPrototypeOf(this).constructor;
      e3 = Reflect.construct(o4, arguments, s4);
    } else e3 = o4.apply(this, arguments);
    return _possibleConstructorReturn(this, e3);
  };
}

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(r4) {
  if (Array.isArray(r4)) return _arrayLikeToArray(r4);
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(r4) {
  if ("undefined" != typeof Symbol && null != r4[Symbol.iterator] || null != r4["@@iterator"]) return Array.from(r4);
}

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(r4) {
  return _arrayWithoutHoles(r4) || _iterableToArray(r4) || _unsupportedIterableToArray(r4) || _nonIterableSpread();
}

// node_modules/@emotion/sheet/dist/emotion-sheet.esm.js
var isDevelopment = false;
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i4 = 0; i4 < document.styleSheets.length; i4++) {
    if (document.styleSheets[i4].ownerNode === tag) {
      return document.styleSheets[i4];
    }
  }
  return void 0;
}
function createStyleElement(options2) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options2.key);
  if (options2.nonce !== void 0) {
    tag.setAttribute("nonce", options2.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options2) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options2.speedy === void 0 ? !isDevelopment : options2.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options2.nonce;
    this.key = options2.key;
    this.container = options2.container;
    this.prepend = options2.prepend;
    this.insertionPoint = options2.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e3) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();

// node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match3(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin2, end2) {
  return value.slice(begin2, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array2) {
  return array2.push(value), value;
}
function combine(array2, callback) {
  return array2.map(callback).join("");
}

// node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length2) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next2() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin2, end2) {
  return substr(characters, begin2, end2);
}
function token(type) {
  switch (type) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace2(type) {
  while (character = peek())
    if (character < 33)
      next2();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next2())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next2() == 32));
}
function delimiter(type) {
  while (next2())
    switch (character) {
      // ] ) " '
      case type:
        return position;
      // " '
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      // (
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      // \
      case 92:
        next2();
        break;
    }
  return position;
}
function commenter(type, index2) {
  while (next2())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type === 47 ? type : next2());
}
function identifier(index2) {
  while (!token(peek()))
    next2();
  return slice(index2, position);
}

// node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse3("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse3(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset3 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next2()) {
      // (
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace2(previous);
        break;
      // \
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      // /
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next2(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      // {
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      // } ; \0
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          // \0 }
          case 0:
          case 125:
            scanning = 0;
          // ;
          case 59 + offset3:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          // @ ;
          case 59:
            characters2 += ";";
          // { rule/at-rule
          default:
            append(reference = ruleset(characters2, root, parent, index2, offset3, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset3 === 0)
                parse3(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse3(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse3(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset3 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      // :
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          // &
          case 38:
            ampersand = offset3 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          // ,
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          // @
          case 64:
            if (peek() === 45)
              characters2 += delimit(next2());
            atrule = peek(), offset3 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          // -
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index2, offset3, rules, points, type, props, children, length2) {
  var post = offset3 - 1;
  var rule = offset3 === 0 ? rules : [""];
  var size2 = sizeof(rule);
  for (var i4 = 0, j4 = 0, k4 = 0; i4 < index2; ++i4)
    for (var x4 = 0, y4 = substr(value, post + 1, post = abs(j4 = points[i4])), z4 = value; x4 < size2; ++x4)
      if (z4 = trim(j4 > 0 ? rule[x4] + " " + y4 : replace(y4, /&\f/g, rule[x4])))
        props[k4++] = z4;
  return node(value, root, parent, offset3 === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i4 = 0; i4 < length2; i4++)
    output += callback(children[i4], i4, children, callback) || "";
  return output;
}
function stringify(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i4 = 0; i4 < length2; i4++)
      output += collection[i4](element, index2, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}

// node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn2) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache2[arg] === void 0) cache2[arg] = fn2(arg);
    return cache2[arg];
  };
}

// node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js
var identifierWithPointTracking = function identifierWithPointTracking2(begin2, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next2();
  }
  return slice(begin2, position);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      // fallthrough
      default:
        parsed[index2] += from(character2);
    }
  } while (character2 = next2());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i4 = 0, k4 = 0; i4 < rules.length; i4++) {
    for (var j4 = 0; j4 < parentRules.length; j4++, k4++) {
      element.props[k4] = points[i4] ? rules[i4].replace(/&\f/g, parentRules[j4]) : parentRules[j4] + " " + rules[i4];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash(value, length2)) {
    // color-adjust
    case 5103:
      return WEBKIT + "print-" + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    // flex, flex-direction
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    // order
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    // align-items
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    // align-self
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    // align-content
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    // flex-shrink
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    // flex-basis
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    // flex-grow
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    // transition
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    // cursor
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    // background, background-image
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    // justify-content
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        // (s)tretch
        case 115:
          return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    // position: sticky
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        // stic(k)y
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        // (inline-)?fl(e)x
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    // writing-mode
    case 5936:
      switch (charat(value, length2 + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        // vertical-r(l)
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        // horizontal(-)tb
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine(element.props, function(value) {
          switch (match3(value, /(::plac\w+|:read-\w+)/)) {
            // :read-(only|write)
            case ":read-only":
            case ":read-write":
              return serialize([copy(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            // :placeholder
            case "::placeholder":
              return serialize([copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options2) {
  var key = options2.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options2.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options2.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i4 = 1; i4 < attrib.length; i4++) {
          inserted[attrib[i4]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache2.inserted[serialized.name] = true;
      }
    };
  }
  var cache2 = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options2.nonce,
      speedy: options2.speedy,
      prepend: options2.prepend,
      insertionPoint: options2.insertionPoint
    }),
    nonce: options2.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache2.sheet.hydrate(nodesToHydrate);
  return cache2;
};

// node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
  var className = cache2.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache2.registered[className] === void 0
  ) {
    cache2.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
  registerStyles(cache2, serialized, isStringTag);
  var className = cache2.key + "-" + serialized.name;
  if (cache2.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};

// node_modules/@emotion/hash/dist/emotion-hash.esm.js
function murmur2(str) {
  var h3 = 0;
  var k4, i4 = 0, len = str.length;
  for (; len >= 4; ++i4, len -= 4) {
    k4 = str.charCodeAt(i4) & 255 | (str.charCodeAt(++i4) & 255) << 8 | (str.charCodeAt(++i4) & 255) << 16 | (str.charCodeAt(++i4) & 255) << 24;
    k4 = /* Math.imul(k, m): */
    (k4 & 65535) * 1540483477 + ((k4 >>> 16) * 59797 << 16);
    k4 ^= /* k >>> r: */
    k4 >>> 24;
    h3 = /* Math.imul(k, m): */
    (k4 & 65535) * 1540483477 + ((k4 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h3 ^= (str.charCodeAt(i4 + 2) & 255) << 16;
    case 2:
      h3 ^= (str.charCodeAt(i4 + 1) & 255) << 8;
    case 1:
      h3 ^= str.charCodeAt(i4) & 255;
      h3 = /* Math.imul(h, m): */
      (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
  }
  h3 ^= h3 >>> 13;
  h3 = /* Math.imul(h, m): */
  (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
  return ((h3 ^ h3 >>> 15) >>> 0).toString(36);
}

// node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// node_modules/@emotion/serialize/dist/emotion-serialize.esm.js
var isDevelopment2 = false;
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match4, p1, p22) {
          cursor = {
            name: p1,
            styles: p22,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes3 = interpolation;
      if (keyframes3.anim === 1) {
        cursor = {
          name: keyframes3.name,
          styles: keyframes3.styles,
          next: cursor
        };
        return keyframes3.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next3 = serializedStyles.next;
        if (next3 !== void 0) {
          while (next3 !== void 0) {
            cursor = {
              name: next3.name,
              styles: next3.styles,
              next: cursor
            };
            next3 = next3.next;
          }
        }
        var styles2 = serializedStyles.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string2 = "";
  if (Array.isArray(obj)) {
    for (var i4 = 0; i4 < obj.length; i4++) {
      string2 += handleInterpolation(mergedProps, registered, obj[i4]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string2 += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string2 += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (key === "NO_COMPONENT_SELECTOR" && isDevelopment2) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string2 += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key) {
            case "animation":
            case "animationName": {
              string2 += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string2 += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string2;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    styles2 += asTemplateStringsArr[0];
  }
  for (var i4 = 1; i4 < args.length; i4++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i4]);
    if (stringMode) {
      var templateStringsArr = strings;
      styles2 += templateStringsArr[i4];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match4;
  while ((match4 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + match4[1];
  }
  var name = murmur2(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor
  };
}

// node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect = Sn ? Sn : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;

// node_modules/@emotion/react/dist/emotion-element-5486c51c.browser.esm.js
var isDevelopment3 = false;
var EmotionCacheContext = /* @__PURE__ */ G(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ w3(function(props, ref) {
    var cache2 = x2(EmotionCacheContext);
    return func(props, cache2, ref);
  });
};
var ThemeContext = /* @__PURE__ */ G({});
var hasOwn = {}.hasOwnProperty;
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
  var newProps = {};
  for (var key in props) {
    if (hasOwn.call(props, key)) {
      newProps[key] = props[key];
    }
  }
  newProps[typePropName] = type;
  return newProps;
};
var Insertion = function Insertion2(_ref3) {
  var cache2 = _ref3.cache, serialized = _ref3.serialized, isStringTag = _ref3.isStringTag;
  registerStyles(cache2, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(
  /* <any, any> */
  function(props, cache2, ref) {
    var cssProp = props.css;
    if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
      cssProp = cache2.registered[cssProp];
    }
    var WrappedComponent = props[typePropName];
    var registeredStyles = [cssProp];
    var className = "";
    if (typeof props.className === "string") {
      className = getRegisteredStyles(cache2.registered, registeredStyles, props.className);
    } else if (props.className != null) {
      className = props.className + " ";
    }
    var serialized = serializeStyles(registeredStyles, void 0, x2(ThemeContext));
    className += cache2.key + "-" + serialized.name;
    var newProps = {};
    for (var key in props) {
      if (hasOwn.call(props, key) && key !== "css" && key !== typePropName && !isDevelopment3) {
        newProps[key] = props[key];
      }
    }
    newProps.className = className;
    if (ref) {
      newProps.ref = ref;
    }
    return /* @__PURE__ */ _(b, null, /* @__PURE__ */ _(Insertion, {
      cache: cache2,
      serialized,
      isStringTag: typeof WrappedComponent === "string"
    }), /* @__PURE__ */ _(WrappedComponent, newProps));
  }
);
var Emotion$1 = Emotion;

// node_modules/@emotion/react/dist/emotion-react.browser.esm.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
var jsx = function jsx2(type, props) {
  var args = arguments;
  if (props == null || !hasOwn.call(props, "css")) {
    return _.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type, props);
  for (var i4 = 2; i4 < argsLength; i4++) {
    createElementArgArray[i4] = args[i4];
  }
  return _.apply(null, createElementArgArray);
};
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};

// node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js
function _taggedTemplateLiteral(e3, t5) {
  return t5 || (t5 = e3.slice(0)), Object.freeze(Object.defineProperties(e3, {
    raw: {
      value: Object.freeze(t5)
    }
  }));
}

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v3) => ({
  x: v3,
  y: v3
});
function rectToClientRect(rect) {
  const {
    x: x4,
    y: y4,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y4,
    left: x4,
    right: x4 + width,
    bottom: y4 + height,
    x: x4,
    y: y4
  };
}

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node2) {
  if (isNode(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref3;
  return (_ref3 = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref3.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  if (isLastTraversableNode(parentNode)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css6 = getComputedStyle2(element);
  let width = parseFloat(css6.width) || 0;
  let height = parseFloat(css6.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $3
  } = getCssDimensions(domElement);
  let x4 = ($3 ? round(rect.width) : rect.width) / width;
  let y4 = ($3 ? round(rect.height) : rect.height) / height;
  if (!x4 || !Number.isFinite(x4)) {
    x4 = 1;
  }
  if (!y4 || !Number.isFinite(y4)) {
    y4 = 1;
  }
  return {
    x: x4,
    y: y4
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x4 = (clientRect.left + visualOffsets.x) / scale.x;
  let y4 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css6 = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css6.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css6.paddingTop)) * iframeScale.y;
      x4 *= iframeScale.x;
      y4 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x4 += left;
      y4 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x4,
    y: y4
  });
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options2 = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options2,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e3) {
      io = new IntersectionObserver(handleObserve, options2);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options2;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref3) => {
      let [firstEntry] = _ref3;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

// node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js
var index = _2;
var use_isomorphic_layout_effect_browser_esm_default = index;

// node_modules/react-select/dist/index-a301f526.esm.js
var _excluded$4 = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"];
var noop = function noop2() {
};
function applyPrefixToName(prefix2, name) {
  if (!name) {
    return prefix2;
  } else if (name[0] === "-") {
    return prefix2 + name;
  } else {
    return prefix2 + "__" + name;
  }
}
function classNames(prefix2, state2) {
  for (var _len = arguments.length, classNameList = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    classNameList[_key - 2] = arguments[_key];
  }
  var arr = [].concat(classNameList);
  if (state2 && prefix2) {
    for (var key in state2) {
      if (state2.hasOwnProperty(key) && state2[key]) {
        arr.push("".concat(applyPrefixToName(prefix2, key)));
      }
    }
  }
  return arr.filter(function(i4) {
    return i4;
  }).map(function(i4) {
    return String(i4).trim();
  }).join(" ");
}
var cleanValue = function cleanValue2(value) {
  if (isArray(value)) return value.filter(Boolean);
  if (_typeof(value) === "object" && value !== null) return [value];
  return [];
};
var cleanCommonProps = function cleanCommonProps2(props) {
  props.className;
  props.clearValue;
  props.cx;
  props.getStyles;
  props.getClassNames;
  props.getValue;
  props.hasValue;
  props.isMulti;
  props.isRtl;
  props.options;
  props.selectOption;
  props.selectProps;
  props.setValue;
  props.theme;
  var innerProps = _objectWithoutProperties(props, _excluded$4);
  return _objectSpread2({}, innerProps);
};
var getStyleProps = function getStyleProps2(props, name, classNamesState) {
  var cx = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, className = props.className;
  return {
    css: getStyles(name, props),
    className: cx(classNamesState !== null && classNamesState !== void 0 ? classNamesState : {}, getClassNames(name, props), className)
  };
};
function isDocumentElement(el) {
  return [document.documentElement, document.body, window].indexOf(el) > -1;
}
function normalizedHeight(el) {
  if (isDocumentElement(el)) {
    return window.innerHeight;
  }
  return el.clientHeight;
}
function getScrollTop(el) {
  if (isDocumentElement(el)) {
    return window.pageYOffset;
  }
  return el.scrollTop;
}
function scrollTo(el, top) {
  if (isDocumentElement(el)) {
    window.scrollTo(0, top);
    return;
  }
  el.scrollTop = top;
}
function getScrollParent(element) {
  var style = getComputedStyle(element);
  var excludeStaticParent = style.position === "absolute";
  var overflowRx = /(auto|scroll)/;
  if (style.position === "fixed") return document.documentElement;
  for (var parent = element; parent = parent.parentElement; ) {
    style = getComputedStyle(parent);
    if (excludeStaticParent && style.position === "static") {
      continue;
    }
    if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
      return parent;
    }
  }
  return document.documentElement;
}
function easeOutCubic(t5, b3, c4, d3) {
  return c4 * ((t5 = t5 / d3 - 1) * t5 * t5 + 1) + b3;
}
function animatedScrollTo(element, to) {
  var duration = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200;
  var callback = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : noop;
  var start = getScrollTop(element);
  var change = to - start;
  var increment = 10;
  var currentTime = 0;
  function animateScroll() {
    currentTime += increment;
    var val = easeOutCubic(currentTime, start, change, duration);
    scrollTo(element, val);
    if (currentTime < duration) {
      window.requestAnimationFrame(animateScroll);
    } else {
      callback(element);
    }
  }
  animateScroll();
}
function scrollIntoView(menuEl, focusedEl) {
  var menuRect = menuEl.getBoundingClientRect();
  var focusedRect = focusedEl.getBoundingClientRect();
  var overScroll = focusedEl.offsetHeight / 3;
  if (focusedRect.bottom + overScroll > menuRect.bottom) {
    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
  } else if (focusedRect.top - overScroll < menuRect.top) {
    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
  }
}
function getBoundingClientObj(element) {
  var rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
}
function isTouchCapable() {
  try {
    document.createEvent("TouchEvent");
    return true;
  } catch (e3) {
    return false;
  }
}
function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch (e3) {
    return false;
  }
}
var passiveOptionAccessed = false;
var options = {
  get passive() {
    return passiveOptionAccessed = true;
  }
};
var w4 = typeof window !== "undefined" ? window : {};
if (w4.addEventListener && w4.removeEventListener) {
  w4.addEventListener("p", noop, options);
  w4.removeEventListener("p", noop, false);
}
var supportsPassiveEvents = passiveOptionAccessed;
function notNullish(item) {
  return item != null;
}
function isArray(arg) {
  return Array.isArray(arg);
}
function valueTernary(isMulti, multiValue, singleValue) {
  return isMulti ? multiValue : singleValue;
}
function singleValueAsValue(singleValue) {
  return singleValue;
}
function multiValueAsValue(multiValue) {
  return multiValue;
}
var removeProps = function removeProps2(propsObj) {
  for (var _len2 = arguments.length, properties = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    properties[_key2 - 1] = arguments[_key2];
  }
  var propsMap = Object.entries(propsObj).filter(function(_ref3) {
    var _ref23 = _slicedToArray(_ref3, 1), key = _ref23[0];
    return !properties.includes(key);
  });
  return propsMap.reduce(function(newProps, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], val = _ref4[1];
    newProps[key] = val;
    return newProps;
  }, {});
};
var _excluded$3 = ["children", "innerProps"];
var _excluded2$1 = ["children", "innerProps"];
function getMenuPlacement(_ref3) {
  var preferredMaxHeight = _ref3.maxHeight, menuEl = _ref3.menuEl, minHeight = _ref3.minHeight, preferredPlacement = _ref3.placement, shouldScroll = _ref3.shouldScroll, isFixedPosition = _ref3.isFixedPosition, controlHeight2 = _ref3.controlHeight;
  var scrollParent = getScrollParent(menuEl);
  var defaultState = {
    placement: "bottom",
    maxHeight: preferredMaxHeight
  };
  if (!menuEl || !menuEl.offsetParent) return defaultState;
  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(), scrollHeight = _scrollParent$getBoun.height;
  var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(), menuBottom = _menuEl$getBoundingCl.bottom, menuHeight = _menuEl$getBoundingCl.height, menuTop = _menuEl$getBoundingCl.top;
  var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(), containerTop = _menuEl$offsetParent$.top;
  var viewHeight = isFixedPosition ? window.innerHeight : normalizedHeight(scrollParent);
  var scrollTop = getScrollTop(scrollParent);
  var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
  var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
  var viewSpaceAbove = containerTop - marginTop;
  var viewSpaceBelow = viewHeight - menuTop;
  var scrollSpaceAbove = viewSpaceAbove + scrollTop;
  var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
  var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
  var scrollUp = scrollTop + menuTop - marginTop;
  var scrollDuration = 160;
  switch (preferredPlacement) {
    case "auto":
    case "bottom":
      if (viewSpaceBelow >= menuHeight) {
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
        return {
          placement: "bottom",
          maxHeight: constrainedHeight
        };
      }
      if (preferredPlacement === "auto" || isFixedPosition) {
        var _constrainedHeight = preferredMaxHeight;
        var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
        if (spaceAbove >= minHeight) {
          _constrainedHeight = Math.min(spaceAbove - marginBottom - controlHeight2, preferredMaxHeight);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight
        };
      }
      if (preferredPlacement === "bottom") {
        if (shouldScroll) {
          scrollTo(scrollParent, scrollDown);
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      break;
    case "top":
      if (viewSpaceAbove >= menuHeight) {
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      }
      if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
        var _constrainedHeight2 = preferredMaxHeight;
        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
          _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
        }
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight2
        };
      }
      return {
        placement: "bottom",
        maxHeight: preferredMaxHeight
      };
    default:
      throw new Error('Invalid placement provided "'.concat(preferredPlacement, '".'));
  }
  return defaultState;
}
function alignToControl(placement) {
  var placementToCSSProp = {
    bottom: "top",
    top: "bottom"
  };
  return placement ? placementToCSSProp[placement] : "bottom";
}
var coercePlacement = function coercePlacement2(p3) {
  return p3 === "auto" ? "bottom" : p3;
};
var menuCSS = function menuCSS2(_ref23, unstyled) {
  var _objectSpread23;
  var placement = _ref23.placement, _ref2$theme = _ref23.theme, borderRadius2 = _ref2$theme.borderRadius, spacing2 = _ref2$theme.spacing, colors2 = _ref2$theme.colors;
  return _objectSpread2((_objectSpread23 = {
    label: "menu"
  }, _defineProperty(_objectSpread23, alignToControl(placement), "100%"), _defineProperty(_objectSpread23, "position", "absolute"), _defineProperty(_objectSpread23, "width", "100%"), _defineProperty(_objectSpread23, "zIndex", 1), _objectSpread23), unstyled ? {} : {
    backgroundColor: colors2.neutral0,
    borderRadius: borderRadius2,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: spacing2.menuGutter,
    marginTop: spacing2.menuGutter
  });
};
var PortalPlacementContext = /* @__PURE__ */ G(null);
var MenuPlacer = function MenuPlacer2(props) {
  var children = props.children, minMenuHeight = props.minMenuHeight, maxMenuHeight = props.maxMenuHeight, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition, menuShouldScrollIntoView = props.menuShouldScrollIntoView, theme = props.theme;
  var _ref3 = x2(PortalPlacementContext) || {}, setPortalPlacement = _ref3.setPortalPlacement;
  var ref = A2(null);
  var _useState = h2(maxMenuHeight), _useState2 = _slicedToArray(_useState, 2), maxHeight = _useState2[0], setMaxHeight = _useState2[1];
  var _useState3 = h2(null), _useState4 = _slicedToArray(_useState3, 2), placement = _useState4[0], setPlacement = _useState4[1];
  var controlHeight2 = theme.spacing.controlHeight;
  use_isomorphic_layout_effect_browser_esm_default(function() {
    var menuEl = ref.current;
    if (!menuEl) return;
    var isFixedPosition = menuPosition === "fixed";
    var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
    var state2 = getMenuPlacement({
      maxHeight: maxMenuHeight,
      menuEl,
      minHeight: minMenuHeight,
      placement: menuPlacement,
      shouldScroll,
      isFixedPosition,
      controlHeight: controlHeight2
    });
    setMaxHeight(state2.maxHeight);
    setPlacement(state2.placement);
    setPortalPlacement === null || setPortalPlacement === void 0 ? void 0 : setPortalPlacement(state2.placement);
  }, [maxMenuHeight, menuPlacement, menuPosition, menuShouldScrollIntoView, minMenuHeight, setPortalPlacement, controlHeight2]);
  return children({
    ref,
    placerProps: _objectSpread2(_objectSpread2({}, props), {}, {
      placement: placement || coercePlacement(menuPlacement),
      maxHeight
    })
  });
};
var Menu = function Menu2(props) {
  var children = props.children, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "menu", {
    menu: true
  }), {
    ref: innerRef
  }, innerProps), children);
};
var Menu$1 = Menu;
var menuListCSS = function menuListCSS2(_ref4, unstyled) {
  var maxHeight = _ref4.maxHeight, baseUnit2 = _ref4.theme.spacing.baseUnit;
  return _objectSpread2({
    maxHeight,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, unstyled ? {} : {
    paddingBottom: baseUnit2,
    paddingTop: baseUnit2
  });
};
var MenuList = function MenuList2(props) {
  var children = props.children, innerProps = props.innerProps, innerRef = props.innerRef, isMulti = props.isMulti;
  return jsx("div", _extends({}, getStyleProps(props, "menuList", {
    "menu-list": true,
    "menu-list--is-multi": isMulti
  }), {
    ref: innerRef
  }, innerProps), children);
};
var noticeCSS = function noticeCSS2(_ref5, unstyled) {
  var _ref5$theme = _ref5.theme, baseUnit2 = _ref5$theme.spacing.baseUnit, colors2 = _ref5$theme.colors;
  return _objectSpread2({
    textAlign: "center"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    padding: "".concat(baseUnit2 * 2, "px ").concat(baseUnit2 * 3, "px")
  });
};
var noOptionsMessageCSS = noticeCSS;
var loadingMessageCSS = noticeCSS;
var NoOptionsMessage = function NoOptionsMessage2(_ref6) {
  var _ref6$children = _ref6.children, children = _ref6$children === void 0 ? "No options" : _ref6$children, innerProps = _ref6.innerProps, restProps = _objectWithoutProperties(_ref6, _excluded$3);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    children,
    innerProps
  }), "noOptionsMessage", {
    "menu-notice": true,
    "menu-notice--no-options": true
  }), innerProps), children);
};
var LoadingMessage = function LoadingMessage2(_ref7) {
  var _ref7$children = _ref7.children, children = _ref7$children === void 0 ? "Loading..." : _ref7$children, innerProps = _ref7.innerProps, restProps = _objectWithoutProperties(_ref7, _excluded2$1);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    children,
    innerProps
  }), "loadingMessage", {
    "menu-notice": true,
    "menu-notice--loading": true
  }), innerProps), children);
};
var menuPortalCSS = function menuPortalCSS2(_ref8) {
  var rect = _ref8.rect, offset3 = _ref8.offset, position2 = _ref8.position;
  return {
    left: rect.left,
    position: position2,
    top: offset3,
    width: rect.width,
    zIndex: 1
  };
};
var MenuPortal = function MenuPortal2(props) {
  var appendTo = props.appendTo, children = props.children, controlElement = props.controlElement, innerProps = props.innerProps, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition;
  var menuPortalRef = A2(null);
  var cleanupRef = A2(null);
  var _useState5 = h2(coercePlacement(menuPlacement)), _useState6 = _slicedToArray(_useState5, 2), placement = _useState6[0], setPortalPlacement = _useState6[1];
  var portalPlacementContext = T2(function() {
    return {
      setPortalPlacement
    };
  }, []);
  var _useState7 = h2(null), _useState8 = _slicedToArray(_useState7, 2), computedPosition = _useState8[0], setComputedPosition = _useState8[1];
  var updateComputedPosition = q2(function() {
    if (!controlElement) return;
    var rect = getBoundingClientObj(controlElement);
    var scrollDistance = menuPosition === "fixed" ? 0 : window.pageYOffset;
    var offset3 = rect[placement] + scrollDistance;
    if (offset3 !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset) || rect.left !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left) || rect.width !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width)) {
      setComputedPosition({
        offset: offset3,
        rect
      });
    }
  }, [controlElement, menuPosition, placement, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width]);
  use_isomorphic_layout_effect_browser_esm_default(function() {
    updateComputedPosition();
  }, [updateComputedPosition]);
  var runAutoUpdate = q2(function() {
    if (typeof cleanupRef.current === "function") {
      cleanupRef.current();
      cleanupRef.current = null;
    }
    if (controlElement && menuPortalRef.current) {
      cleanupRef.current = autoUpdate(controlElement, menuPortalRef.current, updateComputedPosition, {
        elementResize: "ResizeObserver" in window
      });
    }
  }, [controlElement, updateComputedPosition]);
  use_isomorphic_layout_effect_browser_esm_default(function() {
    runAutoUpdate();
  }, [runAutoUpdate]);
  var setMenuPortalElement = q2(function(menuPortalElement) {
    menuPortalRef.current = menuPortalElement;
    runAutoUpdate();
  }, [runAutoUpdate]);
  if (!appendTo && menuPosition !== "fixed" || !computedPosition) return null;
  var menuWrapper = jsx("div", _extends({
    ref: setMenuPortalElement
  }, getStyleProps(_objectSpread2(_objectSpread2({}, props), {}, {
    offset: computedPosition.offset,
    position: menuPosition,
    rect: computedPosition.rect
  }), "menuPortal", {
    "menu-portal": true
  }), innerProps), children);
  return jsx(PortalPlacementContext.Provider, {
    value: portalPlacementContext
  }, appendTo ? /* @__PURE__ */ P5(menuWrapper, appendTo) : menuWrapper);
};
var containerCSS = function containerCSS2(_ref3) {
  var isDisabled = _ref3.isDisabled, isRtl = _ref3.isRtl;
  return {
    label: "container",
    direction: isRtl ? "rtl" : void 0,
    pointerEvents: isDisabled ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
};
var SelectContainer = function SelectContainer2(props) {
  var children = props.children, innerProps = props.innerProps, isDisabled = props.isDisabled, isRtl = props.isRtl;
  return jsx("div", _extends({}, getStyleProps(props, "container", {
    "--is-disabled": isDisabled,
    "--is-rtl": isRtl
  }), innerProps), children);
};
var valueContainerCSS = function valueContainerCSS2(_ref23, unstyled) {
  var spacing2 = _ref23.theme.spacing, isMulti = _ref23.isMulti, hasValue = _ref23.hasValue, controlShouldRenderValue = _ref23.selectProps.controlShouldRenderValue;
  return _objectSpread2({
    alignItems: "center",
    display: isMulti && hasValue && controlShouldRenderValue ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, unstyled ? {} : {
    padding: "".concat(spacing2.baseUnit / 2, "px ").concat(spacing2.baseUnit * 2, "px")
  });
};
var ValueContainer = function ValueContainer2(props) {
  var children = props.children, innerProps = props.innerProps, isMulti = props.isMulti, hasValue = props.hasValue;
  return jsx("div", _extends({}, getStyleProps(props, "valueContainer", {
    "value-container": true,
    "value-container--is-multi": isMulti,
    "value-container--has-value": hasValue
  }), innerProps), children);
};
var indicatorsContainerCSS = function indicatorsContainerCSS2() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
};
var IndicatorsContainer = function IndicatorsContainer2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "indicatorsContainer", {
    indicators: true
  }), innerProps), children);
};
var _templateObject;
var _excluded$2 = ["size"];
var _excluded2 = ["innerProps", "isRtl", "size"];
function _EMOTION_STRINGIFIED_CSS_ERROR__() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref2 = false ? {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
} : {
  name: "tj5bde-Svg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0;label:Svg;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4LCBrZXlmcmFtZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmltcG9ydCB7XG4gIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lLFxuICBDU1NPYmplY3RXaXRoTGFiZWwsXG4gIEdyb3VwQmFzZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0U3R5bGVQcm9wcyB9IGZyb20gJy4uL3V0aWxzJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEljb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgU3ZnID0gKHtcbiAgc2l6ZSxcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU6IG51bWJlciB9KSA9PiAoXG4gIDxzdmdcbiAgICBoZWlnaHQ9e3NpemV9XG4gICAgd2lkdGg9e3NpemV9XG4gICAgdmlld0JveD1cIjAgMCAyMCAyMFwiXG4gICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgY3NzPXt7XG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGZpbGw6ICdjdXJyZW50Q29sb3InLFxuICAgICAgbGluZUhlaWdodDogMSxcbiAgICAgIHN0cm9rZTogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBzdHJva2VXaWR0aDogMCxcbiAgICB9fVxuICAgIHsuLi5wcm9wc31cbiAgLz5cbik7XG5cbmV4cG9ydCB0eXBlIENyb3NzSWNvblByb3BzID0gSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZT86IG51bWJlciB9O1xuZXhwb3J0IGNvbnN0IENyb3NzSWNvbiA9IChwcm9wczogQ3Jvc3NJY29uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTE0LjM0OCAxNC44NDljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDBsLTIuNjUxLTMuMDMwLTIuNjUxIDMuMDI5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI5IDAtMS42OTdsMi43NTgtMy4xNS0yLjc1OS0zLjE1MmMtMC40NjktMC40NjktMC40NjktMS4yMjggMC0xLjY5N3MxLjIyOC0wLjQ2OSAxLjY5NyAwbDIuNjUyIDMuMDMxIDIuNjUxLTMuMDMxYzAuNDY5LTAuNDY5IDEuMjI4LTAuNDY5IDEuNjk3IDBzMC40NjkgMS4yMjkgMCAxLjY5N2wtMi43NTggMy4xNTIgMi43NTggMy4xNWMwLjQ2OSAwLjQ2OSAwLjQ2OSAxLjIyOSAwIDEuNjk4elwiIC8+XG4gIDwvU3ZnPlxuKTtcbmV4cG9ydCB0eXBlIERvd25DaGV2cm9uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgRG93bkNoZXZyb24gPSAocHJvcHM6IERvd25DaGV2cm9uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTQuNTE2IDcuNTQ4YzAuNDM2LTAuNDQ2IDEuMDQzLTAuNDgxIDEuNTc2IDBsMy45MDggMy43NDcgMy45MDgtMy43NDdjMC41MzMtMC40ODEgMS4xNDEtMC40NDYgMS41NzQgMCAwLjQzNiAwLjQ0NSAwLjQwOCAxLjE5NyAwIDEuNjE1LTAuNDA2IDAuNDE4LTQuNjk1IDQuNTAyLTQuNjk1IDQuNTAyLTAuMjE3IDAuMjIzLTAuNTAyIDAuMzM1LTAuNzg3IDAuMzM1cy0wLjU3LTAuMTEyLTAuNzg5LTAuMzM1YzAgMC00LjI4Ny00LjA4NC00LjY5NS00LjUwMnMtMC40MzYtMS4xNyAwLTEuNjE1elwiIC8+XG4gIDwvU3ZnPlxuKTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEJ1dHRvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xufVxuXG5jb25zdCBiYXNlQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTpcbiAgICB8IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbiAgICB8IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JDb250YWluZXInLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICAgICc6aG92ZXInOiB7XG4gICAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsODAgOiBjb2xvcnMubmV1dHJhbDQwLFxuICAgICAgICB9LFxuICAgICAgfSksXG59KTtcblxuZXhwb3J0IGNvbnN0IGRyb3Bkb3duSW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBEcm9wZG93bkluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2Ryb3Bkb3duSW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdkcm9wZG93bi1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPERvd25DaGV2cm9uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDbGVhckluZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFRoZSBjaGlsZHJlbiB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGluZGljYXRvci4gKi9cbiAgY2hpbGRyZW4/OiBSZWFjdE5vZGU7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFySW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBDbGVhckluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2NsZWFySW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdjbGVhci1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPENyb3NzSWNvbiAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2VwYXJhdG9yXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaW5uZXJQcm9wcz86IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3BhbiddO1xufVxuXG5leHBvcnQgY29uc3QgaW5kaWNhdG9yU2VwYXJhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNEaXNhYmxlZCxcbiAgICB0aGVtZToge1xuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgICAgY29sb3JzLFxuICAgIH0sXG4gIH06IEluZGljYXRvclNlcGFyYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+LFxuICB1bnN0eWxlZDogYm9vbGVhblxuKTogQ1NTT2JqZWN0V2l0aExhYmVsID0+ICh7XG4gIGxhYmVsOiAnaW5kaWNhdG9yU2VwYXJhdG9yJyxcbiAgYWxpZ25TZWxmOiAnc3RyZXRjaCcsXG4gIHdpZHRoOiAxLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXNEaXNhYmxlZCA/IGNvbG9ycy5uZXV0cmFsMTAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBtYXJnaW5Cb3R0b206IGJhc2VVbml0ICogMixcbiAgICAgICAgbWFyZ2luVG9wOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgSW5kaWNhdG9yU2VwYXJhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnaW5kaWNhdG9yU2VwYXJhdG9yJywge1xuICAgICAgICAnaW5kaWNhdG9yLXNlcGFyYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAvPlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMb2FkaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgbG9hZGluZ0RvdEFuaW1hdGlvbnMgPSBrZXlmcmFtZXNgXG4gIDAlLCA4MCUsIDEwMCUgeyBvcGFjaXR5OiAwOyB9XG4gIDQwJSB7IG9wYWNpdHk6IDE7IH1cbmA7XG5cbmV4cG9ydCBjb25zdCBsb2FkaW5nSW5kaWNhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHNpemUsXG4gICAgdGhlbWU6IHtcbiAgICAgIGNvbG9ycyxcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICB9LFxuICB9OiBMb2FkaW5nSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdsb2FkaW5nSW5kaWNhdG9yJyxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICB0cmFuc2l0aW9uOiAnY29sb3IgMTUwbXMnLFxuICBhbGlnblNlbGY6ICdjZW50ZXInLFxuICBmb250U2l6ZTogc2l6ZSxcbiAgbGluZUhlaWdodDogMSxcbiAgbWFyZ2luUmlnaHQ6IHNpemUsXG4gIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGNvbG9yOiBpc0ZvY3VzZWQgPyBjb2xvcnMubmV1dHJhbDYwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgICAgICAgcGFkZGluZzogYmFzZVVuaXQgKiAyLFxuICAgICAgfSksXG59KTtcblxuaW50ZXJmYWNlIExvYWRpbmdEb3RQcm9wcyB7XG4gIGRlbGF5OiBudW1iZXI7XG4gIG9mZnNldDogYm9vbGVhbjtcbn1cbmNvbnN0IExvYWRpbmdEb3QgPSAoeyBkZWxheSwgb2Zmc2V0IH06IExvYWRpbmdEb3RQcm9wcykgPT4gKFxuICA8c3BhblxuICAgIGNzcz17e1xuICAgICAgYW5pbWF0aW9uOiBgJHtsb2FkaW5nRG90QW5pbWF0aW9uc30gMXMgZWFzZS1pbi1vdXQgJHtkZWxheX1tcyBpbmZpbml0ZTtgLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzFlbScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIG1hcmdpbkxlZnQ6IG9mZnNldCA/ICcxZW0nIDogdW5kZWZpbmVkLFxuICAgICAgaGVpZ2h0OiAnMWVtJyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgd2lkdGg6ICcxZW0nLFxuICAgIH19XG4gIC8+XG4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRpbmdJbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgLyoqIFNldCBzaXplIG9mIHRoZSBjb250YWluZXIuICovXG4gIHNpemU6IG51bWJlcjtcbn1cbmV4cG9ydCBjb25zdCBMb2FkaW5nSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KHtcbiAgaW5uZXJQcm9wcyxcbiAgaXNSdGwsXG4gIHNpemUgPSA0LFxuICAuLi5yZXN0UHJvcHNcbn06IExvYWRpbmdJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPikgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKFxuICAgICAgICB7IC4uLnJlc3RQcm9wcywgaW5uZXJQcm9wcywgaXNSdGwsIHNpemUgfSxcbiAgICAgICAgJ2xvYWRpbmdJbmRpY2F0b3InLFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdsb2FkaW5nLWluZGljYXRvcic6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MH0gb2Zmc2V0PXtpc1J0bH0gLz5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXsxNjB9IG9mZnNldCAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezMyMH0gb2Zmc2V0PXshaXNSdGx9IC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuIl19 */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__
};
var Svg = function Svg2(_ref3) {
  var size2 = _ref3.size, props = _objectWithoutProperties(_ref3, _excluded$2);
  return jsx("svg", _extends({
    height: size2,
    width: size2,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: _ref2
  }, props));
};
var CrossIcon = function CrossIcon2(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
};
var DownChevron = function DownChevron2(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
};
var baseCSS = function baseCSS2(_ref3, unstyled) {
  var isFocused = _ref3.isFocused, _ref3$theme = _ref3.theme, baseUnit2 = _ref3$theme.spacing.baseUnit, colors2 = _ref3$theme.colors;
  return _objectSpread2({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2,
    ":hover": {
      color: isFocused ? colors2.neutral80 : colors2.neutral40
    }
  });
};
var dropdownIndicatorCSS = baseCSS;
var DropdownIndicator = function DropdownIndicator2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "dropdownIndicator", {
    indicator: true,
    "dropdown-indicator": true
  }), innerProps), children || jsx(DownChevron, null));
};
var clearIndicatorCSS = baseCSS;
var ClearIndicator = function ClearIndicator2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "clearIndicator", {
    indicator: true,
    "clear-indicator": true
  }), innerProps), children || jsx(CrossIcon, null));
};
var indicatorSeparatorCSS = function indicatorSeparatorCSS2(_ref4, unstyled) {
  var isDisabled = _ref4.isDisabled, _ref4$theme = _ref4.theme, baseUnit2 = _ref4$theme.spacing.baseUnit, colors2 = _ref4$theme.colors;
  return _objectSpread2({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors2.neutral10 : colors2.neutral20,
    marginBottom: baseUnit2 * 2,
    marginTop: baseUnit2 * 2
  });
};
var IndicatorSeparator = function IndicatorSeparator2(props) {
  var innerProps = props.innerProps;
  return jsx("span", _extends({}, innerProps, getStyleProps(props, "indicatorSeparator", {
    "indicator-separator": true
  })));
};
var loadingDotAnimations = keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n"])));
var loadingIndicatorCSS = function loadingIndicatorCSS2(_ref5, unstyled) {
  var isFocused = _ref5.isFocused, size2 = _ref5.size, _ref5$theme = _ref5.theme, colors2 = _ref5$theme.colors, baseUnit2 = _ref5$theme.spacing.baseUnit;
  return _objectSpread2({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: size2,
    lineHeight: 1,
    marginRight: size2,
    textAlign: "center",
    verticalAlign: "middle"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2
  });
};
var LoadingDot = function LoadingDot2(_ref6) {
  var delay = _ref6.delay, offset3 = _ref6.offset;
  return jsx("span", {
    css: /* @__PURE__ */ css({
      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: offset3 ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, false ? "" : ";label:LoadingDot;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1RSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4LCBrZXlmcmFtZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmltcG9ydCB7XG4gIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lLFxuICBDU1NPYmplY3RXaXRoTGFiZWwsXG4gIEdyb3VwQmFzZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0U3R5bGVQcm9wcyB9IGZyb20gJy4uL3V0aWxzJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEljb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgU3ZnID0gKHtcbiAgc2l6ZSxcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU6IG51bWJlciB9KSA9PiAoXG4gIDxzdmdcbiAgICBoZWlnaHQ9e3NpemV9XG4gICAgd2lkdGg9e3NpemV9XG4gICAgdmlld0JveD1cIjAgMCAyMCAyMFwiXG4gICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgY3NzPXt7XG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGZpbGw6ICdjdXJyZW50Q29sb3InLFxuICAgICAgbGluZUhlaWdodDogMSxcbiAgICAgIHN0cm9rZTogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBzdHJva2VXaWR0aDogMCxcbiAgICB9fVxuICAgIHsuLi5wcm9wc31cbiAgLz5cbik7XG5cbmV4cG9ydCB0eXBlIENyb3NzSWNvblByb3BzID0gSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZT86IG51bWJlciB9O1xuZXhwb3J0IGNvbnN0IENyb3NzSWNvbiA9IChwcm9wczogQ3Jvc3NJY29uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTE0LjM0OCAxNC44NDljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDBsLTIuNjUxLTMuMDMwLTIuNjUxIDMuMDI5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI5IDAtMS42OTdsMi43NTgtMy4xNS0yLjc1OS0zLjE1MmMtMC40NjktMC40NjktMC40NjktMS4yMjggMC0xLjY5N3MxLjIyOC0wLjQ2OSAxLjY5NyAwbDIuNjUyIDMuMDMxIDIuNjUxLTMuMDMxYzAuNDY5LTAuNDY5IDEuMjI4LTAuNDY5IDEuNjk3IDBzMC40NjkgMS4yMjkgMCAxLjY5N2wtMi43NTggMy4xNTIgMi43NTggMy4xNWMwLjQ2OSAwLjQ2OSAwLjQ2OSAxLjIyOSAwIDEuNjk4elwiIC8+XG4gIDwvU3ZnPlxuKTtcbmV4cG9ydCB0eXBlIERvd25DaGV2cm9uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgRG93bkNoZXZyb24gPSAocHJvcHM6IERvd25DaGV2cm9uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTQuNTE2IDcuNTQ4YzAuNDM2LTAuNDQ2IDEuMDQzLTAuNDgxIDEuNTc2IDBsMy45MDggMy43NDcgMy45MDgtMy43NDdjMC41MzMtMC40ODEgMS4xNDEtMC40NDYgMS41NzQgMCAwLjQzNiAwLjQ0NSAwLjQwOCAxLjE5NyAwIDEuNjE1LTAuNDA2IDAuNDE4LTQuNjk1IDQuNTAyLTQuNjk1IDQuNTAyLTAuMjE3IDAuMjIzLTAuNTAyIDAuMzM1LTAuNzg3IDAuMzM1cy0wLjU3LTAuMTEyLTAuNzg5LTAuMzM1YzAgMC00LjI4Ny00LjA4NC00LjY5NS00LjUwMnMtMC40MzYtMS4xNyAwLTEuNjE1elwiIC8+XG4gIDwvU3ZnPlxuKTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEJ1dHRvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xufVxuXG5jb25zdCBiYXNlQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTpcbiAgICB8IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbiAgICB8IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JDb250YWluZXInLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICAgICc6aG92ZXInOiB7XG4gICAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsODAgOiBjb2xvcnMubmV1dHJhbDQwLFxuICAgICAgICB9LFxuICAgICAgfSksXG59KTtcblxuZXhwb3J0IGNvbnN0IGRyb3Bkb3duSW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBEcm9wZG93bkluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2Ryb3Bkb3duSW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdkcm9wZG93bi1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPERvd25DaGV2cm9uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDbGVhckluZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFRoZSBjaGlsZHJlbiB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGluZGljYXRvci4gKi9cbiAgY2hpbGRyZW4/OiBSZWFjdE5vZGU7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFySW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBDbGVhckluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2NsZWFySW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdjbGVhci1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPENyb3NzSWNvbiAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2VwYXJhdG9yXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaW5uZXJQcm9wcz86IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3BhbiddO1xufVxuXG5leHBvcnQgY29uc3QgaW5kaWNhdG9yU2VwYXJhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNEaXNhYmxlZCxcbiAgICB0aGVtZToge1xuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgICAgY29sb3JzLFxuICAgIH0sXG4gIH06IEluZGljYXRvclNlcGFyYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+LFxuICB1bnN0eWxlZDogYm9vbGVhblxuKTogQ1NTT2JqZWN0V2l0aExhYmVsID0+ICh7XG4gIGxhYmVsOiAnaW5kaWNhdG9yU2VwYXJhdG9yJyxcbiAgYWxpZ25TZWxmOiAnc3RyZXRjaCcsXG4gIHdpZHRoOiAxLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXNEaXNhYmxlZCA/IGNvbG9ycy5uZXV0cmFsMTAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBtYXJnaW5Cb3R0b206IGJhc2VVbml0ICogMixcbiAgICAgICAgbWFyZ2luVG9wOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgSW5kaWNhdG9yU2VwYXJhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnaW5kaWNhdG9yU2VwYXJhdG9yJywge1xuICAgICAgICAnaW5kaWNhdG9yLXNlcGFyYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAvPlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMb2FkaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgbG9hZGluZ0RvdEFuaW1hdGlvbnMgPSBrZXlmcmFtZXNgXG4gIDAlLCA4MCUsIDEwMCUgeyBvcGFjaXR5OiAwOyB9XG4gIDQwJSB7IG9wYWNpdHk6IDE7IH1cbmA7XG5cbmV4cG9ydCBjb25zdCBsb2FkaW5nSW5kaWNhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHNpemUsXG4gICAgdGhlbWU6IHtcbiAgICAgIGNvbG9ycyxcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICB9LFxuICB9OiBMb2FkaW5nSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdsb2FkaW5nSW5kaWNhdG9yJyxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICB0cmFuc2l0aW9uOiAnY29sb3IgMTUwbXMnLFxuICBhbGlnblNlbGY6ICdjZW50ZXInLFxuICBmb250U2l6ZTogc2l6ZSxcbiAgbGluZUhlaWdodDogMSxcbiAgbWFyZ2luUmlnaHQ6IHNpemUsXG4gIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGNvbG9yOiBpc0ZvY3VzZWQgPyBjb2xvcnMubmV1dHJhbDYwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgICAgICAgcGFkZGluZzogYmFzZVVuaXQgKiAyLFxuICAgICAgfSksXG59KTtcblxuaW50ZXJmYWNlIExvYWRpbmdEb3RQcm9wcyB7XG4gIGRlbGF5OiBudW1iZXI7XG4gIG9mZnNldDogYm9vbGVhbjtcbn1cbmNvbnN0IExvYWRpbmdEb3QgPSAoeyBkZWxheSwgb2Zmc2V0IH06IExvYWRpbmdEb3RQcm9wcykgPT4gKFxuICA8c3BhblxuICAgIGNzcz17e1xuICAgICAgYW5pbWF0aW9uOiBgJHtsb2FkaW5nRG90QW5pbWF0aW9uc30gMXMgZWFzZS1pbi1vdXQgJHtkZWxheX1tcyBpbmZpbml0ZTtgLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzFlbScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIG1hcmdpbkxlZnQ6IG9mZnNldCA/ICcxZW0nIDogdW5kZWZpbmVkLFxuICAgICAgaGVpZ2h0OiAnMWVtJyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgd2lkdGg6ICcxZW0nLFxuICAgIH19XG4gIC8+XG4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRpbmdJbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgLyoqIFNldCBzaXplIG9mIHRoZSBjb250YWluZXIuICovXG4gIHNpemU6IG51bWJlcjtcbn1cbmV4cG9ydCBjb25zdCBMb2FkaW5nSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KHtcbiAgaW5uZXJQcm9wcyxcbiAgaXNSdGwsXG4gIHNpemUgPSA0LFxuICAuLi5yZXN0UHJvcHNcbn06IExvYWRpbmdJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPikgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKFxuICAgICAgICB7IC4uLnJlc3RQcm9wcywgaW5uZXJQcm9wcywgaXNSdGwsIHNpemUgfSxcbiAgICAgICAgJ2xvYWRpbmdJbmRpY2F0b3InLFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdsb2FkaW5nLWluZGljYXRvcic6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MH0gb2Zmc2V0PXtpc1J0bH0gLz5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXsxNjB9IG9mZnNldCAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezMyMH0gb2Zmc2V0PXshaXNSdGx9IC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuIl19 */")
  });
};
var LoadingIndicator = function LoadingIndicator2(_ref7) {
  var innerProps = _ref7.innerProps, isRtl = _ref7.isRtl, _ref7$size = _ref7.size, size2 = _ref7$size === void 0 ? 4 : _ref7$size, restProps = _objectWithoutProperties(_ref7, _excluded2);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    innerProps,
    isRtl,
    size: size2
  }), "loadingIndicator", {
    indicator: true,
    "loading-indicator": true
  }), innerProps), jsx(LoadingDot, {
    delay: 0,
    offset: isRtl
  }), jsx(LoadingDot, {
    delay: 160,
    offset: true
  }), jsx(LoadingDot, {
    delay: 320,
    offset: !isRtl
  }));
};
var css$1 = function css2(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, _ref$theme = _ref3.theme, colors2 = _ref$theme.colors, borderRadius2 = _ref$theme.borderRadius, spacing2 = _ref$theme.spacing;
  return _objectSpread2({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: spacing2.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors2.neutral5 : colors2.neutral0,
    borderColor: isDisabled ? colors2.neutral10 : isFocused ? colors2.primary : colors2.neutral20,
    borderRadius: borderRadius2,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: isFocused ? "0 0 0 1px ".concat(colors2.primary) : void 0,
    "&:hover": {
      borderColor: isFocused ? colors2.primary : colors2.neutral30
    }
  });
};
var Control = function Control2(props) {
  var children = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, innerRef = props.innerRef, innerProps = props.innerProps, menuIsOpen = props.menuIsOpen;
  return jsx("div", _extends({
    ref: innerRef
  }, getStyleProps(props, "control", {
    control: true,
    "control--is-disabled": isDisabled,
    "control--is-focused": isFocused,
    "control--menu-is-open": menuIsOpen
  }), innerProps, {
    "aria-disabled": isDisabled || void 0
  }), children);
};
var Control$1 = Control;
var _excluded$1 = ["data"];
var groupCSS = function groupCSS2(_ref3, unstyled) {
  var spacing2 = _ref3.theme.spacing;
  return unstyled ? {} : {
    paddingBottom: spacing2.baseUnit * 2,
    paddingTop: spacing2.baseUnit * 2
  };
};
var Group2 = function Group3(props) {
  var children = props.children, cx = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, Heading = props.Heading, headingProps = props.headingProps, innerProps = props.innerProps, label = props.label, theme = props.theme, selectProps = props.selectProps;
  return jsx("div", _extends({}, getStyleProps(props, "group", {
    group: true
  }), innerProps), jsx(Heading, _extends({}, headingProps, {
    selectProps,
    theme,
    getStyles,
    getClassNames,
    cx
  }), label), jsx("div", null, children));
};
var groupHeadingCSS = function groupHeadingCSS2(_ref23, unstyled) {
  var _ref2$theme = _ref23.theme, colors2 = _ref2$theme.colors, spacing2 = _ref2$theme.spacing;
  return _objectSpread2({
    label: "group",
    cursor: "default",
    display: "block"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: spacing2.baseUnit * 3,
    paddingRight: spacing2.baseUnit * 3,
    textTransform: "uppercase"
  });
};
var GroupHeading = function GroupHeading2(props) {
  var _cleanCommonProps = cleanCommonProps(props);
  _cleanCommonProps.data;
  var innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$1);
  return jsx("div", _extends({}, getStyleProps(props, "groupHeading", {
    "group-heading": true
  }), innerProps));
};
var Group$1 = Group2;
var _excluded3 = ["innerRef", "isDisabled", "isHidden", "inputClassName"];
var inputCSS = function inputCSS2(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, value = _ref3.value, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2(_objectSpread2({
    visibility: isDisabled ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: value ? "translateZ(0)" : ""
  }, containerStyle), unstyled ? {} : {
    margin: spacing2.baseUnit / 2,
    paddingBottom: spacing2.baseUnit / 2,
    paddingTop: spacing2.baseUnit / 2,
    color: colors2.neutral80
  });
};
var spacingStyle = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
};
var containerStyle = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": _objectSpread2({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, spacingStyle)
};
var inputStyle = function inputStyle2(isHidden) {
  return _objectSpread2({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: isHidden ? 0 : 1,
    width: "100%"
  }, spacingStyle);
};
var Input = function Input2(props) {
  var cx = props.cx, value = props.value;
  var _cleanCommonProps = cleanCommonProps(props), innerRef = _cleanCommonProps.innerRef, isDisabled = _cleanCommonProps.isDisabled, isHidden = _cleanCommonProps.isHidden, inputClassName = _cleanCommonProps.inputClassName, innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded3);
  return jsx("div", _extends({}, getStyleProps(props, "input", {
    "input-container": true
  }), {
    "data-value": value || ""
  }), jsx("input", _extends({
    className: cx({
      input: true
    }, inputClassName),
    ref: innerRef,
    style: inputStyle(isHidden),
    disabled: isDisabled
  }, innerProps)));
};
var Input$1 = Input;
var multiValueCSS = function multiValueCSS2(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, borderRadius2 = _ref$theme.borderRadius, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, unstyled ? {} : {
    backgroundColor: colors2.neutral10,
    borderRadius: borderRadius2 / 2,
    margin: spacing2.baseUnit / 2
  });
};
var multiValueLabelCSS = function multiValueLabelCSS2(_ref23, unstyled) {
  var _ref2$theme = _ref23.theme, borderRadius2 = _ref2$theme.borderRadius, colors2 = _ref2$theme.colors, cropWithEllipsis = _ref23.cropWithEllipsis;
  return _objectSpread2({
    overflow: "hidden",
    textOverflow: cropWithEllipsis || cropWithEllipsis === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    color: colors2.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
};
var multiValueRemoveCSS = function multiValueRemoveCSS2(_ref3, unstyled) {
  var _ref3$theme = _ref3.theme, spacing2 = _ref3$theme.spacing, borderRadius2 = _ref3$theme.borderRadius, colors2 = _ref3$theme.colors, isFocused = _ref3.isFocused;
  return _objectSpread2({
    alignItems: "center",
    display: "flex"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    backgroundColor: isFocused ? colors2.dangerLight : void 0,
    paddingLeft: spacing2.baseUnit,
    paddingRight: spacing2.baseUnit,
    ":hover": {
      backgroundColor: colors2.dangerLight,
      color: colors2.danger
    }
  });
};
var MultiValueGeneric = function MultiValueGeneric2(_ref4) {
  var children = _ref4.children, innerProps = _ref4.innerProps;
  return jsx("div", innerProps, children);
};
var MultiValueContainer = MultiValueGeneric;
var MultiValueLabel = MultiValueGeneric;
function MultiValueRemove(_ref5) {
  var children = _ref5.children, innerProps = _ref5.innerProps;
  return jsx("div", _extends({
    role: "button"
  }, innerProps), children || jsx(CrossIcon, {
    size: 14
  }));
}
var MultiValue = function MultiValue2(props) {
  var children = props.children, components2 = props.components, data = props.data, innerProps = props.innerProps, isDisabled = props.isDisabled, removeProps3 = props.removeProps, selectProps = props.selectProps;
  var Container = components2.Container, Label = components2.Label, Remove = components2.Remove;
  return jsx(Container, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValue", {
      "multi-value": true,
      "multi-value--is-disabled": isDisabled
    })), innerProps),
    selectProps
  }, jsx(Label, {
    data,
    innerProps: _objectSpread2({}, getStyleProps(props, "multiValueLabel", {
      "multi-value__label": true
    })),
    selectProps
  }, children), jsx(Remove, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValueRemove", {
      "multi-value__remove": true
    })), {}, {
      "aria-label": "Remove ".concat(children || "option")
    }, removeProps3),
    selectProps
  }));
};
var MultiValue$1 = MultiValue;
var optionCSS = function optionCSS2(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, isSelected = _ref3.isSelected, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, unstyled ? {} : {
    backgroundColor: isSelected ? colors2.primary : isFocused ? colors2.primary25 : "transparent",
    color: isDisabled ? colors2.neutral20 : isSelected ? colors2.neutral0 : "inherit",
    padding: "".concat(spacing2.baseUnit * 2, "px ").concat(spacing2.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: !isDisabled ? isSelected ? colors2.primary : colors2.primary50 : void 0
    }
  });
};
var Option = function Option2(props) {
  var children = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, isSelected = props.isSelected, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "option", {
    option: true,
    "option--is-disabled": isDisabled,
    "option--is-focused": isFocused,
    "option--is-selected": isSelected
  }), {
    ref: innerRef,
    "aria-disabled": isDisabled
  }, innerProps), children);
};
var Option$1 = Option;
var placeholderCSS = function placeholderCSS2(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, unstyled ? {} : {
    color: colors2.neutral50,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
};
var Placeholder = function Placeholder2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "placeholder", {
    placeholder: true
  }), innerProps), children);
};
var Placeholder$1 = Placeholder;
var css3 = function css4(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    color: isDisabled ? colors2.neutral40 : colors2.neutral80,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
};
var SingleValue = function SingleValue2(props) {
  var children = props.children, isDisabled = props.isDisabled, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "singleValue", {
    "single-value": true,
    "single-value--is-disabled": isDisabled
  }), innerProps), children);
};
var SingleValue$1 = SingleValue;
var components = {
  ClearIndicator,
  Control: Control$1,
  DropdownIndicator,
  DownChevron,
  CrossIcon,
  Group: Group$1,
  GroupHeading,
  IndicatorsContainer,
  IndicatorSeparator,
  Input: Input$1,
  LoadingIndicator,
  Menu: Menu$1,
  MenuList,
  MenuPortal,
  LoadingMessage,
  NoOptionsMessage,
  MultiValue: MultiValue$1,
  MultiValueContainer,
  MultiValueLabel,
  MultiValueRemove,
  Option: Option$1,
  Placeholder: Placeholder$1,
  SelectContainer,
  SingleValue: SingleValue$1,
  ValueContainer
};
var defaultComponents = function defaultComponents2(props) {
  return _objectSpread2(_objectSpread2({}, components), props.components);
};

// node_modules/memoize-one/dist/memoize-one.esm.js
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i4 = 0; i4 < newInputs.length; i4++) {
    if (!isEqual(newInputs[i4], lastInputs[i4])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var cache2 = null;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (cache2 && cache2.lastThis === this && isEqual2(newArgs, cache2.lastArgs)) {
      return cache2.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache2 = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache2 = null;
  };
  return memoized;
}

// node_modules/react-select/dist/Select-1fd588c9.esm.js
function _EMOTION_STRINGIFIED_CSS_ERROR__$2() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref = false ? {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
} : {
  name: "1f43avz-a11yText-A11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap;label:A11yText;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkExMXlUZXh0LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFNSSIsImZpbGUiOiJBMTF5VGV4dC50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGpzeCBqc3ggKi9cbmltcG9ydCB7IGpzeCB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLy8gQXNzaXN0aXZlIHRleHQgdG8gZGVzY3JpYmUgdmlzdWFsIGVsZW1lbnRzLiBIaWRkZW4gZm9yIHNpZ2h0ZWQgdXNlcnMuXG5jb25zdCBBMTF5VGV4dCA9IChwcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ10pID0+IChcbiAgPHNwYW5cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAnYTExeVRleHQnLFxuICAgICAgekluZGV4OiA5OTk5LFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgY2xpcDogJ3JlY3QoMXB4LCAxcHgsIDFweCwgMXB4KScsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQTExeVRleHQ7XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__$2
};
var A11yText = function A11yText2(props) {
  return jsx("span", _extends({
    css: _ref
  }, props));
};
var A11yText$1 = A11yText;
var defaultAriaLiveMessages = {
  guidance: function guidance(props) {
    var isSearchable = props.isSearchable, isMulti = props.isMulti, tabSelectsValue = props.tabSelectsValue, context = props.context, isInitialFocus = props.isInitialFocus;
    switch (context) {
      case "menu":
        return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(tabSelectsValue ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return isInitialFocus ? "".concat(props["aria-label"] || "Select", " is focused ").concat(isSearchable ? ",type to refine list" : "", ", press Down to open the menu, ").concat(isMulti ? " press left to focus selected values" : "") : "";
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function onChange(props) {
    var action = props.action, _props$label = props.label, label = _props$label === void 0 ? "" : _props$label, labels = props.labels, isDisabled = props.isDisabled;
    switch (action) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(label, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(labels.length > 1 ? "s" : "", " ").concat(labels.join(","), ", selected.");
      case "select-option":
        return isDisabled ? "option ".concat(label, " is disabled. Select another option.") : "option ".concat(label, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function onFocus(props) {
    var context = props.context, focused = props.focused, options2 = props.options, _props$label2 = props.label, label = _props$label2 === void 0 ? "" : _props$label2, selectValue = props.selectValue, isDisabled = props.isDisabled, isSelected = props.isSelected, isAppleDevice2 = props.isAppleDevice;
    var getArrayIndex = function getArrayIndex2(arr, item) {
      return arr && arr.length ? "".concat(arr.indexOf(item) + 1, " of ").concat(arr.length) : "";
    };
    if (context === "value" && selectValue) {
      return "value ".concat(label, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
    }
    if (context === "menu" && isAppleDevice2) {
      var disabled2 = isDisabled ? " disabled" : "";
      var status = "".concat(isSelected ? " selected" : "").concat(disabled2);
      return "".concat(label).concat(status, ", ").concat(getArrayIndex(options2, focused), ".");
    }
    return "";
  },
  onFilter: function onFilter(props) {
    var inputValue = props.inputValue, resultsMessage = props.resultsMessage;
    return "".concat(resultsMessage).concat(inputValue ? " for search term " + inputValue : "", ".");
  }
};
var LiveRegion = function LiveRegion2(props) {
  var ariaSelection = props.ariaSelection, focusedOption = props.focusedOption, focusedValue = props.focusedValue, focusableOptions = props.focusableOptions, isFocused = props.isFocused, selectValue = props.selectValue, selectProps = props.selectProps, id2 = props.id, isAppleDevice2 = props.isAppleDevice;
  var ariaLiveMessages = selectProps.ariaLiveMessages, getOptionLabel4 = selectProps.getOptionLabel, inputValue = selectProps.inputValue, isMulti = selectProps.isMulti, isOptionDisabled3 = selectProps.isOptionDisabled, isSearchable = selectProps.isSearchable, menuIsOpen = selectProps.menuIsOpen, options2 = selectProps.options, screenReaderStatus2 = selectProps.screenReaderStatus, tabSelectsValue = selectProps.tabSelectsValue, isLoading = selectProps.isLoading;
  var ariaLabel = selectProps["aria-label"];
  var ariaLive = selectProps["aria-live"];
  var messages = T2(function() {
    return _objectSpread2(_objectSpread2({}, defaultAriaLiveMessages), ariaLiveMessages || {});
  }, [ariaLiveMessages]);
  var ariaSelected = T2(function() {
    var message = "";
    if (ariaSelection && messages.onChange) {
      var option = ariaSelection.option, selectedOptions = ariaSelection.options, removedValue = ariaSelection.removedValue, removedValues = ariaSelection.removedValues, value = ariaSelection.value;
      var asOption = function asOption2(val) {
        return !Array.isArray(val) ? val : null;
      };
      var selected = removedValue || option || asOption(value);
      var label = selected ? getOptionLabel4(selected) : "";
      var multiSelected = selectedOptions || removedValues || void 0;
      var labels = multiSelected ? multiSelected.map(getOptionLabel4) : [];
      var onChangeProps = _objectSpread2({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: selected && isOptionDisabled3(selected, selectValue),
        label,
        labels
      }, ariaSelection);
      message = messages.onChange(onChangeProps);
    }
    return message;
  }, [ariaSelection, messages, isOptionDisabled3, selectValue, getOptionLabel4]);
  var ariaFocused = T2(function() {
    var focusMsg = "";
    var focused = focusedOption || focusedValue;
    var isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));
    if (focused && messages.onFocus) {
      var onFocusProps = {
        focused,
        label: getOptionLabel4(focused),
        isDisabled: isOptionDisabled3(focused, selectValue),
        isSelected,
        options: focusableOptions,
        context: focused === focusedOption ? "menu" : "value",
        selectValue,
        isAppleDevice: isAppleDevice2
      };
      focusMsg = messages.onFocus(onFocusProps);
    }
    return focusMsg;
  }, [focusedOption, focusedValue, getOptionLabel4, isOptionDisabled3, messages, focusableOptions, selectValue, isAppleDevice2]);
  var ariaResults = T2(function() {
    var resultsMsg = "";
    if (menuIsOpen && options2.length && !isLoading && messages.onFilter) {
      var resultsMessage = screenReaderStatus2({
        count: focusableOptions.length
      });
      resultsMsg = messages.onFilter({
        inputValue,
        resultsMessage
      });
    }
    return resultsMsg;
  }, [focusableOptions, inputValue, menuIsOpen, messages, options2, screenReaderStatus2, isLoading]);
  var isInitialFocus = (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus";
  var ariaGuidance = T2(function() {
    var guidanceMsg = "";
    if (messages.guidance) {
      var context = focusedValue ? "value" : menuIsOpen ? "menu" : "input";
      guidanceMsg = messages.guidance({
        "aria-label": ariaLabel,
        context,
        isDisabled: focusedOption && isOptionDisabled3(focusedOption, selectValue),
        isMulti,
        isSearchable,
        tabSelectsValue,
        isInitialFocus
      });
    }
    return guidanceMsg;
  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled3, isSearchable, menuIsOpen, messages, selectValue, tabSelectsValue, isInitialFocus]);
  var ScreenReaderText = jsx(b, null, jsx("span", {
    id: "aria-selection"
  }, ariaSelected), jsx("span", {
    id: "aria-focused"
  }, ariaFocused), jsx("span", {
    id: "aria-results"
  }, ariaResults), jsx("span", {
    id: "aria-guidance"
  }, ariaGuidance));
  return jsx(b, null, jsx(A11yText$1, {
    id: id2
  }, isInitialFocus && ScreenReaderText), jsx(A11yText$1, {
    "aria-live": ariaLive,
    "aria-atomic": "false",
    "aria-relevant": "additions text",
    role: "log"
  }, isFocused && !isInitialFocus && ScreenReaderText));
};
var LiveRegion$1 = LiveRegion;
var diacritics = [{
  base: "A",
  letters: "A\u24B6\uFF21\xC0\xC1\xC2\u1EA6\u1EA4\u1EAA\u1EA8\xC3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\xC4\u01DE\u1EA2\xC5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F"
}, {
  base: "AA",
  letters: "\uA732"
}, {
  base: "AE",
  letters: "\xC6\u01FC\u01E2"
}, {
  base: "AO",
  letters: "\uA734"
}, {
  base: "AU",
  letters: "\uA736"
}, {
  base: "AV",
  letters: "\uA738\uA73A"
}, {
  base: "AY",
  letters: "\uA73C"
}, {
  base: "B",
  letters: "B\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181"
}, {
  base: "C",
  letters: "C\u24B8\uFF23\u0106\u0108\u010A\u010C\xC7\u1E08\u0187\u023B\uA73E"
}, {
  base: "D",
  letters: "D\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779"
}, {
  base: "DZ",
  letters: "\u01F1\u01C4"
}, {
  base: "Dz",
  letters: "\u01F2\u01C5"
}, {
  base: "E",
  letters: "E\u24BA\uFF25\xC8\xC9\xCA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\xCB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E"
}, {
  base: "F",
  letters: "F\u24BB\uFF26\u1E1E\u0191\uA77B"
}, {
  base: "G",
  letters: "G\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E"
}, {
  base: "H",
  letters: "H\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D"
}, {
  base: "I",
  letters: "I\u24BE\uFF29\xCC\xCD\xCE\u0128\u012A\u012C\u0130\xCF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197"
}, {
  base: "J",
  letters: "J\u24BF\uFF2A\u0134\u0248"
}, {
  base: "K",
  letters: "K\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2"
}, {
  base: "L",
  letters: "L\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780"
}, {
  base: "LJ",
  letters: "\u01C7"
}, {
  base: "Lj",
  letters: "\u01C8"
}, {
  base: "M",
  letters: "M\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C"
}, {
  base: "N",
  letters: "N\u24C3\uFF2E\u01F8\u0143\xD1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4"
}, {
  base: "NJ",
  letters: "\u01CA"
}, {
  base: "Nj",
  letters: "\u01CB"
}, {
  base: "O",
  letters: "O\u24C4\uFF2F\xD2\xD3\xD4\u1ED2\u1ED0\u1ED6\u1ED4\xD5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\xD6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\xD8\u01FE\u0186\u019F\uA74A\uA74C"
}, {
  base: "OI",
  letters: "\u01A2"
}, {
  base: "OO",
  letters: "\uA74E"
}, {
  base: "OU",
  letters: "\u0222"
}, {
  base: "P",
  letters: "P\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754"
}, {
  base: "Q",
  letters: "Q\u24C6\uFF31\uA756\uA758\u024A"
}, {
  base: "R",
  letters: "R\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782"
}, {
  base: "S",
  letters: "S\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784"
}, {
  base: "T",
  letters: "T\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786"
}, {
  base: "TZ",
  letters: "\uA728"
}, {
  base: "U",
  letters: "U\u24CA\uFF35\xD9\xDA\xDB\u0168\u1E78\u016A\u1E7A\u016C\xDC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244"
}, {
  base: "V",
  letters: "V\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245"
}, {
  base: "VY",
  letters: "\uA760"
}, {
  base: "W",
  letters: "W\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72"
}, {
  base: "X",
  letters: "X\u24CD\uFF38\u1E8A\u1E8C"
}, {
  base: "Y",
  letters: "Y\u24CE\uFF39\u1EF2\xDD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE"
}, {
  base: "Z",
  letters: "Z\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762"
}, {
  base: "a",
  letters: "a\u24D0\uFF41\u1E9A\xE0\xE1\xE2\u1EA7\u1EA5\u1EAB\u1EA9\xE3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\xE4\u01DF\u1EA3\xE5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250"
}, {
  base: "aa",
  letters: "\uA733"
}, {
  base: "ae",
  letters: "\xE6\u01FD\u01E3"
}, {
  base: "ao",
  letters: "\uA735"
}, {
  base: "au",
  letters: "\uA737"
}, {
  base: "av",
  letters: "\uA739\uA73B"
}, {
  base: "ay",
  letters: "\uA73D"
}, {
  base: "b",
  letters: "b\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253"
}, {
  base: "c",
  letters: "c\u24D2\uFF43\u0107\u0109\u010B\u010D\xE7\u1E09\u0188\u023C\uA73F\u2184"
}, {
  base: "d",
  letters: "d\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A"
}, {
  base: "dz",
  letters: "\u01F3\u01C6"
}, {
  base: "e",
  letters: "e\u24D4\uFF45\xE8\xE9\xEA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\xEB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD"
}, {
  base: "f",
  letters: "f\u24D5\uFF46\u1E1F\u0192\uA77C"
}, {
  base: "g",
  letters: "g\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F"
}, {
  base: "h",
  letters: "h\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265"
}, {
  base: "hv",
  letters: "\u0195"
}, {
  base: "i",
  letters: "i\u24D8\uFF49\xEC\xED\xEE\u0129\u012B\u012D\xEF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131"
}, {
  base: "j",
  letters: "j\u24D9\uFF4A\u0135\u01F0\u0249"
}, {
  base: "k",
  letters: "k\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3"
}, {
  base: "l",
  letters: "l\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747"
}, {
  base: "lj",
  letters: "\u01C9"
}, {
  base: "m",
  letters: "m\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F"
}, {
  base: "n",
  letters: "n\u24DD\uFF4E\u01F9\u0144\xF1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5"
}, {
  base: "nj",
  letters: "\u01CC"
}, {
  base: "o",
  letters: "o\u24DE\uFF4F\xF2\xF3\xF4\u1ED3\u1ED1\u1ED7\u1ED5\xF5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\xF6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\xF8\u01FF\u0254\uA74B\uA74D\u0275"
}, {
  base: "oi",
  letters: "\u01A3"
}, {
  base: "ou",
  letters: "\u0223"
}, {
  base: "oo",
  letters: "\uA74F"
}, {
  base: "p",
  letters: "p\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755"
}, {
  base: "q",
  letters: "q\u24E0\uFF51\u024B\uA757\uA759"
}, {
  base: "r",
  letters: "r\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783"
}, {
  base: "s",
  letters: "s\u24E2\uFF53\xDF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B"
}, {
  base: "t",
  letters: "t\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787"
}, {
  base: "tz",
  letters: "\uA729"
}, {
  base: "u",
  letters: "u\u24E4\uFF55\xF9\xFA\xFB\u0169\u1E79\u016B\u1E7B\u016D\xFC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289"
}, {
  base: "v",
  letters: "v\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C"
}, {
  base: "vy",
  letters: "\uA761"
}, {
  base: "w",
  letters: "w\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73"
}, {
  base: "x",
  letters: "x\u24E7\uFF58\u1E8B\u1E8D"
}, {
  base: "y",
  letters: "y\u24E8\uFF59\u1EF3\xFD\u0177\u1EF9\u0233\u1E8F\xFF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF"
}, {
  base: "z",
  letters: "z\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763"
}];
var anyDiacritic = new RegExp("[" + diacritics.map(function(d3) {
  return d3.letters;
}).join("") + "]", "g");
var diacriticToBase = {};
for (i4 = 0; i4 < diacritics.length; i4++) {
  diacritic = diacritics[i4];
  for (j4 = 0; j4 < diacritic.letters.length; j4++) {
    diacriticToBase[diacritic.letters[j4]] = diacritic.base;
  }
}
var diacritic;
var j4;
var i4;
var stripDiacritics = function stripDiacritics2(str) {
  return str.replace(anyDiacritic, function(match4) {
    return diacriticToBase[match4];
  });
};
var memoizedStripDiacriticsForInput = memoizeOne(stripDiacritics);
var trimString = function trimString2(str) {
  return str.replace(/^\s+|\s+$/g, "");
};
var defaultStringify = function defaultStringify2(option) {
  return "".concat(option.label, " ").concat(option.value);
};
var createFilter = function createFilter2(config3) {
  return function(option, rawInput) {
    if (option.data.__isNew__) return true;
    var _ignoreCase$ignoreAcc = _objectSpread2({
      ignoreCase: true,
      ignoreAccents: true,
      stringify: defaultStringify,
      trim: true,
      matchFrom: "any"
    }, config3), ignoreCase = _ignoreCase$ignoreAcc.ignoreCase, ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents, stringify2 = _ignoreCase$ignoreAcc.stringify, trim2 = _ignoreCase$ignoreAcc.trim, matchFrom = _ignoreCase$ignoreAcc.matchFrom;
    var input2 = trim2 ? trimString(rawInput) : rawInput;
    var candidate = trim2 ? trimString(stringify2(option)) : stringify2(option);
    if (ignoreCase) {
      input2 = input2.toLowerCase();
      candidate = candidate.toLowerCase();
    }
    if (ignoreAccents) {
      input2 = memoizedStripDiacriticsForInput(input2);
      candidate = stripDiacritics(candidate);
    }
    return matchFrom === "start" ? candidate.substr(0, input2.length) === input2 : candidate.indexOf(input2) > -1;
  };
};
var _excluded4 = ["innerRef"];
function DummyInput(_ref3) {
  var innerRef = _ref3.innerRef, props = _objectWithoutProperties(_ref3, _excluded4);
  var filteredProps = removeProps(props, "onExited", "in", "enter", "exit", "appear");
  return jsx("input", _extends({
    ref: innerRef
  }, filteredProps, {
    css: /* @__PURE__ */ css({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, false ? "" : ";label:DummyInput;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkR1bW15SW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCTSIsImZpbGUiOiJEdW1teUlucHV0LnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgcmVtb3ZlUHJvcHMgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIER1bW15SW5wdXQoe1xuICBpbm5lclJlZixcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snaW5wdXQnXSAmIHtcbiAgcmVhZG9ubHkgaW5uZXJSZWY6IFJlZjxIVE1MSW5wdXRFbGVtZW50Pjtcbn0pIHtcbiAgLy8gUmVtb3ZlIGFuaW1hdGlvbiBwcm9wcyBub3QgbWVhbnQgZm9yIEhUTUwgZWxlbWVudHNcbiAgY29uc3QgZmlsdGVyZWRQcm9wcyA9IHJlbW92ZVByb3BzKFxuICAgIHByb3BzLFxuICAgICdvbkV4aXRlZCcsXG4gICAgJ2luJyxcbiAgICAnZW50ZXInLFxuICAgICdleGl0JyxcbiAgICAnYXBwZWFyJ1xuICApO1xuXG4gIHJldHVybiAoXG4gICAgPGlucHV0XG4gICAgICByZWY9e2lubmVyUmVmfVxuICAgICAgey4uLmZpbHRlcmVkUHJvcHN9XG4gICAgICBjc3M9e3tcbiAgICAgICAgbGFiZWw6ICdkdW1teUlucHV0JyxcbiAgICAgICAgLy8gZ2V0IHJpZCBvZiBhbnkgZGVmYXVsdCBzdHlsZXNcbiAgICAgICAgYmFja2dyb3VuZDogMCxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICAvLyBpbXBvcnRhbnQhIHRoaXMgaGlkZXMgdGhlIGZsYXNoaW5nIGN1cnNvclxuICAgICAgICBjYXJldENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBmb250U2l6ZTogJ2luaGVyaXQnLFxuICAgICAgICBncmlkQXJlYTogJzEgLyAxIC8gMiAvIDMnLFxuICAgICAgICBvdXRsaW5lOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAvLyBpbXBvcnRhbnQhIHdpdGhvdXQgYHdpZHRoYCBicm93c2VycyB3b24ndCBhbGxvdyBmb2N1c1xuICAgICAgICB3aWR0aDogMSxcblxuICAgICAgICAvLyByZW1vdmUgY3Vyc29yIG9uIGRlc2t0b3BcbiAgICAgICAgY29sb3I6ICd0cmFuc3BhcmVudCcsXG5cbiAgICAgICAgLy8gcmVtb3ZlIGN1cnNvciBvbiBtb2JpbGUgd2hpbHN0IG1haW50YWluaW5nIFwic2Nyb2xsIGludG8gdmlld1wiIGJlaGF2aW91clxuICAgICAgICBsZWZ0OiAtMTAwLFxuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoLjAxKScsXG4gICAgICB9fVxuICAgIC8+XG4gICk7XG59XG4iXX0= */")
  }));
}
var cancelScroll = function cancelScroll2(event) {
  if (event.cancelable) event.preventDefault();
  event.stopPropagation();
};
function useScrollCapture(_ref3) {
  var isEnabled = _ref3.isEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var isBottom = A2(false);
  var isTop = A2(false);
  var touchStart = A2(0);
  var scrollTarget = A2(null);
  var handleEventDelta = q2(function(event, delta) {
    if (scrollTarget.current === null) return;
    var _scrollTarget$current = scrollTarget.current, scrollTop = _scrollTarget$current.scrollTop, scrollHeight = _scrollTarget$current.scrollHeight, clientHeight = _scrollTarget$current.clientHeight;
    var target = scrollTarget.current;
    var isDeltaPositive = delta > 0;
    var availableScroll = scrollHeight - clientHeight - scrollTop;
    var shouldCancelScroll = false;
    if (availableScroll > delta && isBottom.current) {
      if (onBottomLeave) onBottomLeave(event);
      isBottom.current = false;
    }
    if (isDeltaPositive && isTop.current) {
      if (onTopLeave) onTopLeave(event);
      isTop.current = false;
    }
    if (isDeltaPositive && delta > availableScroll) {
      if (onBottomArrive && !isBottom.current) {
        onBottomArrive(event);
      }
      target.scrollTop = scrollHeight;
      shouldCancelScroll = true;
      isBottom.current = true;
    } else if (!isDeltaPositive && -delta > scrollTop) {
      if (onTopArrive && !isTop.current) {
        onTopArrive(event);
      }
      target.scrollTop = 0;
      shouldCancelScroll = true;
      isTop.current = true;
    }
    if (shouldCancelScroll) {
      cancelScroll(event);
    }
  }, [onBottomArrive, onBottomLeave, onTopArrive, onTopLeave]);
  var onWheel = q2(function(event) {
    handleEventDelta(event, event.deltaY);
  }, [handleEventDelta]);
  var onTouchStart = q2(function(event) {
    touchStart.current = event.changedTouches[0].clientY;
  }, []);
  var onTouchMove = q2(function(event) {
    var deltaY = touchStart.current - event.changedTouches[0].clientY;
    handleEventDelta(event, deltaY);
  }, [handleEventDelta]);
  var startListening = q2(function(el) {
    if (!el) return;
    var notPassive = supportsPassiveEvents ? {
      passive: false
    } : false;
    el.addEventListener("wheel", onWheel, notPassive);
    el.addEventListener("touchstart", onTouchStart, notPassive);
    el.addEventListener("touchmove", onTouchMove, notPassive);
  }, [onTouchMove, onTouchStart, onWheel]);
  var stopListening = q2(function(el) {
    if (!el) return;
    el.removeEventListener("wheel", onWheel, false);
    el.removeEventListener("touchstart", onTouchStart, false);
    el.removeEventListener("touchmove", onTouchMove, false);
  }, [onTouchMove, onTouchStart, onWheel]);
  y2(function() {
    if (!isEnabled) return;
    var element = scrollTarget.current;
    startListening(element);
    return function() {
      stopListening(element);
    };
  }, [isEnabled, startListening, stopListening]);
  return function(element) {
    scrollTarget.current = element;
  };
}
var STYLE_KEYS = ["boxSizing", "height", "overflow", "paddingRight", "position"];
var LOCK_STYLES = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function preventTouchMove(e3) {
  if (e3.cancelable) e3.preventDefault();
}
function allowTouchMove(e3) {
  e3.stopPropagation();
}
function preventInertiaScroll() {
  var top = this.scrollTop;
  var totalScroll = this.scrollHeight;
  var currentScroll = top + this.offsetHeight;
  if (top === 0) {
    this.scrollTop = 1;
  } else if (currentScroll === totalScroll) {
    this.scrollTop = top - 1;
  }
}
function isTouchDevice() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var activeScrollLocks = 0;
var listenerOptions = {
  capture: false,
  passive: false
};
function useScrollLock(_ref3) {
  var isEnabled = _ref3.isEnabled, _ref$accountForScroll = _ref3.accountForScrollbars, accountForScrollbars = _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
  var originalStyles = A2({});
  var scrollTarget = A2(null);
  var addScrollLock = q2(function(touchScrollTarget) {
    if (!canUseDOM) return;
    var target = document.body;
    var targetStyle = target && target.style;
    if (accountForScrollbars) {
      STYLE_KEYS.forEach(function(key) {
        var val = targetStyle && targetStyle[key];
        originalStyles.current[key] = val;
      });
    }
    if (accountForScrollbars && activeScrollLocks < 1) {
      var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0;
      var clientWidth = document.body ? document.body.clientWidth : 0;
      var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
      Object.keys(LOCK_STYLES).forEach(function(key) {
        var val = LOCK_STYLES[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
      if (targetStyle) {
        targetStyle.paddingRight = "".concat(adjustedPadding, "px");
      }
    }
    if (target && isTouchDevice()) {
      target.addEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.addEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.addEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
    activeScrollLocks += 1;
  }, [accountForScrollbars]);
  var removeScrollLock = q2(function(touchScrollTarget) {
    if (!canUseDOM) return;
    var target = document.body;
    var targetStyle = target && target.style;
    activeScrollLocks = Math.max(activeScrollLocks - 1, 0);
    if (accountForScrollbars && activeScrollLocks < 1) {
      STYLE_KEYS.forEach(function(key) {
        var val = originalStyles.current[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
    }
    if (target && isTouchDevice()) {
      target.removeEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.removeEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.removeEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
  }, [accountForScrollbars]);
  y2(function() {
    if (!isEnabled) return;
    var element = scrollTarget.current;
    addScrollLock(element);
    return function() {
      removeScrollLock(element);
    };
  }, [isEnabled, addScrollLock, removeScrollLock]);
  return function(element) {
    scrollTarget.current = element;
  };
}
function _EMOTION_STRINGIFIED_CSS_ERROR__$1() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var blurSelectInput = function blurSelectInput2(event) {
  var element = event.target;
  return element.ownerDocument.activeElement && element.ownerDocument.activeElement.blur();
};
var _ref2$1 = false ? {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
} : {
  name: "bp8cua-ScrollManager",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0;label:ScrollManager;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNjcm9sbE1hbmFnZXIudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9EVSIsImZpbGUiOiJTY3JvbGxNYW5hZ2VyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgRnJhZ21lbnQsIFJlYWN0RWxlbWVudCwgUmVmQ2FsbGJhY2ssIE1vdXNlRXZlbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlU2Nyb2xsQ2FwdHVyZSBmcm9tICcuL3VzZVNjcm9sbENhcHR1cmUnO1xuaW1wb3J0IHVzZVNjcm9sbExvY2sgZnJvbSAnLi91c2VTY3JvbGxMb2NrJztcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgcmVhZG9ubHkgY2hpbGRyZW46IChyZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PikgPT4gUmVhY3RFbGVtZW50O1xuICByZWFkb25seSBsb2NrRW5hYmxlZDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgY2FwdHVyZUVuYWJsZWQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG9uQm90dG9tQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Cb3R0b21MZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG4gIHJlYWRvbmx5IG9uVG9wQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Ub3BMZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG59XG5cbmNvbnN0IGJsdXJTZWxlY3RJbnB1dCA9IChldmVudDogTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgcmV0dXJuIChcbiAgICBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuICAgIChlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCkuYmx1cigpXG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTY3JvbGxNYW5hZ2VyKHtcbiAgY2hpbGRyZW4sXG4gIGxvY2tFbmFibGVkLFxuICBjYXB0dXJlRW5hYmxlZCA9IHRydWUsXG4gIG9uQm90dG9tQXJyaXZlLFxuICBvbkJvdHRvbUxlYXZlLFxuICBvblRvcEFycml2ZSxcbiAgb25Ub3BMZWF2ZSxcbn06IFByb3BzKSB7XG4gIGNvbnN0IHNldFNjcm9sbENhcHR1cmVUYXJnZXQgPSB1c2VTY3JvbGxDYXB0dXJlKHtcbiAgICBpc0VuYWJsZWQ6IGNhcHR1cmVFbmFibGVkLFxuICAgIG9uQm90dG9tQXJyaXZlLFxuICAgIG9uQm90dG9tTGVhdmUsXG4gICAgb25Ub3BBcnJpdmUsXG4gICAgb25Ub3BMZWF2ZSxcbiAgfSk7XG4gIGNvbnN0IHNldFNjcm9sbExvY2tUYXJnZXQgPSB1c2VTY3JvbGxMb2NrKHsgaXNFbmFibGVkOiBsb2NrRW5hYmxlZCB9KTtcblxuICBjb25zdCB0YXJnZXRSZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PiA9IChlbGVtZW50KSA9PiB7XG4gICAgc2V0U2Nyb2xsQ2FwdHVyZVRhcmdldChlbGVtZW50KTtcbiAgICBzZXRTY3JvbGxMb2NrVGFyZ2V0KGVsZW1lbnQpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPEZyYWdtZW50PlxuICAgICAge2xvY2tFbmFibGVkICYmIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIG9uQ2xpY2s9e2JsdXJTZWxlY3RJbnB1dH1cbiAgICAgICAgICBjc3M9e3sgcG9zaXRpb246ICdmaXhlZCcsIGxlZnQ6IDAsIGJvdHRvbTogMCwgcmlnaHQ6IDAsIHRvcDogMCB9fVxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICAgIHtjaGlsZHJlbih0YXJnZXRSZWYpfVxuICAgIDwvRnJhZ21lbnQ+XG4gICk7XG59XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__$1
};
function ScrollManager(_ref3) {
  var children = _ref3.children, lockEnabled = _ref3.lockEnabled, _ref$captureEnabled = _ref3.captureEnabled, captureEnabled = _ref$captureEnabled === void 0 ? true : _ref$captureEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var setScrollCaptureTarget = useScrollCapture({
    isEnabled: captureEnabled,
    onBottomArrive,
    onBottomLeave,
    onTopArrive,
    onTopLeave
  });
  var setScrollLockTarget = useScrollLock({
    isEnabled: lockEnabled
  });
  var targetRef = function targetRef2(element) {
    setScrollCaptureTarget(element);
    setScrollLockTarget(element);
  };
  return jsx(b, null, lockEnabled && jsx("div", {
    onClick: blurSelectInput,
    css: _ref2$1
  }), children(targetRef));
}
function _EMOTION_STRINGIFIED_CSS_ERROR__2() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref22 = false ? {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
} : {
  name: "5kkxb2-requiredInput-RequiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%;label:RequiredInput;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJlcXVpcmVkSW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNJIiwiZmlsZSI6IlJlcXVpcmVkSW5wdXQudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyBGb2N1c0V2ZW50SGFuZGxlciwgRnVuY3Rpb25Db21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmNvbnN0IFJlcXVpcmVkSW5wdXQ6IEZ1bmN0aW9uQ29tcG9uZW50PHtcbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcbiAgcmVhZG9ubHkgb25Gb2N1czogRm9jdXNFdmVudEhhbmRsZXI8SFRNTElucHV0RWxlbWVudD47XG59PiA9ICh7IG5hbWUsIG9uRm9jdXMgfSkgPT4gKFxuICA8aW5wdXRcbiAgICByZXF1aXJlZFxuICAgIG5hbWU9e25hbWV9XG4gICAgdGFiSW5kZXg9ey0xfVxuICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgb25Gb2N1cz17b25Gb2N1c31cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAncmVxdWlyZWRJbnB1dCcsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgIH19XG4gICAgLy8gUHJldmVudCBgU3dpdGNoaW5nIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWRgIGVycm9yXG4gICAgdmFsdWU9XCJcIlxuICAgIG9uQ2hhbmdlPXsoKSA9PiB7fX1cbiAgLz5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFJlcXVpcmVkSW5wdXQ7XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__2
};
var RequiredInput = function RequiredInput2(_ref3) {
  var name = _ref3.name, onFocus2 = _ref3.onFocus;
  return jsx("input", {
    required: true,
    name,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: onFocus2,
    css: _ref22,
    value: "",
    onChange: function onChange3() {
    }
  });
};
var RequiredInput$1 = RequiredInput;
function testPlatform(re) {
  var _window$navigator$use;
  return typeof window !== "undefined" && window.navigator != null ? re.test(((_window$navigator$use = window.navigator["userAgentData"]) === null || _window$navigator$use === void 0 ? void 0 : _window$navigator$use.platform) || window.navigator.platform) : false;
}
function isIPhone() {
  return testPlatform(/^iPhone/i);
}
function isMac() {
  return testPlatform(/^Mac/i);
}
function isIPad() {
  return testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  isMac() && navigator.maxTouchPoints > 1;
}
function isIOS() {
  return isIPhone() || isIPad();
}
function isAppleDevice() {
  return isMac() || isIOS();
}
var formatGroupLabel = function formatGroupLabel2(group) {
  return group.label;
};
var getOptionLabel$1 = function getOptionLabel(option) {
  return option.label;
};
var getOptionValue$1 = function getOptionValue(option) {
  return option.value;
};
var isOptionDisabled = function isOptionDisabled2(option) {
  return !!option.isDisabled;
};
var defaultStyles = {
  clearIndicator: clearIndicatorCSS,
  container: containerCSS,
  control: css$1,
  dropdownIndicator: dropdownIndicatorCSS,
  group: groupCSS,
  groupHeading: groupHeadingCSS,
  indicatorsContainer: indicatorsContainerCSS,
  indicatorSeparator: indicatorSeparatorCSS,
  input: inputCSS,
  loadingIndicator: loadingIndicatorCSS,
  loadingMessage: loadingMessageCSS,
  menu: menuCSS,
  menuList: menuListCSS,
  menuPortal: menuPortalCSS,
  multiValue: multiValueCSS,
  multiValueLabel: multiValueLabelCSS,
  multiValueRemove: multiValueRemoveCSS,
  noOptionsMessage: noOptionsMessageCSS,
  option: optionCSS,
  placeholder: placeholderCSS,
  singleValue: css3,
  valueContainer: valueContainerCSS
};
var colors = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
};
var borderRadius = 4;
var baseUnit = 4;
var controlHeight = 38;
var menuGutter = baseUnit * 2;
var spacing = {
  baseUnit,
  controlHeight,
  menuGutter
};
var defaultTheme = {
  borderRadius,
  colors,
  spacing
};
var defaultProps = {
  "aria-live": "polite",
  backspaceRemovesValue: true,
  blurInputOnSelect: isTouchCapable(),
  captureMenuScroll: !isTouchCapable(),
  classNames: {},
  closeMenuOnSelect: true,
  closeMenuOnScroll: false,
  components: {},
  controlShouldRenderValue: true,
  escapeClearsValue: false,
  filterOption: createFilter(),
  formatGroupLabel,
  getOptionLabel: getOptionLabel$1,
  getOptionValue: getOptionValue$1,
  isDisabled: false,
  isLoading: false,
  isMulti: false,
  isRtl: false,
  isSearchable: true,
  isOptionDisabled,
  loadingMessage: function loadingMessage() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: false,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: false,
  menuShouldScrollIntoView: !isMobileDevice(),
  noOptionsMessage: function noOptionsMessage() {
    return "No options";
  },
  openMenuOnFocus: false,
  openMenuOnClick: true,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function screenReaderStatus(_ref3) {
    var count = _ref3.count;
    return "".concat(count, " result").concat(count !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: true,
  unstyled: false
};
function toCategorizedOption(props, option, selectValue, index2) {
  var isDisabled = _isOptionDisabled(props, option, selectValue);
  var isSelected = _isOptionSelected(props, option, selectValue);
  var label = getOptionLabel2(props, option);
  var value = getOptionValue2(props, option);
  return {
    type: "option",
    data: option,
    isDisabled,
    isSelected,
    label,
    value,
    index: index2
  };
}
function buildCategorizedOptions(props, selectValue) {
  return props.options.map(function(groupOrOption, groupOrOptionIndex) {
    if ("options" in groupOrOption) {
      var categorizedOptions = groupOrOption.options.map(function(option, optionIndex) {
        return toCategorizedOption(props, option, selectValue, optionIndex);
      }).filter(function(categorizedOption2) {
        return isFocusable(props, categorizedOption2);
      });
      return categorizedOptions.length > 0 ? {
        type: "group",
        data: groupOrOption,
        options: categorizedOptions,
        index: groupOrOptionIndex
      } : void 0;
    }
    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
    return isFocusable(props, categorizedOption) ? categorizedOption : void 0;
  }).filter(notNullish);
}
function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
  return categorizedOptions.reduce(function(optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === "group") {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function(option) {
        return option.data;
      })));
    } else {
      optionsAccumulator.push(categorizedOption.data);
    }
    return optionsAccumulator;
  }, []);
}
function buildFocusableOptionsWithIds(categorizedOptions, optionId) {
  return categorizedOptions.reduce(function(optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === "group") {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function(option) {
        return {
          data: option.data,
          id: "".concat(optionId, "-").concat(categorizedOption.index, "-").concat(option.index)
        };
      })));
    } else {
      optionsAccumulator.push({
        data: categorizedOption.data,
        id: "".concat(optionId, "-").concat(categorizedOption.index)
      });
    }
    return optionsAccumulator;
  }, []);
}
function buildFocusableOptions(props, selectValue) {
  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
}
function isFocusable(props, categorizedOption) {
  var _props$inputValue = props.inputValue, inputValue = _props$inputValue === void 0 ? "" : _props$inputValue;
  var data = categorizedOption.data, isSelected = categorizedOption.isSelected, label = categorizedOption.label, value = categorizedOption.value;
  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
    label,
    value,
    data
  }, inputValue);
}
function getNextFocusedValue(state2, nextSelectValue) {
  var focusedValue = state2.focusedValue, lastSelectValue = state2.selectValue;
  var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
  if (lastFocusedIndex > -1) {
    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
    if (nextFocusedIndex > -1) {
      return focusedValue;
    } else if (lastFocusedIndex < nextSelectValue.length) {
      return nextSelectValue[lastFocusedIndex];
    }
  }
  return null;
}
function getNextFocusedOption(state2, options2) {
  var lastFocusedOption = state2.focusedOption;
  return lastFocusedOption && options2.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options2[0];
}
var getFocusedOptionId = function getFocusedOptionId2(focusableOptionsWithIds, focusedOption) {
  var _focusableOptionsWith;
  var focusedOptionId = (_focusableOptionsWith = focusableOptionsWithIds.find(function(option) {
    return option.data === focusedOption;
  })) === null || _focusableOptionsWith === void 0 ? void 0 : _focusableOptionsWith.id;
  return focusedOptionId || null;
};
var getOptionLabel2 = function getOptionLabel3(props, data) {
  return props.getOptionLabel(data);
};
var getOptionValue2 = function getOptionValue3(props, data) {
  return props.getOptionValue(data);
};
function _isOptionDisabled(props, option, selectValue) {
  return typeof props.isOptionDisabled === "function" ? props.isOptionDisabled(option, selectValue) : false;
}
function _isOptionSelected(props, option, selectValue) {
  if (selectValue.indexOf(option) > -1) return true;
  if (typeof props.isOptionSelected === "function") {
    return props.isOptionSelected(option, selectValue);
  }
  var candidate = getOptionValue2(props, option);
  return selectValue.some(function(i4) {
    return getOptionValue2(props, i4) === candidate;
  });
}
function _filterOption(props, option, inputValue) {
  return props.filterOption ? props.filterOption(option, inputValue) : true;
}
var shouldHideSelectedOptions = function shouldHideSelectedOptions2(props) {
  var hideSelectedOptions = props.hideSelectedOptions, isMulti = props.isMulti;
  if (hideSelectedOptions === void 0) return isMulti;
  return hideSelectedOptions;
};
var instanceId = 1;
var Select = /* @__PURE__ */ function(_Component) {
  _inherits(Select2, _Component);
  var _super = _createSuper(Select2);
  function Select2(_props) {
    var _this;
    _classCallCheck(this, Select2);
    _this = _super.call(this, _props);
    _this.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedOptionId: null,
      focusableOptionsWithIds: [],
      focusedValue: null,
      inputIsHidden: false,
      isFocused: false,
      selectValue: [],
      clearFocusValueOnUpdate: false,
      prevWasFocused: false,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0,
      instancePrefix: ""
    };
    _this.blockOptionHover = false;
    _this.isComposing = false;
    _this.commonProps = void 0;
    _this.initialTouchX = 0;
    _this.initialTouchY = 0;
    _this.openAfterFocus = false;
    _this.scrollToFocusedOptionOnUpdate = false;
    _this.userIsDragging = void 0;
    _this.isAppleDevice = isAppleDevice();
    _this.controlRef = null;
    _this.getControlRef = function(ref) {
      _this.controlRef = ref;
    };
    _this.focusedOptionRef = null;
    _this.getFocusedOptionRef = function(ref) {
      _this.focusedOptionRef = ref;
    };
    _this.menuListRef = null;
    _this.getMenuListRef = function(ref) {
      _this.menuListRef = ref;
    };
    _this.inputRef = null;
    _this.getInputRef = function(ref) {
      _this.inputRef = ref;
    };
    _this.focus = _this.focusInput;
    _this.blur = _this.blurInput;
    _this.onChange = function(newValue, actionMeta) {
      var _this$props = _this.props, onChange3 = _this$props.onChange, name = _this$props.name;
      actionMeta.name = name;
      _this.ariaOnChange(newValue, actionMeta);
      onChange3(newValue, actionMeta);
    };
    _this.setValue = function(newValue, action, option) {
      var _this$props2 = _this.props, closeMenuOnSelect = _this$props2.closeMenuOnSelect, isMulti = _this$props2.isMulti, inputValue = _this$props2.inputValue;
      _this.onInputChange("", {
        action: "set-value",
        prevInputValue: inputValue
      });
      if (closeMenuOnSelect) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      }
      _this.setState({
        clearFocusValueOnUpdate: true
      });
      _this.onChange(newValue, {
        action,
        option
      });
    };
    _this.selectOption = function(newValue) {
      var _this$props3 = _this.props, blurInputOnSelect = _this$props3.blurInputOnSelect, isMulti = _this$props3.isMulti, name = _this$props3.name;
      var selectValue = _this.state.selectValue;
      var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);
      var isDisabled = _this.isOptionDisabled(newValue, selectValue);
      if (deselected) {
        var candidate = _this.getOptionValue(newValue);
        _this.setValue(multiValueAsValue(selectValue.filter(function(i4) {
          return _this.getOptionValue(i4) !== candidate;
        })), "deselect-option", newValue);
      } else if (!isDisabled) {
        if (isMulti) {
          _this.setValue(multiValueAsValue([].concat(_toConsumableArray(selectValue), [newValue])), "select-option", newValue);
        } else {
          _this.setValue(singleValueAsValue(newValue), "select-option");
        }
      } else {
        _this.ariaOnChange(singleValueAsValue(newValue), {
          action: "select-option",
          option: newValue,
          name
        });
        return;
      }
      if (blurInputOnSelect) {
        _this.blurInput();
      }
    };
    _this.removeValue = function(removedValue) {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var candidate = _this.getOptionValue(removedValue);
      var newValueArray = selectValue.filter(function(i4) {
        return _this.getOptionValue(i4) !== candidate;
      });
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "remove-value",
        removedValue
      });
      _this.focusInput();
    };
    _this.clearValue = function() {
      var selectValue = _this.state.selectValue;
      _this.onChange(valueTernary(_this.props.isMulti, [], null), {
        action: "clear",
        removedValues: selectValue
      });
    };
    _this.popValue = function() {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var lastSelectedValue = selectValue[selectValue.length - 1];
      var newValueArray = selectValue.slice(0, selectValue.length - 1);
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      if (lastSelectedValue) {
        _this.onChange(newValue, {
          action: "pop-value",
          removedValue: lastSelectedValue
        });
      }
    };
    _this.getFocusedOptionId = function(focusedOption) {
      return getFocusedOptionId(_this.state.focusableOptionsWithIds, focusedOption);
    };
    _this.getFocusableOptionsWithIds = function() {
      return buildFocusableOptionsWithIds(buildCategorizedOptions(_this.props, _this.state.selectValue), _this.getElementId("option"));
    };
    _this.getValue = function() {
      return _this.state.selectValue;
    };
    _this.cx = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return classNames.apply(void 0, [_this.props.classNamePrefix].concat(args));
    };
    _this.getOptionLabel = function(data) {
      return getOptionLabel2(_this.props, data);
    };
    _this.getOptionValue = function(data) {
      return getOptionValue2(_this.props, data);
    };
    _this.getStyles = function(key, props) {
      var unstyled = _this.props.unstyled;
      var base = defaultStyles[key](props, unstyled);
      base.boxSizing = "border-box";
      var custom2 = _this.props.styles[key];
      return custom2 ? custom2(base, props) : base;
    };
    _this.getClassNames = function(key, props) {
      var _this$props$className, _this$props$className2;
      return (_this$props$className = (_this$props$className2 = _this.props.classNames)[key]) === null || _this$props$className === void 0 ? void 0 : _this$props$className.call(_this$props$className2, props);
    };
    _this.getElementId = function(element) {
      return "".concat(_this.state.instancePrefix, "-").concat(element);
    };
    _this.getComponents = function() {
      return defaultComponents(_this.props);
    };
    _this.buildCategorizedOptions = function() {
      return buildCategorizedOptions(_this.props, _this.state.selectValue);
    };
    _this.getCategorizedOptions = function() {
      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
    };
    _this.buildFocusableOptions = function() {
      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
    };
    _this.getFocusableOptions = function() {
      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
    };
    _this.ariaOnChange = function(value, actionMeta) {
      _this.setState({
        ariaSelection: _objectSpread2({
          value
        }, actionMeta)
      });
    };
    _this.onMenuMouseDown = function(event) {
      if (event.button !== 0) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      _this.focusInput();
    };
    _this.onMenuMouseMove = function(event) {
      _this.blockOptionHover = false;
    };
    _this.onControlMouseDown = function(event) {
      if (event.defaultPrevented) {
        return;
      }
      var openMenuOnClick = _this.props.openMenuOnClick;
      if (!_this.state.isFocused) {
        if (openMenuOnClick) {
          _this.openAfterFocus = true;
        }
        _this.focusInput();
      } else if (!_this.props.menuIsOpen) {
        if (openMenuOnClick) {
          _this.openMenu("first");
        }
      } else {
        if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
          _this.onMenuClose();
        }
      }
      if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
        event.preventDefault();
      }
    };
    _this.onDropdownIndicatorMouseDown = function(event) {
      if (event && event.type === "mousedown" && event.button !== 0) {
        return;
      }
      if (_this.props.isDisabled) return;
      var _this$props4 = _this.props, isMulti = _this$props4.isMulti, menuIsOpen = _this$props4.menuIsOpen;
      _this.focusInput();
      if (menuIsOpen) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      } else {
        _this.openMenu("first");
      }
      event.preventDefault();
    };
    _this.onClearIndicatorMouseDown = function(event) {
      if (event && event.type === "mousedown" && event.button !== 0) {
        return;
      }
      _this.clearValue();
      event.preventDefault();
      _this.openAfterFocus = false;
      if (event.type === "touchend") {
        _this.focusInput();
      } else {
        setTimeout(function() {
          return _this.focusInput();
        });
      }
    };
    _this.onScroll = function(event) {
      if (typeof _this.props.closeMenuOnScroll === "boolean") {
        if (event.target instanceof HTMLElement && isDocumentElement(event.target)) {
          _this.props.onMenuClose();
        }
      } else if (typeof _this.props.closeMenuOnScroll === "function") {
        if (_this.props.closeMenuOnScroll(event)) {
          _this.props.onMenuClose();
        }
      }
    };
    _this.onCompositionStart = function() {
      _this.isComposing = true;
    };
    _this.onCompositionEnd = function() {
      _this.isComposing = false;
    };
    _this.onTouchStart = function(_ref23) {
      var touches = _ref23.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      _this.initialTouchX = touch.clientX;
      _this.initialTouchY = touch.clientY;
      _this.userIsDragging = false;
    };
    _this.onTouchMove = function(_ref3) {
      var touches = _ref3.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
      var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
      var moveThreshold = 5;
      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
    };
    _this.onTouchEnd = function(event) {
      if (_this.userIsDragging) return;
      if (_this.controlRef && !_this.controlRef.contains(event.target) && _this.menuListRef && !_this.menuListRef.contains(event.target)) {
        _this.blurInput();
      }
      _this.initialTouchX = 0;
      _this.initialTouchY = 0;
    };
    _this.onControlTouchEnd = function(event) {
      if (_this.userIsDragging) return;
      _this.onControlMouseDown(event);
    };
    _this.onClearIndicatorTouchEnd = function(event) {
      if (_this.userIsDragging) return;
      _this.onClearIndicatorMouseDown(event);
    };
    _this.onDropdownIndicatorTouchEnd = function(event) {
      if (_this.userIsDragging) return;
      _this.onDropdownIndicatorMouseDown(event);
    };
    _this.handleInputChange = function(event) {
      var prevInputValue = _this.props.inputValue;
      var inputValue = event.currentTarget.value;
      _this.setState({
        inputIsHiddenAfterUpdate: false
      });
      _this.onInputChange(inputValue, {
        action: "input-change",
        prevInputValue
      });
      if (!_this.props.menuIsOpen) {
        _this.onMenuOpen();
      }
    };
    _this.onInputFocus = function(event) {
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
      _this.setState({
        inputIsHiddenAfterUpdate: false,
        isFocused: true
      });
      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
        _this.openMenu("first");
      }
      _this.openAfterFocus = false;
    };
    _this.onInputBlur = function(event) {
      var prevInputValue = _this.props.inputValue;
      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();
        return;
      }
      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
      _this.onInputChange("", {
        action: "input-blur",
        prevInputValue
      });
      _this.onMenuClose();
      _this.setState({
        focusedValue: null,
        isFocused: false
      });
    };
    _this.onOptionHover = function(focusedOption) {
      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
        return;
      }
      var options2 = _this.getFocusableOptions();
      var focusedOptionIndex = options2.indexOf(focusedOption);
      _this.setState({
        focusedOption,
        focusedOptionId: focusedOptionIndex > -1 ? _this.getFocusedOptionId(focusedOption) : null
      });
    };
    _this.shouldHideSelectedOptions = function() {
      return shouldHideSelectedOptions(_this.props);
    };
    _this.onValueInputFocus = function(e3) {
      e3.preventDefault();
      e3.stopPropagation();
      _this.focus();
    };
    _this.onKeyDown = function(event) {
      var _this$props5 = _this.props, isMulti = _this$props5.isMulti, backspaceRemovesValue = _this$props5.backspaceRemovesValue, escapeClearsValue = _this$props5.escapeClearsValue, inputValue = _this$props5.inputValue, isClearable = _this$props5.isClearable, isDisabled = _this$props5.isDisabled, menuIsOpen = _this$props5.menuIsOpen, onKeyDown = _this$props5.onKeyDown, tabSelectsValue = _this$props5.tabSelectsValue, openMenuOnFocus = _this$props5.openMenuOnFocus;
      var _this$state = _this.state, focusedOption = _this$state.focusedOption, focusedValue = _this$state.focusedValue, selectValue = _this$state.selectValue;
      if (isDisabled) return;
      if (typeof onKeyDown === "function") {
        onKeyDown(event);
        if (event.defaultPrevented) {
          return;
        }
      }
      _this.blockOptionHover = true;
      switch (event.key) {
        case "ArrowLeft":
          if (!isMulti || inputValue) return;
          _this.focusValue("previous");
          break;
        case "ArrowRight":
          if (!isMulti || inputValue) return;
          _this.focusValue("next");
          break;
        case "Delete":
        case "Backspace":
          if (inputValue) return;
          if (focusedValue) {
            _this.removeValue(focusedValue);
          } else {
            if (!backspaceRemovesValue) return;
            if (isMulti) {
              _this.popValue();
            } else if (isClearable) {
              _this.clearValue();
            }
          }
          break;
        case "Tab":
          if (_this.isComposing) return;
          if (event.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption || // don't capture the event if the menu opens on focus and the focused
          // option is already selected; it breaks the flow of navigation
          openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
            return;
          }
          _this.selectOption(focusedOption);
          break;
        case "Enter":
          if (event.keyCode === 229) {
            break;
          }
          if (menuIsOpen) {
            if (!focusedOption) return;
            if (_this.isComposing) return;
            _this.selectOption(focusedOption);
            break;
          }
          return;
        case "Escape":
          if (menuIsOpen) {
            _this.setState({
              inputIsHiddenAfterUpdate: false
            });
            _this.onInputChange("", {
              action: "menu-close",
              prevInputValue: inputValue
            });
            _this.onMenuClose();
          } else if (isClearable && escapeClearsValue) {
            _this.clearValue();
          }
          break;
        case " ":
          if (inputValue) {
            return;
          }
          if (!menuIsOpen) {
            _this.openMenu("first");
            break;
          }
          if (!focusedOption) return;
          _this.selectOption(focusedOption);
          break;
        case "ArrowUp":
          if (menuIsOpen) {
            _this.focusOption("up");
          } else {
            _this.openMenu("last");
          }
          break;
        case "ArrowDown":
          if (menuIsOpen) {
            _this.focusOption("down");
          } else {
            _this.openMenu("first");
          }
          break;
        case "PageUp":
          if (!menuIsOpen) return;
          _this.focusOption("pageup");
          break;
        case "PageDown":
          if (!menuIsOpen) return;
          _this.focusOption("pagedown");
          break;
        case "Home":
          if (!menuIsOpen) return;
          _this.focusOption("first");
          break;
        case "End":
          if (!menuIsOpen) return;
          _this.focusOption("last");
          break;
        default:
          return;
      }
      event.preventDefault();
    };
    _this.state.instancePrefix = "react-select-" + (_this.props.instanceId || ++instanceId);
    _this.state.selectValue = cleanValue(_props.value);
    if (_props.menuIsOpen && _this.state.selectValue.length) {
      var focusableOptionsWithIds = _this.getFocusableOptionsWithIds();
      var focusableOptions = _this.buildFocusableOptions();
      var optionIndex = focusableOptions.indexOf(_this.state.selectValue[0]);
      _this.state.focusableOptionsWithIds = focusableOptionsWithIds;
      _this.state.focusedOption = focusableOptions[optionIndex];
      _this.state.focusedOptionId = getFocusedOptionId(focusableOptionsWithIds, focusableOptions[optionIndex]);
    }
    return _this;
  }
  _createClass(Select2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startListeningComposition();
      this.startListeningToTouch();
      if (this.props.closeMenuOnScroll && document && document.addEventListener) {
        document.addEventListener("scroll", this.onScroll, true);
      }
      if (this.props.autoFocus) {
        this.focusInput();
      }
      if (this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props6 = this.props, isDisabled = _this$props6.isDisabled, menuIsOpen = _this$props6.menuIsOpen;
      var isFocused = this.state.isFocused;
      if (
        // ensure focus is restored correctly when the control becomes enabled
        isFocused && !isDisabled && prevProps.isDisabled || // ensure focus is on the Input when the menu opens
        isFocused && menuIsOpen && !prevProps.menuIsOpen
      ) {
        this.focusInput();
      }
      if (isFocused && isDisabled && !prevProps.isDisabled) {
        this.setState({
          isFocused: false
        }, this.onMenuClose);
      } else if (!isFocused && !isDisabled && prevProps.isDisabled && this.inputRef === document.activeElement) {
        this.setState({
          isFocused: true
        });
      }
      if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
        this.scrollToFocusedOptionOnUpdate = false;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stopListeningComposition();
      this.stopListeningToTouch();
      document.removeEventListener("scroll", this.onScroll, true);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function onMenuOpen() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function onMenuClose() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      });
      this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(newValue, actionMeta) {
      this.props.onInputChange(newValue, actionMeta);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function focusInput() {
      if (!this.inputRef) return;
      this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function blurInput() {
      if (!this.inputRef) return;
      this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function openMenu(focusOption) {
      var _this2 = this;
      var _this$state2 = this.state, selectValue = _this$state2.selectValue, isFocused = _this$state2.isFocused;
      var focusableOptions = this.buildFocusableOptions();
      var openAtIndex = focusOption === "first" ? 0 : focusableOptions.length - 1;
      if (!this.props.isMulti) {
        var selectedIndex = focusableOptions.indexOf(selectValue[0]);
        if (selectedIndex > -1) {
          openAtIndex = selectedIndex;
        }
      }
      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
      this.setState({
        inputIsHiddenAfterUpdate: false,
        focusedValue: null,
        focusedOption: focusableOptions[openAtIndex],
        focusedOptionId: this.getFocusedOptionId(focusableOptions[openAtIndex])
      }, function() {
        return _this2.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function focusValue(direction) {
      var _this$state3 = this.state, selectValue = _this$state3.selectValue, focusedValue = _this$state3.focusedValue;
      if (!this.props.isMulti) return;
      this.setState({
        focusedOption: null
      });
      var focusedIndex = selectValue.indexOf(focusedValue);
      if (!focusedValue) {
        focusedIndex = -1;
      }
      var lastIndex = selectValue.length - 1;
      var nextFocus = -1;
      if (!selectValue.length) return;
      switch (direction) {
        case "previous":
          if (focusedIndex === 0) {
            nextFocus = 0;
          } else if (focusedIndex === -1) {
            nextFocus = lastIndex;
          } else {
            nextFocus = focusedIndex - 1;
          }
          break;
        case "next":
          if (focusedIndex > -1 && focusedIndex < lastIndex) {
            nextFocus = focusedIndex + 1;
          }
          break;
      }
      this.setState({
        inputIsHidden: nextFocus !== -1,
        focusedValue: selectValue[nextFocus]
      });
    }
  }, {
    key: "focusOption",
    value: function focusOption() {
      var direction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first";
      var pageSize = this.props.pageSize;
      var focusedOption = this.state.focusedOption;
      var options2 = this.getFocusableOptions();
      if (!options2.length) return;
      var nextFocus = 0;
      var focusedIndex = options2.indexOf(focusedOption);
      if (!focusedOption) {
        focusedIndex = -1;
      }
      if (direction === "up") {
        nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options2.length - 1;
      } else if (direction === "down") {
        nextFocus = (focusedIndex + 1) % options2.length;
      } else if (direction === "pageup") {
        nextFocus = focusedIndex - pageSize;
        if (nextFocus < 0) nextFocus = 0;
      } else if (direction === "pagedown") {
        nextFocus = focusedIndex + pageSize;
        if (nextFocus > options2.length - 1) nextFocus = options2.length - 1;
      } else if (direction === "last") {
        nextFocus = options2.length - 1;
      }
      this.scrollToFocusedOptionOnUpdate = true;
      this.setState({
        focusedOption: options2[nextFocus],
        focusedValue: null,
        focusedOptionId: this.getFocusedOptionId(options2[nextFocus])
      });
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function getTheme() {
        if (!this.props.theme) {
          return defaultTheme;
        }
        if (typeof this.props.theme === "function") {
          return this.props.theme(defaultTheme);
        }
        return _objectSpread2(_objectSpread2({}, defaultTheme), this.props.theme);
      }
    )
  }, {
    key: "getCommonProps",
    value: function getCommonProps() {
      var clearValue = this.clearValue, cx = this.cx, getStyles = this.getStyles, getClassNames = this.getClassNames, getValue = this.getValue, selectOption = this.selectOption, setValue = this.setValue, props = this.props;
      var isMulti = props.isMulti, isRtl = props.isRtl, options2 = props.options;
      var hasValue = this.hasValue();
      return {
        clearValue,
        cx,
        getStyles,
        getClassNames,
        getValue,
        hasValue,
        isMulti,
        isRtl,
        options: options2,
        selectOption,
        selectProps: props,
        setValue,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function hasValue() {
      var selectValue = this.state.selectValue;
      return selectValue.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function hasOptions() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function isClearable() {
      var _this$props7 = this.props, isClearable2 = _this$props7.isClearable, isMulti = _this$props7.isMulti;
      if (isClearable2 === void 0) return isMulti;
      return isClearable2;
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled3(option, selectValue) {
      return _isOptionDisabled(this.props, option, selectValue);
    }
  }, {
    key: "isOptionSelected",
    value: function isOptionSelected(option, selectValue) {
      return _isOptionSelected(this.props, option, selectValue);
    }
  }, {
    key: "filterOption",
    value: function filterOption(option, inputValue) {
      return _filterOption(this.props, option, inputValue);
    }
  }, {
    key: "formatOptionLabel",
    value: function formatOptionLabel(data, context) {
      if (typeof this.props.formatOptionLabel === "function") {
        var _inputValue = this.props.inputValue;
        var _selectValue = this.state.selectValue;
        return this.props.formatOptionLabel(data, {
          context,
          inputValue: _inputValue,
          selectValue: _selectValue
        });
      } else {
        return this.getOptionLabel(data);
      }
    }
  }, {
    key: "formatGroupLabel",
    value: function formatGroupLabel3(data) {
      return this.props.formatGroupLabel(data);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function startListeningComposition() {
        if (document && document.addEventListener) {
          document.addEventListener("compositionstart", this.onCompositionStart, false);
          document.addEventListener("compositionend", this.onCompositionEnd, false);
        }
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function stopListeningComposition() {
      if (document && document.removeEventListener) {
        document.removeEventListener("compositionstart", this.onCompositionStart);
        document.removeEventListener("compositionend", this.onCompositionEnd);
      }
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function startListeningToTouch() {
        if (document && document.addEventListener) {
          document.addEventListener("touchstart", this.onTouchStart, false);
          document.addEventListener("touchmove", this.onTouchMove, false);
          document.addEventListener("touchend", this.onTouchEnd, false);
        }
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function stopListeningToTouch() {
      if (document && document.removeEventListener) {
        document.removeEventListener("touchstart", this.onTouchStart);
        document.removeEventListener("touchmove", this.onTouchMove);
        document.removeEventListener("touchend", this.onTouchEnd);
      }
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function renderInput() {
        var _this$props8 = this.props, isDisabled = _this$props8.isDisabled, isSearchable = _this$props8.isSearchable, inputId = _this$props8.inputId, inputValue = _this$props8.inputValue, tabIndex = _this$props8.tabIndex, form = _this$props8.form, menuIsOpen = _this$props8.menuIsOpen, required = _this$props8.required;
        var _this$getComponents = this.getComponents(), Input3 = _this$getComponents.Input;
        var _this$state4 = this.state, inputIsHidden = _this$state4.inputIsHidden, ariaSelection = _this$state4.ariaSelection;
        var commonProps = this.commonProps;
        var id2 = inputId || this.getElementId("input");
        var ariaAttributes = _objectSpread2(_objectSpread2(_objectSpread2({
          "aria-autocomplete": "list",
          "aria-expanded": menuIsOpen,
          "aria-haspopup": true,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": required,
          role: "combobox",
          "aria-activedescendant": this.isAppleDevice ? void 0 : this.state.focusedOptionId || ""
        }, menuIsOpen && {
          "aria-controls": this.getElementId("listbox")
        }), !isSearchable && {
          "aria-readonly": true
        }), this.hasValue() ? (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        if (!isSearchable) {
          return /* @__PURE__ */ _(DummyInput, _extends({
            id: id2,
            innerRef: this.getInputRef,
            onBlur: this.onInputBlur,
            onChange: noop,
            onFocus: this.onInputFocus,
            disabled: isDisabled,
            tabIndex,
            inputMode: "none",
            form,
            value: ""
          }, ariaAttributes));
        }
        return /* @__PURE__ */ _(Input3, _extends({}, commonProps, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: id2,
          innerRef: this.getInputRef,
          isDisabled,
          isHidden: inputIsHidden,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex,
          form,
          type: "text",
          value: inputValue
        }, ariaAttributes));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function renderPlaceholderOrValue() {
      var _this3 = this;
      var _this$getComponents2 = this.getComponents(), MultiValue3 = _this$getComponents2.MultiValue, MultiValueContainer2 = _this$getComponents2.MultiValueContainer, MultiValueLabel2 = _this$getComponents2.MultiValueLabel, MultiValueRemove2 = _this$getComponents2.MultiValueRemove, SingleValue3 = _this$getComponents2.SingleValue, Placeholder3 = _this$getComponents2.Placeholder;
      var commonProps = this.commonProps;
      var _this$props9 = this.props, controlShouldRenderValue = _this$props9.controlShouldRenderValue, isDisabled = _this$props9.isDisabled, isMulti = _this$props9.isMulti, inputValue = _this$props9.inputValue, placeholder = _this$props9.placeholder;
      var _this$state5 = this.state, selectValue = _this$state5.selectValue, focusedValue = _this$state5.focusedValue, isFocused = _this$state5.isFocused;
      if (!this.hasValue() || !controlShouldRenderValue) {
        return inputValue ? null : /* @__PURE__ */ _(Placeholder3, _extends({}, commonProps, {
          key: "placeholder",
          isDisabled,
          isFocused,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), placeholder);
      }
      if (isMulti) {
        return selectValue.map(function(opt2, index2) {
          var isOptionFocused = opt2 === focusedValue;
          var key = "".concat(_this3.getOptionLabel(opt2), "-").concat(_this3.getOptionValue(opt2));
          return /* @__PURE__ */ _(MultiValue3, _extends({}, commonProps, {
            components: {
              Container: MultiValueContainer2,
              Label: MultiValueLabel2,
              Remove: MultiValueRemove2
            },
            isFocused: isOptionFocused,
            isDisabled,
            key,
            index: index2,
            removeProps: {
              onClick: function onClick() {
                return _this3.removeValue(opt2);
              },
              onTouchEnd: function onTouchEnd() {
                return _this3.removeValue(opt2);
              },
              onMouseDown: function onMouseDown(e3) {
                e3.preventDefault();
              }
            },
            data: opt2
          }), _this3.formatOptionLabel(opt2, "value"));
        });
      }
      if (inputValue) {
        return null;
      }
      var singleValue = selectValue[0];
      return /* @__PURE__ */ _(SingleValue3, _extends({}, commonProps, {
        data: singleValue,
        isDisabled
      }), this.formatOptionLabel(singleValue, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function renderClearIndicator() {
      var _this$getComponents3 = this.getComponents(), ClearIndicator3 = _this$getComponents3.ClearIndicator;
      var commonProps = this.commonProps;
      var _this$props10 = this.props, isDisabled = _this$props10.isDisabled, isLoading = _this$props10.isLoading;
      var isFocused = this.state.isFocused;
      if (!this.isClearable() || !ClearIndicator3 || isDisabled || !this.hasValue() || isLoading) {
        return null;
      }
      var innerProps = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ _(ClearIndicator3, _extends({}, commonProps, {
        innerProps,
        isFocused
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function renderLoadingIndicator() {
      var _this$getComponents4 = this.getComponents(), LoadingIndicator3 = _this$getComponents4.LoadingIndicator;
      var commonProps = this.commonProps;
      var _this$props11 = this.props, isDisabled = _this$props11.isDisabled, isLoading = _this$props11.isLoading;
      var isFocused = this.state.isFocused;
      if (!LoadingIndicator3 || !isLoading) return null;
      var innerProps = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ _(LoadingIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function renderIndicatorSeparator() {
      var _this$getComponents5 = this.getComponents(), DropdownIndicator3 = _this$getComponents5.DropdownIndicator, IndicatorSeparator3 = _this$getComponents5.IndicatorSeparator;
      if (!DropdownIndicator3 || !IndicatorSeparator3) return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      return /* @__PURE__ */ _(IndicatorSeparator3, _extends({}, commonProps, {
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function renderDropdownIndicator() {
      var _this$getComponents6 = this.getComponents(), DropdownIndicator3 = _this$getComponents6.DropdownIndicator;
      if (!DropdownIndicator3) return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      var innerProps = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ _(DropdownIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this4 = this;
      var _this$getComponents7 = this.getComponents(), Group4 = _this$getComponents7.Group, GroupHeading3 = _this$getComponents7.GroupHeading, Menu4 = _this$getComponents7.Menu, MenuList3 = _this$getComponents7.MenuList, MenuPortal3 = _this$getComponents7.MenuPortal, LoadingMessage3 = _this$getComponents7.LoadingMessage, NoOptionsMessage3 = _this$getComponents7.NoOptionsMessage, Option4 = _this$getComponents7.Option;
      var commonProps = this.commonProps;
      var focusedOption = this.state.focusedOption;
      var _this$props12 = this.props, captureMenuScroll = _this$props12.captureMenuScroll, inputValue = _this$props12.inputValue, isLoading = _this$props12.isLoading, loadingMessage2 = _this$props12.loadingMessage, minMenuHeight = _this$props12.minMenuHeight, maxMenuHeight = _this$props12.maxMenuHeight, menuIsOpen = _this$props12.menuIsOpen, menuPlacement = _this$props12.menuPlacement, menuPosition = _this$props12.menuPosition, menuPortalTarget = _this$props12.menuPortalTarget, menuShouldBlockScroll = _this$props12.menuShouldBlockScroll, menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView, noOptionsMessage2 = _this$props12.noOptionsMessage, onMenuScrollToTop = _this$props12.onMenuScrollToTop, onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
      if (!menuIsOpen) return null;
      var render2 = function render3(props, id2) {
        var type = props.type, data = props.data, isDisabled = props.isDisabled, isSelected = props.isSelected, label = props.label, value = props.value;
        var isFocused = focusedOption === data;
        var onHover = isDisabled ? void 0 : function() {
          return _this4.onOptionHover(data);
        };
        var onSelect = isDisabled ? void 0 : function() {
          return _this4.selectOption(data);
        };
        var optionId = "".concat(_this4.getElementId("option"), "-").concat(id2);
        var innerProps = {
          id: optionId,
          onClick: onSelect,
          onMouseMove: onHover,
          onMouseOver: onHover,
          tabIndex: -1,
          role: "option",
          "aria-selected": _this4.isAppleDevice ? void 0 : isSelected
          // is not supported on Apple devices
        };
        return /* @__PURE__ */ _(Option4, _extends({}, commonProps, {
          innerProps,
          data,
          isDisabled,
          isSelected,
          key: optionId,
          label,
          type,
          value,
          isFocused,
          innerRef: isFocused ? _this4.getFocusedOptionRef : void 0
        }), _this4.formatOptionLabel(props.data, "menu"));
      };
      var menuUI;
      if (this.hasOptions()) {
        menuUI = this.getCategorizedOptions().map(function(item) {
          if (item.type === "group") {
            var _data = item.data, options2 = item.options, groupIndex = item.index;
            var groupId = "".concat(_this4.getElementId("group"), "-").concat(groupIndex);
            var headingId = "".concat(groupId, "-heading");
            return /* @__PURE__ */ _(Group4, _extends({}, commonProps, {
              key: groupId,
              data: _data,
              options: options2,
              Heading: GroupHeading3,
              headingProps: {
                id: headingId,
                data: item.data
              },
              label: _this4.formatGroupLabel(item.data)
            }), item.options.map(function(option) {
              return render2(option, "".concat(groupIndex, "-").concat(option.index));
            }));
          } else if (item.type === "option") {
            return render2(item, "".concat(item.index));
          }
        });
      } else if (isLoading) {
        var message = loadingMessage2({
          inputValue
        });
        if (message === null) return null;
        menuUI = /* @__PURE__ */ _(LoadingMessage3, commonProps, message);
      } else {
        var _message = noOptionsMessage2({
          inputValue
        });
        if (_message === null) return null;
        menuUI = /* @__PURE__ */ _(NoOptionsMessage3, commonProps, _message);
      }
      var menuPlacementProps = {
        minMenuHeight,
        maxMenuHeight,
        menuPlacement,
        menuPosition,
        menuShouldScrollIntoView
      };
      var menuElement = /* @__PURE__ */ _(MenuPlacer, _extends({}, commonProps, menuPlacementProps), function(_ref4) {
        var ref = _ref4.ref, _ref4$placerProps = _ref4.placerProps, placement = _ref4$placerProps.placement, maxHeight = _ref4$placerProps.maxHeight;
        return /* @__PURE__ */ _(Menu4, _extends({}, commonProps, menuPlacementProps, {
          innerRef: ref,
          innerProps: {
            onMouseDown: _this4.onMenuMouseDown,
            onMouseMove: _this4.onMenuMouseMove
          },
          isLoading,
          placement
        }), /* @__PURE__ */ _(ScrollManager, {
          captureEnabled: captureMenuScroll,
          onTopArrive: onMenuScrollToTop,
          onBottomArrive: onMenuScrollToBottom,
          lockEnabled: menuShouldBlockScroll
        }, function(scrollTargetRef) {
          return /* @__PURE__ */ _(MenuList3, _extends({}, commonProps, {
            innerRef: function innerRef(instance) {
              _this4.getMenuListRef(instance);
              scrollTargetRef(instance);
            },
            innerProps: {
              role: "listbox",
              "aria-multiselectable": commonProps.isMulti,
              id: _this4.getElementId("listbox")
            },
            isLoading,
            maxHeight,
            focusedOption
          }), menuUI);
        }));
      });
      return menuPortalTarget || menuPosition === "fixed" ? /* @__PURE__ */ _(MenuPortal3, _extends({}, commonProps, {
        appendTo: menuPortalTarget,
        controlElement: this.controlRef,
        menuPlacement,
        menuPosition
      }), menuElement) : menuElement;
    }
  }, {
    key: "renderFormField",
    value: function renderFormField() {
      var _this5 = this;
      var _this$props13 = this.props, delimiter2 = _this$props13.delimiter, isDisabled = _this$props13.isDisabled, isMulti = _this$props13.isMulti, name = _this$props13.name, required = _this$props13.required;
      var selectValue = this.state.selectValue;
      if (required && !this.hasValue() && !isDisabled) {
        return /* @__PURE__ */ _(RequiredInput$1, {
          name,
          onFocus: this.onValueInputFocus
        });
      }
      if (!name || isDisabled) return;
      if (isMulti) {
        if (delimiter2) {
          var value = selectValue.map(function(opt2) {
            return _this5.getOptionValue(opt2);
          }).join(delimiter2);
          return /* @__PURE__ */ _("input", {
            name,
            type: "hidden",
            value
          });
        } else {
          var input2 = selectValue.length > 0 ? selectValue.map(function(opt2, i4) {
            return /* @__PURE__ */ _("input", {
              key: "i-".concat(i4),
              name,
              type: "hidden",
              value: _this5.getOptionValue(opt2)
            });
          }) : /* @__PURE__ */ _("input", {
            name,
            type: "hidden",
            value: ""
          });
          return /* @__PURE__ */ _("div", null, input2);
        }
      } else {
        var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : "";
        return /* @__PURE__ */ _("input", {
          name,
          type: "hidden",
          value: _value
        });
      }
    }
  }, {
    key: "renderLiveRegion",
    value: function renderLiveRegion() {
      var commonProps = this.commonProps;
      var _this$state6 = this.state, ariaSelection = _this$state6.ariaSelection, focusedOption = _this$state6.focusedOption, focusedValue = _this$state6.focusedValue, isFocused = _this$state6.isFocused, selectValue = _this$state6.selectValue;
      var focusableOptions = this.getFocusableOptions();
      return /* @__PURE__ */ _(LiveRegion$1, _extends({}, commonProps, {
        id: this.getElementId("live-region"),
        ariaSelection,
        focusedOption,
        focusedValue,
        isFocused,
        selectValue,
        focusableOptions,
        isAppleDevice: this.isAppleDevice
      }));
    }
  }, {
    key: "render",
    value: function render2() {
      var _this$getComponents8 = this.getComponents(), Control3 = _this$getComponents8.Control, IndicatorsContainer3 = _this$getComponents8.IndicatorsContainer, SelectContainer3 = _this$getComponents8.SelectContainer, ValueContainer3 = _this$getComponents8.ValueContainer;
      var _this$props14 = this.props, className = _this$props14.className, id2 = _this$props14.id, isDisabled = _this$props14.isDisabled, menuIsOpen = _this$props14.menuIsOpen;
      var isFocused = this.state.isFocused;
      var commonProps = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ _(SelectContainer3, _extends({}, commonProps, {
        className,
        innerProps: {
          id: id2,
          onKeyDown: this.onKeyDown
        },
        isDisabled,
        isFocused
      }), this.renderLiveRegion(), /* @__PURE__ */ _(Control3, _extends({}, commonProps, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled,
        isFocused,
        menuIsOpen
      }), /* @__PURE__ */ _(ValueContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ _(IndicatorsContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state2) {
      var prevProps = state2.prevProps, clearFocusValueOnUpdate = state2.clearFocusValueOnUpdate, inputIsHiddenAfterUpdate = state2.inputIsHiddenAfterUpdate, ariaSelection = state2.ariaSelection, isFocused = state2.isFocused, prevWasFocused = state2.prevWasFocused, instancePrefix = state2.instancePrefix;
      var options2 = props.options, value = props.value, menuIsOpen = props.menuIsOpen, inputValue = props.inputValue, isMulti = props.isMulti;
      var selectValue = cleanValue(value);
      var newMenuOptionsState = {};
      if (prevProps && (value !== prevProps.value || options2 !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
        var focusableOptionsWithIds = menuIsOpen ? buildFocusableOptionsWithIds(buildCategorizedOptions(props, selectValue), "".concat(instancePrefix, "-option")) : [];
        var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state2, selectValue) : null;
        var focusedOption = getNextFocusedOption(state2, focusableOptions);
        var focusedOptionId = getFocusedOptionId(focusableOptionsWithIds, focusedOption);
        newMenuOptionsState = {
          selectValue,
          focusedOption,
          focusedOptionId,
          focusableOptionsWithIds,
          focusedValue,
          clearFocusValueOnUpdate: false
        };
      }
      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
        inputIsHidden: inputIsHiddenAfterUpdate,
        inputIsHiddenAfterUpdate: void 0
      } : {};
      var newAriaSelection = ariaSelection;
      var hasKeptFocus = isFocused && prevWasFocused;
      if (isFocused && !hasKeptFocus) {
        newAriaSelection = {
          value: valueTernary(isMulti, selectValue, selectValue[0] || null),
          options: selectValue,
          action: "initial-input-focus"
        };
        hasKeptFocus = !prevWasFocused;
      }
      if ((ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus") {
        newAriaSelection = null;
      }
      return _objectSpread2(_objectSpread2(_objectSpread2({}, newMenuOptionsState), newInputIsHiddenState), {}, {
        prevProps: props,
        ariaSelection: newAriaSelection,
        prevWasFocused: hasKeptFocus
      });
    }
  }]);
  return Select2;
}(k);
Select.defaultProps = defaultProps;

// node_modules/react-select/dist/react-select.esm.js
var StateManagedSelect = /* @__PURE__ */ w3(function(props, ref) {
  var baseSelectProps = useStateManager(props);
  return /* @__PURE__ */ _(Select, _extends({
    ref
  }, baseSelectProps));
});
var StateManagedSelect$1 = StateManagedSelect;

// src/ui/fields/boolean-field.tsx
function BooleanEditable(props) {
  var _a;
  const [state2, dispatch] = useEditableDispatch({
    content: (_a = props.value) != null ? _a : props.defaultValue,
    updater: props.updater
  });
  const onChange3 = useStableCallback(
    (evt) => {
      let newValue = !evt.currentTarget.hasClass("is-enabled");
      dispatch({ type: "content-changed", newValue });
      dispatch({ type: "commit", newValue });
    },
    [state2.content, state2, props.value]
  );
  return /* @__PURE__ */ u3("div", { onClick: onChange3, className: `checkbox-container${state2.content ? " is-enabled" : ""}`, children: /* @__PURE__ */ u3("input", { type: "checkbox" }) });
}

// src/ui/fields/progress-field.tsx
function ProgressEditable(props) {
  const val = A2(props.content);
  y2(() => {
    props.dispatch({ type: "content-changed", newValue: val.current });
  }, [val.current]);
  const finalize = async () => {
    props.dispatch({
      type: "commit",
      newValue: val.current
    });
  };
  const changeCB = useStableCallback(
    (e3) => {
      finalize();
      val.current = parseFloat(e3.currentTarget.value);
    },
    [val.current, props.sourcePath]
  );
  const readOnly = /* @__PURE__ */ u3("progress", { value: val.current, min: props.min, max: props.max, step: props.step });
  const editor = /* @__PURE__ */ u3("input", { type: "range", className: "datacore-progress-editable", value: val.current, onChange: changeCB });
  return /* @__PURE__ */ u3("span", { className: "has-texteditable", children: /* @__PURE__ */ u3(
    Editable,
    {
      dispatch: props.dispatch,
      editor,
      state: { ...props, content: val.current, isEditing: props.isEditing },
      defaultRender: readOnly
    }
  ) });
}

// src/ui/fields/rating.tsx
function RatingEditable({ value, updater, config: config3, defaultValue }) {
  const [state2, dispatch] = useEditableDispatch({
    content: value != null ? value : defaultValue,
    updater
  });
  const parsedValue = T2(() => {
    if (typeof state2.content == "string") {
      if (state2.content.contains("/")) {
        let split = state2.content.split("/");
        return parseInt(split[0]) / parseInt(split[1]);
      }
    } else if (typeof state2.content == "number") {
      return Math.min(state2.content, 5);
    }
    return 0;
  }, [state2.content]);
  const stars = T2(() => {
    var _a;
    let r4 = [];
    for (let i4 = 0; i4 < ((_a = config3 == null ? void 0 : config3.max) != null ? _a : 5); i4++) {
      let clickCb = useStableCallback(() => {
        var _a2;
        let newValue = null;
        if (typeof state2.content == "string") {
          if (state2.content.contains("/")) {
            newValue = `${i4 + 1}/5`;
          }
        } else if (typeof state2.content == "number") {
          newValue = Math.min(i4 + 1, (_a2 = config3 == null ? void 0 : config3.max) != null ? _a2 : 5);
        }
        dispatch({ type: "content-changed", newValue: newValue || i4 + 1 });
        dispatch({ type: "commit", newValue: newValue || i4 + 1 });
      }, [state2, parsedValue, i4]);
      let classes = ["datacore-rating-star"];
      classes.push(i4 < parsedValue ? "filled" : "empty");
      r4.push(
        /* @__PURE__ */ u3("span", { onClick: clickCb, className: classes.join(" "), children: "\u2605" })
      );
    }
    return r4;
  }, [parsedValue, state2]);
  return /* @__PURE__ */ u3("span", { className: "datacore-rating", children: stars });
}

// src/utils/task.ts
function trimEndingLines(text2) {
  let parts = text2.split(/\r?\n/u);
  let trim2 = parts.length - 1;
  while (trim2 > 0 && parts[trim2].trim() == "") trim2--;
  return parts.join("\n");
}
function setTaskCompletion(task, originalText, useEmojiShorthand, completionKey, completionDateFormat, complete) {
  const blockIdRegex = /\^[a-z0-9\-]+/i;
  if (!complete && !useEmojiShorthand) {
    delete task.$infields[completionKey];
    return trimEndingLines(setInlineField(originalText.trimEnd(), completionKey)).trimEnd();
  }
  let parts = originalText.split(/\r?\n/u);
  const matches = blockIdRegex.exec(parts[parts.length - 1]);
  let processedPart = parts[parts.length - 1].split(blockIdRegex).join("");
  if (useEmojiShorthand) {
    processedPart = setEmojiShorthandCompletionField(
      processedPart,
      complete ? DateTime.now().toFormat("yyyy-MM-dd") : ""
    );
  } else {
    processedPart = setInlineField(processedPart, completionKey, DateTime.now().toFormat(completionDateFormat));
    task.$infields[completionKey] = {
      raw: DateTime.now().toFormat(completionDateFormat),
      value: DateTime.now(),
      key: completionKey,
      position: {
        line: task.$line,
        start: 0,
        startValue: 0,
        end: DateTime.now().toFormat(completionDateFormat).length - 1
      }
    };
  }
  processedPart = `${processedPart.trimEnd()}${(matches == null ? void 0 : matches.length) ? " " + matches[0].trim() : ""}`.trimEnd();
  parts[parts.length - 1] = processedPart.trimStart();
  return parts.join("\n");
}
var LIST_ITEM_REGEX = /^[\s>\t]*(\d+\.|\d+\)|\*|-|\+)\s*(\[.{0,1}\])?\s*(.*)$/mu;
async function rewriteTask(vault, core, task, desiredStatus, desiredText) {
  var _a;
  console.log("CHECKS");
  console.log("status equal?", task instanceof MarkdownTaskItem && desiredStatus == task.$status);
  console.log("text undefined?", desiredText == void 0);
  console.log("same as prev?", desiredText == task.$text);
  console.log("after first");
  desiredStatus = desiredStatus == "" ? " " : desiredStatus;
  const tfile = vault.getFileByPath(task.$file);
  let rawFiletext = await vault.read(tfile);
  let hasRN = rawFiletext.contains("\r");
  let filetext = rawFiletext.split(/\r\n|\r|\n/u);
  if (filetext.length < task.$line) return;
  console.log("after 2nc");
  let match4 = LIST_ITEM_REGEX.exec(filetext[task.$line]);
  if (!match4 || ((_a = match4[2]) == null ? void 0 : _a.length) == 0) return;
  console.log("after 3rd");
  let taskTextParts = task.$text.split("\n");
  const statusPart = task instanceof MarkdownTaskItem ? `[${desiredStatus}]` : "";
  let initialSpacing = /^[\s>]*/u.exec(filetext[task.$line])[0];
  let cnt = 0;
  if (desiredText) {
    let desiredParts = desiredText.split("\n");
    let newTextLines = [`${initialSpacing}${task.$symbol} ${statusPart} ${desiredParts[0]}`].concat(
      desiredParts.slice(1).map((l4) => initialSpacing + "	" + l4.trimStart())
    );
    filetext.splice(task.$line, task.$text.split("\n").length, ...newTextLines);
    cnt = newTextLines.length;
  } else {
    filetext[task.$line] = `${initialSpacing}${task.$symbol} ${statusPart} ${taskTextParts[0].trim()}`;
    cnt = 1;
  }
  let newText = filetext.join(hasRN ? "\r\n" : "\n");
  console.log("before modify");
  try {
    await vault.modify(tfile, newText);
  } catch (e3) {
    console.error(e3);
  }
  console.log(task.$file, "\n", filetext.slice(task.$position.start, task.$position.start + cnt).join("\n"));
  if (tfile) core.reload(tfile);
}
async function completeTask(completed, task, vault, core) {
  const tasksToComplete = [task];
  if (core.settings.recursiveTaskCompletion) {
    const forEach = (x4) => {
      if (x4 instanceof MarkdownTaskItem) tasksToComplete.push(x4);
      x4.$elements.forEach(forEach);
    };
    task.$elements.forEach(forEach);
  }
  for (const t5 of tasksToComplete) {
    let newText = setTaskCompletion(
      t5,
      t5.$text,
      core.settings.taskCompletionUseEmojiShorthand,
      core.settings.taskCompletionText,
      core.settings.defaultDateFormat,
      completed
    );
    await rewriteTask(vault, core, t5, completed ? "x" : " ", newText);
  }
}

// src/index/types/yaml.ts
var YamlConversion;
((YamlConversion2) => {
  function yaml(value) {
    const wrapped = Literals.wrapValue(value);
    if (!wrapped) return null;
    switch (wrapped.type) {
      case "string":
      case "boolean":
      case "null":
      case "number":
        return wrapped.value;
      case "array":
        return wrapped.value.map(yaml);
      case "date":
        return wrapped.value.toISO();
      case "duration":
        return wrapped.value.toHuman();
      case "function":
        return null;
      case "link":
        return wrapped.value.markdown();
      case "object":
        return mapObjectValues(wrapped.value, yaml);
    }
  }
  YamlConversion2.yaml = yaml;
  function literal(value) {
    if (value == null) {
      return null;
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        let result = [];
        for (let child of value) {
          result.push(literal(child));
        }
        return result;
      } else if (value instanceof Date) {
        let dateParse = DateTime.fromJSDate(value);
        return dateParse;
      } else {
        let object = value;
        let result = {};
        for (let key in object) {
          result[key] = literal(object[key]);
        }
        return result;
      }
    } else if (typeof value === "number") {
      return value;
    } else if (typeof value === "boolean") {
      return value;
    } else if (typeof value === "string") {
      let dateParse = PRIMITIVES.date.parse(value);
      if (dateParse.status) return dateParse.value;
      let durationParse = PRIMITIVES.duration.parse(value);
      if (durationParse.status) return durationParse.value;
      let linkParse = PRIMITIVES.link.parse(value);
      if (linkParse.status) return linkParse.value;
      return value;
    }
    return null;
  }
  YamlConversion2.literal = literal;
})(YamlConversion || (YamlConversion = {}));

// src/index/edit/field.ts
async function editProvenance(app, provenance, value) {
  const file = app.vault.getFileByPath(provenance.file);
  if (!file) return Result.failure(`File with path ${provenance.file} does not exist.`);
  switch (provenance.type) {
    case "frontmatter":
      await app.fileManager.processFrontMatter(file, (frontmatter) => {
        if (value == null && provenance.key in frontmatter) {
          delete frontmatter[provenance.key];
        }
        frontmatter[provenance.key] = YamlConversion.yaml(value);
      });
      return Result.success(null);
    case "inline-field":
      return editInlineField(app, file, provenance.line, provenance.key, value);
  }
}
async function editInlineField(app, file, line2, key, value) {
  const content = await app.vault.read(file);
  if (!content) return Result.failure(`File with path ${file.path} does not exist.`);
  const updated = lineReplace(content, line2, line2 + 1, (line3) => {
    if (value == null) return setInlineField(line3, key, void 0);
    else return setInlineField(line3, key, "" + YamlConversion.yaml(value));
  });
  if (updated == content) return Result.success(null);
  await app.vault.modify(file, updated);
  return Result.success(null);
}

// src/utils/fields.ts
function useSetField(field, onChange3) {
  const app = x2(APP_CONTEXT);
  return q2(
    (newValue) => {
      editProvenance(app, field.provenance, newValue).then(() => {
        if (onChange3) onChange3(newValue);
      });
    },
    [field, onChange3]
  );
}
async function setTaskText(app, core, text2, item) {
  let withFields = `${text2}${Object.keys(item.$infields).length ? " " : ""}`;
  for (let field in item.$infields) {
    withFields = setInlineField(withFields, field, item.$infields[field].raw);
  }
  console.log("before");
  await rewriteTask(app.vault, core, item, item.$status, withFields);
  console.log("new text", withFields);
}
function useFinalizer(newValue, dispatch) {
  return async function() {
    dispatch({
      type: "content-changed",
      newValue
    });
    dispatch({
      type: "editing-toggled",
      newValue: false
    });
  };
}

// src/ui/fields/editable.tsx
function editableReducer({ content, updater, ...rest }, action) {
  switch (action.type) {
    case "commit":
      updater(action.newValue);
      return { ...rest, updater, content: action.newValue };
    case "editing-toggled":
      !action.newValue && updater(content);
      return { ...rest, updater, content, isEditing: action.newValue };
    case "content-changed":
      return { ...rest, updater, content: action.newValue };
    default:
      return { content, updater, ...rest };
  }
}
function useEditableDispatch(initial2) {
  const init = T2(() => typeof initial2 == "function" ? initial2() : initial2, [initial2]);
  return p2(editableReducer, init, (s4) => init);
}
function Editable({ sourcePath, defaultRender, editor, dispatch, state: state2 }) {
  const currentRef = A2(null);
  const element = T2(() => {
    if (state2.isEditing) {
      return editor;
    } else {
      if (defaultRender) return defaultRender;
      else return /* @__PURE__ */ u3(Lit, { value: state2.content, inline: true, sourcePath: "" });
    }
  }, [state2.isEditing, state2.content, sourcePath, defaultRender]);
  y2(() => {
    dispatch && dispatch({ type: "content-changed", newValue: state2.content });
  }, [state2.content, state2.isEditing]);
  return /* @__PURE__ */ u3("span", { className: "datacore-editable-outer", ref: currentRef, children: element });
}
function ControlledEditable({
  defaultRender,
  editor: Editor,
  onUpdate,
  content,
  props,
  sourcePath
}) {
  const [state2, dispatch] = useEditableDispatch(() => ({
    updater: onUpdate,
    content,
    inline: false,
    isEditing: false
  }));
  const editor = /* @__PURE__ */ u3(Editor, { dispatch, ...props, ...state2 });
  return /* @__PURE__ */ u3(Editable, { dispatch, editor, sourcePath, state: state2 });
}
function SelectableEditable({
  isEditing,
  content,
  updater,
  config: config3,
  dispatch
}) {
  const onChange3 = useStableCallback(
    (newValue, actionMeta) => {
      if (Array.isArray(newValue)) {
        dispatch({
          type: "content-changed",
          newValue: newValue.map((x4) => x4.value)
        });
      } else {
        dispatch({
          type: "content-changed",
          newValue: newValue.value
        });
      }
    },
    [config3, content, updater, isEditing]
  );
  const editor = T2(() => {
    var _a, _b;
    return /* @__PURE__ */ u3(
      StateManagedSelect$1,
      {
        classNamePrefix: "datacore-selectable",
        onChange: onChange3,
        unstyled: true,
        isMulti: (_a = config3 == null ? void 0 : config3.multi) != null ? _a : false,
        options: (_b = config3 == null ? void 0 : config3.options) != null ? _b : [],
        menuPortalTarget: document.body,
        value: (config3 == null ? void 0 : config3.options.filter(
          (x4) => (Array.isArray(content) ? content : [content]).contains(x4.value)
        )) || [],
        classNames: {
          input: (props) => "prompt-input",
          valueContainer: (props) => "suggestion-item value-container",
          container: (props) => "suggestion-container",
          menu: (props) => "suggestion-content suggestion-container",
          option: (props) => `suggestion-item${props.isSelected ? " is-selected" : ""}`
        }
      }
    );
  }, [content, updater, isEditing, config3]);
  return /* @__PURE__ */ u3(Editable, { editor, dispatch, state: { isEditing, content, updater } });
}
function DateEditable({
  dispatch,
  sourcePath,
  ...rest
}) {
  const [state2, o4] = useEditableDispatch(() => {
    var _a;
    return {
      isEditing: rest.isEditing,
      content: rest.content,
      updater: rest.updater,
      inline: (_a = rest.inline) != null ? _a : false
    };
  });
  const settings = x2(SETTINGS_CONTEXT);
  const onChange3 = (evt) => {
    let v3 = new Date(Date.parse(evt.currentTarget.value));
    dispatch({
      type: "content-changed",
      newValue: !!v3 ? DateTime.fromJSDate(v3).toFormat(settings.defaultDateFormat) : null
    });
    dispatch({
      type: "commit",
      newValue: !!v3 ? DateTime.fromJSDate(v3).toFormat(settings.defaultDateFormat) : null
    });
    o4({
      type: "commit",
      newValue: !!v3 ? DateTime.fromJSDate(v3).toFormat(settings.defaultDateFormat) : null
    });
  };
  const jsDate = T2(() => {
    return state2.content instanceof DateTime ? state2.content : typeof state2.content == "string" && !!state2.content ? DateTime.fromJSDate(new Date(Date.parse(state2.content))) : null;
  }, [state2.content]);
  const editorNode = /* @__PURE__ */ u3("input", { type: "date", onChange: onChange3, value: jsDate == null ? void 0 : jsDate.toFormat("yyyy-MM-dd") });
  return /* @__PURE__ */ u3(Editable, { dispatch, state: rest, editor: editorNode });
}
function NumberEditable(props) {
  const cfc = x2(CURRENT_FILE_CONTEXT);
  const [state2, dispatch] = useEditableDispatch(() => ({
    isEditing: false,
    content: props.content,
    updater: props.updater,
    inline: true
  }));
  const value = A2(props.content);
  const onChangeCb = useStableCallback(
    async (evt) => {
      value.current = parseFloat(evt.currentTarget.value);
    },
    [value.current, state2.content, state2.updater, state2.isEditing]
  );
  const finalize = useFinalizer(value.current, dispatch);
  const onInput = useStableCallback(
    async (e3) => {
      if (e3.key === "Enter") {
        await finalize();
      }
    },
    [value.current, state2.updater, state2.content, state2.isEditing]
  );
  const dblClick = useStableCallback(
    (e3) => {
      dispatch({
        type: "editing-toggled",
        newValue: true
      });
    },
    [value.current, state2.updater, state2.isEditing, state2.content]
  );
  const readonlyEl = /* @__PURE__ */ u3(Lit, { inline: false, sourcePath: cfc, value: value.current });
  const editor = /* @__PURE__ */ u3("input", { className: "datacore-editable", type: "number", onChange: onChangeCb, onKeyUp: onInput });
  return /* @__PURE__ */ u3("span", { className: "has-texteditable", onDblClick: dblClick, children: /* @__PURE__ */ u3(Editable, { dispatch, editor, defaultRender: readonlyEl, state: state2 }) });
}
function TextEditable(props) {
  const cfc = x2(CURRENT_FILE_CONTEXT);
  const [state2, dispatch] = useEditableDispatch(() => {
    var _a;
    return {
      isEditing: props.isEditing,
      content: props.content,
      updater: props.updater,
      inline: (_a = props.inline) != null ? _a : false
    };
  });
  const text2 = A2(props.content);
  y2(() => {
    text2.current = state2.content;
    dispatch({ type: "content-changed", newValue: state2.content });
  }, [props.content, state2.content]);
  const onInput = async (e3) => {
    const finalize = useFinalizer(state2.content, dispatch);
    if (props.inline) {
      if (e3.key === "Enter") {
        await finalize();
      }
    } else {
      if (e3.key === "Enter" && e3.ctrlKey) {
        e3.preventDefault();
        await finalize();
      }
    }
  };
  const dblClick = useStableCallback(
    (e3) => {
      dispatch({
        type: "editing-toggled",
        newValue: !state2.isEditing
      });
    },
    [text2.current, props.sourcePath, state2.updater, state2.isEditing, state2.content]
  );
  const readonlyEl = /* @__PURE__ */ u3(b, { children: props.markdown ? /* @__PURE__ */ u3(Markdown, { content: text2.current, sourcePath: props.sourcePath || cfc, inline: false }) : /* @__PURE__ */ u3(Lit, { inline: false, sourcePath: props.sourcePath || cfc, value: text2.current }) });
  const editor = /* @__PURE__ */ u3(
    UncontrolledTextEditable,
    {
      toggler: dblClick,
      onInput,
      inline: props.inline,
      dispatch,
      text: text2.current
    }
  );
  return /* @__PURE__ */ u3("span", { className: "has-texteditable", onDblClick: dblClick, children: /* @__PURE__ */ u3(Editable, { dispatch, editor, defaultRender: readonlyEl, state: state2 }) });
}
function UncontrolledTextEditable({
  inline: inline2,
  text: text2,
  dispatch,
  onInput,
  toggler
}) {
  const [txt, setText] = h2(text2);
  y2(() => {
    dispatch && dispatch({ newValue: txt, type: "content-changed" });
  }, [txt]);
  const onChangeCb = useStableCallback(
    async (evt) => {
      setText(evt.currentTarget.value);
    },
    [text2, dispatch]
  );
  const handleFocus = (e3) => {
    e3.target.select();
  };
  return !inline2 ? /* @__PURE__ */ u3("textarea", { onDblClick: toggler, className: "datacore-editable", onChange: onChangeCb, onKeyUp: onInput, children: txt }) : /* @__PURE__ */ u3("input", { onDblClick: toggler, className: "datacore-editable", type: "text", onChange: onChangeCb, onKeyUp: onInput, onFocus: handleFocus, autoFocus: true });
}
function EditableListField({
  props,
  field,
  parent,
  type,
  dispatch,
  renderAs,
  config: config3
}) {
  const subEditor = T2(() => {
    switch (renderAs) {
      case "progress":
        return type == "number" ? /* @__PURE__ */ u3(
          ProgressEditable,
          {
            dispatch,
            isEditing: props.isEditing,
            content: props.content,
            updater: props.updater,
            max: (config3 == null ? void 0 : config3.max) || 100,
            sourcePath: parent.$file,
            step: (config3 == null ? void 0 : config3.step) || 0.1,
            min: (config3 == null ? void 0 : config3.min) || 0
          }
        ) : null;
      case "rating":
        return /* @__PURE__ */ u3(
          RatingEditable,
          {
            field,
            file: parent.$file,
            type,
            config: config3,
            value: props.content,
            updater: props.updater
          }
        );
      case "select":
        return /* @__PURE__ */ u3(
          SelectableEditable,
          {
            isEditing: props.isEditing,
            dispatch,
            config: config3,
            updater: props.updater,
            type,
            content: props.content
          }
        );
      default:
        return null;
    }
  }, [parent, field, props.content, props.content, props, config3, renderAs]);
  const editor = T2(() => {
    switch (type) {
      case "date":
        return /* @__PURE__ */ u3(
          DateEditable,
          {
            dispatch,
            sourcePath: parent.$file,
            isEditing: props.isEditing,
            content: props.content,
            updater: props.updater
          }
        );
      case "boolean":
        return /* @__PURE__ */ u3(
          BooleanEditable,
          {
            updater: props.updater,
            type,
            value: props.content,
            field,
            file: parent.$file
          }
        );
      case "string":
        return /* @__PURE__ */ u3(b, { children: subEditor != null ? subEditor : /* @__PURE__ */ u3(
          TextEditable,
          {
            sourcePath: parent.$file,
            isEditing: false,
            content: props.content,
            updater: props.updater
          }
        ) });
      case "number":
        return /* @__PURE__ */ u3(b, { children: subEditor != null ? subEditor : /* @__PURE__ */ u3(NumberEditable, { content: props.content, updater: props.updater }) });
      default:
        return /* @__PURE__ */ u3(
          TextEditable,
          {
            sourcePath: parent.$file,
            isEditing: props.isEditing,
            content: Literals.toString(props.content),
            updater: props.updater
          }
        );
    }
  }, [parent, field, props.content, props.content, props, config3, renderAs, subEditor]);
  const dblclick = useStableCallback(
    (evt) => {
      evt.stopPropagation();
      dispatch({ type: "editing-toggled", newValue: !props.isEditing });
    },
    [props.isEditing]
  );
  return /* @__PURE__ */ u3("div", { className: "datacore-field", children: [
    /* @__PURE__ */ u3("span", { className: "field-title", onDblClick: dblclick, children: field.key }),
    /* @__PURE__ */ u3("span", { className: "field-value", tabIndex: 0, children: editor })
  ] });
}

// src/api/ui/views/list.tsx
function DefaultListElement({ element }) {
  const sourcePath = x2(CURRENT_FILE_CONTEXT);
  return /* @__PURE__ */ u3(Lit, { inline: true, value: element, sourcePath });
}
function EditableListElement({
  element: item,
  editor,
  onUpdate,
  file,
  editorProps
}) {
  return /* @__PURE__ */ u3(
    ControlledEditable,
    {
      props: editorProps,
      sourcePath: file,
      content: item,
      editor: editor(item),
      onUpdate,
      defaultRender: /* @__PURE__ */ u3(DefaultListElement, { element: item })
    }
  );
}

// src/api/ui/views/task.tsx
function TaskList({
  rows: items,
  additionalStates: states,
  renderer: listRenderer = (item, index2) => /* @__PURE__ */ u3(
    EditableListElement,
    {
      onUpdate: useListItemEditing(item, ""),
      element: item.$cleantext,
      file: item.$file,
      editorProps: { markdown: true, sourcePath: item.$file },
      editor: (it) => TextEditable
    }
  ),
  ...rest
}) {
  const content = T2(() => {
    return /* @__PURE__ */ u3("ul", { className: "datacore contains-task-list", children: items == null ? void 0 : items.map(
      (item, ind) => item instanceof MarkdownTaskItem ? /* @__PURE__ */ u3(Task, { state: { ...rest, additionalStates: states }, item }, item.$id) : /* @__PURE__ */ u3("li", { children: [
        listRenderer(item, ind),
        /* @__PURE__ */ u3("div", { className: "datacore-list-item-fields", children: /* @__PURE__ */ u3(ListItemFields, { displayedFields: rest.displayedFields, item }) })
      ] })
    ) });
  }, [items, states]);
  return /* @__PURE__ */ u3(b, { children: !!items && content });
}
function Task({ item, state: props }) {
  const app = x2(APP_CONTEXT);
  const core = x2(DATACORE_CONTEXT);
  const { settings } = core;
  const states = [" ", ...props.additionalStates || [], "x"];
  const nextState = () => {
    var _a;
    if (props.additionalStates && ((_a = props.additionalStates) == null ? void 0 : _a.length) > 0) {
      let curIndex = states.findIndex((a4) => a4 === item.$status);
      curIndex++;
      if (curIndex >= states.length) {
        curIndex = 0;
      }
      return states[curIndex];
    } else {
      return item.$completed ? " " : "x";
    }
  };
  const [status, setStatus] = h2(item.$status);
  const completedRef2 = A2(null);
  const onChecked = useStableCallback(async (evt) => {
    const completed = evt.currentTarget.checked;
    let newStatus;
    if (evt.shiftKey) {
      newStatus = nextState();
    } else {
      newStatus = completed ? "x" : " ";
    }
    setStatus(newStatus);
    await completeTask(completed, item, app.vault, core);
    const nv = completed ? DateTime.now().toFormat(settings.defaultDateFormat) : null;
    completedRef2.current && completedRef2.current({ type: "commit", newValue: nv });
  }, []);
  const checked = T2(() => status !== " ", [item.$status, item, status]);
  const eState = T2(() => {
    return {
      updater: useListItemEditing(item, status),
      content: item.$cleantext,
      inline: false,
      isEditing: false
    };
  }, [item.$cleantext, item.$text]);
  const theElement = T2(
    () => /* @__PURE__ */ u3(TextEditable, { sourcePath: item.$file, ...eState }),
    [eState.content, item, props.rows]
  );
  const [collapsed, setCollapsed] = h2(true);
  const hasChildren = T2(() => item.$elements.length > 0, [item, item.$elements, item.$elements.length]);
  return /* @__PURE__ */ u3(
    "li",
    {
      "data-testid": "datacore-task-item",
      className: "datacore task-list-item" + (checked ? " is-checked" : ""),
      "data-task": status,
      children: [
        /* @__PURE__ */ u3(
          CollapseIndicator,
          {
            onClick: () => setCollapsed((c4) => !c4),
            collapsed,
            hasChildren
          }
        ),
        /* @__PURE__ */ u3(
          "input",
          {
            className: "datacore task-list-item-checkbox",
            type: "checkbox",
            checked,
            onClick: onChecked,
            onChange: (e3) => console.log(e3.currentTarget.value)
          }
        ),
        /* @__PURE__ */ u3("div", { children: /* @__PURE__ */ u3("div", { className: "datacore-list-item-content", children: [
          theElement,
          /* @__PURE__ */ u3("div", { className: "datacore-list-item-fields", children: /* @__PURE__ */ u3(ListItemFields, { displayedFields: props.displayedFields, item }) })
        ] }) }),
        hasChildren && !collapsed && /* @__PURE__ */ u3(TaskList, { ...props, rows: item.$elements })
      ]
    },
    item.$id
  );
}
function CollapseIndicator({
  collapsed,
  onClick,
  hasChildren
}) {
  const toggleCnames = ["datacore-collapser"];
  if (collapsed) toggleCnames.push("is-collapsed");
  if (!hasChildren) toggleCnames.push("no-children");
  return /* @__PURE__ */ u3("div", { onClick, className: toggleCnames.join(" "), dir: "auto", children: /* @__PURE__ */ u3(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      className: "svg-icon right-triangle",
      children: /* @__PURE__ */ u3("path", { d: "M3 8L12 17L21 8" })
    }
  ) });
}
function ListItemFields({
  displayedFields: displayedFieldsProp,
  item
}) {
  const app = x2(APP_CONTEXT);
  const core = x2(DATACORE_CONTEXT);
  const { settings } = core;
  const displayedFields = T2(() => {
    if (displayedFieldsProp != void 0) return displayedFieldsProp;
    else {
      return Object.values(item.$infields).map((f4) => {
        return {
          key: f4.key,
          type: Literals.typeOf(f4.value),
          config: {},
          editable: true,
          renderAs: "raw"
        };
      });
    }
  }, [displayedFieldsProp, item.$infields, item]);
  return /* @__PURE__ */ u3(b, { children: displayedFields.map((ifield) => {
    var _a;
    ifield.key = ifield.key.toLocaleLowerCase();
    let defVal = typeof ifield.defaultValue == "function" ? ifield.defaultValue() : ifield.defaultValue;
    let defField = {
      key: ifield.key,
      value: defVal,
      raw: Literals.toString(defVal)
    };
    const fieldValue = ((_a = item.$infields[ifield == null ? void 0 : ifield.key]) == null ? void 0 : _a.value) || defField.value;
    let [state2, dispatch] = useEditableDispatch(() => ({
      content: fieldValue,
      isEditing: false,
      updater: useStableCallback(
        (val) => {
          var _a2;
          const dateString = (v3) => v3 instanceof DateTime ? v3.toFormat(settings.defaultDateFormat) : v3 != null ? Literals.toString(v3) : void 0;
          let withFields = item.$text;
          if (withFields && item.$text) {
            if (item.$infields[ifield.key]) item.$infields[ifield.key].value = dateString(val);
            for (let field in item.$infields) {
              withFields = setInlineField(
                withFields,
                field,
                dateString((_a2 = item.$infields[field]) == null ? void 0 : _a2.value)
              );
            }
            withFields = setInlineField(item.$text, ifield.key, dateString(val));
            rewriteTask(
              app.vault,
              core,
              item,
              item instanceof MarkdownTaskItem ? item.$status : " ",
              withFields
            );
          }
        },
        [item.$infields]
      )
    }));
    if (ifield.key == settings.taskCompletionText) {
      completedRef.current = dispatch;
    }
    state2 = editableReducer(state2, { type: "content-changed", newValue: fieldValue });
    return /* @__PURE__ */ u3(
      EditableListField,
      {
        props: state2,
        dispatch,
        type: ifield.type || Literals.wrapValue(fieldValue).type,
        file: item.$file,
        field: item.$infields[ifield.key] || defField,
        config: ifield.config,
        parent: item,
        updater: state2.updater,
        value: fieldValue,
        renderAs: ifield.renderAs
      }
    );
  }) });
}
function useListItemEditing(item, status) {
  const app = x2(APP_CONTEXT);
  const core = x2(DATACORE_CONTEXT);
  return useStableCallback(
    async (val) => {
      if (typeof val === "string") {
        let withFields = `${val}${Object.keys(item.$infields).length ? " " : ""}`;
        for (let field in item.$infields) {
          withFields = setInlineField(withFields, field, item.$infields[field].raw);
        }
        console.log("use", withFields);
        await rewriteTask(app.vault, core, item, status, withFields);
      }
    },
    [status, item]
  );
}

// src/api/ui/views/paging.tsx
function RawControlledPager({
  page,
  setPage,
  totalPages
}) {
  totalPages = Math.max(1, totalPages);
  const realPage = clamp(page, 0, totalPages - 1);
  const visiblePages = T2(() => splitPages(realPage, totalPages), [realPage, totalPages]);
  return /* @__PURE__ */ u3("div", { className: "dc-paging-control", children: [
    /* @__PURE__ */ u3(
      "button",
      {
        className: "dc-paging-control-page",
        onClick: () => page != 0 && setPage(page - 1),
        disabled: page == 0,
        children: /* @__PURE__ */ u3(
          "svg",
          {
            "aria-hidden": "true",
            fill: "none",
            focusable: "false",
            height: "1em",
            role: "presentation",
            viewBox: "0 0 24 24",
            width: "1em",
            children: /* @__PURE__ */ u3(
              "path",
              {
                d: "M15.5 19l-7-7 7-7",
                stroke: "currentColor",
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "1.5"
              }
            )
          }
        )
      }
    ),
    visiblePages.map((pages, i4) => /* @__PURE__ */ u3(b, { children: [
      i4 > 0 && /* @__PURE__ */ u3(
        "button",
        {
          className: "dc-paging-control-page dc-paging-control-separator",
          onClick: () => setPage(realPage + (isLeftSeperator(realPage, visiblePages.length, i4) ? -5 : 5)),
          children: [
            /* @__PURE__ */ u3(
              "svg",
              {
                "aria-hidden": "true",
                fill: "none",
                height: "1em",
                "shape-rendering": "geometricPrecision",
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "1.5",
                viewBox: "0 0 24 24",
                width: "1em",
                class: "dc-paging-control-ellipsis",
                children: [
                  /* @__PURE__ */ u3("circle", { cx: "12", cy: "12", fill: "currentColor", r: "1" }),
                  /* @__PURE__ */ u3("circle", { cx: "19", cy: "12", fill: "currentColor", r: "1" }),
                  /* @__PURE__ */ u3("circle", { cx: "5", cy: "12", fill: "currentColor", r: "1" })
                ]
              }
            ),
            /* @__PURE__ */ u3(
              "svg",
              {
                "aria-hidden": "true",
                fill: "none",
                focusable: "false",
                height: "1em",
                role: "presentation",
                "shape-rendering": "geometricPrecision",
                stroke: "currentColor",
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "1.5",
                viewBox: "0 0 24 24",
                width: "1em",
                class: `dc-paging-control-leap-${isLeftSeperator(realPage, visiblePages.length, i4) ? "left" : "right"}`,
                children: [
                  /* @__PURE__ */ u3("path", { d: "M13 17l5-5-5-5" }),
                  /* @__PURE__ */ u3("path", { d: "M6 17l5-5-5-5" })
                ]
              }
            )
          ]
        }
      ),
      pages.map((p3) => /* @__PURE__ */ u3(
        "button",
        {
          className: `dc-paging-control-page ${p3 === realPage ? " dc-paging-control-page-active" : ""}`,
          onClick: (event) => setPage(p3),
          children: p3 + 1
        }
      ))
    ] })),
    /* @__PURE__ */ u3(
      "button",
      {
        className: "dc-paging-control-page",
        onClick: () => page !== totalPages - 1 && setPage(page + 1),
        disabled: page === totalPages - 1,
        children: /* @__PURE__ */ u3(
          "svg",
          {
            "aria-hidden": "true",
            fill: "none",
            focusable: "false",
            height: "1em",
            role: "presentation",
            viewBox: "0 0 24 24",
            width: "1em",
            children: /* @__PURE__ */ u3(
              "path",
              {
                d: "M8.5 5l7 7-7 7",
                stroke: "currentColor",
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "1.5"
              }
            )
          }
        )
      }
    )
  ] });
}
var ControlledPager = xn.memo(RawControlledPager);
function usePaging({
  initialPage = 0,
  pageSize,
  elements
}) {
  const totalPages = Math.max(1, Math.ceil(elements / pageSize));
  const [pageStart, setPageStart] = h2(() => clamp(initialPage, 0, totalPages - 1));
  const setBoundedPage = q2(
    (page2) => setPageStart(clamp(page2, 0, totalPages - 1) * pageSize),
    [pageSize, totalPages]
  );
  const page = clamp(Math.floor(pageStart / pageSize), 0, totalPages - 1);
  return [page, totalPages, setBoundedPage];
}
function useDatacorePaging({
  initialPage = 0,
  paging,
  scrollOnPageChange,
  elements,
  container
}) {
  const settings = x2(SETTINGS_CONTEXT);
  const pageSize = typeof paging === "number" ? paging : settings.defaultPageSize;
  const pagingEnabled = typeof paging === "number" || paging === true;
  const shouldScroll = typeof scrollOnPageChange === "number" && scrollOnPageChange >= pageSize || !!(scrollOnPageChange != null ? scrollOnPageChange : settings.scrollOnPageChange);
  const [page, totalPages, rawSetPage] = usePaging({ initialPage, pageSize, elements });
  const setPage = q2(
    (newPage) => {
      var _a;
      if (page != newPage && container && shouldScroll) {
        (_a = container.current) == null ? void 0 : _a.scrollIntoView({
          behavior: "smooth",
          block: "start",
          inline: "nearest"
        });
      }
      rawSetPage(newPage);
    },
    [page, container, shouldScroll, rawSetPage]
  );
  return { enabled: pagingEnabled, scroll: shouldScroll, page, pageSize, totalPages, setPage };
}
function clamp(input2, min2, max2) {
  if (input2 < min2) return min2;
  if (input2 > max2) return max2;
  return input2;
}
function splitPages(page, totalPages) {
  if (totalPages < 12) return [Array.from({ length: totalPages }, (_3, i4) => i4)];
  if (page < 5)
    return [
      [0, 1, 2, 3, 4, 5, 6, 7],
      [totalPages - 2, totalPages - 1]
    ];
  else if (page > totalPages - 6)
    return [
      [0, 1],
      [
        totalPages - 8,
        totalPages - 7,
        totalPages - 6,
        totalPages - 5,
        totalPages - 4,
        totalPages - 3,
        totalPages - 2,
        totalPages - 1
      ]
    ];
  else
    return [
      [0, 1],
      [page - 2, page - 1, page, page + 1, page + 2],
      [totalPages - 2, totalPages - 1]
    ];
}
function isLeftSeperator(realPage, visiblePagesLength, seperatorIndex) {
  if (visiblePagesLength === 2) {
    if (realPage < 5) {
      return false;
    } else {
      return true;
    }
  } else {
    if (seperatorIndex === 1) {
      return true;
    } else {
      return false;
    }
  }
}

// node_modules/@fortawesome/free-solid-svg-icons/index.mjs
var faSortDown = {
  prefix: "fas",
  iconName: "sort-down",
  icon: [320, 512, ["sort-desc"], "f0dd", "M182.6 470.6c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-9.2-9.2-11.9-22.9-6.9-34.9s16.6-19.8 29.6-19.8l256 0c12.9 0 24.6 7.8 29.6 19.8s2.2 25.7-6.9 34.9l-128 128z"]
};
var faSort = {
  prefix: "fas",
  iconName: "sort",
  icon: [320, 512, ["unsorted"], "f0dc", "M137.4 41.4c12.5-12.5 32.8-12.5 45.3 0l128 128c9.2 9.2 11.9 22.9 6.9 34.9s-16.6 19.8-29.6 19.8L32 224c-12.9 0-24.6-7.8-29.6-19.8s-2.2-25.7 6.9-34.9l128-128zm0 429.3l-128-128c-9.2-9.2-11.9-22.9-6.9-34.9s16.6-19.8 29.6-19.8l256 0c12.9 0 24.6 7.8 29.6 19.8s2.2 25.7-6.9 34.9l-128 128c-12.5 12.5-32.8 12.5-45.3 0z"]
};
var faSortUp = {
  prefix: "fas",
  iconName: "sort-up",
  icon: [320, 512, ["sort-asc"], "f0de", "M182.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-128 128c-9.2 9.2-11.9 22.9-6.9 34.9s16.6 19.8 29.6 19.8l256 0c12.9 0 24.6-7.8 29.6-19.8s2.2-25.7-6.9-34.9l-128-128z"]
};

// node_modules/@fortawesome/fontawesome-svg-core/index.mjs
var noop3 = () => {
};
var _WINDOW = {};
var _DOCUMENT = {};
var _MUTATION_OBSERVER = null;
var _PERFORMANCE = {
  mark: noop3,
  measure: noop3
};
try {
  if (typeof window !== "undefined") _WINDOW = window;
  if (typeof document !== "undefined") _DOCUMENT = document;
  if (typeof MutationObserver !== "undefined") _MUTATION_OBSERVER = MutationObserver;
  if (typeof performance !== "undefined") _PERFORMANCE = performance;
} catch (e3) {
}
var {
  userAgent = ""
} = _WINDOW.navigator || {};
var WINDOW = _WINDOW;
var DOCUMENT = _DOCUMENT;
var MUTATION_OBSERVER = _MUTATION_OBSERVER;
var PERFORMANCE = _PERFORMANCE;
var IS_BROWSER = !!WINDOW.document;
var IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === "function" && typeof DOCUMENT.createElement === "function";
var IS_IE = ~userAgent.indexOf("MSIE") || ~userAgent.indexOf("Trident/");
var a3 = "classic";
var t4 = "duotone";
var r3 = "sharp";
var o3 = "sharp-duotone";
var c3 = [a3, t4, r3, o3];
var et$1 = {
  classic: {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  sharp: {
    900: "fass",
    400: "fasr",
    300: "fasl",
    100: "fast"
  },
  "sharp-duotone": {
    900: "fasds"
  }
};
var bt = {
  kit: {
    fak: "kit",
    "fa-kit": "kit"
  },
  "kit-duotone": {
    fakd: "kit-duotone",
    "fa-kit-duotone": "kit-duotone"
  }
};
var Ct = ["kit"];
var Dt = /fa(s|r|l|t|d|b|k|kd|ss|sr|sl|st|sds)?[\-\ ]/;
var Kt = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i;
var ao = {
  "Font Awesome 5 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 5 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal"
  },
  "Font Awesome 5 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 5 Duotone": {
    900: "fad"
  }
};
var eo = {
  "Font Awesome 6 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 6 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  "Font Awesome 6 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 6 Duotone": {
    900: "fad"
  },
  "Font Awesome 6 Sharp": {
    900: "fass",
    400: "fasr",
    normal: "fasr",
    300: "fasl",
    100: "fast"
  },
  "Font Awesome 6 Sharp Duotone": {
    900: "fasds"
  }
};
var lo = {
  classic: {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
  },
  sharp: {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl",
    "fa-thin": "fast"
  },
  "sharp-duotone": {
    "fa-solid": "fasds"
  }
};
var y3 = {
  classic: ["fas", "far", "fal", "fat"],
  sharp: ["fass", "fasr", "fasl", "fast"],
  "sharp-duotone": ["fasds"]
};
var no = {
  classic: {
    fab: "fa-brands",
    fad: "fa-duotone",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
  },
  sharp: {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light",
    fast: "fa-thin"
  },
  "sharp-duotone": {
    fasds: "fa-solid"
  }
};
var fo = {
  classic: {
    solid: "fas",
    regular: "far",
    light: "fal",
    thin: "fat",
    duotone: "fad",
    brands: "fab"
  },
  sharp: {
    solid: "fass",
    regular: "fasr",
    light: "fasl",
    thin: "fast"
  },
  "sharp-duotone": {
    solid: "fasds"
  }
};
var ho = {
  classic: {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fad: "duotone",
    "fa-duotone": "duotone",
    fab: "brands",
    "fa-brands": "brands"
  },
  sharp: {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light",
    fast: "thin",
    "fa-thin": "thin"
  },
  "sharp-duotone": {
    fa: "solid",
    fasds: "solid",
    "fa-solid": "solid"
  }
};
var x$1 = ["solid", "regular", "light", "thin", "duotone", "brands"];
var u$1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var m$1 = u$1.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);
var t$1 = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
};
var yo = [...Object.keys(y3), ...x$1, "2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", t$1.GROUP, t$1.SWAP_OPACITY, t$1.PRIMARY, t$1.SECONDARY].concat(u$1.map((o4) => "".concat(o4, "x"))).concat(m$1.map((o4) => "w-".concat(o4)));
var mo = {
  "Font Awesome Kit": {
    400: "fak",
    normal: "fak"
  },
  "Font Awesome Kit Duotone": {
    400: "fakd",
    normal: "fakd"
  }
};
var Io = {
  kit: {
    "fa-kit": "fak"
  },
  "kit-duotone": {
    "fa-kit-duotone": "fakd"
  }
};
var Fo = {
  kit: {
    fak: "fa-kit"
  },
  "kit-duotone": {
    fakd: "fa-kit-duotone"
  }
};
var So = {
  kit: {
    kit: "fak"
  },
  "kit-duotone": {
    "kit-duotone": "fakd"
  }
};
var NAMESPACE_IDENTIFIER = "___FONT_AWESOME___";
var UNITS_IN_GRID = 16;
var DEFAULT_CSS_PREFIX = "fa";
var DEFAULT_REPLACEMENT_CLASS = "svg-inline--fa";
var DATA_FA_I2SVG = "data-fa-i2svg";
var DATA_FA_PSEUDO_ELEMENT = "data-fa-pseudo-element";
var DATA_FA_PSEUDO_ELEMENT_PENDING = "data-fa-pseudo-element-pending";
var DATA_PREFIX = "data-prefix";
var DATA_ICON = "data-icon";
var HTML_CLASS_I2SVG_BASE_CLASS = "fontawesome-i2svg";
var MUTATION_APPROACH_ASYNC = "async";
var TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS = ["HTML", "HEAD", "STYLE", "SCRIPT"];
var PRODUCTION = (() => {
  try {
    return false;
  } catch (e$$1) {
    return false;
  }
})();
var FAMILIES = [a3, r3, o3];
function familyProxy(obj) {
  return new Proxy(obj, {
    get(target, prop) {
      return prop in target ? target[prop] : target[a3];
    }
  });
}
var _PREFIX_TO_STYLE = {
  ...ho
};
_PREFIX_TO_STYLE[a3] = {
  ...ho[a3],
  ...bt["kit"],
  ...bt["kit-duotone"]
};
var PREFIX_TO_STYLE = familyProxy(_PREFIX_TO_STYLE);
var _STYLE_TO_PREFIX = {
  ...fo
};
_STYLE_TO_PREFIX[a3] = {
  ..._STYLE_TO_PREFIX[a3],
  ...So["kit"],
  ...So["kit-duotone"]
};
var STYLE_TO_PREFIX = familyProxy(_STYLE_TO_PREFIX);
var _PREFIX_TO_LONG_STYLE = {
  ...no
};
_PREFIX_TO_LONG_STYLE[a3] = {
  ..._PREFIX_TO_LONG_STYLE[a3],
  ...Fo["kit"]
};
var PREFIX_TO_LONG_STYLE = familyProxy(_PREFIX_TO_LONG_STYLE);
var _LONG_STYLE_TO_PREFIX = {
  ...lo
};
_LONG_STYLE_TO_PREFIX[a3] = {
  ..._LONG_STYLE_TO_PREFIX[a3],
  ...Io["kit"]
};
var LONG_STYLE_TO_PREFIX = familyProxy(_LONG_STYLE_TO_PREFIX);
var ICON_SELECTION_SYNTAX_PATTERN = Dt;
var LAYERS_TEXT_CLASSNAME = "fa-layers-text";
var FONT_FAMILY_PATTERN = Kt;
var _FONT_WEIGHT_TO_PREFIX = {
  ...et$1
};
var FONT_WEIGHT_TO_PREFIX = familyProxy(_FONT_WEIGHT_TO_PREFIX);
var ATTRIBUTES_WATCHED_FOR_MUTATION = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"];
var DUOTONE_CLASSES = t$1;
var prefixes = /* @__PURE__ */ new Set();
Object.keys(STYLE_TO_PREFIX[a3]).map(prefixes.add.bind(prefixes));
Object.keys(STYLE_TO_PREFIX[r3]).map(prefixes.add.bind(prefixes));
Object.keys(STYLE_TO_PREFIX[o3]).map(prefixes.add.bind(prefixes));
var RESERVED_CLASSES = [...Ct, ...yo];
var initial = WINDOW.FontAwesomeConfig || {};
function getAttrConfig(attr) {
  var element = DOCUMENT.querySelector("script[" + attr + "]");
  if (element) {
    return element.getAttribute(attr);
  }
}
function coerce(val) {
  if (val === "") return true;
  if (val === "false") return false;
  if (val === "true") return true;
  return val;
}
if (DOCUMENT && typeof DOCUMENT.querySelector === "function") {
  const attrs = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
  attrs.forEach((_ref3) => {
    let [attr, key] = _ref3;
    const val = coerce(getAttrConfig(attr));
    if (val !== void 0 && val !== null) {
      initial[key] = val;
    }
  });
}
var _default = {
  styleDefault: "solid",
  familyDefault: "classic",
  cssPrefix: DEFAULT_CSS_PREFIX,
  replacementClass: DEFAULT_REPLACEMENT_CLASS,
  autoReplaceSvg: true,
  autoAddCss: true,
  autoA11y: true,
  searchPseudoElements: false,
  observeMutations: true,
  mutateApproach: "async",
  keepOriginalSource: true,
  measurePerformance: false,
  showMissingIcons: true
};
if (initial.familyPrefix) {
  initial.cssPrefix = initial.familyPrefix;
}
var _config = {
  ..._default,
  ...initial
};
if (!_config.autoReplaceSvg) _config.observeMutations = false;
var config = {};
Object.keys(_default).forEach((key) => {
  Object.defineProperty(config, key, {
    enumerable: true,
    set: function(val) {
      _config[key] = val;
      _onChangeCb.forEach((cb) => cb(config));
    },
    get: function() {
      return _config[key];
    }
  });
});
Object.defineProperty(config, "familyPrefix", {
  enumerable: true,
  set: function(val) {
    _config.cssPrefix = val;
    _onChangeCb.forEach((cb) => cb(config));
  },
  get: function() {
    return _config.cssPrefix;
  }
});
WINDOW.FontAwesomeConfig = config;
var _onChangeCb = [];
function onChange2(cb) {
  _onChangeCb.push(cb);
  return () => {
    _onChangeCb.splice(_onChangeCb.indexOf(cb), 1);
  };
}
var d$2 = UNITS_IN_GRID;
var meaninglessTransform = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: false,
  flipY: false
};
function insertCss(css6) {
  if (!css6 || !IS_DOM) {
    return;
  }
  const style = DOCUMENT.createElement("style");
  style.setAttribute("type", "text/css");
  style.innerHTML = css6;
  const headChildren = DOCUMENT.head.childNodes;
  let beforeChild = null;
  for (let i4 = headChildren.length - 1; i4 > -1; i4--) {
    const child = headChildren[i4];
    const tagName = (child.tagName || "").toUpperCase();
    if (["STYLE", "LINK"].indexOf(tagName) > -1) {
      beforeChild = child;
    }
  }
  DOCUMENT.head.insertBefore(style, beforeChild);
  return css6;
}
var idPool = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function nextUniqueId() {
  let size2 = 12;
  let id2 = "";
  while (size2-- > 0) {
    id2 += idPool[Math.random() * 62 | 0];
  }
  return id2;
}
function toArray(obj) {
  const array2 = [];
  for (let i4 = (obj || []).length >>> 0; i4--; ) {
    array2[i4] = obj[i4];
  }
  return array2;
}
function classArray(node2) {
  if (node2.classList) {
    return toArray(node2.classList);
  } else {
    return (node2.getAttribute("class") || "").split(" ").filter((i4) => i4);
  }
}
function htmlEscape(str) {
  return "".concat(str).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function joinAttributes(attributes) {
  return Object.keys(attributes || {}).reduce((acc, attributeName) => {
    return acc + "".concat(attributeName, '="').concat(htmlEscape(attributes[attributeName]), '" ');
  }, "").trim();
}
function joinStyles(styles2) {
  return Object.keys(styles2 || {}).reduce((acc, styleName) => {
    return acc + "".concat(styleName, ": ").concat(styles2[styleName].trim(), ";");
  }, "");
}
function transformIsMeaningful(transform2) {
  return transform2.size !== meaninglessTransform.size || transform2.x !== meaninglessTransform.x || transform2.y !== meaninglessTransform.y || transform2.rotate !== meaninglessTransform.rotate || transform2.flipX || transform2.flipY;
}
function transformForSvg(_ref3) {
  let {
    transform: transform2,
    containerWidth,
    iconWidth
  } = _ref3;
  const outer = {
    transform: "translate(".concat(containerWidth / 2, " 256)")
  };
  const innerTranslate = "translate(".concat(transform2.x * 32, ", ").concat(transform2.y * 32, ") ");
  const innerScale = "scale(".concat(transform2.size / 16 * (transform2.flipX ? -1 : 1), ", ").concat(transform2.size / 16 * (transform2.flipY ? -1 : 1), ") ");
  const innerRotate = "rotate(".concat(transform2.rotate, " 0 0)");
  const inner = {
    transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
  };
  const path = {
    transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
  };
  return {
    outer,
    inner,
    path
  };
}
function transformForCss(_ref23) {
  let {
    transform: transform2,
    width = UNITS_IN_GRID,
    height = UNITS_IN_GRID,
    startCentered = false
  } = _ref23;
  let val = "";
  if (startCentered && IS_IE) {
    val += "translate(".concat(transform2.x / d$2 - width / 2, "em, ").concat(transform2.y / d$2 - height / 2, "em) ");
  } else if (startCentered) {
    val += "translate(calc(-50% + ".concat(transform2.x / d$2, "em), calc(-50% + ").concat(transform2.y / d$2, "em)) ");
  } else {
    val += "translate(".concat(transform2.x / d$2, "em, ").concat(transform2.y / d$2, "em) ");
  }
  val += "scale(".concat(transform2.size / d$2 * (transform2.flipX ? -1 : 1), ", ").concat(transform2.size / d$2 * (transform2.flipY ? -1 : 1), ") ");
  val += "rotate(".concat(transform2.rotate, "deg) ");
  return val;
}
var baseStyles = ':root, :host {\n  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Free";\n  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Free";\n  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Pro";\n  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Pro";\n  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";\n  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 6 Sharp Duotone";\n}\n\nsvg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {\n  overflow: visible;\n  box-sizing: content-box;\n}\n\n.svg-inline--fa {\n  display: var(--fa-display, inline-block);\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-2xs {\n  vertical-align: 0.1em;\n}\n.svg-inline--fa.fa-xs {\n  vertical-align: 0em;\n}\n.svg-inline--fa.fa-sm {\n  vertical-align: -0.0714285705em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.2em;\n}\n.svg-inline--fa.fa-xl {\n  vertical-align: -0.25em;\n}\n.svg-inline--fa.fa-2xl {\n  vertical-align: -0.3125em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-li {\n  width: var(--fa-li-width, 2em);\n  top: 0.25em;\n}\n.svg-inline--fa.fa-fw {\n  width: var(--fa-fw-width, 1.25em);\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  transform-origin: center center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: var(--fa-counter-background-color, #ff253a);\n  border-radius: var(--fa-counter-border-radius, 1em);\n  box-sizing: border-box;\n  color: var(--fa-inverse, #fff);\n  line-height: var(--fa-counter-line-height, 1);\n  max-width: var(--fa-counter-max-width, 5em);\n  min-width: var(--fa-counter-min-width, 1.5em);\n  overflow: hidden;\n  padding: var(--fa-counter-padding, 0.25em 0.5em);\n  right: var(--fa-right, 0);\n  text-overflow: ellipsis;\n  top: var(--fa-top, 0);\n  transform: scale(var(--fa-counter-scale, 0.25));\n  transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: var(--fa-bottom, 0);\n  right: var(--fa-right, 0);\n  top: auto;\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: var(--fa-bottom, 0);\n  left: var(--fa-left, 0);\n  right: auto;\n  top: auto;\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  top: var(--fa-top, 0);\n  right: var(--fa-right, 0);\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: var(--fa-left, 0);\n  right: auto;\n  top: var(--fa-top, 0);\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: top left;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-2xs {\n  font-size: 0.625em;\n  line-height: 0.1em;\n  vertical-align: 0.225em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n  line-height: 0.0833333337em;\n  vertical-align: 0.125em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n  line-height: 0.0714285718em;\n  vertical-align: 0.0535714295em;\n}\n\n.fa-lg {\n  font-size: 1.25em;\n  line-height: 0.05em;\n  vertical-align: -0.075em;\n}\n\n.fa-xl {\n  font-size: 1.5em;\n  line-height: 0.0416666682em;\n  vertical-align: -0.125em;\n}\n\n.fa-2xl {\n  font-size: 2em;\n  line-height: 0.03125em;\n  vertical-align: -0.1875em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: var(--fa-li-margin, 2.5em);\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: calc(-1 * var(--fa-li-width, 2em));\n  position: absolute;\n  text-align: center;\n  width: var(--fa-li-width, 2em);\n  line-height: inherit;\n}\n\n.fa-border {\n  border-color: var(--fa-border-color, #eee);\n  border-radius: var(--fa-border-radius, 0.1em);\n  border-style: var(--fa-border-style, solid);\n  border-width: var(--fa-border-width, 0.08em);\n  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);\n}\n\n.fa-pull-left {\n  float: left;\n  margin-right: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-pull-right {\n  float: right;\n  margin-left: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-beat {\n  animation-name: fa-beat;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-bounce {\n  animation-name: fa-bounce;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n}\n\n.fa-fade {\n  animation-name: fa-fade;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-beat-fade {\n  animation-name: fa-beat-fade;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-flip {\n  animation-name: fa-flip;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-shake {\n  animation-name: fa-shake;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin {\n  animation-name: fa-spin;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 2s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin-reverse {\n  --fa-animation-direction: reverse;\n}\n\n.fa-pulse,\n.fa-spin-pulse {\n  animation-name: fa-spin;\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, steps(8));\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .fa-beat,\n.fa-bounce,\n.fa-fade,\n.fa-beat-fade,\n.fa-flip,\n.fa-pulse,\n.fa-shake,\n.fa-spin,\n.fa-spin-pulse {\n    animation-delay: -1ms;\n    animation-duration: 1ms;\n    animation-iteration-count: 1;\n    transition-delay: 0s;\n    transition-duration: 0s;\n  }\n}\n@keyframes fa-beat {\n  0%, 90% {\n    transform: scale(1);\n  }\n  45% {\n    transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@keyframes fa-bounce {\n  0% {\n    transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    transform: scale(1, 1) translateY(0);\n  }\n}\n@keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@keyframes fa-flip {\n  50% {\n    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@keyframes fa-shake {\n  0% {\n    transform: rotate(-15deg);\n  }\n  4% {\n    transform: rotate(15deg);\n  }\n  8%, 24% {\n    transform: rotate(-18deg);\n  }\n  12%, 28% {\n    transform: rotate(18deg);\n  }\n  16% {\n    transform: rotate(-22deg);\n  }\n  20% {\n    transform: rotate(22deg);\n  }\n  32% {\n    transform: rotate(-12deg);\n  }\n  36% {\n    transform: rotate(12deg);\n  }\n  40%, 100% {\n    transform: rotate(0deg);\n  }\n}\n@keyframes fa-spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  transform: scale(1, -1);\n}\n\n.fa-flip-both,\n.fa-flip-horizontal.fa-flip-vertical {\n  transform: scale(-1, -1);\n}\n\n.fa-rotate-by {\n  transform: rotate(var(--fa-rotate-angle, 0));\n}\n\n.fa-stack {\n  display: inline-block;\n  vertical-align: middle;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: var(--fa-stack-z-index, auto);\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}\n\n.sr-only,\n.fa-sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.sr-only-focusable:not(:focus),\n.fa-sr-only-focusable:not(:focus) {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}\n\n.fad.fa-inverse,\n.fa-duotone.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}';
function css5() {
  const dcp = DEFAULT_CSS_PREFIX;
  const drc = DEFAULT_REPLACEMENT_CLASS;
  const fp = config.cssPrefix;
  const rc = config.replacementClass;
  let s4 = baseStyles;
  if (fp !== dcp || rc !== drc) {
    const dPatt = new RegExp("\\.".concat(dcp, "\\-"), "g");
    const customPropPatt = new RegExp("\\--".concat(dcp, "\\-"), "g");
    const rPatt = new RegExp("\\.".concat(drc), "g");
    s4 = s4.replace(dPatt, ".".concat(fp, "-")).replace(customPropPatt, "--".concat(fp, "-")).replace(rPatt, ".".concat(rc));
  }
  return s4;
}
var _cssInserted = false;
function ensureCss() {
  if (config.autoAddCss && !_cssInserted) {
    insertCss(css5());
    _cssInserted = true;
  }
}
var InjectCSS = {
  mixout() {
    return {
      dom: {
        css: css5,
        insertCss: ensureCss
      }
    };
  },
  hooks() {
    return {
      beforeDOMElementCreation() {
        ensureCss();
      },
      beforeI2svg() {
        ensureCss();
      }
    };
  }
};
var w$1 = WINDOW || {};
if (!w$1[NAMESPACE_IDENTIFIER]) w$1[NAMESPACE_IDENTIFIER] = {};
if (!w$1[NAMESPACE_IDENTIFIER].styles) w$1[NAMESPACE_IDENTIFIER].styles = {};
if (!w$1[NAMESPACE_IDENTIFIER].hooks) w$1[NAMESPACE_IDENTIFIER].hooks = {};
if (!w$1[NAMESPACE_IDENTIFIER].shims) w$1[NAMESPACE_IDENTIFIER].shims = [];
var namespace = w$1[NAMESPACE_IDENTIFIER];
var functions = [];
var listener = function() {
  DOCUMENT.removeEventListener("DOMContentLoaded", listener);
  loaded = 1;
  functions.map((fn2) => fn2());
};
var loaded = false;
if (IS_DOM) {
  loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
  if (!loaded) DOCUMENT.addEventListener("DOMContentLoaded", listener);
}
function domready(fn2) {
  if (!IS_DOM) return;
  loaded ? setTimeout(fn2, 0) : functions.push(fn2);
}
function toHtml(abstractNodes) {
  const {
    tag,
    attributes = {},
    children = []
  } = abstractNodes;
  if (typeof abstractNodes === "string") {
    return htmlEscape(abstractNodes);
  } else {
    return "<".concat(tag, " ").concat(joinAttributes(attributes), ">").concat(children.map(toHtml).join(""), "</").concat(tag, ">");
  }
}
function iconFromMapping(mapping, prefix2, iconName) {
  if (mapping && mapping[prefix2] && mapping[prefix2][iconName]) {
    return {
      prefix: prefix2,
      iconName,
      icon: mapping[prefix2][iconName]
    };
  }
}
var bindInternal4 = function bindInternal42(func, thisContext) {
  return function(a4, b3, c4, d3) {
    return func.call(thisContext, a4, b3, c4, d3);
  };
};
var reduce = function fastReduceObject(subject, fn2, initialValue, thisContext) {
  var keys2 = Object.keys(subject), length2 = keys2.length, iterator = thisContext !== void 0 ? bindInternal4(fn2, thisContext) : fn2, i4, key, result;
  if (initialValue === void 0) {
    i4 = 1;
    result = subject[keys2[0]];
  } else {
    i4 = 0;
    result = initialValue;
  }
  for (; i4 < length2; i4++) {
    key = keys2[i4];
    result = iterator(result, subject[key], key, subject);
  }
  return result;
};
function ucs2decode(string2) {
  const output = [];
  let counter2 = 0;
  const length2 = string2.length;
  while (counter2 < length2) {
    const value = string2.charCodeAt(counter2++);
    if (value >= 55296 && value <= 56319 && counter2 < length2) {
      const extra = string2.charCodeAt(counter2++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter2--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function toHex(unicode) {
  const decoded = ucs2decode(unicode);
  return decoded.length === 1 ? decoded[0].toString(16) : null;
}
function codePointAt(string2, index2) {
  const size2 = string2.length;
  let first = string2.charCodeAt(index2);
  let second;
  if (first >= 55296 && first <= 56319 && size2 > index2 + 1) {
    second = string2.charCodeAt(index2 + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function normalizeIcons(icons) {
  return Object.keys(icons).reduce((acc, iconName) => {
    const icon2 = icons[iconName];
    const expanded = !!icon2.icon;
    if (expanded) {
      acc[icon2.iconName] = icon2.icon;
    } else {
      acc[iconName] = icon2;
    }
    return acc;
  }, {});
}
function defineIcons(prefix2, icons) {
  let params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    skipHooks = false
  } = params;
  const normalized = normalizeIcons(icons);
  if (typeof namespace.hooks.addPack === "function" && !skipHooks) {
    namespace.hooks.addPack(prefix2, normalizeIcons(icons));
  } else {
    namespace.styles[prefix2] = {
      ...namespace.styles[prefix2] || {},
      ...normalized
    };
  }
  if (prefix2 === "fas") {
    defineIcons("fa", icons);
  }
}
var {
  styles,
  shims
} = namespace;
var LONG_STYLE = {
  [a3]: Object.values(PREFIX_TO_LONG_STYLE[a3]),
  [r3]: Object.values(PREFIX_TO_LONG_STYLE[r3]),
  [o3]: Object.values(PREFIX_TO_LONG_STYLE[o3])
};
var _defaultUsablePrefix = null;
var _byUnicode = {};
var _byLigature = {};
var _byOldName = {};
var _byOldUnicode = {};
var _byAlias = {};
var PREFIXES = {
  [a3]: Object.keys(PREFIX_TO_STYLE[a3]),
  [r3]: Object.keys(PREFIX_TO_STYLE[r3]),
  [o3]: Object.keys(PREFIX_TO_STYLE[o3])
};
function isReserved(name) {
  return ~RESERVED_CLASSES.indexOf(name);
}
function getIconName(cssPrefix, cls) {
  const parts = cls.split("-");
  const prefix2 = parts[0];
  const iconName = parts.slice(1).join("-");
  if (prefix2 === cssPrefix && iconName !== "" && !isReserved(iconName)) {
    return iconName;
  } else {
    return null;
  }
}
var build = () => {
  const lookup = (reducer) => {
    return reduce(styles, (o$$1, style, prefix2) => {
      o$$1[prefix2] = reduce(style, reducer, {});
      return o$$1;
    }, {});
  };
  _byUnicode = lookup((acc, icon2, iconName) => {
    if (icon2[3]) {
      acc[icon2[3]] = iconName;
    }
    if (icon2[2]) {
      const aliases = icon2[2].filter((a$$1) => {
        return typeof a$$1 === "number";
      });
      aliases.forEach((alias) => {
        acc[alias.toString(16)] = iconName;
      });
    }
    return acc;
  });
  _byLigature = lookup((acc, icon2, iconName) => {
    acc[iconName] = iconName;
    if (icon2[2]) {
      const aliases = icon2[2].filter((a$$1) => {
        return typeof a$$1 === "string";
      });
      aliases.forEach((alias) => {
        acc[alias] = iconName;
      });
    }
    return acc;
  });
  _byAlias = lookup((acc, icon2, iconName) => {
    const aliases = icon2[2];
    acc[iconName] = iconName;
    aliases.forEach((alias) => {
      acc[alias] = iconName;
    });
    return acc;
  });
  const hasRegular = "far" in styles || config.autoFetchSvg;
  const shimLookups = reduce(shims, (acc, shim) => {
    const maybeNameMaybeUnicode = shim[0];
    let prefix2 = shim[1];
    const iconName = shim[2];
    if (prefix2 === "far" && !hasRegular) {
      prefix2 = "fas";
    }
    if (typeof maybeNameMaybeUnicode === "string") {
      acc.names[maybeNameMaybeUnicode] = {
        prefix: prefix2,
        iconName
      };
    }
    if (typeof maybeNameMaybeUnicode === "number") {
      acc.unicodes[maybeNameMaybeUnicode.toString(16)] = {
        prefix: prefix2,
        iconName
      };
    }
    return acc;
  }, {
    names: {},
    unicodes: {}
  });
  _byOldName = shimLookups.names;
  _byOldUnicode = shimLookups.unicodes;
  _defaultUsablePrefix = getCanonicalPrefix(config.styleDefault, {
    family: config.familyDefault
  });
};
onChange2((c$$1) => {
  _defaultUsablePrefix = getCanonicalPrefix(c$$1.styleDefault, {
    family: config.familyDefault
  });
});
build();
function byUnicode(prefix2, unicode) {
  return (_byUnicode[prefix2] || {})[unicode];
}
function byLigature(prefix2, ligature) {
  return (_byLigature[prefix2] || {})[ligature];
}
function byAlias(prefix2, alias) {
  return (_byAlias[prefix2] || {})[alias];
}
function byOldName(name) {
  return _byOldName[name] || {
    prefix: null,
    iconName: null
  };
}
function byOldUnicode(unicode) {
  const oldUnicode = _byOldUnicode[unicode];
  const newUnicode = byUnicode("fas", unicode);
  return oldUnicode || (newUnicode ? {
    prefix: "fas",
    iconName: newUnicode
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function getDefaultUsablePrefix() {
  return _defaultUsablePrefix;
}
var emptyCanonicalIcon = () => {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function getCanonicalPrefix(styleOrPrefix) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    family = a3
  } = params;
  const style = PREFIX_TO_STYLE[family][styleOrPrefix];
  const prefix2 = STYLE_TO_PREFIX[family][styleOrPrefix] || STYLE_TO_PREFIX[family][style];
  const defined = styleOrPrefix in namespace.styles ? styleOrPrefix : null;
  const result = prefix2 || defined || null;
  return result;
}
var PREFIXES_FOR_FAMILY = {
  [a3]: Object.keys(PREFIX_TO_LONG_STYLE[a3]),
  [r3]: Object.keys(PREFIX_TO_LONG_STYLE[r3]),
  [o3]: Object.keys(PREFIX_TO_LONG_STYLE[o3])
};
function getCanonicalIcon(values) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    skipLookups = false
  } = params;
  const famProps = {
    [a3]: "".concat(config.cssPrefix, "-").concat(a3),
    [r3]: "".concat(config.cssPrefix, "-").concat(r3),
    [o3]: "".concat(config.cssPrefix, "-").concat(o3)
  };
  let givenPrefix = null;
  let family = a3;
  const nonDuotoneFamilyIds = c3.filter((familyId) => familyId !== t4);
  nonDuotoneFamilyIds.forEach((familyId) => {
    if (values.includes(famProps[familyId]) || values.some((v$$1) => PREFIXES_FOR_FAMILY[familyId].includes(v$$1))) {
      family = familyId;
    }
  });
  const canonical = values.reduce((acc, cls) => {
    const iconName = getIconName(config.cssPrefix, cls);
    if (styles[cls]) {
      cls = LONG_STYLE[family].includes(cls) ? LONG_STYLE_TO_PREFIX[family][cls] : cls;
      givenPrefix = cls;
      acc.prefix = cls;
    } else if (PREFIXES[family].indexOf(cls) > -1) {
      givenPrefix = cls;
      acc.prefix = getCanonicalPrefix(cls, {
        family
      });
    } else if (iconName) {
      acc.iconName = iconName;
    } else if (cls !== config.replacementClass && !nonDuotoneFamilyIds.some((familyName) => cls === famProps[familyName])) {
      acc.rest.push(cls);
    }
    if (!skipLookups && acc.prefix && acc.iconName) {
      const shim = givenPrefix === "fa" ? byOldName(acc.iconName) : {};
      const aliasIconName = byAlias(acc.prefix, acc.iconName);
      if (shim.prefix) {
        givenPrefix = null;
      }
      acc.iconName = shim.iconName || aliasIconName || acc.iconName;
      acc.prefix = shim.prefix || acc.prefix;
      if (acc.prefix === "far" && !styles["far"] && styles["fas"] && !config.autoFetchSvg) {
        acc.prefix = "fas";
      }
    }
    return acc;
  }, emptyCanonicalIcon());
  if (values.includes("fa-brands") || values.includes("fab")) {
    canonical.prefix = "fab";
  }
  if (values.includes("fa-duotone") || values.includes("fad")) {
    canonical.prefix = "fad";
  }
  if (!canonical.prefix && family === r3 && (styles["fass"] || config.autoFetchSvg)) {
    canonical.prefix = "fass";
    canonical.iconName = byAlias(canonical.prefix, canonical.iconName) || canonical.iconName;
  }
  if (!canonical.prefix && family === o3 && (styles["fasds"] || config.autoFetchSvg)) {
    canonical.prefix = "fasds";
    canonical.iconName = byAlias(canonical.prefix, canonical.iconName) || canonical.iconName;
  }
  if (canonical.prefix === "fa" || givenPrefix === "fa") {
    canonical.prefix = getDefaultUsablePrefix() || "fas";
  }
  return canonical;
}
var Library = class {
  constructor() {
    this.definitions = {};
  }
  add() {
    for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {
      definitions[_key] = arguments[_key];
    }
    const additions = definitions.reduce(this._pullDefinitions, {});
    Object.keys(additions).forEach((key) => {
      this.definitions[key] = {
        ...this.definitions[key] || {},
        ...additions[key]
      };
      defineIcons(key, additions[key]);
      const longPrefix = PREFIX_TO_LONG_STYLE[a3][key];
      if (longPrefix) defineIcons(longPrefix, additions[key]);
      build();
    });
  }
  reset() {
    this.definitions = {};
  }
  _pullDefinitions(additions, definition) {
    const normalized = definition.prefix && definition.iconName && definition.icon ? {
      0: definition
    } : definition;
    Object.keys(normalized).map((key) => {
      const {
        prefix: prefix2,
        iconName,
        icon: icon2
      } = normalized[key];
      const aliases = icon2[2];
      if (!additions[prefix2]) additions[prefix2] = {};
      if (aliases.length > 0) {
        aliases.forEach((alias) => {
          if (typeof alias === "string") {
            additions[prefix2][alias] = icon2;
          }
        });
      }
      additions[prefix2][iconName] = icon2;
    });
    return additions;
  }
};
var _plugins = [];
var _hooks = {};
var providers = {};
var defaultProviderKeys = Object.keys(providers);
function registerPlugins(nextPlugins, _ref3) {
  let {
    mixoutsTo: obj
  } = _ref3;
  _plugins = nextPlugins;
  _hooks = {};
  Object.keys(providers).forEach((k4) => {
    if (defaultProviderKeys.indexOf(k4) === -1) {
      delete providers[k4];
    }
  });
  _plugins.forEach((plugin) => {
    const mixout = plugin.mixout ? plugin.mixout() : {};
    Object.keys(mixout).forEach((tk) => {
      if (typeof mixout[tk] === "function") {
        obj[tk] = mixout[tk];
      }
      if (typeof mixout[tk] === "object") {
        Object.keys(mixout[tk]).forEach((sk) => {
          if (!obj[tk]) {
            obj[tk] = {};
          }
          obj[tk][sk] = mixout[tk][sk];
        });
      }
    });
    if (plugin.hooks) {
      const hooks = plugin.hooks();
      Object.keys(hooks).forEach((hook) => {
        if (!_hooks[hook]) {
          _hooks[hook] = [];
        }
        _hooks[hook].push(hooks[hook]);
      });
    }
    if (plugin.provides) {
      plugin.provides(providers);
    }
  });
  return obj;
}
function chainHooks(hook, accumulator) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  const hookFns = _hooks[hook] || [];
  hookFns.forEach((hookFn) => {
    accumulator = hookFn.apply(null, [accumulator, ...args]);
  });
  return accumulator;
}
function callHooks(hook) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  const hookFns = _hooks[hook] || [];
  hookFns.forEach((hookFn) => {
    hookFn.apply(null, args);
  });
  return void 0;
}
function callProvided() {
  const hook = arguments[0];
  const args = Array.prototype.slice.call(arguments, 1);
  return providers[hook] ? providers[hook].apply(null, args) : void 0;
}
function findIconDefinition(iconLookup) {
  if (iconLookup.prefix === "fa") {
    iconLookup.prefix = "fas";
  }
  let {
    iconName
  } = iconLookup;
  const prefix2 = iconLookup.prefix || getDefaultUsablePrefix();
  if (!iconName) return;
  iconName = byAlias(prefix2, iconName) || iconName;
  return iconFromMapping(library.definitions, prefix2, iconName) || iconFromMapping(namespace.styles, prefix2, iconName);
}
var library = new Library();
var noAuto = () => {
  config.autoReplaceSvg = false;
  config.observeMutations = false;
  callHooks("noAuto");
};
var dom = {
  i2svg: function() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (IS_DOM) {
      callHooks("beforeI2svg", params);
      callProvided("pseudoElements2svg", params);
      return callProvided("i2svg", params);
    } else {
      return Promise.reject(new Error("Operation requires a DOM of some kind."));
    }
  },
  watch: function() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      autoReplaceSvgRoot
    } = params;
    if (config.autoReplaceSvg === false) {
      config.autoReplaceSvg = true;
    }
    config.observeMutations = true;
    domready(() => {
      autoReplace({
        autoReplaceSvgRoot
      });
      callHooks("watch", params);
    });
  }
};
var parse4 = {
  icon: (icon2) => {
    if (icon2 === null) {
      return null;
    }
    if (typeof icon2 === "object" && icon2.prefix && icon2.iconName) {
      return {
        prefix: icon2.prefix,
        iconName: byAlias(icon2.prefix, icon2.iconName) || icon2.iconName
      };
    }
    if (Array.isArray(icon2) && icon2.length === 2) {
      const iconName = icon2[1].indexOf("fa-") === 0 ? icon2[1].slice(3) : icon2[1];
      const prefix2 = getCanonicalPrefix(icon2[0]);
      return {
        prefix: prefix2,
        iconName: byAlias(prefix2, iconName) || iconName
      };
    }
    if (typeof icon2 === "string" && (icon2.indexOf("".concat(config.cssPrefix, "-")) > -1 || icon2.match(ICON_SELECTION_SYNTAX_PATTERN))) {
      const canonicalIcon = getCanonicalIcon(icon2.split(" "), {
        skipLookups: true
      });
      return {
        prefix: canonicalIcon.prefix || getDefaultUsablePrefix(),
        iconName: byAlias(canonicalIcon.prefix, canonicalIcon.iconName) || canonicalIcon.iconName
      };
    }
    if (typeof icon2 === "string") {
      const prefix2 = getDefaultUsablePrefix();
      return {
        prefix: prefix2,
        iconName: byAlias(prefix2, icon2) || icon2
      };
    }
  }
};
var api = {
  noAuto,
  config,
  dom,
  parse: parse4,
  library,
  findIconDefinition,
  toHtml
};
var autoReplace = function() {
  let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    autoReplaceSvgRoot = DOCUMENT
  } = params;
  if ((Object.keys(namespace.styles).length > 0 || config.autoFetchSvg) && IS_DOM && config.autoReplaceSvg) api.dom.i2svg({
    node: autoReplaceSvgRoot
  });
};
function domVariants(val, abstractCreator) {
  Object.defineProperty(val, "abstract", {
    get: abstractCreator
  });
  Object.defineProperty(val, "html", {
    get: function() {
      return val.abstract.map((a4) => toHtml(a4));
    }
  });
  Object.defineProperty(val, "node", {
    get: function() {
      if (!IS_DOM) return;
      const container = DOCUMENT.createElement("div");
      container.innerHTML = val.html;
      return container.children;
    }
  });
  return val;
}
function asIcon(_ref3) {
  let {
    children,
    main,
    mask,
    attributes,
    styles: styles2,
    transform: transform2
  } = _ref3;
  if (transformIsMeaningful(transform2) && main.found && !mask.found) {
    const {
      width,
      height
    } = main;
    const offset3 = {
      x: width / height / 2,
      y: 0.5
    };
    attributes["style"] = joinStyles({
      ...styles2,
      "transform-origin": "".concat(offset3.x + transform2.x / 16, "em ").concat(offset3.y + transform2.y / 16, "em")
    });
  }
  return [{
    tag: "svg",
    attributes,
    children
  }];
}
function asSymbol(_ref3) {
  let {
    prefix: prefix2,
    iconName,
    children,
    attributes,
    symbol
  } = _ref3;
  const id2 = symbol === true ? "".concat(prefix2, "-").concat(config.cssPrefix, "-").concat(iconName) : symbol;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: {
        ...attributes,
        id: id2
      },
      children
    }]
  }];
}
function makeInlineSvgAbstract(params) {
  const {
    icons: {
      main,
      mask
    },
    prefix: prefix2,
    iconName,
    transform: transform2,
    symbol,
    title,
    maskId,
    titleId,
    extra,
    watchable = false
  } = params;
  const {
    width,
    height
  } = mask.found ? mask : main;
  const isUploadedIcon = prefix2 === "fak";
  const attrClass = [config.replacementClass, iconName ? "".concat(config.cssPrefix, "-").concat(iconName) : ""].filter((c4) => extra.classes.indexOf(c4) === -1).filter((c4) => c4 !== "" || !!c4).concat(extra.classes).join(" ");
  let content = {
    children: [],
    attributes: {
      ...extra.attributes,
      "data-prefix": prefix2,
      "data-icon": iconName,
      "class": attrClass,
      "role": extra.attributes.role || "img",
      "xmlns": "http://www.w3.org/2000/svg",
      "viewBox": "0 0 ".concat(width, " ").concat(height)
    }
  };
  const uploadedIconWidthStyle = isUploadedIcon && !~extra.classes.indexOf("fa-fw") ? {
    width: "".concat(width / height * 16 * 0.0625, "em")
  } : {};
  if (watchable) {
    content.attributes[DATA_FA_I2SVG] = "";
  }
  if (title) {
    content.children.push({
      tag: "title",
      attributes: {
        id: content.attributes["aria-labelledby"] || "title-".concat(titleId || nextUniqueId())
      },
      children: [title]
    });
    delete content.attributes.title;
  }
  const args = {
    ...content,
    prefix: prefix2,
    iconName,
    main,
    mask,
    maskId,
    transform: transform2,
    symbol,
    styles: {
      ...uploadedIconWidthStyle,
      ...extra.styles
    }
  };
  const {
    children,
    attributes
  } = mask.found && main.found ? callProvided("generateAbstractMask", args) || {
    children: [],
    attributes: {}
  } : callProvided("generateAbstractIcon", args) || {
    children: [],
    attributes: {}
  };
  args.children = children;
  args.attributes = attributes;
  if (symbol) {
    return asSymbol(args);
  } else {
    return asIcon(args);
  }
}
function makeLayersTextAbstract(params) {
  const {
    content,
    width,
    height,
    transform: transform2,
    title,
    extra,
    watchable = false
  } = params;
  const attributes = {
    ...extra.attributes,
    ...title ? {
      "title": title
    } : {},
    "class": extra.classes.join(" ")
  };
  if (watchable) {
    attributes[DATA_FA_I2SVG] = "";
  }
  const styles2 = {
    ...extra.styles
  };
  if (transformIsMeaningful(transform2)) {
    styles2["transform"] = transformForCss({
      transform: transform2,
      startCentered: true,
      width,
      height
    });
    styles2["-webkit-transform"] = styles2["transform"];
  }
  const styleString = joinStyles(styles2);
  if (styleString.length > 0) {
    attributes["style"] = styleString;
  }
  const val = [];
  val.push({
    tag: "span",
    attributes,
    children: [content]
  });
  if (title) {
    val.push({
      tag: "span",
      attributes: {
        class: "sr-only"
      },
      children: [title]
    });
  }
  return val;
}
function makeLayersCounterAbstract(params) {
  const {
    content,
    title,
    extra
  } = params;
  const attributes = {
    ...extra.attributes,
    ...title ? {
      "title": title
    } : {},
    "class": extra.classes.join(" ")
  };
  const styleString = joinStyles(extra.styles);
  if (styleString.length > 0) {
    attributes["style"] = styleString;
  }
  const val = [];
  val.push({
    tag: "span",
    attributes,
    children: [content]
  });
  if (title) {
    val.push({
      tag: "span",
      attributes: {
        class: "sr-only"
      },
      children: [title]
    });
  }
  return val;
}
var {
  styles: styles$1
} = namespace;
function asFoundIcon(icon2) {
  const width = icon2[0];
  const height = icon2[1];
  const [vectorData] = icon2.slice(4);
  let element = null;
  if (Array.isArray(vectorData)) {
    element = {
      tag: "g",
      attributes: {
        class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.GROUP)
      },
      children: [{
        tag: "path",
        attributes: {
          class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.SECONDARY),
          fill: "currentColor",
          d: vectorData[0]
        }
      }, {
        tag: "path",
        attributes: {
          class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.PRIMARY),
          fill: "currentColor",
          d: vectorData[1]
        }
      }]
    };
  } else {
    element = {
      tag: "path",
      attributes: {
        fill: "currentColor",
        d: vectorData
      }
    };
  }
  return {
    found: true,
    width,
    height,
    icon: element
  };
}
var missingIconResolutionMixin = {
  found: false,
  width: 512,
  height: 512
};
function maybeNotifyMissing(iconName, prefix2) {
  if (!PRODUCTION && !config.showMissingIcons && iconName) {
    console.error('Icon with name "'.concat(iconName, '" and prefix "').concat(prefix2, '" is missing.'));
  }
}
function findIcon(iconName, prefix2) {
  let givenPrefix = prefix2;
  if (prefix2 === "fa" && config.styleDefault !== null) {
    prefix2 = getDefaultUsablePrefix();
  }
  return new Promise((resolve, reject) => {
    if (givenPrefix === "fa") {
      const shim = byOldName(iconName) || {};
      iconName = shim.iconName || iconName;
      prefix2 = shim.prefix || prefix2;
    }
    if (iconName && prefix2 && styles$1[prefix2] && styles$1[prefix2][iconName]) {
      const icon2 = styles$1[prefix2][iconName];
      return resolve(asFoundIcon(icon2));
    }
    maybeNotifyMissing(iconName, prefix2);
    resolve({
      ...missingIconResolutionMixin,
      icon: config.showMissingIcons && iconName ? callProvided("missingIconAbstract") || {} : {}
    });
  });
}
var noop$1 = () => {
};
var p$2 = config.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
  mark: noop$1,
  measure: noop$1
};
var preamble = 'FA "6.6.0"';
var begin = (name) => {
  p$2.mark("".concat(preamble, " ").concat(name, " begins"));
  return () => end(name);
};
var end = (name) => {
  p$2.mark("".concat(preamble, " ").concat(name, " ends"));
  p$2.measure("".concat(preamble, " ").concat(name), "".concat(preamble, " ").concat(name, " begins"), "".concat(preamble, " ").concat(name, " ends"));
};
var perf = {
  begin,
  end
};
var noop$2 = () => {
};
function isWatched(node2) {
  const i2svg = node2.getAttribute ? node2.getAttribute(DATA_FA_I2SVG) : null;
  return typeof i2svg === "string";
}
function hasPrefixAndIcon(node2) {
  const prefix2 = node2.getAttribute ? node2.getAttribute(DATA_PREFIX) : null;
  const icon2 = node2.getAttribute ? node2.getAttribute(DATA_ICON) : null;
  return prefix2 && icon2;
}
function hasBeenReplaced(node2) {
  return node2 && node2.classList && node2.classList.contains && node2.classList.contains(config.replacementClass);
}
function getMutator() {
  if (config.autoReplaceSvg === true) {
    return mutators.replace;
  }
  const mutator = mutators[config.autoReplaceSvg];
  return mutator || mutators.replace;
}
function createElementNS(tag) {
  return DOCUMENT.createElementNS("http://www.w3.org/2000/svg", tag);
}
function createElement(tag) {
  return DOCUMENT.createElement(tag);
}
function convertSVG(abstractObj) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    ceFn = abstractObj.tag === "svg" ? createElementNS : createElement
  } = params;
  if (typeof abstractObj === "string") {
    return DOCUMENT.createTextNode(abstractObj);
  }
  const tag = ceFn(abstractObj.tag);
  Object.keys(abstractObj.attributes || []).forEach(function(key) {
    tag.setAttribute(key, abstractObj.attributes[key]);
  });
  const children = abstractObj.children || [];
  children.forEach(function(child) {
    tag.appendChild(convertSVG(child, {
      ceFn
    }));
  });
  return tag;
}
function nodeAsComment(node2) {
  let comment2 = " ".concat(node2.outerHTML, " ");
  comment2 = "".concat(comment2, "Font Awesome fontawesome.com ");
  return comment2;
}
var mutators = {
  replace: function(mutation) {
    const node2 = mutation[0];
    if (node2.parentNode) {
      mutation[1].forEach((abstract) => {
        node2.parentNode.insertBefore(convertSVG(abstract), node2);
      });
      if (node2.getAttribute(DATA_FA_I2SVG) === null && config.keepOriginalSource) {
        let comment2 = DOCUMENT.createComment(nodeAsComment(node2));
        node2.parentNode.replaceChild(comment2, node2);
      } else {
        node2.remove();
      }
    }
  },
  nest: function(mutation) {
    const node2 = mutation[0];
    const abstract = mutation[1];
    if (~classArray(node2).indexOf(config.replacementClass)) {
      return mutators.replace(mutation);
    }
    const forSvg = new RegExp("".concat(config.cssPrefix, "-.*"));
    delete abstract[0].attributes.id;
    if (abstract[0].attributes.class) {
      const splitClasses = abstract[0].attributes.class.split(" ").reduce((acc, cls) => {
        if (cls === config.replacementClass || cls.match(forSvg)) {
          acc.toSvg.push(cls);
        } else {
          acc.toNode.push(cls);
        }
        return acc;
      }, {
        toNode: [],
        toSvg: []
      });
      abstract[0].attributes.class = splitClasses.toSvg.join(" ");
      if (splitClasses.toNode.length === 0) {
        node2.removeAttribute("class");
      } else {
        node2.setAttribute("class", splitClasses.toNode.join(" "));
      }
    }
    const newInnerHTML = abstract.map((a4) => toHtml(a4)).join("\n");
    node2.setAttribute(DATA_FA_I2SVG, "");
    node2.innerHTML = newInnerHTML;
  }
};
function performOperationSync(op) {
  op();
}
function perform(mutations, callback) {
  const callbackFunction = typeof callback === "function" ? callback : noop$2;
  if (mutations.length === 0) {
    callbackFunction();
  } else {
    let frame = performOperationSync;
    if (config.mutateApproach === MUTATION_APPROACH_ASYNC) {
      frame = WINDOW.requestAnimationFrame || performOperationSync;
    }
    frame(() => {
      const mutator = getMutator();
      const mark = perf.begin("mutate");
      mutations.map(mutator);
      mark();
      callbackFunction();
    });
  }
}
var disabled = false;
function disableObservation() {
  disabled = true;
}
function enableObservation() {
  disabled = false;
}
var mo$1 = null;
function observe(options2) {
  if (!MUTATION_OBSERVER) {
    return;
  }
  if (!config.observeMutations) {
    return;
  }
  const {
    treeCallback = noop$2,
    nodeCallback = noop$2,
    pseudoElementsCallback = noop$2,
    observeMutationsRoot = DOCUMENT
  } = options2;
  mo$1 = new MUTATION_OBSERVER((objects) => {
    if (disabled) return;
    const defaultPrefix = getDefaultUsablePrefix();
    toArray(objects).forEach((mutationRecord) => {
      if (mutationRecord.type === "childList" && mutationRecord.addedNodes.length > 0 && !isWatched(mutationRecord.addedNodes[0])) {
        if (config.searchPseudoElements) {
          pseudoElementsCallback(mutationRecord.target);
        }
        treeCallback(mutationRecord.target);
      }
      if (mutationRecord.type === "attributes" && mutationRecord.target.parentNode && config.searchPseudoElements) {
        pseudoElementsCallback(mutationRecord.target.parentNode);
      }
      if (mutationRecord.type === "attributes" && isWatched(mutationRecord.target) && ~ATTRIBUTES_WATCHED_FOR_MUTATION.indexOf(mutationRecord.attributeName)) {
        if (mutationRecord.attributeName === "class" && hasPrefixAndIcon(mutationRecord.target)) {
          const {
            prefix: prefix2,
            iconName
          } = getCanonicalIcon(classArray(mutationRecord.target));
          mutationRecord.target.setAttribute(DATA_PREFIX, prefix2 || defaultPrefix);
          if (iconName) mutationRecord.target.setAttribute(DATA_ICON, iconName);
        } else if (hasBeenReplaced(mutationRecord.target)) {
          nodeCallback(mutationRecord.target);
        }
      }
    });
  });
  if (!IS_DOM) return;
  mo$1.observe(observeMutationsRoot, {
    childList: true,
    attributes: true,
    characterData: true,
    subtree: true
  });
}
function disconnect() {
  if (!mo$1) return;
  mo$1.disconnect();
}
function styleParser(node2) {
  const style = node2.getAttribute("style");
  let val = [];
  if (style) {
    val = style.split(";").reduce((acc, style2) => {
      const styles2 = style2.split(":");
      const prop = styles2[0];
      const value = styles2.slice(1);
      if (prop && value.length > 0) {
        acc[prop] = value.join(":").trim();
      }
      return acc;
    }, {});
  }
  return val;
}
function classParser(node2) {
  const existingPrefix = node2.getAttribute("data-prefix");
  const existingIconName = node2.getAttribute("data-icon");
  const innerText = node2.innerText !== void 0 ? node2.innerText.trim() : "";
  let val = getCanonicalIcon(classArray(node2));
  if (!val.prefix) {
    val.prefix = getDefaultUsablePrefix();
  }
  if (existingPrefix && existingIconName) {
    val.prefix = existingPrefix;
    val.iconName = existingIconName;
  }
  if (val.iconName && val.prefix) {
    return val;
  }
  if (val.prefix && innerText.length > 0) {
    val.iconName = byLigature(val.prefix, node2.innerText) || byUnicode(val.prefix, toHex(node2.innerText));
  }
  if (!val.iconName && config.autoFetchSvg && node2.firstChild && node2.firstChild.nodeType === Node.TEXT_NODE) {
    val.iconName = node2.firstChild.data;
  }
  return val;
}
function attributesParser(node2) {
  const extraAttributes = toArray(node2.attributes).reduce((acc, attr) => {
    if (acc.name !== "class" && acc.name !== "style") {
      acc[attr.name] = attr.value;
    }
    return acc;
  }, {});
  const title = node2.getAttribute("title");
  const titleId = node2.getAttribute("data-fa-title-id");
  if (config.autoA11y) {
    if (title) {
      extraAttributes["aria-labelledby"] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
    } else {
      extraAttributes["aria-hidden"] = "true";
      extraAttributes["focusable"] = "false";
    }
  }
  return extraAttributes;
}
function blankMeta() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: meaninglessTransform,
    symbol: false,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function parseMeta(node2) {
  let parser2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: true
  };
  const {
    iconName,
    prefix: prefix2,
    rest: extraClasses
  } = classParser(node2);
  const extraAttributes = attributesParser(node2);
  const pluginMeta = chainHooks("parseNodeAttributes", {}, node2);
  let extraStyles = parser2.styleParser ? styleParser(node2) : [];
  return {
    iconName,
    title: node2.getAttribute("title"),
    titleId: node2.getAttribute("data-fa-title-id"),
    prefix: prefix2,
    transform: meaninglessTransform,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: false,
    extra: {
      classes: extraClasses,
      styles: extraStyles,
      attributes: extraAttributes
    },
    ...pluginMeta
  };
}
var {
  styles: styles$2
} = namespace;
function generateMutation(node2) {
  const nodeMeta = config.autoReplaceSvg === "nest" ? parseMeta(node2, {
    styleParser: false
  }) : parseMeta(node2);
  if (~nodeMeta.extra.classes.indexOf(LAYERS_TEXT_CLASSNAME)) {
    return callProvided("generateLayersText", node2, nodeMeta);
  } else {
    return callProvided("generateSvgReplacementMutation", node2, nodeMeta);
  }
}
var knownPrefixes = /* @__PURE__ */ new Set();
FAMILIES.map((family) => {
  knownPrefixes.add("fa-".concat(family));
});
Object.keys(PREFIX_TO_STYLE[a3]).map(knownPrefixes.add.bind(knownPrefixes));
Object.keys(PREFIX_TO_STYLE[r3]).map(knownPrefixes.add.bind(knownPrefixes));
Object.keys(PREFIX_TO_STYLE[o3]).map(knownPrefixes.add.bind(knownPrefixes));
knownPrefixes = [...knownPrefixes];
function onTree(root) {
  let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!IS_DOM) return Promise.resolve();
  const htmlClassList = DOCUMENT.documentElement.classList;
  const hclAdd = (suffix) => htmlClassList.add("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  const hclRemove = (suffix) => htmlClassList.remove("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  const prefixes2 = config.autoFetchSvg ? knownPrefixes : FAMILIES.map((f$$1) => "fa-".concat(f$$1)).concat(Object.keys(styles$2));
  if (!prefixes2.includes("fa")) {
    prefixes2.push("fa");
  }
  const prefixesDomQuery = [".".concat(LAYERS_TEXT_CLASSNAME, ":not([").concat(DATA_FA_I2SVG, "])")].concat(prefixes2.map((p$$1) => ".".concat(p$$1, ":not([").concat(DATA_FA_I2SVG, "])"))).join(", ");
  if (prefixesDomQuery.length === 0) {
    return Promise.resolve();
  }
  let candidates = [];
  try {
    candidates = toArray(root.querySelectorAll(prefixesDomQuery));
  } catch (e$$1) {
  }
  if (candidates.length > 0) {
    hclAdd("pending");
    hclRemove("complete");
  } else {
    return Promise.resolve();
  }
  const mark = perf.begin("onTree");
  const mutations = candidates.reduce((acc, node2) => {
    try {
      const mutation = generateMutation(node2);
      if (mutation) {
        acc.push(mutation);
      }
    } catch (e$$1) {
      if (!PRODUCTION) {
        if (e$$1.name === "MissingIcon") {
          console.error(e$$1);
        }
      }
    }
    return acc;
  }, []);
  return new Promise((resolve, reject) => {
    Promise.all(mutations).then((resolvedMutations) => {
      perform(resolvedMutations, () => {
        hclAdd("active");
        hclAdd("complete");
        hclRemove("pending");
        if (typeof callback === "function") callback();
        mark();
        resolve();
      });
    }).catch((e$$1) => {
      mark();
      reject(e$$1);
    });
  });
}
function onNode(node2) {
  let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  generateMutation(node2).then((mutation) => {
    if (mutation) {
      perform([mutation], callback);
    }
  });
}
function resolveIcons(next3) {
  return function(maybeIconDefinition) {
    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
    let {
      mask
    } = params;
    if (mask) {
      mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
    }
    return next3(iconDefinition, {
      ...params,
      mask
    });
  };
}
var render = function(iconDefinition) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    transform: transform2 = meaninglessTransform,
    symbol = false,
    mask = null,
    maskId = null,
    title = null,
    titleId = null,
    classes = [],
    attributes = {},
    styles: styles2 = {}
  } = params;
  if (!iconDefinition) return;
  const {
    prefix: prefix2,
    iconName,
    icon: icon2
  } = iconDefinition;
  return domVariants({
    type: "icon",
    ...iconDefinition
  }, () => {
    callHooks("beforeDOMElementCreation", {
      iconDefinition,
      params
    });
    if (config.autoA11y) {
      if (title) {
        attributes["aria-labelledby"] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
      } else {
        attributes["aria-hidden"] = "true";
        attributes["focusable"] = "false";
      }
    }
    return makeInlineSvgAbstract({
      icons: {
        main: asFoundIcon(icon2),
        mask: mask ? asFoundIcon(mask.icon) : {
          found: false,
          width: null,
          height: null,
          icon: {}
        }
      },
      prefix: prefix2,
      iconName,
      transform: {
        ...meaninglessTransform,
        ...transform2
      },
      symbol,
      title,
      maskId,
      titleId,
      extra: {
        attributes,
        styles: styles2,
        classes
      }
    });
  });
};
var ReplaceElements = {
  mixout() {
    return {
      icon: resolveIcons(render)
    };
  },
  hooks() {
    return {
      mutationObserverCallbacks(accumulator) {
        accumulator.treeCallback = onTree;
        accumulator.nodeCallback = onNode;
        return accumulator;
      }
    };
  },
  provides(providers$$1) {
    providers$$1.i2svg = function(params) {
      const {
        node: node2 = DOCUMENT,
        callback = () => {
        }
      } = params;
      return onTree(node2, callback);
    };
    providers$$1.generateSvgReplacementMutation = function(node2, nodeMeta) {
      const {
        iconName,
        title,
        titleId,
        prefix: prefix2,
        transform: transform2,
        symbol,
        mask,
        maskId,
        extra
      } = nodeMeta;
      return new Promise((resolve, reject) => {
        Promise.all([findIcon(iconName, prefix2), mask.iconName ? findIcon(mask.iconName, mask.prefix) : Promise.resolve({
          found: false,
          width: 512,
          height: 512,
          icon: {}
        })]).then((_ref3) => {
          let [main, mask2] = _ref3;
          resolve([node2, makeInlineSvgAbstract({
            icons: {
              main,
              mask: mask2
            },
            prefix: prefix2,
            iconName,
            transform: transform2,
            symbol,
            maskId,
            title,
            titleId,
            extra,
            watchable: true
          })]);
        }).catch(reject);
      });
    };
    providers$$1.generateAbstractIcon = function(_ref23) {
      let {
        children,
        attributes,
        main,
        transform: transform2,
        styles: styles2
      } = _ref23;
      const styleString = joinStyles(styles2);
      if (styleString.length > 0) {
        attributes["style"] = styleString;
      }
      let nextChild;
      if (transformIsMeaningful(transform2)) {
        nextChild = callProvided("generateAbstractTransformGrouping", {
          main,
          transform: transform2,
          containerWidth: main.width,
          iconWidth: main.width
        });
      }
      children.push(nextChild || main.icon);
      return {
        children,
        attributes
      };
    };
  }
};
var Layers = {
  mixout() {
    return {
      layer(assembler) {
        let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          classes = []
        } = params;
        return domVariants({
          type: "layer"
        }, () => {
          callHooks("beforeDOMElementCreation", {
            assembler,
            params
          });
          let children = [];
          assembler((args) => {
            Array.isArray(args) ? args.map((a4) => {
              children = children.concat(a4.abstract);
            }) : children = children.concat(args.abstract);
          });
          return [{
            tag: "span",
            attributes: {
              class: ["".concat(config.cssPrefix, "-layers"), ...classes].join(" ")
            },
            children
          }];
        });
      }
    };
  }
};
var LayersCounter = {
  mixout() {
    return {
      counter(content) {
        let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          title = null,
          classes = [],
          attributes = {},
          styles: styles2 = {}
        } = params;
        return domVariants({
          type: "counter",
          content
        }, () => {
          callHooks("beforeDOMElementCreation", {
            content,
            params
          });
          return makeLayersCounterAbstract({
            content: content.toString(),
            title,
            extra: {
              attributes,
              styles: styles2,
              classes: ["".concat(config.cssPrefix, "-layers-counter"), ...classes]
            }
          });
        });
      }
    };
  }
};
var LayersText = {
  mixout() {
    return {
      text(content) {
        let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          transform: transform2 = meaninglessTransform,
          title = null,
          classes = [],
          attributes = {},
          styles: styles2 = {}
        } = params;
        return domVariants({
          type: "text",
          content
        }, () => {
          callHooks("beforeDOMElementCreation", {
            content,
            params
          });
          return makeLayersTextAbstract({
            content,
            transform: {
              ...meaninglessTransform,
              ...transform2
            },
            title,
            extra: {
              attributes,
              styles: styles2,
              classes: ["".concat(config.cssPrefix, "-layers-text"), ...classes]
            }
          });
        });
      }
    };
  },
  provides(providers$$1) {
    providers$$1.generateLayersText = function(node2, nodeMeta) {
      const {
        title,
        transform: transform2,
        extra
      } = nodeMeta;
      let width = null;
      let height = null;
      if (IS_IE) {
        const computedFontSize = parseInt(getComputedStyle(node2).fontSize, 10);
        const boundingClientRect = node2.getBoundingClientRect();
        width = boundingClientRect.width / computedFontSize;
        height = boundingClientRect.height / computedFontSize;
      }
      if (config.autoA11y && !title) {
        extra.attributes["aria-hidden"] = "true";
      }
      return Promise.resolve([node2, makeLayersTextAbstract({
        content: node2.innerHTML,
        width,
        height,
        transform: transform2,
        title,
        extra,
        watchable: true
      })]);
    };
  }
};
var CLEAN_CONTENT_PATTERN = new RegExp('"', "ug");
var SECONDARY_UNICODE_RANGE = [1105920, 1112319];
var _FONT_FAMILY_WEIGHT_TO_PREFIX = {
  ...{
    FontAwesome: {
      normal: "fas",
      400: "fas"
    }
  },
  ...eo,
  ...ao,
  ...mo
};
var FONT_FAMILY_WEIGHT_TO_PREFIX = Object.keys(_FONT_FAMILY_WEIGHT_TO_PREFIX).reduce((acc, key) => {
  acc[key.toLowerCase()] = _FONT_FAMILY_WEIGHT_TO_PREFIX[key];
  return acc;
}, {});
var FONT_FAMILY_WEIGHT_FALLBACK = Object.keys(FONT_FAMILY_WEIGHT_TO_PREFIX).reduce((acc, fontFamily) => {
  const weights = FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamily];
  acc[fontFamily] = weights[900] || [...Object.entries(weights)][0][1];
  return acc;
}, {});
function hexValueFromContent(content) {
  const cleaned = content.replace(CLEAN_CONTENT_PATTERN, "");
  const codePoint = codePointAt(cleaned, 0);
  const isPrependTen = codePoint >= SECONDARY_UNICODE_RANGE[0] && codePoint <= SECONDARY_UNICODE_RANGE[1];
  const isDoubled = cleaned.length === 2 ? cleaned[0] === cleaned[1] : false;
  return {
    value: isDoubled ? toHex(cleaned[0]) : toHex(cleaned),
    isSecondary: isPrependTen || isDoubled
  };
}
function getPrefix(fontFamily, fontWeight) {
  const fontFamilySanitized = fontFamily.replace(/^['"]|['"]$/g, "").toLowerCase();
  const fontWeightInteger = parseInt(fontWeight);
  const fontWeightSanitized = isNaN(fontWeightInteger) ? "normal" : fontWeightInteger;
  return (FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamilySanitized] || {})[fontWeightSanitized] || FONT_FAMILY_WEIGHT_FALLBACK[fontFamilySanitized];
}
function replaceForPosition(node2, position2) {
  const pendingAttribute = "".concat(DATA_FA_PSEUDO_ELEMENT_PENDING).concat(position2.replace(":", "-"));
  return new Promise((resolve, reject) => {
    if (node2.getAttribute(pendingAttribute) !== null) {
      return resolve();
    }
    const children = toArray(node2.children);
    const alreadyProcessedPseudoElement = children.filter((c4) => c4.getAttribute(DATA_FA_PSEUDO_ELEMENT) === position2)[0];
    const styles2 = WINDOW.getComputedStyle(node2, position2);
    const fontFamily = styles2.getPropertyValue("font-family");
    const fontFamilyMatch = fontFamily.match(FONT_FAMILY_PATTERN);
    const fontWeight = styles2.getPropertyValue("font-weight");
    const content = styles2.getPropertyValue("content");
    if (alreadyProcessedPseudoElement && !fontFamilyMatch) {
      node2.removeChild(alreadyProcessedPseudoElement);
      return resolve();
    } else if (fontFamilyMatch && content !== "none" && content !== "") {
      const content2 = styles2.getPropertyValue("content");
      let prefix2 = getPrefix(fontFamily, fontWeight);
      const {
        value: hexValue,
        isSecondary
      } = hexValueFromContent(content2);
      const isV4 = fontFamilyMatch[0].startsWith("FontAwesome");
      let iconName = byUnicode(prefix2, hexValue);
      let iconIdentifier = iconName;
      if (isV4) {
        const iconName4 = byOldUnicode(hexValue);
        if (iconName4.iconName && iconName4.prefix) {
          iconName = iconName4.iconName;
          prefix2 = iconName4.prefix;
        }
      }
      if (iconName && !isSecondary && (!alreadyProcessedPseudoElement || alreadyProcessedPseudoElement.getAttribute(DATA_PREFIX) !== prefix2 || alreadyProcessedPseudoElement.getAttribute(DATA_ICON) !== iconIdentifier)) {
        node2.setAttribute(pendingAttribute, iconIdentifier);
        if (alreadyProcessedPseudoElement) {
          node2.removeChild(alreadyProcessedPseudoElement);
        }
        const meta = blankMeta();
        const {
          extra
        } = meta;
        extra.attributes[DATA_FA_PSEUDO_ELEMENT] = position2;
        findIcon(iconName, prefix2).then((main) => {
          const abstract = makeInlineSvgAbstract({
            ...meta,
            icons: {
              main,
              mask: emptyCanonicalIcon()
            },
            prefix: prefix2,
            iconName: iconIdentifier,
            extra,
            watchable: true
          });
          const element = DOCUMENT.createElementNS("http://www.w3.org/2000/svg", "svg");
          if (position2 === "::before") {
            node2.insertBefore(element, node2.firstChild);
          } else {
            node2.appendChild(element);
          }
          element.outerHTML = abstract.map((a4) => toHtml(a4)).join("\n");
          node2.removeAttribute(pendingAttribute);
          resolve();
        }).catch(reject);
      } else {
        resolve();
      }
    } else {
      resolve();
    }
  });
}
function replace2(node2) {
  return Promise.all([replaceForPosition(node2, "::before"), replaceForPosition(node2, "::after")]);
}
function processable(node2) {
  return node2.parentNode !== document.head && !~TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS.indexOf(node2.tagName.toUpperCase()) && !node2.getAttribute(DATA_FA_PSEUDO_ELEMENT) && (!node2.parentNode || node2.parentNode.tagName !== "svg");
}
function searchPseudoElements(root) {
  if (!IS_DOM) return;
  return new Promise((resolve, reject) => {
    const operations = toArray(root.querySelectorAll("*")).filter(processable).map(replace2);
    const end2 = perf.begin("searchPseudoElements");
    disableObservation();
    Promise.all(operations).then(() => {
      end2();
      enableObservation();
      resolve();
    }).catch(() => {
      end2();
      enableObservation();
      reject();
    });
  });
}
var PseudoElements = {
  hooks() {
    return {
      mutationObserverCallbacks(accumulator) {
        accumulator.pseudoElementsCallback = searchPseudoElements;
        return accumulator;
      }
    };
  },
  provides(providers2) {
    providers2.pseudoElements2svg = function(params) {
      const {
        node: node2 = DOCUMENT
      } = params;
      if (config.searchPseudoElements) {
        searchPseudoElements(node2);
      }
    };
  }
};
var _unwatched = false;
var MutationObserver$1 = {
  mixout() {
    return {
      dom: {
        unwatch() {
          disableObservation();
          _unwatched = true;
        }
      }
    };
  },
  hooks() {
    return {
      bootstrap() {
        observe(chainHooks("mutationObserverCallbacks", {}));
      },
      noAuto() {
        disconnect();
      },
      watch(params) {
        const {
          observeMutationsRoot
        } = params;
        if (_unwatched) {
          enableObservation();
        } else {
          observe(chainHooks("mutationObserverCallbacks", {
            observeMutationsRoot
          }));
        }
      }
    };
  }
};
var parseTransformString = (transformString) => {
  let transform2 = {
    size: 16,
    x: 0,
    y: 0,
    flipX: false,
    flipY: false,
    rotate: 0
  };
  return transformString.toLowerCase().split(" ").reduce((acc, n3) => {
    const parts = n3.toLowerCase().split("-");
    const first = parts[0];
    let rest = parts.slice(1).join("-");
    if (first && rest === "h") {
      acc.flipX = true;
      return acc;
    }
    if (first && rest === "v") {
      acc.flipY = true;
      return acc;
    }
    rest = parseFloat(rest);
    if (isNaN(rest)) {
      return acc;
    }
    switch (first) {
      case "grow":
        acc.size = acc.size + rest;
        break;
      case "shrink":
        acc.size = acc.size - rest;
        break;
      case "left":
        acc.x = acc.x - rest;
        break;
      case "right":
        acc.x = acc.x + rest;
        break;
      case "up":
        acc.y = acc.y - rest;
        break;
      case "down":
        acc.y = acc.y + rest;
        break;
      case "rotate":
        acc.rotate = acc.rotate + rest;
        break;
    }
    return acc;
  }, transform2);
};
var PowerTransforms = {
  mixout() {
    return {
      parse: {
        transform: (transformString) => {
          return parseTransformString(transformString);
        }
      }
    };
  },
  hooks() {
    return {
      parseNodeAttributes(accumulator, node2) {
        const transformString = node2.getAttribute("data-fa-transform");
        if (transformString) {
          accumulator.transform = parseTransformString(transformString);
        }
        return accumulator;
      }
    };
  },
  provides(providers2) {
    providers2.generateAbstractTransformGrouping = function(_ref3) {
      let {
        main,
        transform: transform2,
        containerWidth,
        iconWidth
      } = _ref3;
      const outer = {
        transform: "translate(".concat(containerWidth / 2, " 256)")
      };
      const innerTranslate = "translate(".concat(transform2.x * 32, ", ").concat(transform2.y * 32, ") ");
      const innerScale = "scale(".concat(transform2.size / 16 * (transform2.flipX ? -1 : 1), ", ").concat(transform2.size / 16 * (transform2.flipY ? -1 : 1), ") ");
      const innerRotate = "rotate(".concat(transform2.rotate, " 0 0)");
      const inner = {
        transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
      };
      const path = {
        transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
      };
      const operations = {
        outer,
        inner,
        path
      };
      return {
        tag: "g",
        attributes: {
          ...operations.outer
        },
        children: [{
          tag: "g",
          attributes: {
            ...operations.inner
          },
          children: [{
            tag: main.icon.tag,
            children: main.icon.children,
            attributes: {
              ...main.icon.attributes,
              ...operations.path
            }
          }]
        }]
      };
    };
  }
};
var ALL_SPACE = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function fillBlack(abstract) {
  let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (abstract.attributes && (abstract.attributes.fill || force)) {
    abstract.attributes.fill = "black";
  }
  return abstract;
}
function deGroup(abstract) {
  if (abstract.tag === "g") {
    return abstract.children;
  } else {
    return [abstract];
  }
}
var Masks = {
  hooks() {
    return {
      parseNodeAttributes(accumulator, node2) {
        const maskData = node2.getAttribute("data-fa-mask");
        const mask = !maskData ? emptyCanonicalIcon() : getCanonicalIcon(maskData.split(" ").map((i4) => i4.trim()));
        if (!mask.prefix) {
          mask.prefix = getDefaultUsablePrefix();
        }
        accumulator.mask = mask;
        accumulator.maskId = node2.getAttribute("data-fa-mask-id");
        return accumulator;
      }
    };
  },
  provides(providers2) {
    providers2.generateAbstractMask = function(_ref3) {
      let {
        children,
        attributes,
        main,
        mask,
        maskId: explicitMaskId,
        transform: transform2
      } = _ref3;
      const {
        width: mainWidth,
        icon: mainPath
      } = main;
      const {
        width: maskWidth,
        icon: maskPath
      } = mask;
      const trans = transformForSvg({
        transform: transform2,
        containerWidth: maskWidth,
        iconWidth: mainWidth
      });
      const maskRect = {
        tag: "rect",
        attributes: {
          ...ALL_SPACE,
          fill: "white"
        }
      };
      const maskInnerGroupChildrenMixin = mainPath.children ? {
        children: mainPath.children.map(fillBlack)
      } : {};
      const maskInnerGroup = {
        tag: "g",
        attributes: {
          ...trans.inner
        },
        children: [fillBlack({
          tag: mainPath.tag,
          attributes: {
            ...mainPath.attributes,
            ...trans.path
          },
          ...maskInnerGroupChildrenMixin
        })]
      };
      const maskOuterGroup = {
        tag: "g",
        attributes: {
          ...trans.outer
        },
        children: [maskInnerGroup]
      };
      const maskId = "mask-".concat(explicitMaskId || nextUniqueId());
      const clipId = "clip-".concat(explicitMaskId || nextUniqueId());
      const maskTag = {
        tag: "mask",
        attributes: {
          ...ALL_SPACE,
          id: maskId,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        },
        children: [maskRect, maskOuterGroup]
      };
      const defs = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: clipId
          },
          children: deGroup(maskPath)
        }, maskTag]
      };
      children.push(defs, {
        tag: "rect",
        attributes: {
          fill: "currentColor",
          "clip-path": "url(#".concat(clipId, ")"),
          mask: "url(#".concat(maskId, ")"),
          ...ALL_SPACE
        }
      });
      return {
        children,
        attributes
      };
    };
  }
};
var MissingIconIndicator = {
  provides(providers2) {
    let reduceMotion = false;
    if (WINDOW.matchMedia) {
      reduceMotion = WINDOW.matchMedia("(prefers-reduced-motion: reduce)").matches;
    }
    providers2.missingIconAbstract = function() {
      const gChildren = [];
      const FILL = {
        fill: "currentColor"
      };
      const ANIMATION_BASE = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      gChildren.push({
        tag: "path",
        attributes: {
          ...FILL,
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        }
      });
      const OPACITY_ANIMATE = {
        ...ANIMATION_BASE,
        attributeName: "opacity"
      };
      const dot2 = {
        tag: "circle",
        attributes: {
          ...FILL,
          cx: "256",
          cy: "364",
          r: "28"
        },
        children: []
      };
      if (!reduceMotion) {
        dot2.children.push({
          tag: "animate",
          attributes: {
            ...ANIMATION_BASE,
            attributeName: "r",
            values: "28;14;28;28;14;28;"
          }
        }, {
          tag: "animate",
          attributes: {
            ...OPACITY_ANIMATE,
            values: "1;0;1;1;0;1;"
          }
        });
      }
      gChildren.push(dot2);
      gChildren.push({
        tag: "path",
        attributes: {
          ...FILL,
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        },
        children: reduceMotion ? [] : [{
          tag: "animate",
          attributes: {
            ...OPACITY_ANIMATE,
            values: "1;0;0;0;0;1;"
          }
        }]
      });
      if (!reduceMotion) {
        gChildren.push({
          tag: "path",
          attributes: {
            ...FILL,
            opacity: "0",
            d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
          },
          children: [{
            tag: "animate",
            attributes: {
              ...OPACITY_ANIMATE,
              values: "0;0;1;1;0;0;"
            }
          }]
        });
      }
      return {
        tag: "g",
        attributes: {
          "class": "missing"
        },
        children: gChildren
      };
    };
  }
};
var SvgSymbols = {
  hooks() {
    return {
      parseNodeAttributes(accumulator, node2) {
        const symbolData = node2.getAttribute("data-fa-symbol");
        const symbol = symbolData === null ? false : symbolData === "" ? true : symbolData;
        accumulator["symbol"] = symbol;
        return accumulator;
      }
    };
  }
};
var plugins = [InjectCSS, ReplaceElements, Layers, LayersCounter, LayersText, PseudoElements, MutationObserver$1, PowerTransforms, Masks, MissingIconIndicator, SvgSymbols];
registerPlugins(plugins, {
  mixoutsTo: api
});
var noAuto$1 = api.noAuto;
var config$1 = api.config;
var library$1 = api.library;
var dom$1 = api.dom;
var parse$1 = api.parse;
var findIconDefinition$1 = api.findIconDefinition;
var toHtml$1 = api.toHtml;
var icon = api.icon;
var layer = api.layer;
var text = api.text;
var counter = api.counter;

// node_modules/@fortawesome/react-fontawesome/index.es.js
var import_prop_types = __toESM(require_prop_types());
function ownKeys2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread22(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = null != arguments[i4] ? arguments[i4] : {};
    i4 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _typeof2(obj) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof2(obj);
}
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i4;
  for (i4 = 0; i4 < sourceKeys.length; i4++) {
    key = sourceKeys[i4];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties2(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose2(source, excluded);
  var key, i4;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i4 = 0; i4 < sourceSymbolKeys.length; i4++) {
      key = sourceSymbolKeys[i4];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _toConsumableArray2(arr) {
  return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
}
function _arrayWithoutHoles2(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray2(arr);
}
function _iterableToArray2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray2(o4, minLen) {
  if (!o4) return;
  if (typeof o4 === "string") return _arrayLikeToArray2(o4, minLen);
  var n3 = Object.prototype.toString.call(o4).slice(8, -1);
  if (n3 === "Object" && o4.constructor) n3 = o4.constructor.name;
  if (n3 === "Map" || n3 === "Set") return Array.from(o4);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return _arrayLikeToArray2(o4, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i4 = 0, arr2 = new Array(len); i4 < len; i4++) arr2[i4] = arr[i4];
  return arr2;
}
function _nonIterableSpread2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function classList(props) {
  var _classes;
  var beat = props.beat, fade = props.fade, beatFade = props.beatFade, bounce = props.bounce, shake = props.shake, flash = props.flash, spin = props.spin, spinPulse = props.spinPulse, spinReverse = props.spinReverse, pulse = props.pulse, fixedWidth = props.fixedWidth, inverse = props.inverse, border = props.border, listItem = props.listItem, flip2 = props.flip, size2 = props.size, rotation = props.rotation, pull = props.pull;
  var classes = (_classes = {
    "fa-beat": beat,
    "fa-fade": fade,
    "fa-beat-fade": beatFade,
    "fa-bounce": bounce,
    "fa-shake": shake,
    "fa-flash": flash,
    "fa-spin": spin,
    "fa-spin-reverse": spinReverse,
    "fa-spin-pulse": spinPulse,
    "fa-pulse": pulse,
    "fa-fw": fixedWidth,
    "fa-inverse": inverse,
    "fa-border": border,
    "fa-li": listItem,
    "fa-flip": flip2 === true,
    "fa-flip-horizontal": flip2 === "horizontal" || flip2 === "both",
    "fa-flip-vertical": flip2 === "vertical" || flip2 === "both"
  }, _defineProperty2(_classes, "fa-".concat(size2), typeof size2 !== "undefined" && size2 !== null), _defineProperty2(_classes, "fa-rotate-".concat(rotation), typeof rotation !== "undefined" && rotation !== null && rotation !== 0), _defineProperty2(_classes, "fa-pull-".concat(pull), typeof pull !== "undefined" && pull !== null), _defineProperty2(_classes, "fa-swap-opacity", props.swapOpacity), _classes);
  return Object.keys(classes).map(function(key) {
    return classes[key] ? key : null;
  }).filter(function(key) {
    return key;
  });
}
function _isNumerical(obj) {
  obj = obj - 0;
  return obj === obj;
}
function camelize(string2) {
  if (_isNumerical(string2)) {
    return string2;
  }
  string2 = string2.replace(/[\-_\s]+(.)?/g, function(match4, chr) {
    return chr ? chr.toUpperCase() : "";
  });
  return string2.substr(0, 1).toLowerCase() + string2.substr(1);
}
var _excluded5 = ["style"];
function capitalize(val) {
  return val.charAt(0).toUpperCase() + val.slice(1);
}
function styleToObject(style) {
  return style.split(";").map(function(s4) {
    return s4.trim();
  }).filter(function(s4) {
    return s4;
  }).reduce(function(acc, pair2) {
    var i4 = pair2.indexOf(":");
    var prop = camelize(pair2.slice(0, i4));
    var value = pair2.slice(i4 + 1).trim();
    prop.startsWith("webkit") ? acc[capitalize(prop)] = value : acc[prop] = value;
    return acc;
  }, {});
}
function convert2(createElement2, element) {
  var extraProps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof element === "string") {
    return element;
  }
  var children = (element.children || []).map(function(child) {
    return convert2(createElement2, child);
  });
  var mixins = Object.keys(element.attributes || {}).reduce(function(acc, key) {
    var val = element.attributes[key];
    switch (key) {
      case "class":
        acc.attrs["className"] = val;
        delete element.attributes["class"];
        break;
      case "style":
        acc.attrs["style"] = styleToObject(val);
        break;
      default:
        if (key.indexOf("aria-") === 0 || key.indexOf("data-") === 0) {
          acc.attrs[key.toLowerCase()] = val;
        } else {
          acc.attrs[camelize(key)] = val;
        }
    }
    return acc;
  }, {
    attrs: {}
  });
  var _extraProps$style = extraProps.style, existingStyle = _extraProps$style === void 0 ? {} : _extraProps$style, remaining = _objectWithoutProperties2(extraProps, _excluded5);
  mixins.attrs["style"] = _objectSpread22(_objectSpread22({}, mixins.attrs["style"]), existingStyle);
  return createElement2.apply(void 0, [element.tag, _objectSpread22(_objectSpread22({}, mixins.attrs), remaining)].concat(_toConsumableArray2(children)));
}
var PRODUCTION2 = false;
try {
  PRODUCTION2 = false;
} catch (e3) {
}
function log() {
  if (!PRODUCTION2 && console && typeof console.error === "function") {
    var _console;
    (_console = console).error.apply(_console, arguments);
  }
}
function normalizeIconArgs(icon2) {
  if (icon2 && _typeof2(icon2) === "object" && icon2.prefix && icon2.iconName && icon2.icon) {
    return icon2;
  }
  if (parse$1.icon) {
    return parse$1.icon(icon2);
  }
  if (icon2 === null) {
    return null;
  }
  if (icon2 && _typeof2(icon2) === "object" && icon2.prefix && icon2.iconName) {
    return icon2;
  }
  if (Array.isArray(icon2) && icon2.length === 2) {
    return {
      prefix: icon2[0],
      iconName: icon2[1]
    };
  }
  if (typeof icon2 === "string") {
    return {
      prefix: "fas",
      iconName: icon2
    };
  }
}
function objectWithKey(key, value) {
  return Array.isArray(value) && value.length > 0 || !Array.isArray(value) && value ? _defineProperty2({}, key, value) : {};
}
var defaultProps2 = {
  border: false,
  className: "",
  mask: null,
  maskId: null,
  fixedWidth: false,
  inverse: false,
  flip: false,
  icon: null,
  listItem: false,
  pull: null,
  pulse: false,
  rotation: null,
  size: null,
  spin: false,
  spinPulse: false,
  spinReverse: false,
  beat: false,
  fade: false,
  beatFade: false,
  bounce: false,
  shake: false,
  symbol: false,
  title: "",
  titleId: null,
  transform: null,
  swapOpacity: false
};
var FontAwesomeIcon = /* @__PURE__ */ xn.forwardRef(function(props, ref) {
  var allProps = _objectSpread22(_objectSpread22({}, defaultProps2), props);
  var iconArgs = allProps.icon, maskArgs = allProps.mask, symbol = allProps.symbol, className = allProps.className, title = allProps.title, titleId = allProps.titleId, maskId = allProps.maskId;
  var iconLookup = normalizeIconArgs(iconArgs);
  var classes = objectWithKey("classes", [].concat(_toConsumableArray2(classList(allProps)), _toConsumableArray2((className || "").split(" "))));
  var transform2 = objectWithKey("transform", typeof allProps.transform === "string" ? parse$1.transform(allProps.transform) : allProps.transform);
  var mask = objectWithKey("mask", normalizeIconArgs(maskArgs));
  var renderedIcon = icon(iconLookup, _objectSpread22(_objectSpread22(_objectSpread22(_objectSpread22({}, classes), transform2), mask), {}, {
    symbol,
    title,
    titleId,
    maskId
  }));
  if (!renderedIcon) {
    log("Could not find icon", iconLookup);
    return null;
  }
  var abstract = renderedIcon.abstract;
  var extraProps = {
    ref
  };
  Object.keys(allProps).forEach(function(key) {
    if (!defaultProps2.hasOwnProperty(key)) {
      extraProps[key] = allProps[key];
    }
  });
  return convertCurry(abstract[0], extraProps);
});
FontAwesomeIcon.displayName = "FontAwesomeIcon";
FontAwesomeIcon.propTypes = {
  beat: import_prop_types.default.bool,
  border: import_prop_types.default.bool,
  beatFade: import_prop_types.default.bool,
  bounce: import_prop_types.default.bool,
  className: import_prop_types.default.string,
  fade: import_prop_types.default.bool,
  flash: import_prop_types.default.bool,
  mask: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.array, import_prop_types.default.string]),
  maskId: import_prop_types.default.string,
  fixedWidth: import_prop_types.default.bool,
  inverse: import_prop_types.default.bool,
  flip: import_prop_types.default.oneOf([true, false, "horizontal", "vertical", "both"]),
  icon: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.array, import_prop_types.default.string]),
  listItem: import_prop_types.default.bool,
  pull: import_prop_types.default.oneOf(["right", "left"]),
  pulse: import_prop_types.default.bool,
  rotation: import_prop_types.default.oneOf([0, 90, 180, 270]),
  shake: import_prop_types.default.bool,
  size: import_prop_types.default.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
  spin: import_prop_types.default.bool,
  spinPulse: import_prop_types.default.bool,
  spinReverse: import_prop_types.default.bool,
  symbol: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.string]),
  title: import_prop_types.default.string,
  titleId: import_prop_types.default.string,
  transform: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.object]),
  swapOpacity: import_prop_types.default.bool
};
var convertCurry = convert2.bind(null, xn.createElement);

// src/api/ui/views/table.tsx
function VanillaTable(props) {
  const columns = useInterning(props.columns, (a4, b3) => {
    if (a4.length != b3.length) return false;
    return a4.every((value, index2) => value == b3[index2]);
  });
  const tableRef = A2(null);
  const totalElements = T2(() => Groupings.count(props.rows), [props.rows]);
  const paging = useDatacorePaging({
    initialPage: 0,
    paging: props.paging,
    scrollOnPageChange: props.scrollOnPaging,
    elements: totalElements,
    container: tableRef
  });
  const pagedRows = T2(() => {
    console.log("recalc rows");
    if (paging.enabled)
      return Groupings.slice(props.rows, paging.page * paging.pageSize, (paging.page + 1) * paging.pageSize);
    else return props.rows;
  }, [paging.page, paging.pageSize, paging.enabled, props.rows]);
  const groupings = T2(() => {
    if (!props.groupings) return void 0;
    if (Array.isArray(props.groupings)) return props.groupings;
    if (Literals.isFunction(props.groupings)) return [{ render: props.groupings }];
    else return [props.groupings];
  }, [props.groupings]);
  return /* @__PURE__ */ u3("div", { ref: tableRef, children: [
    /* @__PURE__ */ u3("table", { className: "datacore-table", children: [
      /* @__PURE__ */ u3("thead", { children: /* @__PURE__ */ u3("tr", { className: "datacore-table-header-row", children: columns.map((col) => /* @__PURE__ */ u3(VanillaTableHeaderCell, { column: col })) }) }),
      /* @__PURE__ */ u3("tbody", { children: pagedRows.map((row) => /* @__PURE__ */ u3(VanillaRowGroup, { level: 0, groupings, columns, element: row })) })
    ] }),
    paging.enabled && /* @__PURE__ */ u3(ControlledPager, { page: paging.page, totalPages: paging.totalPages, setPage: paging.setPage })
  ] });
}
function VanillaTableHeaderCell({ column: column2 }) {
  const header = T2(() => {
    if (!column2.title) {
      return column2.id;
    } else if (typeof column2.title === "function") {
      return column2.title();
    } else {
      return column2.title;
    }
  }, [column2.id, column2.title]);
  const realWidth = T2(
    () => column2.width === "minimum" ? "1px" : column2.width === "maximum" ? "auto" : column2.width,
    [column2.width]
  );
  return /* @__PURE__ */ u3("th", { width: realWidth, className: "datacore-table-header-cell", children: /* @__PURE__ */ u3("div", { className: "datacore-table-header-title", children: header }) });
}
function VanillaRowGroup({
  level,
  columns,
  element,
  groupings
}) {
  if (Groupings.isElementGroup(element)) {
    const groupingConfig = groupings ? groupings[Math.min(groupings.length - 1, level)] : void 0;
    return /* @__PURE__ */ u3(b, { children: [
      /* @__PURE__ */ u3(TableGroupHeader, { level, value: element, width: columns.length, config: groupingConfig }),
      element.rows.map((row) => /* @__PURE__ */ u3(VanillaRowGroup, { level: level + 1, columns, element: row }))
    ] });
  } else {
    return /* @__PURE__ */ u3(TableRow, { level, row: element, columns });
  }
}
function TableGroupHeader({
  level,
  value,
  width,
  config: config3
}) {
  const sourcePath = x2(CURRENT_FILE_CONTEXT);
  const rawRenderable = T2(() => {
    if (config3 == null ? void 0 : config3.render) return config3.render(value.key, value.rows);
    else
      return /* @__PURE__ */ u3("h2", { children: /* @__PURE__ */ u3(Lit, { sourcePath, inline: true, value: value.key }) });
  }, [config3 == null ? void 0 : config3.render, value.key, value.rows]);
  const renderable = useAsElement(rawRenderable);
  return /* @__PURE__ */ u3("tr", { className: "datacore-table-group-header", children: /* @__PURE__ */ u3("td", { colSpan: width, children: renderable }) });
}
function TableRow({ level, row, columns }) {
  return /* @__PURE__ */ u3(
    "tr",
    {
      className: "datacore-table-row",
      style: level ? `padding-left: ${level * 5}px` : void 0,
      children: columns.map((col) => /* @__PURE__ */ u3(TableRowCell, { row, column: col }))
    },
    "$id" in row ? row.$id : void 0
  );
}
function TableRowCell({ row, column: column2 }) {
  const value = column2.value(row);
  const [editableState, dispatch] = useEditableDispatch({
    content: value,
    isEditing: false,
    updater: (v3) => column2.onUpdate && column2.onUpdate(v3, row)
  });
  const renderable = T2(() => {
    if (column2.render) {
      let r4 = column2.render(value, row);
      return r4;
    } else return value;
  }, [row, column2.render, editableState.content, value]);
  const rendered = useAsElement(renderable);
  const { editor: Editor } = column2;
  return /* @__PURE__ */ u3(
    "td",
    {
      onDblClick: () => dispatch({ type: "editing-toggled", newValue: !editableState.isEditing }),
      className: "datacore-table-cell",
      children: column2.editable && editableState.isEditing && Editor ? /* @__PURE__ */ u3(Editor, { dispatch, ...column2.editorProps ? column2.editorProps(row) : {}, ...editableState }) : rendered
    }
  );
}
function useAsElement(element) {
  const sourcePath = x2(CURRENT_FILE_CONTEXT);
  return T2(() => {
    if (t(element)) {
      return element;
    } else {
      return /* @__PURE__ */ u3(Lit, { sourcePath, inline: true, value: element });
    }
  }, [element]);
}
function SortButton({
  direction,
  onClick,
  className
}) {
  const icon2 = T2(() => {
    if (direction == "ascending") return faSortDown;
    else if (direction == "descending") return faSortUp;
    return faSort;
  }, [direction]);
  return /* @__PURE__ */ u3("div", { onClick, className, children: /* @__PURE__ */ u3(FontAwesomeIcon, { icon: icon2 }) });
}
var DEFAULT_TABLE_COMPARATOR = (a4, b3, _ao, _bo) => Literals.compare(a4, b3);

// src/api/ui/views/callout.tsx
var METADATA_SPLIT_REGEX = /\|(.*)/s;
function Callout({
  collapsible = true,
  open: openProp,
  initialOpen,
  onOpenChange,
  title,
  icon: icon2,
  children,
  type
}) {
  var _a, _b;
  const [open, setOpen] = useControlledState(initialOpen != null ? initialOpen : true, openProp, onOpenChange);
  return /* @__PURE__ */ u3(
    "div",
    {
      "data-callout-metadata": (_a = type == null ? void 0 : type.split(METADATA_SPLIT_REGEX)) == null ? void 0 : _a[1],
      "data-callout": (_b = type == null ? void 0 : type.split(METADATA_SPLIT_REGEX)) == null ? void 0 : _b[0],
      "data-callout-fold": open ? "+" : "-",
      className: combineClasses("datacore", "callout", collapsible ? "is-collapsible" : void 0),
      children: [
        /* @__PURE__ */ u3("div", { className: "callout-title", onClick: () => collapsible && setOpen(!open), children: [
          icon2 && /* @__PURE__ */ u3("div", { className: "callout-icon", children: icon2 }),
          /* @__PURE__ */ u3("div", { className: "callout-title-inner", children: title }),
          collapsible && /* @__PURE__ */ u3("div", { className: combineClasses("callout-fold", !open ? "is-collapsed" : void 0), children: /* @__PURE__ */ u3(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              width: "24",
              height: "24",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              "stroke-width": "2",
              "stroke-linecap": "round",
              "stroke-linejoin": "round",
              class: "svg-icon lucide-chevron-down",
              children: /* @__PURE__ */ u3("path", { d: "m6 9 6 6 6-6" })
            }
          ) })
        ] }),
        open && /* @__PURE__ */ u3("div", { className: "callout-content", children })
      ]
    }
  );
}

// src/api/ui/views/cards.tsx
function Card(props) {
  const cardTitle = T2(() => {
    if (typeof props.title === "function") {
      return props.title(props.value);
    } else {
      return props.title;
    }
  }, [props.value, props.title]);
  const innerContent = T2(() => {
    if (typeof props.content === "function") return props.content(props.value);
    else return props.content;
  }, [props.value, props.content]);
  const footerContent = T2(() => {
    if (props.footer !== void 0) {
      if (typeof props.footer === "function") {
        return props.footer(props.value);
      } else {
        return props.footer;
      }
    }
    return null;
  }, [props.footer, props.value]);
  const titleClasses = T2(() => {
    let base = ["datacore-card-title"];
    if (props.centerTitle) base = base.concat("centered");
    return base;
  }, [props.centerTitle, props.title, props.content, props.value]);
  return /* @__PURE__ */ u3("div", { className: "datacore-card", children: [
    /* @__PURE__ */ u3("div", { className: titleClasses.join(" "), children: cardTitle }),
    /* @__PURE__ */ u3("div", { className: "datacore-card-inner", children: [
      /* @__PURE__ */ u3("div", { className: "datacore-card-content", children: innerContent }),
      /* @__PURE__ */ u3("div", { className: "datacore-card-footer", children: footerContent })
    ] })
  ] });
}

// src/api/data-array.ts
var _DataArrayImpl = class _DataArrayImpl {
  constructor(values, defaultComparator = Literals.compare) {
    this.values = values;
    this.defaultComparator = defaultComparator;
    this.length = values.length;
  }
  static wrap(arr, defaultComparator = Literals.compare) {
    return new Proxy(new _DataArrayImpl(arr, defaultComparator), _DataArrayImpl.ARRAY_PROXY);
  }
  lwrap(values) {
    return _DataArrayImpl.wrap(values, this.defaultComparator);
  }
  chain(op) {
    return op(this);
  }
  where(predicate) {
    return this.lwrap(this.values.filter(predicate));
  }
  filter(predicate) {
    return this.where(predicate);
  }
  map(f4) {
    return this.lwrap(this.values.map(f4));
  }
  flatMap(f4) {
    let result = [];
    for (let index2 = 0; index2 < this.length; index2++) {
      let value = f4(this.values[index2], index2, this.values);
      if (!value || value.length == 0) continue;
      for (let r4 of value) result.push(r4);
    }
    return this.lwrap(result);
  }
  mutate(f4) {
    for (let index2 = 0; index2 < this.values.length; index2++) {
      f4(this.values[index2], index2, this.values);
    }
    return this;
  }
  limit(count) {
    return this.lwrap(this.values.slice(0, count));
  }
  slice(start, end2) {
    return this.lwrap(this.values.slice(start, end2));
  }
  concat(other) {
    return this.lwrap(this.values.concat(other.values));
  }
  /** Return the first index of the given (optionally starting the search) */
  indexOf(element, fromIndex) {
    return this.findIndex((e3) => this.defaultComparator(e3, element) == 0, fromIndex);
  }
  /** Return the first element that satisfies the given predicate. */
  find(pred) {
    let index2 = this.findIndex(pred);
    if (index2 == -1) return void 0;
    else return this.values[index2];
  }
  findIndex(pred, fromIndex) {
    for (let index2 = fromIndex != null ? fromIndex : 0; index2 < this.length; index2++) {
      if (pred(this.values[index2], index2, this.values)) return index2;
    }
    return -1;
  }
  includes(element) {
    return this.indexOf(element, 0) != -1;
  }
  join(sep) {
    return this.map((s4) => Literals.toString(s4)).array().join(sep != null ? sep : ", ");
  }
  sort(key, direction, comparator) {
    if (this.values.length == 0) return this;
    let realComparator = comparator != null ? comparator : this.defaultComparator;
    let realKey = key != null ? key : (l4) => l4;
    let copy2 = [].concat(this.array()).map((elem, index2) => {
      return { index: index2, value: elem };
    });
    copy2.sort((a4, b3) => {
      let aKey = realKey(a4.value, a4.index, this.values);
      let bKey = realKey(b3.value, b3.index, this.values);
      return direction === "desc" ? -realComparator(aKey, bKey) : realComparator(aKey, bKey);
    });
    return this.lwrap(copy2.map((e3) => e3.value));
  }
  sortInPlace(key, direction, comparator) {
    if (this.values.length == 0) return this;
    let realComparator = comparator != null ? comparator : this.defaultComparator;
    let realKey = key != null ? key : (l4) => l4;
    this.values.sort((a4, b3) => {
      let aKey = realKey(a4);
      let bKey = realKey(b3);
      return direction == "desc" ? -realComparator(aKey, bKey) : realComparator(aKey, bKey);
    });
    return this;
  }
  groupBy(key, comparator) {
    if (this.values.length == 0) return this.lwrap([]);
    let intermediate = this.sort(key, "asc", comparator);
    comparator = comparator != null ? comparator : this.defaultComparator;
    let result = [];
    let currentRow = [intermediate[0]];
    let current = key(intermediate[0], 0, intermediate.values);
    for (let index2 = 1; index2 < intermediate.length; index2++) {
      let newKey = key(intermediate[index2], index2, intermediate.values);
      if (comparator(current, newKey) != 0) {
        result.push({ key: current, rows: currentRow });
        current = newKey;
        currentRow = [intermediate[index2]];
      } else {
        currentRow.push(intermediate[index2]);
      }
    }
    result.push({ key: current, rows: currentRow });
    return this.lwrap(result);
  }
  groupIn(key, comparator) {
    if (Groupings.isGrouping(this.values)) {
      return this.map((v3) => {
        return {
          key: v3.key,
          rows: DataArray.wrap(v3.rows).groupIn(key, comparator)
        };
      });
    } else {
      return this.groupBy(key, comparator);
    }
  }
  distinct(key, comparator) {
    if (this.values.length == 0) return this;
    let realKey = key != null ? key : (x4) => x4;
    let intermediate = this.map((x4, index2) => {
      return { key: realKey(x4, index2, this.values), value: x4 };
    }).sort((x4) => x4.key, "asc", comparator);
    comparator = comparator != null ? comparator : this.defaultComparator;
    let result = [intermediate[0].value];
    for (let index2 = 1; index2 < intermediate.length; index2++) {
      if (comparator(intermediate[index2 - 1].key, intermediate[index2].key) != 0) {
        result.push(intermediate[index2].value);
      }
    }
    return this.lwrap(result);
  }
  every(f4) {
    return this.values.every(f4);
  }
  some(f4) {
    return this.values.some(f4);
  }
  none(f4) {
    return this.values.every((v3, i4, a4) => !f4(v3, i4, a4));
  }
  first() {
    return this.values.length > 0 ? this.values[0] : void 0;
  }
  last() {
    return this.values.length > 0 ? this.values[this.values.length - 1] : void 0;
  }
  to(key) {
    let result = [];
    for (let child of this.values) {
      let value = child[key];
      if (value === void 0 || value === null) continue;
      if (Array.isArray(value) || DataArray.isDataArray(value)) value.forEach((v3) => result.push(v3));
      else result.push(value);
    }
    return this.lwrap(result);
  }
  into(key) {
    let result = [];
    for (let child of this.values) {
      let value = child[key];
      if (value === void 0 || value === null) continue;
      result.push(value);
    }
    return this.lwrap(result);
  }
  expand(key) {
    let result = [];
    let queue = [].concat(this.values);
    while (queue.length > 0) {
      let next3 = queue.pop();
      let value = next3[key];
      if (value === void 0 || value === null) continue;
      if (Array.isArray(value)) value.forEach((v3) => queue.push(v3));
      else if (value instanceof _DataArrayImpl) value.forEach((v3) => queue.push(v3));
      else queue.push(value);
      result.push(next3);
    }
    return this.lwrap(result);
  }
  forEach(f4) {
    for (let index2 = 0; index2 < this.values.length; index2++) {
      f4(this.values[index2], index2, this.values);
    }
  }
  array() {
    return [].concat(this.values);
  }
  [Symbol.iterator]() {
    return this.values[Symbol.iterator]();
  }
  toString() {
    return "[" + this.values.join(", ") + "]";
  }
};
_DataArrayImpl.ARRAY_FUNCTIONS = /* @__PURE__ */ new Set([
  "chain",
  "where",
  "filter",
  "map",
  "flatMap",
  "mutate",
  "slice",
  "concat",
  "indexOf",
  "limit",
  "find",
  "findIndex",
  "includes",
  "join",
  "sort",
  "sortInPlace",
  "groupBy",
  "groupIn",
  "distinct",
  "every",
  "some",
  "none",
  "first",
  "last",
  "to",
  "into",
  "lwrap",
  "expand",
  "forEach",
  "length",
  "values",
  "array",
  "defaultComparator",
  "toString",
  "settings"
]);
_DataArrayImpl.ARRAY_PROXY = {
  get: function(target, prop, reciever) {
    if (typeof prop === "symbol") return target[prop];
    else if (typeof prop === "number") return target.values[prop];
    else if (prop === "constructor") return target.values.constructor;
    else if (!isNaN(parseInt(prop))) return target.values[parseInt(prop)];
    else if (_DataArrayImpl.ARRAY_FUNCTIONS.has(prop.toString())) return target[prop.toString()];
    return target.to(prop);
  }
};
var DataArrayImpl = _DataArrayImpl;
var DataArray;
((DataArray2) => {
  function wrap(raw) {
    if (isDataArray(raw)) return raw;
    return DataArrayImpl.wrap(raw);
  }
  DataArray2.wrap = wrap;
  function from2(raw) {
    if (isDataArray(raw)) return raw;
    let data = [];
    for (let elem of raw) data.push(elem);
    return DataArrayImpl.wrap(data);
  }
  DataArray2.from = from2;
  function isDataArray(obj) {
    return obj instanceof DataArrayImpl;
  }
  DataArray2.isDataArray = isDataArray;
})(DataArray || (DataArray = {}));
var oldArrayIsArray = Array.isArray;
Array.isArray = (arg) => {
  return oldArrayIsArray(arg) || DataArray.isDataArray(arg);
};

// src/api/coerce.ts
var Coerce;
((Coerce2) => {
  function string2(value) {
    const wrapped = Literals.wrapValue(value);
    if (!wrapped) return void 0;
    switch (wrapped.type) {
      case "string":
        return wrapped.value;
      case "number":
        return "" + wrapped.value;
      case "date":
        return renderMinimalDate(wrapped.value, "yyyy-MM-dd", "yyyy-MM-dd HH:mm:ss");
      case "link":
        return wrapped.value.markdown();
      case "boolean":
        return "" + wrapped.value;
      default:
        return void 0;
    }
  }
  Coerce2.string = string2;
  function boolean(value) {
    if (typeof value === "boolean") return value;
    else if (typeof value === "string" && value.toLowerCase() === "true") return true;
    else if (typeof value === "string" && value.toLowerCase() === "false") return false;
    else return void 0;
  }
  Coerce2.boolean = boolean;
  function number(value) {
    if (typeof value === "number") return value;
    else if (typeof value === "string") {
      const parsed = parseFloat(value);
      if (!isNaN(parsed)) return parsed;
      else return void 0;
    } else return void 0;
  }
  Coerce2.number = number;
  function date(value) {
    if (value instanceof DateTime) return value;
    else if (typeof value === "string") {
      const parsed = PRIMITIVES.datePlus.parse(value);
      if (parsed.status) return parsed.value;
      else return void 0;
    } else return void 0;
  }
  Coerce2.date = date;
  function duration(value) {
    if (value instanceof Duration) return value;
    else if (typeof value === "string") {
      const parsed = PRIMITIVES.duration.parse(value);
      if (parsed.status) return parsed.value;
      else return void 0;
    } else return void 0;
  }
  Coerce2.duration = duration;
  function link(value) {
    if (value instanceof Link) return value;
    else if (typeof value === "string") {
      const parsed = PRIMITIVES.embedLink.parse(value);
      if (parsed.status) return parsed.value;
      else return void 0;
    } else return void 0;
  }
  Coerce2.link = link;
  function array2(value) {
    if (Array.isArray(value)) return value;
    else return [value];
  }
  Coerce2.array = array2;
})(Coerce || (Coerce = {}));

// src/utils/deferred.ts
function deferred() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  const deferred2 = promise;
  deferred2.resolve = resolve;
  deferred2.reject = reject;
  return deferred2;
}

// src/api/script-cache.ts
var _ScriptCache = class _ScriptCache {
  constructor(store) {
    this.store = store;
    /** Caches scripts by fully qualified path. */
    this.scripts = /* @__PURE__ */ new Map();
  }
  /** Load the given script at the given path, recursively loading any subscripts as well.  */
  async load(path, context) {
    const key = this.pathkey(path);
    const currentScript = this.scripts.get(key);
    if (currentScript) {
      if (currentScript.type === "loaded") return Result.success(currentScript.object);
      return Result.failure(
        `Failed to import script "${path.toString()}", as it is in the middle of being loaded. Do you have
                 a circular dependency in your require() calls? The currently loaded or loading scripts are: 
                 ${Array.from(this.scripts.values()).map((sc) => "	" + sc.path).join("\n")}`
      );
    }
    const deferral = deferred();
    this.scripts.set(key, { type: "loading", promise: deferral, path: key });
    const result = await this.loadUncached(path, context);
    deferral.resolve(result);
    if (result.successful) {
      this.scripts.set(key, { type: "loaded", path: key, object: result.value });
    } else {
      this.scripts.delete(key);
    }
    return result;
  }
  /** Load a script, directly bypassing the cache. */
  async loadUncached(path, context) {
    const maybeSource = await this.resolveSource(path);
    if (!maybeSource.successful) return maybeSource;
    const { code, language } = maybeSource.value;
    let basic;
    try {
      basic = transpile(code, language);
    } catch (error) {
      return Result.failure(`Failed to import ${path.toString()} while transpiling from ${language}: ${error}`);
    }
    const finalContext = Object.assign({ h: _, Fragment: b }, context);
    try {
      return Result.success(await asyncEvalInContext(basic, finalContext));
    } catch (error) {
      return Result.failure(`Failed to execute script '${path.toString()}': ${error}`);
    }
  }
  /** Normalize a path or link to a textual path. */
  pathkey(path) {
    if (path instanceof Link) return path.obsidianLink();
    else return path;
  }
  /** Attempts to resolve the source to load given a path or link to a markdown section. */
  async resolveSource(path) {
    const object = this.store.resolveLink(path);
    if (!object) return Result.failure("Could not find a script at the given path: " + path.toString());
    const tfile = this.store.vault.getFileByPath(object.$file);
    if (!tfile) return Result.failure(`File "${object.$file}" not found.`);
    if (tfile.extension.toLocaleLowerCase() in _ScriptCache.FILE_EXTENSIONS) {
      const language = _ScriptCache.FILE_EXTENSIONS[tfile.extension.toLocaleLowerCase()];
      try {
        const code = await this.store.vault.cachedRead(tfile);
        return Result.success({ code, language });
      } catch (error) {
        return Result.failure("Failed to load javascript/typescript source file: " + error);
      }
    }
    if (object instanceof MarkdownSection) {
      const maybeBlock = object.$blocks.filter((b3) => b3.$type === "codeblock").find(
        (cb) => cb.$languages.some((language2) => language2.toLocaleLowerCase() in _ScriptCache.SCRIPT_LANGUAGES)
      );
      if (!maybeBlock)
        return Result.failure("Could not find a script in the given markdown section: " + path.toString());
      const language = _ScriptCache.SCRIPT_LANGUAGES[maybeBlock.$languages.find((lang) => lang.toLocaleLowerCase() in _ScriptCache.SCRIPT_LANGUAGES)];
      return (await this.readCodeblock(tfile, maybeBlock)).map((code) => ({ code, language }));
    } else if (object instanceof MarkdownCodeblock) {
      const maybeLanguage = object.$languages.find(
        (lang) => lang.toLocaleLowerCase() in _ScriptCache.SCRIPT_LANGUAGES
      );
      if (!maybeLanguage)
        return Result.failure(`The codeblock referenced by '${path}' is not a JS/TS codeblock.`);
      const language = _ScriptCache.SCRIPT_LANGUAGES[maybeLanguage];
      return (await this.readCodeblock(tfile, object)).map((code) => ({ code, language }));
    }
    return Result.failure(`Cannot import '${path.toString()}: not a JS/TS file or codeblock reference.`);
  }
  /** Read the contents of a codeblock from a file. */
  async readCodeblock(file, block) {
    try {
      const raw = lineRange(
        await this.store.vault.cachedRead(file),
        block.$contentPosition.start,
        block.$contentPosition.end
      );
      if (block.$style === "fenced") return Result.success(raw);
      else
        return Result.success(
          raw.split("\n").map((line2) => line2.trimStart()).join("\n")
        );
    } catch (error) {
      return Result.failure(`Failed to read a codeblock from ${file.path}: ${error}`);
    }
  }
};
/** All of the tags we recognize for scripts. */
_ScriptCache.SCRIPT_LANGUAGES = {
  js: "js",
  javascript: "js",
  datacorejs: "js",
  typescript: "ts",
  ts: "ts",
  datacorets: "ts",
  jsx: "jsx",
  datacorejsx: "jsx",
  tsx: "tsx",
  datacoretsx: "tsx"
};
/** All of the direct file extensions we can load. */
_ScriptCache.FILE_EXTENSIONS = {
  tsx: "tsx",
  jsx: "jsx",
  js: "js",
  ts: "ts"
};
var ScriptCache = _ScriptCache;

// src/ui/fields/editable-fields.tsx
function FieldCheckbox(props) {
  var _a;
  const { field, defaultChecked = false, dispatch, ...rest } = props;
  return /* @__PURE__ */ u3(
    Checkbox,
    {
      ...rest,
      disabled: void 0,
      defaultChecked: (_a = field == null ? void 0 : field.value) != null ? _a : defaultChecked,
      onCheckChange: useSetField(
        field,
        (b3) => dispatch({ type: "content-changed", newValue: { ...field, value: b3 } })
      ),
      checked: void 0
    }
  );
}
function EditableTextField(props) {
  var _a;
  const { field, defaultValue = "", inline: inline2, dispatch } = props;
  console.log(field == null ? void 0 : field.value);
  return /* @__PURE__ */ u3(
    ControlledEditableTextField,
    {
      content: (_a = field == null ? void 0 : field.value) != null ? _a : defaultValue,
      inline: inline2,
      dispatch
    }
  );
}
function ControlledEditableTextField(props) {
  const { content, inline: inline2, dispatch } = props;
  const [textState, setText] = h2(content);
  const onInput = async (e3) => {
    setText(e3.currentTarget.value);
    if (props.inline) {
      if (e3.key === "Enter") {
        e3.preventDefault();
        await useFinalizer(textState, dispatch)();
      }
    } else {
      if (e3.key === "Enter" && e3.ctrlKey) {
        e3.preventDefault();
        await useFinalizer(textState, dispatch)();
      }
    }
  };
  return /* @__PURE__ */ u3(UncontrolledTextEditable, { text: content, inline: inline2, dispatch, onInput });
}
function FieldSlider(props) {
  var _a;
  const { field, dispatch, defaultValue = 0, min: min2, max: max2, step, ...rest } = props;
  const value = (_a = field == null ? void 0 : field.value) != null ? _a : defaultValue;
  return /* @__PURE__ */ u3(
    Slider,
    {
      ...rest,
      disabled: false,
      defaultValue: value,
      min: min2,
      max: max2,
      step,
      value: void 0,
      onValueChange: useSetField(
        field,
        (b3) => dispatch({ type: "content-changed", newValue: { ...field, value: b3 } })
      )
    }
  );
}
function FieldSwitch(props) {
  var _a;
  const { field, dispatch, defaultValue = false, ...rest } = props;
  return /* @__PURE__ */ u3(
    Switch,
    {
      ...rest,
      onToggleChange: useSetField(
        field,
        (b3) => dispatch({ type: "content-changed", newValue: { ...field, value: b3 } })
      ),
      defaultChecked: (_a = field == null ? void 0 : field.value) != null ? _a : defaultValue,
      checked: void 0
    }
  );
}
function FieldSelect({
  multi = false,
  options: options2,
  defaultValue,
  field,
  dispatch
}) {
  const innerCallback = useSetField(
    field,
    (b3) => dispatch({ type: "content-changed", newValue: { ...field, value: b3 } })
  );
  const onChange3 = q2(
    (newValue) => {
      let normalized;
      if (Array.isArray(newValue)) {
        normalized = newValue.map((x4) => x4.value);
      } else {
        normalized = newValue.value;
      }
      innerCallback(normalized);
    },
    [field, innerCallback]
  );
  const arrayVal = T2(
    () => Array.isArray(field == null ? void 0 : field.value) ? field.value : !!field ? [field.value] : [defaultValue],
    [field]
  );
  const defVal = T2(
    () => multi ? options2.filter((a4) => arrayVal.findIndex((b3) => b3 == a4.value) != -1) : options2.find((a4) => a4.value == (field == null ? void 0 : field.value)),
    [options2, multi]
  );
  return /* @__PURE__ */ u3(
    StateManagedSelect$1,
    {
      classNamePrefix: "datacore-selectable",
      onChange: (n3) => onChange3(n3),
      unstyled: true,
      isMulti: multi != null ? multi : false,
      options: options2,
      menuPortalTarget: document.body,
      defaultValue: defVal,
      classNames: {
        input: () => "prompt-input",
        valueContainer: () => "suggestion-item value-container",
        container: () => "suggestion-container",
        menu: () => "suggestion-content suggestion-container",
        option: (props) => `suggestion-item${props.isSelected ? " is-selected" : ""}`
      }
    }
  );
}

// src/api/ui/views/tree-table.tsx
var TreeUtils;
((TreeUtils2) => {
  function isTreeTableRowData(data) {
    return "children" in data && "value" in data && !Array.isArray(data) && Object.keys(data).length == 2 && Array.isArray(data.children);
  }
  TreeUtils2.isTreeTableRowData = isTreeTableRowData;
  function countInTreeRow(node2, top = true) {
    let result = 0;
    if (!top) result++;
    for (let n3 of node2.children) result += countInTreeRow(n3, false);
    return result;
  }
  TreeUtils2.countInTreeRow = countInTreeRow;
  function ofArray(source, childFn) {
    const mapper = (el) => {
      return {
        value: el,
        children: childFn(el).map(mapper)
      };
    };
    return source.map(mapper);
  }
  TreeUtils2.ofArray = ofArray;
  function ofNode(source, childFn) {
    return {
      value: source,
      children: ofArray(childFn(source), childFn)
    };
  }
  TreeUtils2.ofNode = ofNode;
  function ofGrouping(elements, childFn) {
    const mapper = (l4) => {
      if (Groupings.isElementGroup(l4))
        return { key: l4.key, rows: l4.rows.map(mapper) };
      return {
        value: l4,
        children: childFn(l4).map(mapper)
      };
    };
    return elements.map(mapper);
  }
  TreeUtils2.ofGrouping = ofGrouping;
  function count(elements) {
    if (Groupings.isElementGroup(elements)) {
      return count(elements.rows);
    } else if (Groupings.isGrouping(elements)) {
      let result = 0;
      for (let group of elements) result += count(group.rows);
      return result;
    } else {
      return elements.reduce((pv, cv) => pv + countInTreeRow(cv), 0);
    }
  }
  TreeUtils2.count = count;
  function slice2(elements, start, end2) {
    let initial2 = [...Groupings.slice(elements, start, end2)];
    let index2 = 0, seen = 0;
    for (let element of initial2) {
      if (Groupings.isElementGroup(element)) {
        let groupSize = Groupings.count(elements);
        let groupStart = Math.min(seen, start);
        let groupEnd = Math.min(groupSize, end2);
        initial2[index2].rows = Groupings.slice(
          element.rows,
          groupStart,
          groupEnd
        );
        seen += groupSize;
      } else {
        seen += countInTreeRow(element);
      }
      index2++;
    }
    return initial2;
  }
  TreeUtils2.slice = slice2;
  function sort(rows, comparators) {
    const realComparator = (a4, b3) => {
      for (let comp of comparators) {
        const direction = comp.direction.toLocaleLowerCase() === "ascending" ? 1 : -1;
        let result = 0;
        if (Groupings.isElementGroup(a4) && Groupings.isElementGroup(b3)) {
          result = 0;
        } else if (!Groupings.isElementGroup(a4) && !Groupings.isElementGroup(b3)) {
          result = direction * comp.fn(comp.actualValue(a4.value), comp.actualValue(b3.value), a4.value, b3.value);
        }
        if (result != 0) return result;
      }
      return 0;
    };
    const map = (t5) => {
      let r4;
      if (Groupings.isElementGroup(t5))
        r4 = { ...t5, rows: sort(t5.rows, comparators).map(map) };
      else r4 = { ...t5, children: sort(t5.children, comparators).map(map) };
      return r4;
    };
    return rows.map(map).sort(realComparator);
  }
  TreeUtils2.sort = sort;
})(TreeUtils || (TreeUtils = {}));
function useKeyFn(id2, ...deps) {
  const ret = q2(
    (el) => {
      if (Groupings.isElementGroup(el)) {
        return el.key;
      } else {
        return id2(el.value);
      }
    },
    [...deps]
  );
  return ret;
}
function treeTableReducer(state2, action) {
  switch (action.type) {
    case "sort-column":
      if (action.direction == void 0) {
        return { ...state2, sortOn: void 0 };
      } else {
        return {
          ...state2,
          sortOn: [
            {
              type: "column",
              id: action.column,
              direction: action.direction
            }
          ]
        };
      }
    case "row-expand":
      const newMap = /* @__PURE__ */ new Map();
      if (!state2.openMap) return { ...state2 };
      for (const k4 of state2.openMap.keys()) newMap.set(k4, state2.openMap.get(k4));
      newMap.set(state2.id(action.row), action.newValue);
      return { ...state2, openMap: newMap };
    case "open-map-changed":
      return { ...state2, openMap: action.newValue };
  }
  console.warn("datacore: Encountered unrecognized operation: " + action.type);
  return state2;
}
function useTreeTableDispatch(initial2) {
  const init = T2(() => typeof initial2 == "function" ? initial2() : initial2, []);
  return p2(treeTableReducer, init);
}
var EXPANDED_CONTEXT = G(null);
function TypedExpandedContext() {
  return EXPANDED_CONTEXT;
}
function TreeTableHeaderCell({
  column: column2,
  sort,
  sortable
}) {
  const { dispatch } = x2(TypedExpandedContext());
  const header = T2(() => {
    if (!column2.title) return column2.id;
    else if (typeof column2.title === "function") return column2.title();
    else return column2.title;
  }, [column2.id, column2.title]);
  const sortClicked = useStableCallback(
    (_event) => {
      if (sort == void 0) dispatch({ type: "sort-column", column: column2.id, direction: "ascending" });
      else if (sort == "ascending") dispatch({ type: "sort-column", column: column2.id, direction: "descending" });
      else dispatch({ type: "sort-column", column: column2.id, direction: void 0 });
    },
    [column2.id]
  );
  const realWidth = T2(
    () => column2.width === "minimum" ? "1px" : column2.width === "maximum" ? "auto" : column2.width + "px",
    [column2.width]
  );
  return /* @__PURE__ */ u3("th", { width: realWidth, className: "datacore-table-header-cell", children: /* @__PURE__ */ u3("div", { className: "datacore-table-header-cell-content", children: [
    sortable && /* @__PURE__ */ u3(SortButton, { className: "datacore-table-sort", direction: sort, onClick: sortClicked }),
    /* @__PURE__ */ u3("div", { onClick: sortClicked, className: "datacore-table-header-title", children: header })
  ] }) });
}
function TreeTableGroupHeader({
  level,
  value,
  width,
  config: config3
}) {
  const sourcePath = x2(CURRENT_FILE_CONTEXT);
  const rawRenderable = T2(() => {
    if (config3 == null ? void 0 : config3.render) return config3.render(value.key, value.rows);
    else
      return /* @__PURE__ */ u3("h2", { children: /* @__PURE__ */ u3(Lit, { sourcePath, inline: true, value: value.key }) });
  }, [config3 == null ? void 0 : config3.render, value.key, value.rows]);
  const renderable = useAsElement(rawRenderable);
  return /* @__PURE__ */ u3("tr", { className: "datacore-table-group-header", children: /* @__PURE__ */ u3("td", { style: { paddingLeft: `${level * 1.12}em` }, colSpan: width + 1, children: renderable }) });
}
function TreeTableRowGroup({
  level,
  columns,
  element,
  groupings
}) {
  const { id: id2 } = x2(TypedExpandedContext());
  const keyFn = useKeyFn(id2);
  const groupIndex = groupings ? Math.min(groupings.length - 1, level) : 0;
  if (Groupings.isElementGroup(element)) {
    const groupingConfig = groupings ? groupings[groupIndex] : void 0;
    return /* @__PURE__ */ u3(b, { children: [
      /* @__PURE__ */ u3(TreeTableGroupHeader, { level, value: element, width: columns.length, config: groupingConfig }),
      element.rows.map((row) => /* @__PURE__ */ u3(TreeTableRowGroup, { level: level + 1, columns, element: row, groupings }))
    ] }, keyFn(element));
  } else {
    return /* @__PURE__ */ u3(TreeTableRow, { row: element, columns, level: level - groupIndex + 1 }, keyFn(element));
  }
}
function TreeTableRowExpander({ row, level }) {
  const { openMap, dispatch, id: id2 } = x2(TypedExpandedContext());
  const open = T2(() => {
    var _a;
    return (_a = openMap.get(id2(row))) != null ? _a : false;
  }, [row, openMap, openMap.get(id2(row)), dispatch]);
  return /* @__PURE__ */ u3(
    "td",
    {
      onClick: () => dispatch({ type: "row-expand", row, newValue: !open }),
      style: { paddingLeft: `${(level - 1) * 1.125}em` },
      children: /* @__PURE__ */ u3("div", { className: combineClasses("datacore-collapser", !open ? "is-collapsed" : void 0), dir: "auto", children: /* @__PURE__ */ u3(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          width: "24",
          height: "24",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          className: "svg-icon right-triangle",
          children: /* @__PURE__ */ u3("path", { d: "M3 8L12 17L21 8" })
        }
      ) })
    }
  );
}
function TreeTableRow({
  level,
  row,
  columns
}) {
  const { openMap, id: id2 } = x2(TypedExpandedContext());
  const open = T2(() => openMap.get(id2(row.value)), [openMap, openMap.get(id2(row.value)), row, row.value]);
  const hasChildren = T2(() => row.children.length > 0, [row, row.children, row.value]);
  return /* @__PURE__ */ u3(b, { children: [
    /* @__PURE__ */ u3("tr", { className: "datacore-table-row", children: [
      hasChildren ? /* @__PURE__ */ u3(TreeTableRowExpander, { level, row: row.value }) : /* @__PURE__ */ u3("td", {}),
      columns.map((col, i4) => /* @__PURE__ */ u3(TreeTableRowCell, { row, column: col, level, isFirst: i4 == 0 }))
    ] }),
    open ? row.children.map((child) => /* @__PURE__ */ u3(TreeTableRow, { row: child, columns, level: level + 1 }, id2(child.value))) : null
  ] });
}
function TreeTableRowCell({
  row,
  column: column2,
  level,
  isFirst = false
}) {
  var _a;
  const value = column2.value(row.value);
  const updater = q2(
    (v3) => {
      column2.onUpdate && column2.onUpdate(v3, row.value);
    },
    [value, row.value]
  );
  const [editableState, dispatch] = useEditableDispatch({
    content: value,
    isEditing: false,
    updater: (v3) => column2.onUpdate && column2.onUpdate(v3, row.value)
  });
  const renderable = T2(() => {
    return column2.render ? column2.render(editableState.content, row.value) : value;
  }, [column2.render, value, editableState.content, row.value, updater]);
  const rendered = useAsElement(renderable);
  const { editor: Editor } = column2;
  return /* @__PURE__ */ u3(
    "td",
    {
      style: { paddingLeft: isFirst ? `${(level - 1) * 1.2}em` : void 0 },
      onDblClick: () => dispatch({ type: "editing-toggled", newValue: !editableState.isEditing }),
      className: "datacore-table-cell",
      children: column2.editable && editableState.isEditing && Editor ? /* @__PURE__ */ u3(Editor, { field: value, dispatch, ...(_a = column2.editorProps) != null ? _a : {}, ...editableState }) : rendered
    }
  );
}
function ControlledTreeTableView(props) {
  const columns = useInterning(props.columns, (a4, b3) => {
    if (a4.length != b3.length) return false;
    return a4.every((value, index2) => value == b3[index2]);
  });
  const totalElements = T2(() => {
    if (Groupings.isGrouping(props.rows)) return Groupings.count(props.rows);
    else
      return props.rows.reduce(
        (pv, cv) => pv + TreeUtils.countInTreeRow(TreeUtils.ofNode(cv, props.childSelector)),
        0
      );
  }, [props.rows]);
  const tableRef = A2(null);
  const paging = useDatacorePaging({
    initialPage: 0,
    paging: props.paging,
    scrollOnPageChange: props.scrollOnPaging,
    elements: totalElements,
    container: tableRef
  });
  const rawSorts = useInterning(props.sortOn, (a4, b3) => Literals.compare(a4, b3) == 0);
  const sorts = T2(() => {
    return rawSorts == null ? void 0 : rawSorts.filter((sort) => {
      var _a;
      const column2 = columns.find((col) => col.id == sort.id);
      return column2 && ((_a = column2.sortable) != null ? _a : true);
    });
  }, [columns, rawSorts]);
  const groupings = T2(() => {
    if (!props.groupings) return void 0;
    if (Array.isArray(props.groupings)) return props.groupings;
    if (Literals.isFunction(props.groupings)) return [{ render: props.groupings }];
    else return [props.groupings];
  }, [props.groupings]);
  const rawRows = T2(() => {
    if (!Groupings.isGrouping(props.rows)) return TreeUtils.ofArray(props.rows, props.childSelector);
    return TreeUtils.ofGrouping(props.rows, props.childSelector);
  }, [props.rows]);
  const rows = T2(() => {
    if (sorts == void 0 || sorts.length == 0) return rawRows;
    const comparators = sorts.map((x4) => {
      var _a;
      const col = columns.find((y4) => y4.id == x4.id);
      const comp = (_a = col == null ? void 0 : col.comparator) != null ? _a : DEFAULT_TABLE_COMPARATOR;
      return {
        fn: comp,
        direction: x4.direction,
        actualValue: col.value
      };
    });
    return TreeUtils.sort(rawRows, comparators);
  }, [rawRows, sorts]);
  const pagedRows = T2(() => {
    if (paging.enabled)
      return TreeUtils.slice(rows, paging.page * paging.pageSize, (paging.page + 1) * paging.pageSize);
    return rows;
  }, [paging.page, paging.pageSize, paging.enabled, props.rows, rows]);
  const keyFn = useKeyFn(props.id, pagedRows);
  const Context2 = TypedExpandedContext();
  return /* @__PURE__ */ u3(Context2.Provider, { value: { openMap: props.openMap, dispatch: props.dispatch, id: props.id }, children: /* @__PURE__ */ u3("div", { ref: tableRef, children: [
    /* @__PURE__ */ u3("table", { className: "datacore-table", children: [
      /* @__PURE__ */ u3("thead", { children: /* @__PURE__ */ u3("tr", { className: "datacore-table-header-row", children: [
        /* @__PURE__ */ u3("th", { className: "datacore-table-header-cell", width: "1px" }),
        columns.map((x4) => {
          var _a, _b, _c;
          return /* @__PURE__ */ u3(
            TreeTableHeaderCell,
            {
              sort: (_b = (_a = props.sortOn) == null ? void 0 : _a.find((s4) => s4.id === x4.id)) == null ? void 0 : _b.direction,
              column: x4,
              sortable: (_c = x4.sortable) != null ? _c : true
            }
          );
        })
      ] }) }),
      /* @__PURE__ */ u3("tbody", { children: pagedRows.map((row) => /* @__PURE__ */ u3(
        TreeTableRowGroup,
        {
          element: row,
          columns,
          level: 0,
          groupings
        },
        keyFn(row)
      )) })
    ] }),
    paging.enabled && /* @__PURE__ */ u3(ControlledPager, { page: paging.page, totalPages: paging.totalPages, setPage: paging.setPage })
  ] }) });
}
function TreeTableView(props) {
  var _a;
  const [state2, dispatch] = useTreeTableDispatch({
    sortOn: (_a = props.sortOn) != null ? _a : [],
    id: props.id ? props.id : (x4) => x4.$id
  });
  const refState = T2(() => A2(state2), [state2]);
  if (state2.openMap !== void 0) refState.current = state2;
  else refState.current.openMap = /* @__PURE__ */ new Map();
  y2(() => {
    var _a2;
    dispatch({ type: "open-map-changed", newValue: (_a2 = refState.current.openMap) != null ? _a2 : /* @__PURE__ */ new Map() });
  }, [dispatch]);
  delete props.sortOn;
  return /* @__PURE__ */ u3(ControlledTreeTableView, { dispatch, ...state2, ...props });
}

// src/api/local-api.tsx
var DatacoreLocalApi = class {
  constructor(api2, path) {
    this.api = api2;
    this.path = path;
    ///////////////////////
    // General utilities //
    ///////////////////////
    /** Utilities for coercing types into one specific type for easier programming. */
    this.coerce = Coerce;
    /////////////
    //  Hooks  //
    /////////////
    // Export the common preact hooks for people to use via `dc.`:
    this.useState = h2;
    this.useCallback = q2;
    this.useReducer = p2;
    this.useMemo = T2;
    this.useEffect = y2;
    this.createContext = G;
    this.useContext = x2;
    this.useRef = A2;
    this.useInterning = useInterning;
    this.useSetField = useSetField;
    /////////////////////
    // Visual Elements //
    /////////////////////
    /** Vertical flexbox container; good for putting items together in a column. */
    this.Stack = Stack;
    /** Horizontal flexbox container; good for putting items together in a row. */
    this.Group = Group;
    /** Renders a literal value in a pretty way that respects settings. */
    this.Literal = (({ value, sourcePath, inline: inline2 }) => {
      var _a;
      const implicitSourcePath = x2(CURRENT_FILE_CONTEXT);
      return /* @__PURE__ */ u3(Lit, { value, sourcePath: (_a = sourcePath != null ? sourcePath : implicitSourcePath) != null ? _a : this.path, inline: inline2 });
    }).bind(this);
    /** Renders markdown using the Obsidian markdown renderer, optionally attaching additional styles. */
    this.Markdown = (({
      content,
      sourcePath,
      inline: inline2,
      style,
      className
    }) => {
      var _a;
      const implicitSourcePath = x2(CURRENT_FILE_CONTEXT);
      return /* @__PURE__ */ u3(
        Markdown,
        {
          content,
          sourcePath: (_a = sourcePath != null ? sourcePath : implicitSourcePath) != null ? _a : this.path,
          inline: inline2,
          style,
          cls: className
        }
      );
    }).bind(this);
    /** Renders an obsidian-style link directly and more effieicntly than rendering markdown. */
    this.Link = ObsidianLink;
    /** Create a vanilla Obsidian embed for the given link. */
    this.LinkEmbed = (({
      link,
      inline: inline2,
      sourcePath
    }) => {
      var _a;
      const realLink = T2(() => typeof link === "string" ? Link.file(link) : link, [link]);
      const implicitSourcePath = x2(CURRENT_FILE_CONTEXT);
      return /* @__PURE__ */ u3(
        Embed,
        {
          link: realLink,
          inline: inline2 != null ? inline2 : false,
          sourcePath: (_a = sourcePath != null ? sourcePath : implicitSourcePath) != null ? _a : this.path
        }
      );
    }).bind(this);
    /** Create an explicit 'span' embed which extracts a span of lines from a markdown file. */
    this.SpanEmbed = (({
      path,
      start,
      end: end2,
      explain,
      showExplain,
      sourcePath: maybeSourcePath
    }) => {
      const sourcePath = maybeSourcePath != null ? maybeSourcePath : this.path;
      const resolvedPath = T2(() => this.resolvePath(path, sourcePath), [path, sourcePath]);
      return /* @__PURE__ */ u3(LineSpanEmbed, { path: resolvedPath, start, end: end2, explain, showExplain });
    }).bind(this);
    /** Renders an obsidian lucide icon. */
    this.Icon = Icon;
    ///////////
    // Views //
    ///////////
    this.TaskList = TaskList;
    this.VanillaTable = VanillaTable;
    this.TreeTable = TreeTableView;
    this.Card = Card;
    /////////////////////////
    // Interative elements //
    /////////////////////////
    this.Button = Button;
    this.Textbox = Textbox;
    this.Callout = Callout;
    this.Checkbox = Checkbox;
    this.Slider = Slider;
    this.Switch = Switch;
    this.VanillaSelect = VanillaSelect;
    this.VanillaTextBox = ControlledEditableTextField;
    /////////////////////////
    //    field editors    //
    /////////////////////////
    this.FieldCheckbox = FieldCheckbox;
    this.FieldSlider = FieldSlider;
    this.FieldSelect = FieldSelect;
    this.FieldSwitch = FieldSwitch;
    this.TextField = EditableTextField;
    this.scriptCache = new ScriptCache(this.core.datastore);
  }
  /** The current file path for the local API. */
  currentPath() {
    return this.path;
  }
  /** The full markdown file metadata for the current file. */
  currentFile() {
    return this.api.page(this.path);
  }
  /** Get acess to luxon functions. */
  get luxon() {
    return luxon_exports;
  }
  /** Get access to preact functions. */
  get preact() {
    return preact_module_exports;
  }
  get preact_compat() {
    return compat_module_exports;
  }
  /** Central Obsidian app object. */
  get app() {
    return this.core.app;
  }
  /** The internal plugin central datastructure. */
  get core() {
    return this.api.core;
  }
  //////////////////////////////
  // Script loading utilities //
  //////////////////////////////
  /**
   * Asynchronously load a javascript block from the given path or link; you can either load from JS/TS/JSX/TSX files
   * directly, or from codeblocks by loading from the section the codeblock is inside of. There are a few stipulations
   * to loading:
   * - You cannot load cyclical dependencies.
   * - This is similar to vanilla js `require()`, not `import ... `. Your scripts you are requiring need to explicitly
   *   return the things they are exporting, like the example below. The `export` keyword does not work.
   *
   * ```js
   * function MyElement() {
   *  ...
   * }
   *
   * return { MyElement };
   * ```
   */
  async require(path) {
    const result = await this.scriptCache.load(path, { dc: this });
    return result.orElseThrow();
  }
  /** Resolve a local or absolute path or link to an absolute path. */
  resolvePath(path, sourcePath) {
    return this.api.resolvePath(path, sourcePath != null ? sourcePath : this.path);
  }
  /** Try to parse the given query, returning a monadic success/failure result. */
  tryParseQuery(query) {
    return this.api.tryParseQuery(query);
  }
  /** Try to parse the given query, throwing an error if it is invalid. */
  parseQuery(query) {
    return this.tryParseQuery(query).orElseThrow((e3) => "Failed to parse query: " + e3);
  }
  /** Create a file link pointing to the given path. */
  fileLink(path) {
    return Link.file(path);
  }
  /** Create a link to a header with the given name. */
  headerLink(path, header) {
    return Link.header(path, header);
  }
  /** Create a link to a block with the given path and block ID. */
  blockLink(path, block) {
    return Link.block(path, block);
  }
  /** Try to parse the given link, throwing an error if it is invalid. */
  parseLink(linktext) {
    return this.api.parseLink(linktext);
  }
  /** Try to parse a link, returning a monadic success/failure result. */
  tryParseLink(linktext) {
    return this.api.tryParseLink(linktext);
  }
  /** Create a data array from a regular array. */
  array(input2) {
    return DataArray.wrap(input2);
  }
  /** Sets the text of a given task programmatically. */
  async setTaskText(newText, task) {
    await setTaskText(this.app, this.core, newText, task);
  }
  /** Sets the completion status of a given task programmatically. */
  async setTaskCompletion(completed, task) {
    await completeTask(completed, task, this.app.vault, this.core);
  }
  //////////////
  // Contexts //
  //////////////
  // export the necessary contexts to enable rendering
  // datacore components outside the datacore plugin
  // itself
  get SETTINGS_CONTEXT() {
    return SETTINGS_CONTEXT;
  }
  get COMPONENT_CONTEXT() {
    return COMPONENT_CONTEXT;
  }
  get DATACORE_CONTEXT() {
    return DATACORE_CONTEXT;
  }
  get APP_CONTEXT() {
    return APP_CONTEXT;
  }
  /** Memoize the input automatically and process it using a Data Array; returns a vanilla array back. */
  useArray(input2, process2, deps) {
    return T2(() => process2(DataArray.wrap(input2)).array(), [input2, ...deps != null ? deps : []]);
  }
  /** Use the file metadata for the current file. Automatically updates the view when the current file metadata changes. */
  useCurrentFile(settings) {
    return useFileMetadata(this.core, this.path, settings);
  }
  /** Use the current path. Automatically updates the view if the path changes (though that would be weird). */
  useCurrentPath(settings) {
    const meta = this.useCurrentFile(settings);
    return meta.$path;
  }
  /** Use the file metadata for a specific file. Automatically updates the view when the file changes. */
  useFile(path, settings) {
    return useFileMetadata(this.core, path, settings);
  }
  /** Automatically refresh the view whenever the index updates; returns the latest index revision ID. */
  useIndexUpdates(settings) {
    return useIndexUpdates(this.core, settings);
  }
  /**
   * Run a query, automatically re-running it whenever the vault changes. Returns more information about the query
   * execution, such as index revision and total search duration.
   */
  useFullQuery(query, settings) {
    return useFullQuery(this.core, this.parseQuery(query), settings);
  }
  /** Run a query, automatically re-running it whenever the vault changes. */
  useQuery(query, settings) {
    return useQuery(this.core, this.parseQuery(query), settings);
  }
};

// src/api/api.ts
var import_parsimmon = __toESM(require_parsimmon_umd_min());
var DatacoreApi = class {
  constructor(core) {
    this.core = core;
    ///////////////////////
    // General utilities //
    ///////////////////////
    /** Utilities for coercing types into one specific type for easier programming. */
    this.coerce = Coerce;
  }
  /** Get acess to luxon functions. */
  get luxon() {
    return luxon_exports;
  }
  /** Get access to preact functions. */
  get preact() {
    return preact_module_exports;
  }
  /** Central Obsidian app object. */
  get app() {
    return this.core.app;
  }
  get hooks() {
    return hooks_module_exports;
  }
  ///////////////
  // Local API //
  ///////////////
  /** Construct a local API for the file at the given path. */
  local(path) {
    return new DatacoreLocalApi(this, path);
  }
  /////////////////////////
  // Querying + Fetching //
  /////////////////////////
  /** Load a markdown file by full path or link. */
  page(path) {
    const realPath = path instanceof Link ? path.path : path;
    return this.core.datastore.load(realPath);
  }
  /** Execute a textual or typed index query, returning all results. */
  query(query) {
    return this.tryQuery(query).orElseThrow();
  }
  /** Execute a textual or typed index query, returning all results. */
  tryQuery(query) {
    return this.tryFullQuery(query).map((result) => result.results);
  }
  /** Execute a textual or typed index query, returning results plus performance metadata. */
  fullquery(query) {
    return this.tryFullQuery(query).orElseThrow();
  }
  /** Execute a textual or typed index query, returning results plus performance metadata. */
  tryFullQuery(query) {
    const parsedQuery = typeof query === "string" ? QUERY.query.tryParse(query) : query;
    return this.core.datastore.search(parsedQuery);
  }
  /** Resolve a local or absolute path or link to an absolute path. */
  resolvePath(path, sourcePath) {
    const rawpath = path instanceof Link ? path.path : path;
    if (rawpath.startsWith("/")) return rawpath.substring(1);
    const absolute = this.core.metadataCache.getFirstLinkpathDest(rawpath, sourcePath != null ? sourcePath : "");
    if (absolute) return absolute.path;
    return rawpath;
  }
  /** Try to parse the given query, returning a monadic success/failure result. */
  tryParseQuery(query) {
    if (!(typeof query === "string")) return Result.success(query);
    const result = QUERY.query.parse(query);
    if (result.status) return Result.success(result.value);
    else return Result.failure(import_parsimmon.default.formatError(query, result));
  }
  /** Try to parse the given query, throwing an error if it is invalid. */
  parseQuery(query) {
    return this.tryParseQuery(query).orElseThrow((e3) => "Failed to parse query: " + e3);
  }
  /** Create a file link pointing to the given path. */
  fileLink(path) {
    return Link.file(path);
  }
  /** Create a link to a header with the given name. */
  headerLink(path, header) {
    return Link.header(path, header);
  }
  /** Create a link to a block with the given path and block ID. */
  blockLink(path, block) {
    return Link.block(path, block);
  }
  /** Try to parse the given link, throwing an error if it is invalid. */
  parseLink(linktext) {
    return this.tryParseLink(linktext).orElseThrow((e3) => "Failed to parse link: " + e3);
  }
  /** Try to parse a link, returning a monadic success/failure result. */
  tryParseLink(linktext) {
    const parsed = PRIMITIVES.embedLink.parse(linktext);
    if (!parsed.status) return Result.failure(import_parsimmon.default.formatError(linktext, parsed));
    return Result.success(parsed.value);
  }
  /** Create a data array from a regular array. */
  array(input2) {
    return DataArray.wrap(input2);
  }
  /////////////////////
  // Visual Elements //
  /////////////////////
  /**
   * Run the given DatacoreJS script, rendering it into the given container. This function
   * will return quickly; actual rendering is done asynchronously in the background.
   *
   * Returns a markdown render child representing the rendered object.
   */
  executeJs(source, container, component, sourcePath) {
    return this._renderJavascript(source, container, component, sourcePath, "js");
  }
  /**
   * Similar to `executeJs`, but for JSX scripts. If you are unsure if your input will be JS
   * or JSX, use this one, as it also supports regular javascript (albeit at at a mild performance
   * hit to rendering).
   */
  executeJsx(source, container, component, sourcePath) {
    return this._renderJavascript(source, container, component, sourcePath, "jsx");
  }
  /**
   * Similar to `executeJs`, but for TypeScript scripts. Use the TSX variant for TSX supprot.
   */
  executeTs(source, container, component, sourcePath) {
    return this._renderJavascript(source, container, component, sourcePath, "ts");
  }
  /**
   * Similar to `executeTs`, but for TSX scripts. If you are unsure if your input will be TS
   * or TSX, use this one, as it also supports regular javascript (albeit at at a mild performance
   * hit to rendering).
   *
   * This generally will also work if you are unsure if your input is javascript or typescript,
   * though beware there are a few niche cases where javascript and typescript diverge in syntax.
   */
  executeTsx(source, container, component, sourcePath) {
    return this._renderJavascript(source, container, component, sourcePath, "tsx");
  }
  /**
   * @private
   * Shared logic for rendering any JS/TS script.
   */
  _renderJavascript(source, container, component, sourcePath, language) {
    let local = new DatacoreLocalApi(this, sourcePath);
    const renderer = new DatacoreJSRenderer(local, container, sourcePath, source, language);
    component.addChild(renderer);
    return renderer;
  }
};

// src/index/storage/folder.ts
var import_obsidian5 = require("obsidian");
var _FolderIndex = class _FolderIndex {
  constructor(vault) {
    this.vault = vault;
  }
  /** Get the list of all files under the given path. */
  get(prefix2, filter) {
    let folder = this.vault.getAbstractFileByPath(prefix2 || "/");
    if (!folder) {
      return _FolderIndex.EMPTY_SET;
    } else if (folder instanceof import_obsidian5.TFolder) {
      return new Set(this.walk(folder, filter));
    } else {
      if (!filter || filter(prefix2)) {
        return new Set(prefix2);
      } else {
        return _FolderIndex.EMPTY_SET;
      }
    }
  }
  /** Get the list of files specifically under the given path. */
  getExact(prefix2, filter) {
    let folder = this.vault.getAbstractFileByPath(prefix2 || "/");
    if (!folder) {
      return _FolderIndex.EMPTY_SET;
    } else if (folder instanceof import_obsidian5.TFolder) {
      const elements = /* @__PURE__ */ new Set();
      for (const file of folder.children) {
        if (!(file instanceof import_obsidian5.TFile)) continue;
        if (filter && !filter(file.path)) continue;
        elements.add(file.path);
      }
      return elements;
    } else {
      if (!filter || filter(prefix2)) {
        return new Set(prefix2);
      } else {
        return _FolderIndex.EMPTY_SET;
      }
    }
  }
  /** Determines if the given path exists in the index. */
  pathExists(path) {
    return this.vault.getAbstractFileByPath(path || "/") != null;
  }
  /** Determines if the given folder exists in the index. */
  folderExists(folder) {
    return this.vault.getAbstractFileByPath(folder || "/") instanceof import_obsidian5.TFolder;
  }
  /**
   * Use the in-memory prefix index to convert a relative path to an absolute one.
   */
  resolveRelative(path, origin) {
    if (!origin) return path;
    else if (path.startsWith("/")) return path.substring(1);
    let relativePath = getParentFolder(origin) + "/" + path;
    if (this.pathExists(relativePath)) return relativePath;
    else return path;
  }
  *walk(folder, filter) {
    for (const file of folder.children) {
      if (file instanceof import_obsidian5.TFolder) {
        yield* this.walk(file, filter);
      } else if (filter ? filter(file.path) : true) {
        yield file.path;
      }
    }
  }
};
/** Empty placeholder set. */
_FolderIndex.EMPTY_SET = /* @__PURE__ */ new Set();
var FolderIndex = _FolderIndex;

// src/index/storage/inverted.ts
var _InvertedIndex = class _InvertedIndex {
  constructor() {
    this.inverted = /* @__PURE__ */ new Map();
  }
  /** Set the key to the given values. */
  set(key, values) {
    for (let value of values) {
      if (!this.inverted.has(value)) this.inverted.set(value, /* @__PURE__ */ new Set());
      this.inverted.get(value).add(key);
    }
  }
  /** Get all keys that map to the given value. */
  get(value) {
    var _a;
    return (_a = this.inverted.get(value)) != null ? _a : _InvertedIndex.EMPTY_SET;
  }
  /** Delete a key from the set of associated values. */
  delete(key, values) {
    for (let value of values) {
      const set = this.inverted.get(value);
      if (set) {
        set.delete(key);
      }
      if (set && set.size == 0) {
        this.inverted.delete(value);
      }
    }
  }
  clear() {
    this.inverted.clear();
  }
};
_InvertedIndex.EMPTY_SET = /* @__PURE__ */ new Set();
var InvertedIndex = _InvertedIndex;

// node_modules/flatqueue/index.js
var FlatQueue = class {
  constructor() {
    this.ids = [];
    this.values = [];
    this.length = 0;
  }
  clear() {
    this.length = 0;
  }
  push(id2, value) {
    let pos = this.length++;
    while (pos > 0) {
      const parent = pos - 1 >> 1;
      const parentValue = this.values[parent];
      if (value >= parentValue) break;
      this.ids[pos] = this.ids[parent];
      this.values[pos] = parentValue;
      pos = parent;
    }
    this.ids[pos] = id2;
    this.values[pos] = value;
  }
  pop() {
    if (this.length === 0) return void 0;
    const top = this.ids[0];
    this.length--;
    if (this.length > 0) {
      const id2 = this.ids[0] = this.ids[this.length];
      const value = this.values[0] = this.values[this.length];
      const halfLength = this.length >> 1;
      let pos = 0;
      while (pos < halfLength) {
        let left = (pos << 1) + 1;
        const right = left + 1;
        let bestIndex = this.ids[left];
        let bestValue = this.values[left];
        const rightValue = this.values[right];
        if (right < this.length && rightValue < bestValue) {
          left = right;
          bestIndex = this.ids[right];
          bestValue = rightValue;
        }
        if (bestValue >= value) break;
        this.ids[pos] = bestIndex;
        this.values[pos] = bestValue;
        pos = left;
      }
      this.ids[pos] = id2;
      this.values[pos] = value;
    }
    return top;
  }
  peek() {
    if (this.length === 0) return void 0;
    return this.ids[0];
  }
  peekValue() {
    if (this.length === 0) return void 0;
    return this.values[0];
  }
  shrink() {
    this.ids.length = this.values.length = this.length;
  }
};

// src/index/storage/fields.ts
var import_sorted_btree = __toESM(require_b_tree());
var EverythingFieldIndex = class {
  constructor(all) {
    this.all = all;
  }
  add(id2, value) {
  }
  delete(id2, value) {
  }
  equals(value) {
    return void 0;
  }
};
var IdFieldIndex = class {
  constructor(all, lookup) {
    this.all = all;
    this.lookup = lookup;
  }
  add(id2, value) {
  }
  delete(id2, value) {
  }
  equals(value) {
    if (!Literals.isString(value)) return void 0;
    if (this.lookup(value)) {
      return /* @__PURE__ */ new Set([value]);
    } else {
      return void 0;
    }
  }
};
var SetFieldIndex = class {
  constructor() {
    this.present = /* @__PURE__ */ new Set();
  }
  /** Add an (object, value) pairing to the collection. */
  add(id2, value) {
    this.present.add(id2);
  }
  /** Delete an (object, value) pairing from the collection. */
  delete(id2, value) {
    this.present.delete(id2);
  }
  /** Return a set of all pages in which the field exists at all (even if undefined). */
  all() {
    return this.present;
  }
  /** Return all pages with a value exactly equal to the given value. */
  equals(value) {
    return void 0;
  }
};
var _BTreeFieldIndex = class _BTreeFieldIndex {
  constructor() {
    this.present = /* @__PURE__ */ new Set();
    this.values = new import_sorted_btree.default([], (a4, b3) => Literals.compare(a4, b3));
  }
  /** Add an (object, value) pairing to the collection. */
  add(id2, value) {
    this.present.add(id2);
    this.values.setIfNotPresent(value, /* @__PURE__ */ new Set());
    this.values.get(value).add(id2);
  }
  /** Delete an (object, value) pairing from the collection. */
  delete(id2, value) {
    this.present.delete(id2);
    const set = this.values.get(value);
    set == null ? void 0 : set.delete(id2);
    if (set == null || set.size == 0) {
      this.values.delete(value);
    }
  }
  /** Return a set of all pages in which the field exists at all (even if undefined). */
  all() {
    return this.present;
  }
  /** Return all pages with a value exactly equal to the given value. */
  equals(value) {
    return this.values.get(value, _BTreeFieldIndex.EMPTY_SET);
  }
};
/** Placeholder empty set. */
_BTreeFieldIndex.EMPTY_SET = /* @__PURE__ */ new Set();
var BTreeFieldIndex = _BTreeFieldIndex;

// src/expression/binaryop.ts
var BinaryOpHandler = class _BinaryOpHandler {
  static create() {
    return new _BinaryOpHandler();
  }
  constructor() {
    this.map = /* @__PURE__ */ new Map();
    this.handleDefaultNulls = false;
  }
  register(left, op, right, func) {
    this.map.set(_BinaryOpHandler.repr(op, left, right), (a4, b3, c4) => Result.success(func(a4, b3, c4)));
    return this;
  }
  registerResult(left, op, right, func) {
    this.map.set(_BinaryOpHandler.repr(op, left, right), func);
    return this;
  }
  registerComm(left, op, right, func) {
    return this.register(left, op, right, func).register(right, op, left, (a4, b3, ctx) => func(b3, a4, ctx));
  }
  /** If enabled, all null (op) null operations produce null. */
  withDefaultNullHandling() {
    this.handleDefaultNulls = true;
    return this;
  }
  /** Implement a comparison function. */
  compare(type, compare) {
    return this.register(type, "<", type, (a4, b3, ctx) => compare(a4, b3, ctx) < 0).register(type, "<=", type, (a4, b3, ctx) => compare(a4, b3, ctx) <= 0).register(type, ">", type, (a4, b3, ctx) => compare(a4, b3, ctx) > 0).register(type, ">=", type, (a4, b3, ctx) => compare(a4, b3, ctx) >= 0).register(type, "=", type, (a4, b3, ctx) => compare(a4, b3, ctx) == 0).register(type, "!=", type, (a4, b3, ctx) => compare(a4, b3, ctx) != 0);
  }
  /** Attempt to evaluate the given binary operator on the two literal fields. */
  evaluate(op, left, right, ctx) {
    let leftType = Literals.typeOf(left);
    let rightType = Literals.typeOf(right);
    if (!leftType) return Result.failure(`Unrecognized value '${left}'`);
    else if (!rightType) return Result.failure(`Unrecognized value '${right}'`);
    if (this.handleDefaultNulls && leftType === "null" && rightType === "null") return Result.success(null);
    let handler = this.map.get(_BinaryOpHandler.repr(op, leftType, rightType));
    if (handler) return handler(left, right, ctx);
    let handler2 = this.map.get(_BinaryOpHandler.repr(op, leftType, "*"));
    if (handler2) return handler2(left, right, ctx);
    let handler3 = this.map.get(_BinaryOpHandler.repr(op, "*", rightType));
    if (handler3) return handler3(left, right, ctx);
    let handler4 = this.map.get(_BinaryOpHandler.repr(op, "*", "*"));
    if (handler4) return handler4(left, right, ctx);
    return Result.failure(`No implementation found for '${leftType} ${op} ${rightType}'`);
  }
  /** Create a string representation of the given triplet for unique lookup in the map. */
  static repr(op, left, right) {
    return `${left},${op},${right}`;
  }
};
function createBinaryOps(linkNormalizer) {
  return BinaryOpHandler.create().compare("*", (a4, b3) => Literals.compare(a4, b3, linkNormalizer)).register("*", "&", "*", (a4, b3) => Literals.isTruthy(a4) && Literals.isTruthy(b3)).register("*", "|", "*", (a4, b3) => Literals.isTruthy(a4) || Literals.isTruthy(b3)).register("number", "+", "number", (a4, b3) => a4 + b3).register("number", "-", "number", (a4, b3) => a4 - b3).register("number", "*", "number", (a4, b3) => a4 * b3).register("number", "/", "number", (a4, b3) => a4 / b3).register("number", "%", "number", (a4, b3) => a4 % b3).register("string", "+", "*", (a4, b3, ctx) => a4 + Literals.toString(b3, stringSettings(ctx.settings))).register("*", "+", "string", (a4, b3, ctx) => Literals.toString(a4, stringSettings(ctx.settings)) + b3).registerComm("string", "*", "number", (a4, b3) => b3 < 0 ? "" : a4.repeat(b3)).register("date", "-", "date", (a4, b3) => {
    return normalizeDuration(
      a4.diff(b3, ["years", "months", "days", "hours", "minutes", "seconds", "milliseconds"])
    );
  }).register("date", "-", "duration", (a4, b3) => a4.minus(b3)).registerComm("date", "+", "duration", (a4, b3) => a4.plus(b3)).register("duration", "+", "duration", (a4, b3) => normalizeDuration(a4.plus(b3))).register("duration", "-", "duration", (a4, b3) => normalizeDuration(a4.minus(b3))).register("duration", "/", "number", (a4, b3) => normalizeDuration(a4.mapUnits((x4) => x4 / b3))).registerComm("duration", "*", "number", (a4, b3) => normalizeDuration(a4.mapUnits((x4) => x4 * b3))).register("array", "+", "array", (a4, b3) => [].concat(a4).concat(b3)).register("object", "+", "object", (a4, b3) => Object.assign({}, a4, b3)).register("array", "index", "number", (arr, idx) => {
    if (idx < 0 || idx >= arr.length) return null;
    return arr[idx];
  }).registerResult("array", "index", "string", (arr, key, context) => {
    if (arr.length == 0) return Result.success([]);
    const result = [];
    for (const element of arr) {
      const resolved = context.evaluate(
        Expressions.index(Expressions.literal(element), Expressions.literal(key))
      );
      if (!resolved.successful) return Result.failure(resolved.error);
      result.push(resolved.value);
    }
    return Result.success(result);
  }).register("object", "index", "string", (obj, key) => {
    var _a;
    return (_a = Fieldbearings.get(obj, key)) != null ? _a : null;
  }).registerResult("link", "index", "string", indexLink).registerResult("link", "index", "number", indexLink).register("object", "index", "number", (obj, key) => {
    var _a;
    return (_a = obj[key]) != null ? _a : null;
  }).register("string", "index", "number", (str, idx) => idx < 0 || idx >= str.length ? null : str[idx]).register("date", "index", "string", indexDate).register("duration", "index", "string", indexDuration).withDefaultNullHandling();
}
function stringSettings(settings) {
  return {
    dateFormat: settings.defaultDateFormat,
    dateTimeFormat: settings.defaultDateTimeFormat,
    nullRepresentation: settings.renderNullAs
  };
}
function indexLink(link, key, context) {
  const object = context.linkHandler.resolve(link);
  if (!object) return Result.success(null);
  return context.evaluate(Expressions.index(Expressions.literal(object), Expressions.literal(key)));
}
function indexDate(date, key) {
  switch (key) {
    case "year":
      return date.year;
    case "month":
      return date.month;
    case "day":
      return date.day;
    case "hour":
      return date.hour;
    case "minute":
      return date.minute;
    case "second":
      return date.second;
    case "millisecond":
      return date.millisecond;
    case "week":
      return date.weekNumber;
    default:
      return null;
  }
}
function indexDuration(dur, key) {
  switch (key) {
    case "years":
      return dur.years;
    case "months":
      return dur.months;
    case "days":
      return dur.days;
    case "hours":
      return dur.hours;
    case "minutes":
      return dur.minutes;
    case "seconds":
      return dur.seconds;
    case "milliseconds":
      return dur.milliseconds;
    default:
      return null;
  }
}

// src/expression/functions.ts
var FunctionBuilder = class {
  constructor(name) {
    this.name = name;
    this.variants = [];
    this.vectorized = {};
  }
  /** Add a general function variant which accepts any number of arguments of any type. */
  vararg(impl) {
    this.variants.push({ args: [], varargs: true, impl });
    return this;
  }
  /** Add a function variant which takes in a single argument. */
  add1(argType, impl) {
    this.variants.push({
      args: [argType],
      varargs: false,
      impl: (c4, ...rest) => impl(rest[0], c4)
    });
    return this;
  }
  /** Add a function variant which takes in two typed arguments. */
  add2(arg1, arg2, impl) {
    this.variants.push({
      args: [arg1, arg2],
      varargs: false,
      impl: (c4, ...rest) => impl(rest[0], rest[1], c4)
    });
    return this;
  }
  /** Add a function variant which takes in three typed arguments. */
  add3(arg1, arg2, arg3, impl) {
    this.variants.push({
      args: [arg1, arg2, arg3],
      varargs: false,
      impl: (c4, ...rest) => impl(rest[0], rest[1], rest[2], c4)
    });
    return this;
  }
  /** Add vectorized variants which accept the given number of arguments and delegate. */
  vectorize(numArgs, positions) {
    this.vectorized[numArgs] = positions;
    return this;
  }
  /** Return a function which checks the number and type of arguments, passing them on to the first matching variant. */
  build() {
    let self2 = (context, ...args) => {
      let types = [];
      for (let arg of args) {
        let argType = Literals.typeOf(arg);
        if (!argType) throw Error(`Unrecognized argument type for argument '${arg}'`);
        types.push(argType);
      }
      if (this.vectorized[types.length]) {
        let vectorizedPositions = this.vectorized[types.length].filter((k4) => types[k4] == "array");
        if (vectorizedPositions.length > 0) {
          let minLength = vectorizedPositions.map((p3) => args[p3].length).reduce((p3, c4) => Math.min(p3, c4));
          let result = [];
          for (let vpos = 0; vpos < minLength; vpos++) {
            let subargs = [];
            for (let index2 = 0; index2 < args.length; index2++) {
              if (vectorizedPositions.includes(index2)) {
                let arr = args[index2];
                subargs.push(arr[vpos]);
              } else {
                subargs.push(args[index2]);
              }
            }
            result.push(self2(context, ...subargs));
          }
          return result;
        }
      }
      outer: for (let variant of this.variants) {
        if (variant.varargs) return variant.impl(context, ...args);
        if (variant.args.length != types.length) continue;
        for (let index2 = 0; index2 < variant.args.length; index2++) {
          if (variant.args[index2] != "*" && variant.args[index2] != types[index2]) continue outer;
        }
        return variant.impl(context, ...args);
      }
      throw Error(`No implementation of '${this.name}' found for arguments: ${types.join(", ")}`);
    };
    return self2;
  }
};
var Functions;
((Functions2) => {
  function bind(func, context) {
    return (...args) => func(context, ...args);
  }
  Functions2.bind = bind;
  function bindAll(funcs, context) {
    let result = {};
    for (let [key, func] of Object.entries(funcs)) {
      result[key] = Functions2.bind(func, context);
    }
    return result;
  }
  Functions2.bindAll = bindAll;
})(Functions || (Functions = {}));
var DefaultFunctions;
((DefaultFunctions2) => {
  DefaultFunctions2.typeOf = new FunctionBuilder("type").add1("array", (_3) => "array").add1("boolean", (_3) => "boolean").add1("date", (_3) => "date").add1("duration", (_3) => "duration").add1("function", (_3) => "function").add1("link", (_3) => "link").add1("null", (_3) => "null").add1("number", (_3) => "number").add1("object", (_3) => "object").add1("string", (_3) => "string").add1("*", (_3) => "unknown").build();
  DefaultFunctions2.length = new FunctionBuilder("length").add1("array", (a4) => a4.length).add1("object", (a4) => Object.keys(a4).length).add1("string", (a4) => a4.length).add1("null", (_a) => 0).build();
  DefaultFunctions2.list = (_context, ...args) => args;
  DefaultFunctions2.object = (_context, ...args) => {
    if (args.length % 2 != 0) throw Error("object() requires an even number of arguments");
    let result = {};
    for (let index2 = 0; index2 < args.length; index2 += 2) {
      let key = args[index2];
      if (!Literals.isString(key)) throw Error("keys should be of type string for object(key1, value1, ...)");
      result[key] = args[index2 + 1];
    }
    return result;
  };
  DefaultFunctions2.link = new FunctionBuilder("link").add1("string", (a4, c4) => Link.file(c4.linkHandler.normalize(a4), false)).add1("link", (a4) => a4).add1("null", (_a) => null).vectorize(1, [0]).add2("string", "string", (t5, d3, c4) => Link.file(c4.linkHandler.normalize(t5), false, d3)).add3("string", "string", "boolean", (t5, d3, e3, c4) => Link.file(c4.linkHandler.normalize(t5), e3, d3)).add2("link", "string", (t5, d3) => t5.withDisplay(d3)).add2("null", "*", () => null).add2("*", "null", (t5, _n2, c4) => (0, DefaultFunctions2.link)(c4, t5)).vectorize(2, [0, 1]).build();
  DefaultFunctions2.embed = new FunctionBuilder("embed").add1("link", (l4) => l4.toEmbed()).vectorize(1, [0]).add2("link", "boolean", (l4, e3, c4) => e3 ? l4.toEmbed() : l4.fromEmbed()).add1("null", () => null).add2("null", "*", () => null).add2("*", "null", () => null).vectorize(2, [0, 1]).build();
  DefaultFunctions2.date = new FunctionBuilder("date").add1("string", (str) => {
    let parsedDate = PRIMITIVES.datePlus.parse(str);
    if (parsedDate.status) return parsedDate.value;
    else return null;
  }).add1("date", (d3) => d3).add1("link", (link2, c4) => {
    var _a, _b;
    if (link2.display) {
      let parsedDate2 = PRIMITIVES.date.parse(link2.display);
      if (parsedDate2.status) return parsedDate2.value;
    }
    let parsedDate = PRIMITIVES.date.parse(link2.path);
    if (parsedDate.status) return parsedDate.value;
    let resolved = c4.linkHandler.resolve(link2.path);
    if (resolved && ((_a = resolved == null ? void 0 : resolved.file) == null ? void 0 : _a.day)) {
      return (_b = resolved == null ? void 0 : resolved.file) == null ? void 0 : _b.day;
    }
    return null;
  }).add2("string", "string", (d3, f4) => {
    if (f4 === "x" || f4 === "X") {
      let match4 = NUMBER_REGEX.exec(d3);
      if (match4) return DateTime.fromMillis(Number.parseInt(match4[0]) * (f4 === "X" ? 1e3 : 1));
      else {
        throw Error("Not a number for format( (${ f }): ${ d }");
      }
    } else {
      let parsedDate = DateTime.fromFormat(d3, f4);
      if (parsedDate.isValid) return parsedDate;
      else {
        throw Error(`Can't handle format (${f4}) on date string (${d3})`);
      }
    }
  }).add1("null", () => null).vectorize(1, [0]).build();
  DefaultFunctions2.dur = new FunctionBuilder("dur").add1("string", (str) => {
    let parsedDur = PRIMITIVES.duration.parse(str.trim());
    if (parsedDur.status) return parsedDur.value;
    else return null;
  }).add1("duration", (d3) => d3).add1("null", (d3) => d3).vectorize(1, [0]).build();
  DefaultFunctions2.dateformat = new FunctionBuilder("dateformat").add2("date", "string", (date2, format) => date2.toFormat(format, { locale: currentLocale() })).add2("null", "string", (_nul, _format) => null).vectorize(2, [0]).build();
  DefaultFunctions2.localtime = new FunctionBuilder("localtime").add1("date", (d3) => d3.toLocal()).add1("null", () => null).vectorize(1, [0]).build();
  const NUMBER_REGEX = /-?[0-9]+(\.[0-9]+)?/;
  DefaultFunctions2.number = new FunctionBuilder("number").add1("number", (a4) => a4).add1("string", (str) => {
    let match4 = NUMBER_REGEX.exec(str);
    if (match4) return Number.parseFloat(match4[0]);
    else return null;
  }).add1("null", () => null).vectorize(1, [0]).build();
  DefaultFunctions2.string = new FunctionBuilder("string").add1("*", (a4, ctx) => Literals.toString(a4, stringSettings(ctx.settings))).build();
  DefaultFunctions2.round = new FunctionBuilder("round").add1("number", (n3) => Math.round(n3)).add1("null", () => null).vectorize(1, [0]).add2("number", "number", (n3, p3) => {
    if (p3 <= 0) return Math.round(n3);
    return parseFloat(n3.toFixed(p3));
  }).add2("number", "null", (n3) => Math.round(n3)).add2("null", "*", () => null).vectorize(2, [0]).build();
  DefaultFunctions2.min = new FunctionBuilder("min").add2("*", "null", (a4, _n2) => a4).add2("null", "*", (_n2, a4) => a4).add2("*", "*", (a4, b3, ctx) => Literals.compare(a4, b3, ctx.linkHandler.normalize) <= 0 ? a4 : b3).add1("array", (a4, ctx) => (0, DefaultFunctions2.min)(ctx, ...a4)).vararg((ctx, ...args) => args.length == 0 ? null : args.reduce((p3, c4) => (0, DefaultFunctions2.min)(ctx, p3, c4))).build();
  DefaultFunctions2.max = new FunctionBuilder("max").add2("*", "null", (a4, _n2) => a4).add2("null", "*", (_n2, a4) => a4).add2("*", "*", (a4, b3, ctx) => Literals.compare(a4, b3, ctx.linkHandler.normalize) > 0 ? a4 : b3).add1("array", (a4, ctx) => (0, DefaultFunctions2.max)(ctx, ...a4)).vararg((ctx, ...args) => args.length == 0 ? null : args.reduce((p3, c4) => (0, DefaultFunctions2.max)(ctx, p3, c4))).build();
  DefaultFunctions2.minby = new FunctionBuilder("minby").add2("array", "function", (arr, func, ctx) => {
    if (arr.length == 0) return null;
    let values = arr.map((v3) => {
      return { value: v3, mapped: func(ctx, v3) };
    });
    let filtered = values.filter((v3) => !Literals.isNull(v3.mapped));
    if (filtered.length == 0) return arr[0];
    return filtered.reduce((p3, c4) => {
      if (Literals.compare(p3.mapped, c4.mapped, ctx.linkHandler.normalize) <= 0) return p3;
      else return c4;
    }).value;
  }).add2("null", "function", (_arr, _func, _ctx) => null).build();
  DefaultFunctions2.maxby = new FunctionBuilder("maxby").add2("array", "function", (arr, func, ctx) => {
    if (arr.length == 0) return null;
    let values = arr.map((v3) => {
      return { value: v3, mapped: func(ctx, v3) };
    });
    let filtered = values.filter((v3) => !Literals.isNull(v3.mapped));
    if (filtered.length == 0) return arr[0];
    return filtered.reduce((p3, c4) => {
      if (Literals.compare(p3.mapped, c4.mapped, ctx.linkHandler.normalize) > 0) return p3;
      else return c4;
    }).value;
  }).add2("null", "function", (_arr, _func, _ctx) => null).build();
  DefaultFunctions2.striptime = new FunctionBuilder("striptime").add1("date", (d3) => DateTime.fromObject({ year: d3.year, month: d3.month, day: d3.day })).add1("null", (_n2) => null).vectorize(1, [0]).build();
  DefaultFunctions2.contains = new FunctionBuilder("contains").add2("array", "*", (l4, elem, context) => l4.some((e3) => (0, DefaultFunctions2.contains)(context, e3, elem))).add2("string", "string", (haystack, needle) => haystack.includes(needle)).add2("object", "string", (obj, key) => key in obj).add2(
    "*",
    "*",
    (elem1, elem2, context) => context.evaluate(Expressions.binaryOp(Expressions.literal(elem1), "=", Expressions.literal(elem2))).orElseThrow()
  ).vectorize(2, [1]).build();
  DefaultFunctions2.icontains = new FunctionBuilder("icontains").add2("array", "*", (l4, elem, context) => l4.some((e3) => (0, DefaultFunctions2.icontains)(context, e3, elem))).add2(
    "string",
    "string",
    (haystack, needle) => haystack.toLocaleLowerCase().includes(needle.toLocaleLowerCase())
  ).add2("object", "string", (obj, key) => key in obj).add2(
    "*",
    "*",
    (elem1, elem2, context) => context.evaluate(Expressions.binaryOp(Expressions.literal(elem1), "=", Expressions.literal(elem2))).orElseThrow()
  ).vectorize(2, [1]).build();
  DefaultFunctions2.econtains = new FunctionBuilder("econtains").add2(
    "array",
    "*",
    (l4, elem, context) => l4.some(
      (e3) => context.evaluate(Expressions.binaryOp(Expressions.literal(elem), "=", Expressions.literal(e3))).orElseThrow()
    )
  ).add2("string", "string", (haystack, needle) => haystack.includes(needle)).add2("object", "string", (obj, key) => key in obj).add2(
    "*",
    "*",
    (elem1, elem2, context) => context.evaluate(Expressions.binaryOp(Expressions.literal(elem1), "=", Expressions.literal(elem2))).orElseThrow()
  ).vectorize(2, [1]).build();
  DefaultFunctions2.containsword = new FunctionBuilder("containsword").add2(
    "string",
    "string",
    (hay, needle) => !!hay.match(new RegExp(".*\\b" + escapeRegex(needle) + "\\b.*", "i"))
  ).add2("null", "*", (_a, _b) => null).add2("*", "null", (_a, _b) => null).vectorize(2, [0, 1]).build();
  DefaultFunctions2.extract = (context, ...args) => {
    if (args.length == 0) return "extract(object, key1, ...) requires at least 1 argument";
    let object2 = args[0];
    if (Literals.isArray(object2)) return object2.map((v3) => (0, DefaultFunctions2.extract)(context, v3, ...args.slice(1)));
    let result = {};
    for (let index2 = 1; index2 < args.length; index2++) {
      let key = args[index2];
      if (!Literals.isString(key)) throw Error("extract(object, key1, ...) must be called with string keys");
      result[key] = context.evaluate(Expressions.index(Expressions.literal(object2), Expressions.literal(key))).orElseThrow();
    }
    return result;
  };
  DefaultFunctions2.reverse = new FunctionBuilder("reverse").add1("array", (l4) => {
    let result = [];
    for (let index2 = l4.length - 1; index2 >= 0; index2--) result.push(l4[index2]);
    return result;
  }).add1("string", (l4) => {
    let result = "";
    for (let c4 = 0; c4 < l4.length; c4++) result += l4[l4.length - c4 - 1];
    return result;
  }).add1("*", (e3) => e3).build();
  DefaultFunctions2.sort = new FunctionBuilder("sort").add1("array", (list2, context) => (0, DefaultFunctions2.sort)(context, list2, (_ctx, a4) => a4)).add2("array", "function", (list2, key, context) => {
    let result = [].concat(list2);
    result.sort((a4, b3) => {
      let akey = key(context, a4);
      let bkey = key(context, b3);
      let le = context.evaluate(Expressions.binaryOp(Expressions.literal(akey), "<", Expressions.literal(bkey))).orElseThrow();
      if (Literals.isTruthy(le)) return -1;
      let eq = context.evaluate(Expressions.binaryOp(Expressions.literal(akey), "=", Expressions.literal(bkey))).orElseThrow();
      if (Literals.isTruthy(eq)) return 0;
      return 1;
    });
    return result;
  }).add1("*", (e3) => e3).build();
  DefaultFunctions2.regextest = new FunctionBuilder("regextest").add2("string", "string", (pattern, field) => RegExp(pattern).test(field)).add2("null", "*", (_n2, _a) => false).add2("*", "null", (_a, _n2) => false).vectorize(2, [0, 1]).build();
  DefaultFunctions2.regexmatch = new FunctionBuilder("regexmatch").add2("string", "string", (pattern, field) => {
    if (!pattern.startsWith("^") && !pattern.endsWith("$")) pattern = "^" + pattern + "$";
    return !!field.match(pattern);
  }).add2("null", "*", (_n2, _a) => false).add2("*", "null", (_a, _n2) => false).vectorize(2, [0, 1]).build();
  DefaultFunctions2.regexreplace = new FunctionBuilder("regexreplace").add3("string", "string", "string", (field, pat, rep) => {
    try {
      let reg = new RegExp(pat, "g");
      return field.replace(reg, rep);
    } catch (ex) {
      throw Error(`Invalid regexp '${pat}' in regexreplace`);
    }
  }).add3("null", "*", "*", () => null).add3("*", "null", "*", () => null).add3("*", "*", "null", () => null).vectorize(3, [0, 1, 2]).build();
  DefaultFunctions2.lower = new FunctionBuilder("lower").add1("string", (s4) => s4.toLocaleLowerCase()).add1("null", () => null).vectorize(1, [0]).build();
  DefaultFunctions2.upper = new FunctionBuilder("upper").add1("string", (s4) => s4.toLocaleUpperCase()).add1("null", () => null).vectorize(1, [0]).build();
  DefaultFunctions2.replace = new FunctionBuilder("replace").add3("string", "string", "string", (str, pat, repr) => str.split(pat).join(repr)).add3("null", "*", "*", () => null).add3("*", "null", "*", () => null).add3("*", "*", "null", () => null).vectorize(3, [0, 1, 2]).build();
  const splitImpl = (str, delim, limit) => str.split(new RegExp(delim), limit).map((str2) => str2 || "");
  DefaultFunctions2.split = new FunctionBuilder("split").add2("string", "string", (string3, splitter) => splitImpl(string3, splitter)).add3("string", "string", "number", (string3, splitter, limit) => splitImpl(string3, splitter, limit)).add2("null", "*", () => null).add2("*", "null", () => null).add3("*", "*", "null", () => null).add3("*", "null", "*", () => null).add3("null", "*", "*", () => null).build();
  DefaultFunctions2.startswith = new FunctionBuilder("startswith").add2("string", "string", (str, starting) => str.startsWith(starting)).add2("null", "*", () => null).add2("*", "null", () => null).vectorize(2, [0, 1]).build();
  DefaultFunctions2.endswith = new FunctionBuilder("endswith").add2("string", "string", (str, ending) => str.endsWith(ending)).add2("null", "*", () => null).add2("*", "null", () => null).vectorize(2, [0, 1]).build();
  DefaultFunctions2.padleft = new FunctionBuilder("padleft").add2("string", "number", (str, len) => str.padStart(len, " ")).add3("string", "number", "string", (str, len, padding) => str.padStart(len, padding)).add2("null", "*", () => null).add2("*", "null", () => null).add3("null", "*", "*", () => null).add3("*", "null", "*", () => null).add3("*", "*", "null", () => null).vectorize(2, [0, 1]).vectorize(3, [0, 1, 2]).build();
  DefaultFunctions2.padright = new FunctionBuilder("padright").add2("string", "number", (str, len) => str.padEnd(len, " ")).add3("string", "number", "string", (str, len, padding) => str.padEnd(len, padding)).add2("null", "*", () => null).add2("*", "null", () => null).add3("null", "*", "*", () => null).add3("*", "null", "*", () => null).add3("*", "*", "null", () => null).vectorize(2, [0, 1]).vectorize(3, [0, 1, 2]).build();
  DefaultFunctions2.substring = new FunctionBuilder("substring").add2("string", "number", (str, start) => str.substring(start)).add3("string", "number", "number", (str, start, end2) => str.substring(start, end2)).add2("null", "*", () => null).add2("*", "null", () => null).add3("null", "*", "*", () => null).add3("*", "null", "*", () => null).add3("*", "*", "null", () => null).vectorize(2, [0, 1]).vectorize(3, [0, 1, 2]).build();
  DefaultFunctions2.truncate = new FunctionBuilder("truncate").add3("string", "number", "string", (str, length3, suffix) => {
    if (str.length > length3 - suffix.length) {
      return str.substring(0, Math.max(0, length3 - suffix.length)) + suffix;
    } else {
      return str;
    }
  }).add2("string", "number", (str, length3, ctx) => (0, DefaultFunctions2.truncate)(ctx, str, length3, "...")).add2("null", "*", () => null).add2("*", "null", () => null).add3("null", "*", "*", () => null).add3("*", "null", "*", () => null).add3("*", "*", "null", () => null).vectorize(2, [0, 1]).vectorize(3, [0, 1, 2]).build();
  DefaultFunctions2.fdefault = new FunctionBuilder("default").add2("*", "*", (v3, bk) => Literals.isNull(v3) ? bk : v3).vectorize(2, [0, 1]).build();
  DefaultFunctions2.ldefault = new FunctionBuilder("ldefault").add2("*", "*", (v3, bk) => Literals.isNull(v3) ? bk : v3).build();
  DefaultFunctions2.choice = new FunctionBuilder("choice").add3("*", "*", "*", (b3, left, right) => Literals.isTruthy(b3) ? left : right).vectorize(3, [0]).build();
  DefaultFunctions2.reduce = new FunctionBuilder("reduce").add2("array", "string", (lis, op, context) => {
    if (lis.length == 0) return null;
    if (op != "+" && op != "-" && op != "*" && op != "/" && op != "&" && op != "|")
      throw Error("reduce(array, op) supports '+', '-', '/', '*', '&', and '|'");
    let value = lis[0];
    for (let index2 = 1; index2 < lis.length; index2++) {
      value = context.evaluate(Expressions.binaryOp(Expressions.literal(value), op, Expressions.literal(lis[index2]))).orElseThrow();
    }
    return value;
  }).add2("array", "function", (lis, op, context) => {
    if (lis.length == 0) return null;
    let value = lis[0];
    for (let index2 = 1; index2 < lis.length; index2++) {
      if (Literals.isNull(lis[index2])) continue;
      value = op(context, value, lis[index2]);
    }
    return value;
  }).add2("null", "*", () => null).add2("*", "null", () => null).vectorize(2, [1]).build();
  DefaultFunctions2.sum = new FunctionBuilder("sum").add1("array", (arr, c4) => (0, DefaultFunctions2.reduce)(c4, arr, "+")).add1("*", (e3) => e3).build();
  DefaultFunctions2.average = new FunctionBuilder("average").add1("array", (array2, context) => {
    if (array2.length == 0) return null;
    const add = (0, DefaultFunctions2.sum)(context, array2);
    if (add == null || add == void 0) return null;
    return context.evaluate(Expressions.binaryOp(Expressions.literal(add), "/", Expressions.literal(array2.length))).orElseThrow();
  }).add1("*", (e3) => e3).build();
  DefaultFunctions2.product = new FunctionBuilder("product").add1("array", (arr, c4) => (0, DefaultFunctions2.reduce)(c4, arr, "*")).add1("*", (e3) => e3).build();
  DefaultFunctions2.join = new FunctionBuilder("join").add2(
    "array",
    "string",
    (arr, sep, ctx) => arr.map((e3) => Literals.toString(e3, stringSettings(ctx.settings))).join(sep)
  ).add2("array", "null", (arr, _s, context) => (0, DefaultFunctions2.join)(context, arr, ", ")).add2("*", "string", (elem, sep, ctx) => Literals.toString(elem, stringSettings(ctx.settings))).add1("array", (arr, context) => (0, DefaultFunctions2.join)(context, arr, ", ")).add1("*", (e3, ctx) => Literals.toString(e3, stringSettings(ctx.settings))).vectorize(2, [1]).build();
  DefaultFunctions2.any = new FunctionBuilder("any").add1("array", (arr) => arr.some((v3) => Literals.isTruthy(v3))).add2("array", "function", (arr, f4, ctx) => arr.some((v3) => Literals.isTruthy(f4(ctx, v3)))).vararg((_ctx, ...args) => args.some((v3) => Literals.isTruthy(v3))).build();
  DefaultFunctions2.all = new FunctionBuilder("all").add1("array", (arr) => arr.every((v3) => Literals.isTruthy(v3))).add2("array", "function", (arr, f4, ctx) => arr.every((v3) => Literals.isTruthy(f4(ctx, v3)))).vararg((_ctx, ...args) => args.every((v3) => Literals.isTruthy(v3))).build();
  DefaultFunctions2.none = new FunctionBuilder("all").add1("array", (arr) => !arr.some((v3) => Literals.isTruthy(v3))).add2("array", "function", (arr, f4, ctx) => !arr.some((v3) => Literals.isTruthy(f4(ctx, v3)))).vararg((_ctx, ...args) => !args.some((v3) => Literals.isTruthy(v3))).build();
  DefaultFunctions2.filter = new FunctionBuilder("filter").add2("array", "function", (arr, f4, ctx) => arr.filter((v3) => Literals.isTruthy(f4(ctx, v3)))).add2("null", "*", () => null).build();
  DefaultFunctions2.map = new FunctionBuilder("map").add2("array", "function", (arr, f4, ctx) => arr.map((v3) => f4(ctx, v3))).add2("null", "*", () => null).build();
  DefaultFunctions2.nonnull = new FunctionBuilder("nonnull").add1("array", (arr) => arr.filter((v3) => Literals.typeOf(v3) != "null")).vararg((_ctx, ...args) => args.filter((v3) => Literals.typeOf(v3) != "null")).build();
  DefaultFunctions2.meta = new FunctionBuilder("meta").add1("link", (link2) => {
    var _a, _b;
    return {
      display: (_a = link2.display) != null ? _a : null,
      embed: link2.embed,
      path: link2.path,
      subpath: (_b = link2.subpath) != null ? _b : null,
      type: link2.type
    };
  }).build();
  DefaultFunctions2.flat = new FunctionBuilder("flat").add1("array", (a4) => {
    return a4.flat();
  }).add2("array", "number", (a4, n3) => {
    return a4.flat(n3);
  }).add1("null", () => null).build();
})(DefaultFunctions || (DefaultFunctions = {}));
var DEFAULT_FUNCTIONS = {
  // Constructors.
  list: DefaultFunctions.list,
  array: DefaultFunctions.list,
  link: DefaultFunctions.link,
  embed: DefaultFunctions.embed,
  date: DefaultFunctions.date,
  dur: DefaultFunctions.dur,
  dateformat: DefaultFunctions.dateformat,
  localtime: DefaultFunctions.localtime,
  number: DefaultFunctions.number,
  string: DefaultFunctions.string,
  object: DefaultFunctions.object,
  typeof: DefaultFunctions.typeOf,
  // Math Operations.
  round: DefaultFunctions.round,
  min: DefaultFunctions.min,
  max: DefaultFunctions.max,
  minby: DefaultFunctions.minby,
  maxby: DefaultFunctions.maxby,
  // String operations.
  regexreplace: DefaultFunctions.regexreplace,
  regextest: DefaultFunctions.regextest,
  regexmatch: DefaultFunctions.regexmatch,
  replace: DefaultFunctions.replace,
  lower: DefaultFunctions.lower,
  upper: DefaultFunctions.upper,
  split: DefaultFunctions.split,
  startswith: DefaultFunctions.startswith,
  endswith: DefaultFunctions.endswith,
  padleft: DefaultFunctions.padleft,
  padright: DefaultFunctions.padright,
  substring: DefaultFunctions.substring,
  truncate: DefaultFunctions.truncate,
  // Date Operations.
  striptime: DefaultFunctions.striptime,
  // List operations.
  length: DefaultFunctions.length,
  contains: DefaultFunctions.contains,
  icontains: DefaultFunctions.icontains,
  econtains: DefaultFunctions.econtains,
  containsword: DefaultFunctions.containsword,
  reverse: DefaultFunctions.reverse,
  sort: DefaultFunctions.sort,
  flat: DefaultFunctions.flat,
  // Aggregation operations like reduce.
  reduce: DefaultFunctions.reduce,
  join: DefaultFunctions.join,
  sum: DefaultFunctions.sum,
  product: DefaultFunctions.product,
  average: DefaultFunctions.average,
  all: DefaultFunctions.all,
  any: DefaultFunctions.any,
  none: DefaultFunctions.none,
  filter: DefaultFunctions.filter,
  map: DefaultFunctions.map,
  nonnull: DefaultFunctions.nonnull,
  // Object/Utility operations.
  extract: DefaultFunctions.extract,
  default: DefaultFunctions.fdefault,
  ldefault: DefaultFunctions.ldefault,
  choice: DefaultFunctions.choice,
  meta: DefaultFunctions.meta
};

// src/expression/evaluator.ts
var Evaluator = class {
  /**
   * Create a new context with the given namespace of globals, as well as optionally with custom binary operator, function,
   * and link handlers.
   */
  constructor(linkHandler, settings, globals = {}, binaryOps = createBinaryOps(linkHandler.normalize), functions2 = DEFAULT_FUNCTIONS) {
    this.linkHandler = linkHandler;
    this.settings = settings;
    this.globals = globals;
    this.binaryOps = binaryOps;
    this.functions = functions2;
  }
  /** Set a global value in this context. */
  set(name, value) {
    this.globals[name] = value;
    return this;
  }
  /** Get the value of a global variable by name. Returns null if not present. */
  get(name) {
    var _a;
    return (_a = this.globals[name]) != null ? _a : null;
  }
  /** Try to evaluate an arbitrary expression in this context, raising an exception on failure. */
  tryEvaluate(expr, variables = Variables.empty()) {
    return this.evaluate(expr, variables).orElseThrow();
  }
  /** Evaluate an arbitrary expression in this context. */
  evaluate(expr, variables = Variables.empty()) {
    switch (expr.type) {
      case "literal":
        return Result.success(expr.value);
      case "variable":
        if (expr.name === Expressions.ROW) return Result.success(variables.all());
        const resolved = variables.resolve(expr.name);
        if (resolved !== void 0) return Result.success(resolved);
        if (expr.name in this.globals) return Result.success(this.globals[expr.name]);
        return Result.success(null);
      case "negated":
        return this.evaluate(expr.child, variables).map((s4) => !Literals.isTruthy(s4));
      case "binaryop":
        return Result.flatMap2(
          this.evaluate(expr.left, variables),
          this.evaluate(expr.right, variables),
          (a4, b3) => this.binaryOps.evaluate(expr.op, a4, b3, this)
        );
      case "list":
        let result = [];
        for (let child of expr.values) {
          let subeval = this.evaluate(child, variables);
          if (!subeval.successful) return subeval;
          result.push(subeval.value);
        }
        return Result.success(result);
      case "object":
        let objResult = {};
        for (let [key, child] of Object.entries(expr.values)) {
          let subeval = this.evaluate(child, variables);
          if (!subeval.successful) return subeval;
          objResult[key] = subeval.value;
        }
        return Result.success(objResult);
      case "lambda":
        return Result.success((ctx, ...args2) => {
          let locals = {};
          for (let arg = 0; arg < Math.min(args2.length, expr.arguments.length); arg++) {
            locals[expr.arguments[arg]] = args2[arg];
          }
          return ctx.evaluate(expr.value, Variables.lambda(variables, locals)).orElseThrow();
        });
      case "function":
        let rawFunc = expr.func.type == "variable" ? Result.success(expr.func.name) : this.evaluate(expr.func, variables);
        if (!rawFunc.successful) return rawFunc;
        let func = rawFunc.value;
        let args = [];
        for (let arg of expr.arguments) {
          let resolved2 = this.evaluate(arg, variables);
          if (!resolved2.successful) return resolved2;
          args.push(resolved2.value);
        }
        let call;
        if (Literals.isFunction(func)) call = func;
        else if (Literals.isString(func) && func in this.functions) call = this.functions[func];
        else if (Literals.isString(func)) return Result.failure(`Unrecognized function name '${func}'`);
        else return Result.failure(`Cannot call type '${Literals.typeOf(func)}' as a function`);
        try {
          return Result.success(call(this, ...args));
        } catch (e3) {
          return Result.failure(e3.message);
        }
    }
  }
};
var ObjectVariables = class {
  constructor(object) {
    this.object = object;
  }
  all() {
    return this.object;
  }
  resolve(name) {
    return this.object[name];
  }
};
var FieldbearingVariables = class {
  constructor(object) {
    this.object = object;
  }
  all() {
    const object = {};
    for (const field of this.object.fields) {
      object[field.key] = field.value;
    }
    return object;
  }
  resolve(name) {
    var _a;
    return (_a = this.object.field(name)) == null ? void 0 : _a.value;
  }
};
var LambdaVariables = class {
  constructor(parent, locals) {
    this.parent = parent;
    this.locals = locals;
  }
  all() {
    return { ...this.parent.all(), ...this.locals };
  }
  resolve(name) {
    var _a;
    return (_a = this.locals[name]) != null ? _a : this.parent.resolve(name);
  }
};
var Variables;
((Variables2) => {
  function empty() {
    return new ObjectVariables({});
  }
  Variables2.empty = empty;
  function infer(object) {
    if (Fieldbearings.isFieldbearing(object)) {
      return new FieldbearingVariables(object);
    } else {
      return new ObjectVariables(object);
    }
  }
  Variables2.infer = infer;
  function lambda(parent, locals) {
    return new LambdaVariables(parent, locals);
  }
  Variables2.lambda = lambda;
})(Variables || (Variables = {}));

// src/index/storage/query-executor.ts
function optimizeQuery(query) {
  query = denest(query);
  query = constantfold(query);
  return query;
}
function denest(query) {
  switch (query.type) {
    case "and":
      const ands = query.elements.flatMap((element) => {
        const fixed = denest(element);
        if (fixed.type === "and") return fixed.elements;
        else return [fixed];
      });
      return { type: "and", elements: ands };
    case "or":
      const ors = query.elements.flatMap((element) => {
        const fixed = denest(element);
        if (fixed.type === "or") return fixed.elements;
        else return [fixed];
      });
      return { type: "or", elements: ors };
    case "not":
      return { type: "not", element: denest(query.element) };
    case "child-of":
      return Object.assign({}, query, { parents: denest(query.parents) });
    case "parent-of":
      return Object.assign({}, query, { children: denest(query.children) });
    case "linked":
      return Object.assign({}, query, { source: denest(query.source) });
    default:
      return query;
  }
}
function constantfold(query) {
  switch (query.type) {
    case "and":
      const achildren = [];
      for (const child of query.elements) {
        const folded2 = constantfold(child);
        if (folded2.type === "constant") {
          if (folded2.constant) continue;
          else return { type: "constant", constant: false };
        }
        achildren.push(folded2);
      }
      return { type: "and", elements: achildren };
    case "or":
      const ochildren = [];
      for (const child of query.elements) {
        const folded2 = constantfold(child);
        if (folded2.type === "constant") {
          if (!folded2.constant) continue;
          else return { type: "constant", constant: true };
        }
        ochildren.push(folded2);
      }
      return { type: "or", elements: ochildren };
    case "not":
      const folded = constantfold(query.element);
      if (folded.type === "constant") {
        return { type: "constant", constant: !folded.constant };
      }
      return { type: "not", element: folded };
    case "child-of":
      const parents = constantfold(query.parents);
      if (parents.type === "constant") {
        if (!parents.constant) return { type: "constant", constant: false };
        else if (parents.constant && query.inclusive) return { type: "constant", constant: true };
      }
      return Object.assign({}, query, { parents });
    case "parent-of":
      const children = constantfold(query.children);
      if (children.type === "constant") {
        if (!children.constant) return { type: "constant", constant: false };
        else if (children.constant && query.inclusive) return { type: "constant", constant: true };
      }
      return Object.assign({}, query, { children });
    case "linked":
      const source = constantfold(query.source);
      if (source.type === "constant") {
        if (!source.constant) return { type: "constant", constant: false };
        else if (source.constant && query.inclusive) return { type: "constant", constant: true };
      }
      return Object.assign({}, query, { source });
    default:
      return query;
  }
}
function execute(query, resolver, evaluator) {
  return simplify(query, resolver).flatMap((tree) => collapse(tree, resolver, evaluator));
}
function simplify(query, resolver) {
  switch (query.type) {
    case "and":
      return Result.mapAll(query.elements, (child) => simplify(child, resolver)).map((elements) => {
        const flattened = elements.flatMap(
          (element) => element.type === "and" ? element.elements : [element]
        );
        const other = [];
        const primitive = Filters.lazyIntersect(flattened, (element) => {
          if (element.type === "filter") return element.filter;
          else {
            other.push(element);
            return void 0;
          }
        });
        if (primitive.type === "nothing") return { type: "filter", filter: Filters.NOTHING };
        else if (primitive.type != "everything") other.push(FilterTrees.filter(primitive));
        return FilterTrees.and(other);
      });
    case "or":
      return Result.mapAll(query.elements, (child) => simplify(child, resolver)).map((elements) => {
        const flattened = elements.flatMap((element) => element.type === "or" ? element.elements : [element]);
        const other = [];
        const primitive = Filters.lazyUnion(flattened, (element) => {
          if (element.type === "filter") return element.filter;
          else {
            other.push(element);
            return void 0;
          }
        });
        if (primitive.type === "everything") return { type: "filter", filter: Filters.EVERYTHING };
        else if (primitive.type != "nothing") other.push(FilterTrees.filter(primitive));
        return FilterTrees.or(other);
      });
    case "not":
      return simplify(query.element, resolver).map(FilterTrees.not);
    case "expression":
      const candidates = hasVariables(query.expression, resolver);
      return Result.success({ type: "scan", candidates, expression: query.expression });
    default:
      return resolver.resolve(query).map((filter) => ({ type: "filter", filter }));
  }
}
function collapse(tree, resolver, evaluator, limit = Filters.EVERYTHING) {
  switch (tree.type) {
    case "or":
      return Filters.lazyFailableUnion(tree.elements, (element) => collapse(element, resolver, evaluator, limit));
    case "and":
      const primitives = tree.elements.filter((elem) => elem.type === "filter").map((f4) => f4.filter);
      let restrictedLimit = Filters.intersect([limit, ...primitives]);
      for (const element of tree.elements) {
        if (element.type === "filter") continue;
        const maybeEvaluated = collapse(element, resolver, evaluator, restrictedLimit);
        if (!maybeEvaluated.successful) return maybeEvaluated.cast();
        const evaluated = maybeEvaluated.value;
        restrictedLimit = Filters.intersect([restrictedLimit, evaluated]);
        if (restrictedLimit.type === "nothing") return Result.success(Filters.NOTHING);
      }
      return Result.success(restrictedLimit);
    case "not":
      return collapse(tree.element, resolver, evaluator, limit).map(Filters.negate);
    case "filter":
      return Result.success(tree.filter);
    case "scan":
      const candidates = Filters.resolve(Filters.intersect([tree.candidates, limit]), resolver.universe);
      return filterScan(candidates, tree.expression, evaluator, resolver).map(Filters.atom);
  }
}
function filterScan(candidates, expr, evaluator, resolver) {
  const result = /* @__PURE__ */ new Set();
  for (const candidate of candidates) {
    const object = resolver.load(candidate);
    if (!object) continue;
    const value = evaluator.evaluate(expr, Variables.infer(object));
    if (!value.successful) {
      return Result.failure(`Error while evaluating expression "${Expressions.toString(expr)}": ${value.error}`);
    } else {
      if (Literals.isTruthy(value.value)) result.add(candidate);
    }
  }
  return Result.success(result);
}
function hasVariables(expr, resolver) {
  const variables = Expressions.unboundVariables(expr, /* @__PURE__ */ new Set([Expressions.ROW, "this"]));
  if (variables.size == 0) return Filters.EVERYTHING;
  return Filters.lazyUnion(variables, (variable) => resolver.resolvePrimitive({ type: "field", value: variable }));
}
var FilterTrees;
((FilterTrees2) => {
  function filter(filter2) {
    return { type: "filter", filter: filter2 };
  }
  FilterTrees2.filter = filter;
  function and(children) {
    if (children.length == 0) return filter(Filters.EVERYTHING);
    else if (children.length == 1) return children[0];
    else return { type: "and", elements: children };
  }
  FilterTrees2.and = and;
  function or(children) {
    if (children.length == 0) return filter(Filters.NOTHING);
    else if (children.length == 1) return children[0];
    else return { type: "or", elements: children };
  }
  FilterTrees2.or = or;
  function not(child) {
    if (child.type === "filter") return { type: "filter", filter: Filters.negate(child.filter) };
    else return { type: "not", element: child };
  }
  FilterTrees2.not = not;
})(FilterTrees || (FilterTrees = {}));

// src/index/datastore.ts
var Datastore = class {
  constructor(vault, metadataCache, settings) {
    this.vault = vault;
    this.metadataCache = metadataCache;
    this.settings = settings;
    this.revision = 0;
    this.ids = /* @__PURE__ */ new Set();
    this.objects = /* @__PURE__ */ new Map();
    this.children = /* @__PURE__ */ new Map();
    this.types = new InvertedIndex();
    this.etags = new InvertedIndex();
    this.tags = new InvertedIndex();
    this.links = new InvertedIndex();
    this.fields = this._initializeFields();
    this.folder = new FolderIndex(vault);
  }
  /** Return the total number of objects in the store. */
  get size() {
    return this.objects.size;
  }
  /** Update the revision of the datastore due to an external update. */
  touch() {
    this.revision += 1;
  }
  /** Load an object by ID or list of IDs. */
  load(id2) {
    if (Array.isArray(id2)) {
      return id2.map((a4) => this.load(a4)).filter((obj) => obj !== void 0);
    }
    return this.objects.get(id2);
  }
  /** Sets up sane field defaults for several indexable fields. */
  _initializeFields() {
    const fields = /* @__PURE__ */ new Map();
    fields.set(
      "$id",
      new IdFieldIndex(
        () => this.ids,
        (id2) => this.objects.has(id2)
      )
    );
    fields.set("$types", new EverythingFieldIndex(() => this.ids));
    fields.set("$typename", new EverythingFieldIndex(() => this.ids));
    fields.set("$revision", new EverythingFieldIndex(() => this.ids));
    fields.set("$completed", new BTreeFieldIndex());
    fields.set("$status", new BTreeFieldIndex());
    return fields;
  }
  /**
   * Store the given object, making it immediately queryable. Storing an object
   * takes ownership over it, and index-specific variables (prefixed via '$') may be
   * added to the object.
   */
  store(object, substorer) {
    this._recursiveStore(object, this.revision++, substorer, void 0);
  }
  /** Recursively store objects using a potential subindexer. */
  _recursiveStore(object, revision, substorer, parent) {
    if (Literals.isArray(object)) {
      for (let element of object) {
        this._recursiveStore(element, revision, substorer, parent);
      }
      return;
    }
    this._deleteRecursive(object.$id);
    object.$revision = revision;
    object.$parent = parent;
    this.ids.add(object.$id);
    this.objects.set(object.$id, object);
    if (parent) {
      if (!this.children.has(parent.$id)) this.children.set(parent.$id, /* @__PURE__ */ new Set());
      this.children.get(parent.$id).add(object.$id);
    }
    this._index(object);
    substorer == null ? void 0 : substorer(object, (incoming, subindex) => this._recursiveStore(incoming, revision, subindex, object));
  }
  /** Delete an object by ID from the index, recursively deleting any child objects as well. */
  delete(id2) {
    if (this._deleteRecursive(id2)) {
      this.revision++;
      return true;
    }
    return false;
  }
  /** Internal method that does not bump the revision. */
  _deleteRecursive(id2) {
    const object = this.objects.get(id2);
    if (!object) {
      return false;
    }
    const children = this.children.get(id2);
    if (children) {
      for (let child of children) {
        this._deleteRecursive(child);
      }
      this.children.delete(id2);
    }
    this._unindex(object);
    this.ids.delete(id2);
    this.objects.delete(id2);
    return true;
  }
  /** Add the given indexable to the appropriate indices. */
  _index(object) {
    this.types.set(object.$id, object.$types);
    if (object.$types.contains(TAGGABLE_TYPE) && iterableExists(object, "$tags")) {
      const tags3 = object.$tags;
      this.etags.set(object.$id, tags3);
      this.tags.set(object.$id, extractSubtags(tags3));
    }
    if (object.$types.contains(LINKBEARING_TYPE) && iterableExists(object, "$links")) {
      this.links.set(
        object.$id,
        object.$links.map((link) => link.obsidianLink())
      );
    }
    if (object.$types.contains(FIELDBEARING_TYPE) && "fields" in object) {
      for (const field of object.fields) {
        const norm = field.key.toLowerCase();
        if (!this.fields.has(norm)) this.fields.set(norm, new SetFieldIndex());
        this.fields.get(norm).add(object.$id, field.value);
      }
    }
  }
  /** Remove the given indexable from all indices. */
  _unindex(object) {
    this.types.delete(object.$id, object.$types);
    if (object.$types.contains(TAGGABLE_TYPE) && iterableExists(object, "$tags")) {
      const tags3 = object.$tags;
      this.etags.delete(object.$id, tags3);
      this.tags.delete(object.$id, extractSubtags(tags3));
    }
    if (object.$types.contains(LINKBEARING_TYPE) && iterableExists(object, "$links")) {
      this.links.delete(
        object.$id,
        object.$links.map((link) => link.obsidianLink())
      );
    }
    if (object.$types.contains(FIELDBEARING_TYPE) && "fields" in object) {
      for (const field of object.fields) {
        const norm = field.key.toLowerCase();
        if (!this.fields.has(norm)) continue;
        this.fields.get(norm).delete(object.$id, field.value);
      }
    }
  }
  /** Completely clear the datastore of all values. */
  clear() {
    this.ids.clear();
    this.objects.clear();
    this.children.clear();
    this.types.clear();
    this.tags.clear();
    this.etags.clear();
    this.links.clear();
    this.fields.clear();
    this.revision++;
  }
  /** Find the corresponding object for a given link. */
  resolveLink(rawLink, sourcePath) {
    let link = typeof rawLink === "string" ? Link.parseInner(rawLink) : rawLink;
    if (sourcePath) {
      const linkdest = this.metadataCache.getFirstLinkpathDest(link.path, sourcePath);
      if (linkdest) link = link.withPath(linkdest.path);
    }
    const file = this.objects.get(link.path);
    if (!file) return void 0;
    if (link.type === "file") return file;
    if (!(file instanceof MarkdownPage)) return void 0;
    if (link.type === "header") {
      const section = file.$sections.find(
        (sec) => normalizeHeaderForLink(sec.$title) == link.subpath || sec.$title == link.subpath
      );
      if (section) return section;
      else return void 0;
    } else if (link.type === "block") {
      for (const section of file.$sections) {
        const block = section.$blocks.find((bl) => bl.$blockId === link.subpath);
        if (block) return block;
      }
      return void 0;
    } else {
      throw new Error(`Unrecognized link type: ${link.type}`);
    }
  }
  /**
   * Search the datastore for all documents matching the given query, returning them
   * as a list of indexed objects along with performance metadata.
   */
  search(query, settings) {
    var _a;
    const start = Date.now();
    const maybeFilter = this._search(query, settings);
    if (!maybeFilter.successful) return maybeFilter.cast();
    const result = Filters.resolve(maybeFilter.value, this.ids);
    const objects = [];
    let maxRevision = 0;
    for (let id2 of result) {
      const object = this.objects.get(id2);
      if (object) {
        objects.push(object);
        maxRevision = Math.max(maxRevision, (_a = object.$revision) != null ? _a : 0);
      }
    }
    return Result.success({
      query,
      results: objects,
      duration: (Date.now() - start) / 1e3,
      revision: maxRevision
    });
  }
  /** Internal search which yields a filter of results. */
  _search(query, settings) {
    const sourcePath = settings == null ? void 0 : settings.sourcePath;
    const file = sourcePath ? this.objects.get(sourcePath) : void 0;
    const evaluator = new Evaluator(
      {
        exists: (path) => this.resolveLink(typeof path == "string" ? Link.file(path) : path, sourcePath) != null,
        resolve: (path) => {
          var _a;
          return (_a = this.resolveLink(typeof path == "string" ? Link.file(path) : path, sourcePath)) != null ? _a : null;
        },
        normalize: (path) => {
          var _a, _b;
          return (_b = (_a = this.metadataCache.getFirstLinkpathDest(path, sourcePath != null ? sourcePath : "")) == null ? void 0 : _a.path) != null ? _b : path;
        }
      },
      this.settings
    );
    if (file) evaluator.set("this", file);
    const resolver = {
      universe: this.ids,
      resolve: (leaf) => this._resolveSource(leaf, settings),
      resolvePrimitive: (leaf) => this._resolvePrimitive(leaf, settings),
      load: (id2) => this.load(id2)
    };
    return execute(optimizeQuery(query), resolver, evaluator);
  }
  _resolveSource(query, settings) {
    var _a, _b;
    switch (query.type) {
      case "child-of":
        const maybeParents = this._search(query.parents, settings);
        if (!maybeParents.successful) return maybeParents.cast();
        const parents = maybeParents.value;
        if (Filters.empty(parents)) {
          return Result.success(Filters.NOTHING);
        } else if (parents.type === "everything") {
          if (query.inclusive) return Result.success(Filters.EVERYTHING);
          const allChildren = /* @__PURE__ */ new Set();
          for (const element of this.objects.values()) {
            if (element.$parent) allChildren.add(element.$id);
          }
          return Result.success(Filters.atom(allChildren));
        }
        const resolvedParents = Filters.resolve(parents, this.ids);
        const childResults = new Set(query.inclusive ? resolvedParents : []);
        for (const parent of resolvedParents) {
          for (const child of this._iterateChildren(parent)) {
            childResults.add(child);
          }
        }
        return Result.success(Filters.atom(childResults));
      case "parent-of":
        const maybeChildren = this._search(query.children, settings);
        if (!maybeChildren.successful) return maybeChildren.cast();
        const children = maybeChildren.value;
        if (Filters.empty(children)) {
          return Result.success(Filters.NOTHING);
        } else if (children.type === "everything") {
          if (query.inclusive) return Result.success(Filters.EVERYTHING);
          return Result.success(Filters.atom(new Set(this.children.keys())));
        }
        const resolvedChildren = Filters.resolve(children, this.ids);
        const parentResults = new Set(query.inclusive ? resolvedChildren : []);
        for (const child of resolvedChildren) {
          for (const parent of this._iterateParents(child)) {
            parentResults.add(parent);
          }
        }
        return Result.success(Filters.atom(parentResults));
      case "linked":
        if (query.distance && query.distance < 0) return Result.success(Filters.NOTHING);
        const maybeSources = this._search(query.source, settings);
        if (!maybeSources.successful) return maybeSources.cast();
        const sources = maybeSources.value;
        if (Filters.empty(sources)) return Result.success(Filters.NOTHING);
        else if (sources.type === "everything") {
          if (query.inclusive) return Result.success(Filters.EVERYTHING);
          else return Result.success(Filters.NOTHING);
        }
        const resolvedSources = Filters.resolve(sources, this.ids);
        const direction = (_a = query.direction) != null ? _a : "both";
        const results = this._traverseLinked(
          resolvedSources,
          (_b = query.distance) != null ? _b : 1,
          (id2) => this._iterateAdjacentLinked(id2, direction)
        );
        if (!query.inclusive)
          return Result.success(Filters.atom(Filters.setIntersectNegation(results, resolvedSources)));
        else return Result.success(Filters.atom(results));
      default:
        return Result.success(this._resolvePrimitive(query, settings));
    }
  }
  /** Resolve leaf nodes in a search AST, yielding raw sets of results. */
  _resolvePrimitive(query, settings) {
    var _a, _b;
    switch (query.type) {
      case "constant":
        return Filters.constant(query.constant);
      case "id":
        const exactObject = this.objects.get(query.value);
        return exactObject ? Filters.atom(/* @__PURE__ */ new Set([exactObject.$id])) : Filters.NOTHING;
      case "link":
        const resolvedPath = (_b = this.metadataCache.getFirstLinkpathDest(
          query.value.path,
          (_a = settings == null ? void 0 : settings.sourcePath) != null ? _a : ""
        )) == null ? void 0 : _b.path;
        const resolved = resolvedPath ? query.value.withPath(resolvedPath) : query.value;
        const object = this.resolveLink(resolved);
        return object ? Filters.atom(/* @__PURE__ */ new Set([object.$id])) : Filters.NOTHING;
      case "typed":
        return Filters.nullableAtom(this.types.get(query.value));
      case "tagged":
        if (query.exact) {
          return Filters.nullableAtom(this.etags.get(query.value));
        } else {
          return Filters.nullableAtom(this.tags.get(query.value));
        }
      case "path":
        let toplevel;
        if (query.exact) {
          toplevel = this.folder.getExact(query.value);
        } else {
          if (query.value == "" || query.value == "/") return Filters.EVERYTHING;
          toplevel = this.folder.get(query.value);
        }
        if (toplevel.size == 0) return Filters.NOTHING;
        const result = new Set(toplevel);
        for (let top of toplevel) {
          for (let child of this._iterateChildren(top)) {
            result.add(child);
          }
        }
        return Filters.atom(result);
      case "field":
        const normkey = query.value.toLowerCase();
        const fieldIndex = this.fields.get(normkey);
        if (fieldIndex == null) return Filters.NOTHING;
        return Filters.atom(fieldIndex.all());
      case "equal-value":
        return Filters.lazyUnion(
          query.values,
          (value) => this._filterFields(
            query.field,
            (index2) => index2.equals(value),
            (field) => Literals.compare(value, field.value) == 0
          )
        );
    }
  }
  /** Filter documents by field values, using the fast lookup if it returns a result and otherwise filtering over every document using the slow predicate. */
  _filterFields(key, fast, slow) {
    const normkey = key.toLowerCase();
    const index2 = this.fields.get(normkey);
    if (index2 == null) return Filters.NOTHING;
    const fastlookup = fast(index2);
    if (fastlookup != null) return Filters.atom(fastlookup);
    const matches = /* @__PURE__ */ new Set();
    for (const objectId of index2.all()) {
      const object = this.objects.get(objectId);
      if (!object || !object.$types.contains(FIELDBEARING_TYPE)) continue;
      const field = object.field(normkey);
      if (!field) continue;
      if (slow(field)) matches.add(objectId);
    }
    return Filters.atom(matches);
  }
  /**
   * Does Breadth-first Search to find all linked files within distance <distance>. This includes all source nodes,
   * so remove them afterwards if you do not want them.
   */
  _traverseLinked(sourceIds, distance, adjacent) {
    if (distance < 0) return /* @__PURE__ */ new Set();
    if (sourceIds.size == 0) return /* @__PURE__ */ new Set();
    const visited = new Set(sourceIds);
    const queue = new FlatQueue();
    for (const element of sourceIds) queue.push(element, 0);
    while (queue.length > 0) {
      const dist = queue.peekValue();
      const element = queue.pop();
      for (const neighbor of adjacent(element)) {
        if (visited.has(neighbor)) continue;
        visited.add(neighbor);
        if (dist < distance) queue.push(neighbor, dist + 1);
      }
    }
    return visited;
  }
  /** Iterate all linked objects for the given object. */
  *_iterateAdjacentLinked(id2, direction) {
    const object = this.objects.get(id2);
    if (!object) return;
    if ((direction === "both" || direction === "incoming") && "$link" in object && object["$link"]) {
      const incoming = this.links.get(object.$link.obsidianLink());
      if (incoming) {
        for (const id3 of incoming) {
          yield id3;
        }
      }
    }
    if ((direction === "both" || direction === "outgoing") && object.$types.contains(LINKABLE_TYPE) && iterableExists(object, "$links")) {
      for (const link of object.$links) {
        const resolved = this.resolveLink(link);
        if (resolved) yield resolved.$id;
      }
    }
  }
  /** Iterator which produces all parents of the given object. */
  *_iterateParents(child) {
    let object = this.objects.get(child);
    while (object && (object == null ? void 0 : object.$parent)) {
      yield object.$parent.$id;
      object = object.$parent;
    }
  }
  /** Iterative which produces all children (recursively) of the given object. */
  *_iterateChildren(parent) {
    const children = this.children.get(parent);
    if (children && children.size > 0) {
      for (let child of children) {
        yield child;
        yield* this._iterateChildren(child);
      }
    }
  }
};
function iterableExists(object, key) {
  return key in object && object[key] !== void 0 && Symbol.iterator in object[key];
}

// src/index/persister.ts
var import_localforage = __toESM(require_localforage());
var LocalStorageCache = class {
  constructor(appId, version) {
    this.appId = appId;
    this.version = version;
    this.persister = import_localforage.default.createInstance({
      name: "datacore/cache/" + appId,
      driver: [import_localforage.default.INDEXEDDB],
      description: "Cache metadata about files and sections in the datacore index."
    });
  }
  /** Drop the entire cache instance and re-create a new fresh instance. */
  async recreate() {
    await import_localforage.default.dropInstance({ name: "datacore/cache/" + this.appId });
    this.persister = import_localforage.default.createInstance({
      name: "datacore/cache/" + this.appId,
      driver: [import_localforage.default.INDEXEDDB],
      description: "Cache metadata about files and sections in the datacore index."
    });
  }
  /** Load file metadata by path. */
  async loadFile(path) {
    return this.persister.getItem(this.fileKey(path)).then((raw) => {
      return raw;
    });
  }
  /** Store file metadata by path. */
  async storeFile(path, data) {
    await this.persister.setItem(this.fileKey(path), {
      version: this.version,
      time: Date.now(),
      data
    });
  }
  /** Drop old file keys that no longer exist. */
  async synchronize(existing) {
    let keys2 = new Set(await this.allFiles());
    for (let exist of existing) keys2.delete(exist);
    for (let key of keys2) await this.persister.removeItem(this.fileKey(key));
    return keys2;
  }
  /** Obtain a list of all metadata keys. */
  async allKeys() {
    return this.persister.keys();
  }
  /** Obtain a list of all persisted files. */
  async allFiles() {
    let keys2 = await this.allKeys();
    return keys2.filter((k4) => k4.startsWith("file:")).map((k4) => k4.substring(5));
  }
  /** Get a unique key for a given file path. */
  fileKey(path) {
    return "file:" + path;
  }
};

// inline-worker:__inline-worker
function inlineWorker(scriptText) {
  let blob = new Blob([scriptText], { type: "text/javascript" });
  let url = URL.createObjectURL(blob);
  let worker = new Worker(url, { "name": "Datacore Indexer" });
  URL.revokeObjectURL(url);
  return worker;
}

// src/index/web-worker/importer.worker.ts
function Worker2() {
  return inlineWorker('var cl=Object.create;var Js=Object.defineProperty,fl=Object.defineProperties,dl=Object.getOwnPropertyDescriptor,hl=Object.getOwnPropertyDescriptors,ml=Object.getOwnPropertyNames,qr=Object.getOwnPropertySymbols,pl=Object.getPrototypeOf,zs=Object.prototype.hasOwnProperty,Mo=Object.prototype.propertyIsEnumerable;var Hs=(n,e)=>(e=Symbol[n])?e:Symbol.for("Symbol."+n),Dl=n=>{throw TypeError(n)};var Ao=(n,e,t)=>e in n?Js(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,R=(n,e)=>{for(var t in e||(e={}))zs.call(e,t)&&Ao(n,t,e[t]);if(qr)for(var t of qr(e))Mo.call(e,t)&&Ao(n,t,e[t]);return n},De=(n,e)=>fl(n,hl(e));var Ys=(n,e)=>{var t={};for(var r in n)zs.call(n,r)&&e.indexOf(r)<0&&(t[r]=n[r]);if(n!=null&&qr)for(var r of qr(n))e.indexOf(r)<0&&Mo.call(n,r)&&(t[r]=n[r]);return t};var _o=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports);var yl=(n,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of ml(e))!zs.call(n,s)&&s!==t&&Js(n,s,{get:()=>e[s],enumerable:!(r=dl(e,s))||r.enumerable});return n};var Vr=(n,e,t)=>(t=n!=null?cl(pl(n)):{},yl(e||!n||!n.__esModule?Js(t,"default",{value:n,enumerable:!0}):t,n));var gl=function(n,e){this[0]=n,this[1]=e};var S=n=>{var e=n[Hs("asyncIterator")],t=!1,r,s={};return e==null?(e=n[Hs("iterator")](),r=i=>s[i]=o=>e[i](o)):(e=e.call(n),r=i=>s[i]=o=>{if(t){if(t=!1,i==="throw")throw o;return o}return t=!0,{done:!1,value:new gl(new Promise(a=>{var u=e[i](o);u instanceof Object||Dl("Object expected"),a(u)}),1)}}),s[Hs("iterator")]=()=>s,r("next"),"throw"in e?r("throw"):s.throw=i=>{throw i},"return"in e&&r("return"),s};var ns=_o((dr,Ai)=>{(function(n,e){typeof dr=="object"&&typeof Ai=="object"?Ai.exports=e():typeof define=="function"&&define.amd?define([],e):typeof dr=="object"?dr.Parsimmon=e():n.Parsimmon=e()})(typeof self!="undefined"?self:dr,function(){return function(n){var e={};function t(r){if(e[r])return e[r].exports;var s=e[r]={i:r,l:!1,exports:{}};return n[r].call(s.exports,s,s.exports,t),s.l=!0,s.exports}return t.m=n,t.c=e,t.d=function(r,s,i){t.o(r,s)||Object.defineProperty(r,s,{configurable:!1,enumerable:!0,get:i})},t.r=function(r){Object.defineProperty(r,"__esModule",{value:!0})},t.n=function(r){var s=r&&r.__esModule?function(){return r.default}:function(){return r};return t.d(s,"a",s),s},t.o=function(r,s){return Object.prototype.hasOwnProperty.call(r,s)},t.p="",t(t.s=0)}([function(n,e,t){"use strict";function r(c){if(!(this instanceof r))return new r(c);this._=c}var s=r.prototype;function i(c,p){for(var E=0;E<c;E++)p(E)}function o(c,p,E){return function(k,L){i(L.length,function(A){k(L[A],A,L)})}(function(k,L,A){p=c(p,k,L,A)},E),p}function a(c,p){return o(function(E,k,L,A){return E.concat([c(k,L,A)])},[],p)}function u(c,p){var E={v:0,buf:p};return i(c,function(){var k;E={v:E.v<<1|(k=E.buf,k[0]>>7),buf:function(L){var A=o(function(M,K,ee,Fe){return M.concat(ee===Fe.length-1?Buffer.from([K,0]).readUInt16BE(0):Fe.readUInt16BE(ee))},[],L);return Buffer.from(a(function(M){return(M<<1&65535)>>8},A))}(E.buf)}}),E}function l(){return typeof Buffer!="undefined"}function f(){if(!l())throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.")}function d(c){f();var p=o(function(A,M){return A+M},0,c);if(p%8!=0)throw new Error("The bits ["+c.join(", ")+"] add up to "+p+" which is not an even number of bytes; the total should be divisible by 8");var E,k=p/8,L=(E=function(A){return A>48},o(function(A,M){return A||(E(M)?M:A)},null,c));if(L)throw new Error(L+" bit range requested exceeds 48 bit (6 byte) Number max.");return new r(function(A,M){var K=k+M;return K>A.length?v(M,k.toString()+" bytes"):w(K,o(function(ee,Fe){var me=u(Fe,ee.buf);return{coll:ee.coll.concat(me.v),buf:me.buf}},{coll:[],buf:A.slice(M,K)},c).coll)})}function m(c,p){return new r(function(E,k){return f(),k+p>E.length?v(k,p+" bytes for "+c):w(k+p,E.slice(k,k+p))})}function h(c,p){if(typeof(E=p)!="number"||Math.floor(E)!==E||p<0||p>6)throw new Error(c+" requires integer length in range [0, 6].");var E}function b(c){return h("uintBE",c),m("uintBE("+c+")",c).map(function(p){return p.readUIntBE(0,c)})}function g(c){return h("uintLE",c),m("uintLE("+c+")",c).map(function(p){return p.readUIntLE(0,c)})}function D(c){return h("intBE",c),m("intBE("+c+")",c).map(function(p){return p.readIntBE(0,c)})}function T(c){return h("intLE",c),m("intLE("+c+")",c).map(function(p){return p.readIntLE(0,c)})}function I(c){return c instanceof r}function N(c){return{}.toString.call(c)==="[object Array]"}function y(c){return l()&&Buffer.isBuffer(c)}function w(c,p){return{status:!0,index:c,value:p,furthest:-1,expected:[]}}function v(c,p){return N(p)||(p=[p]),{status:!1,index:-1,value:null,furthest:c,expected:p}}function O(c,p){if(!p||c.furthest>p.furthest)return c;var E=c.furthest===p.furthest?function(k,L){if(function(){if(r._supportsSet!==void 0)return r._supportsSet;var ft=typeof Set!="undefined";return r._supportsSet=ft,ft}()&&Array.from){for(var A=new Set(k),M=0;M<L.length;M++)A.add(L[M]);var K=Array.from(A);return K.sort(),K}for(var ee={},Fe=0;Fe<k.length;Fe++)ee[k[Fe]]=!0;for(var me=0;me<L.length;me++)ee[L[me]]=!0;var ct=[];for(var Ce in ee)({}).hasOwnProperty.call(ee,Ce)&&ct.push(Ce);return ct.sort(),ct}(c.expected,p.expected):p.expected;return{status:c.status,index:c.index,value:c.value,furthest:p.furthest,expected:E}}var C={};function U(c,p){if(y(c))return{offset:p,line:-1,column:-1};c in C||(C[c]={});for(var E=C[c],k=0,L=0,A=0,M=p;M>=0;){if(M in E){k=E[M].line,A===0&&(A=E[M].lineStart);break}(c.charAt(M)===`\n`||c.charAt(M)==="\\r"&&c.charAt(M+1)!==`\n`)&&(L++,A===0&&(A=M+1)),M--}var K=k+L,ee=p-A;return E[p]={line:K,lineStart:A},{offset:p,line:K+1,column:ee+1}}function j(c){if(!I(c))throw new Error("not a parser: "+c)}function G(c,p){return typeof c=="string"?c.charAt(p):c[p]}function x(c){if(typeof c!="number")throw new Error("not a number: "+c)}function B(c){if(typeof c!="function")throw new Error("not a function: "+c)}function q(c){if(typeof c!="string")throw new Error("not a string: "+c)}var de=2,he=3,oe=8,Mr=5*oe,_r=4*oe,Gt="  ";function Nt(c,p){return new Array(p+1).join(c)}function At(c,p,E){var k=p-c.length;return k<=0?c:Nt(E,k)+c}function Ne(c,p,E,k){return{from:c-p>0?c-p:0,to:c+E>k?k:c+E}}function Mt(c,p){var E,k,L,A,M,K=p.index,ee=K.offset,Fe=1;if(ee===c.length)return"Got the end of the input";if(y(c)){var me=ee-ee%oe,ct=ee-me,Ce=Ne(me,Mr,_r+oe,c.length),ft=a(function(ae){return a(function(Qt){return At(Qt.toString(16),2,"0")},ae)},function(ae,Qt){var Xt=ae.length,Pt=[],en=0;if(Xt<=Qt)return[ae.slice()];for(var tn=0;tn<Xt;tn++)Pt[en]||Pt.push([]),Pt[en].push(ae[tn]),(tn+1)%Qt==0&&en++;return Pt}(c.slice(Ce.from,Ce.to).toJSON().data,oe));A=function(ae){return ae.from===0&&ae.to===1?{from:ae.from,to:ae.to}:{from:ae.from/oe,to:Math.floor(ae.to/oe)}}(Ce),k=me/oe,E=3*ct,ct>=4&&(E+=1),Fe=2,L=a(function(ae){return ae.length<=4?ae.join(" "):ae.slice(0,4).join(" ")+"  "+ae.slice(4).join(" ")},ft),(M=(8*(A.to>0?A.to-1:A.to)).toString(16).length)<2&&(M=2)}else{var Zt=c.split(/\\r\\n|[\\n\\r\\u2028\\u2029]/);E=K.column-1,k=K.line-1,A=Ne(k,de,he,Zt.length),L=Zt.slice(A.from,A.to),M=A.to.toString().length}var ll=k-A.from;return y(c)&&(M=(8*(A.to>0?A.to-1:A.to)).toString(16).length)<2&&(M=2),o(function(ae,Qt,Xt){var Pt,en=Xt===ll,tn=en?"> ":Gt;return Pt=y(c)?At((8*(A.from+Xt)).toString(16),M,"0"):At((A.from+Xt+1).toString(),M," "),[].concat(ae,[tn+Pt+" | "+Qt],en?[Gt+Nt(" ",M)+" | "+At("",E," ")+Nt("^",Fe)]:[])},[],L).join(`\n`)}function So(c,p){return[`\n`,"-- PARSING FAILED "+Nt("-",50),`\n\n`,Mt(c,p),`\n\n`,(E=p.expected,E.length===1?`Expected:\n\n`+E[0]:`Expected one of the following: \n\n`+E.join(", ")),`\n`].join("");var E}function ko(c){return c.flags!==void 0?c.flags:[c.global?"g":"",c.ignoreCase?"i":"",c.multiline?"m":"",c.unicode?"u":"",c.sticky?"y":""].join("")}function Br(){for(var c=[].slice.call(arguments),p=c.length,E=0;E<p;E+=1)j(c[E]);return r(function(k,L){for(var A,M=new Array(p),K=0;K<p;K+=1){if(!(A=O(c[K]._(k,L),A)).status)return A;M[K]=A.value,L=A.index}return O(w(L,M),A)})}function _t(){var c=[].slice.call(arguments);if(c.length===0)throw new Error("seqMap needs at least one argument");var p=c.pop();return B(p),Br.apply(null,c).map(function(E){return p.apply(null,E)})}function Pr(){var c=[].slice.call(arguments),p=c.length;if(p===0)return $r("zero alternates");for(var E=0;E<p;E+=1)j(c[E]);return r(function(k,L){for(var A,M=0;M<c.length;M+=1)if((A=O(c[M]._(k,L),A)).status)return A;return A})}function Co(c,p){return Us(c,p).or(Bt([]))}function Us(c,p){return j(c),j(p),_t(c,p.then(c).many(),function(E,k){return[E].concat(k)})}function Mn(c){q(c);var p="\'"+c+"\'";return r(function(E,k){var L=k+c.length,A=E.slice(k,L);return A===c?w(L,A):v(k,p)})}function lt(c,p){(function(L){if(!(L instanceof RegExp))throw new Error("not a regexp: "+L);for(var A=ko(L),M=0;M<A.length;M++){var K=A.charAt(M);if(K!=="i"&&K!=="m"&&K!=="u"&&K!=="s")throw new Error(\'unsupported regexp flag "\'+K+\'": \'+L)}})(c),arguments.length>=2?x(p):p=0;var E=function(L){return RegExp("^(?:"+L.source+")",ko(L))}(c),k=""+c;return r(function(L,A){var M=E.exec(L.slice(A));if(M){if(0<=p&&p<=M.length){var K=M[0],ee=M[p];return w(A+K.length,ee)}return v(A,"valid match group (0 to "+M.length+") in "+k)}return v(A,k)})}function Bt(c){return r(function(p,E){return w(E,c)})}function $r(c){return r(function(p,E){return v(E,c)})}function Rr(c){if(I(c))return r(function(p,E){var k=c._(p,E);return k.index=E,k.value="",k});if(typeof c=="string")return Rr(Mn(c));if(c instanceof RegExp)return Rr(lt(c));throw new Error("not a string, regexp, or parser: "+c)}function vo(c){return j(c),r(function(p,E){var k=c._(p,E),L=p.slice(E,k.index);return k.status?v(E,\'not "\'+L+\'"\'):w(E,null)})}function jr(c){return B(c),r(function(p,E){var k=G(p,E);return E<p.length&&c(k)?w(E+1,k):v(E,"a character/byte matching "+c)})}function Oo(c,p){arguments.length<2&&(p=c,c=void 0);var E=r(function(k,L){return E._=p()._,E._(k,L)});return c?E.desc(c):E}function Ks(){return $r("fantasy-land/empty")}s.parse=function(c){if(typeof c!="string"&&!y(c))throw new Error(".parse must be called with a string or Buffer as its argument");var p,E=this.skip(Ws)._(c,0);return p=E.status?{status:!0,value:E.value}:{status:!1,index:U(c,E.furthest),expected:E.expected},delete C[c],p},s.tryParse=function(c){var p=this.parse(c);if(p.status)return p.value;var E=So(c,p),k=new Error(E);throw k.type="ParsimmonError",k.result=p,k},s.assert=function(c,p){return this.chain(function(E){return c(E)?Bt(E):$r(p)})},s.or=function(c){return Pr(this,c)},s.trim=function(c){return this.wrap(c,c)},s.wrap=function(c,p){return _t(c,this,p,function(E,k){return k})},s.thru=function(c){return c(this)},s.then=function(c){return j(c),Br(this,c).map(function(p){return p[1]})},s.many=function(){var c=this;return r(function(p,E){for(var k=[],L=void 0;;){if(!(L=O(c._(p,E),L)).status)return O(w(E,k),L);if(E===L.index)throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");E=L.index,k.push(L.value)}})},s.tieWith=function(c){return q(c),this.map(function(p){if(function(L){if(!N(L))throw new Error("not an array: "+L)}(p),p.length){q(p[0]);for(var E=p[0],k=1;k<p.length;k++)q(p[k]),E+=c+p[k];return E}return""})},s.tie=function(){return this.tieWith("")},s.times=function(c,p){var E=this;return arguments.length<2&&(p=c),x(c),x(p),r(function(k,L){for(var A=[],M=void 0,K=void 0,ee=0;ee<c;ee+=1){if(K=O(M=E._(k,L),K),!M.status)return K;L=M.index,A.push(M.value)}for(;ee<p&&(K=O(M=E._(k,L),K),M.status);ee+=1)L=M.index,A.push(M.value);return O(w(L,A),K)})},s.result=function(c){return this.map(function(){return c})},s.atMost=function(c){return this.times(0,c)},s.atLeast=function(c){return _t(this.times(c),this.many(),function(p,E){return p.concat(E)})},s.map=function(c){B(c);var p=this;return r(function(E,k){var L=p._(E,k);return L.status?O(w(L.index,c(L.value)),L):L})},s.contramap=function(c){B(c);var p=this;return r(function(E,k){var L=p.parse(c(E.slice(k)));return L.status?w(k+E.length,L.value):L})},s.promap=function(c,p){return B(c),B(p),this.contramap(c).map(p)},s.skip=function(c){return Br(this,c).map(function(p){return p[0]})},s.mark=function(){return _t(_n,this,_n,function(c,p,E){return{start:c,value:p,end:E}})},s.node=function(c){return _t(_n,this,_n,function(p,E,k){return{name:c,value:E,start:p,end:k}})},s.sepBy=function(c){return Co(this,c)},s.sepBy1=function(c){return Us(this,c)},s.lookahead=function(c){return this.skip(Rr(c))},s.notFollowedBy=function(c){return this.skip(vo(c))},s.desc=function(c){N(c)||(c=[c]);var p=this;return r(function(E,k){var L=p._(E,k);return L.status||(L.expected=c),L})},s.fallback=function(c){return this.or(Bt(c))},s.ap=function(c){return _t(c,this,function(p,E){return p(E)})},s.chain=function(c){var p=this;return r(function(E,k){var L=p._(E,k);return L.status?O(c(L.value)._(E,L.index),L):L})},s.concat=s.or,s.empty=Ks,s.of=Bt,s["fantasy-land/ap"]=s.ap,s["fantasy-land/chain"]=s.chain,s["fantasy-land/concat"]=s.concat,s["fantasy-land/empty"]=s.empty,s["fantasy-land/of"]=s.of,s["fantasy-land/map"]=s.map;var _n=r(function(c,p){return w(p,U(c,p))}),el=r(function(c,p){return p>=c.length?v(p,"any character/byte"):w(p+1,G(c,p))}),tl=r(function(c,p){return w(c.length,c.slice(p))}),Ws=r(function(c,p){return p<c.length?v(p,"EOF"):w(p,null)}),nl=lt(/[0-9]/).desc("a digit"),rl=lt(/[0-9]*/).desc("optional digits"),sl=lt(/[a-z]/i).desc("a letter"),il=lt(/[a-z]*/i).desc("optional letters"),ol=lt(/\\s*/).desc("optional whitespace"),al=lt(/\\s+/).desc("whitespace"),xo=Mn("\\r"),Io=Mn(`\n`),Lo=Mn(`\\r\n`),No=Pr(Lo,Io,xo).desc("newline"),ul=Pr(No,Ws);r.all=tl,r.alt=Pr,r.any=el,r.cr=xo,r.createLanguage=function(c){var p={};for(var E in c)({}).hasOwnProperty.call(c,E)&&function(k){p[k]=Oo(function(){return c[k](p)})}(E);return p},r.crlf=Lo,r.custom=function(c){return r(c(w,v))},r.digit=nl,r.digits=rl,r.empty=Ks,r.end=ul,r.eof=Ws,r.fail=$r,r.formatError=So,r.index=_n,r.isParser=I,r.lazy=Oo,r.letter=sl,r.letters=il,r.lf=Io,r.lookahead=Rr,r.makeFailure=v,r.makeSuccess=w,r.newline=No,r.noneOf=function(c){return jr(function(p){return c.indexOf(p)<0}).desc("none of \'"+c+"\'")},r.notFollowedBy=vo,r.of=Bt,r.oneOf=function(c){for(var p=c.split(""),E=0;E<p.length;E++)p[E]="\'"+p[E]+"\'";return jr(function(k){return c.indexOf(k)>=0}).desc(p)},r.optWhitespace=ol,r.Parser=r,r.range=function(c,p){return jr(function(E){return c<=E&&E<=p}).desc(c+"-"+p)},r.regex=lt,r.regexp=lt,r.sepBy=Co,r.sepBy1=Us,r.seq=Br,r.seqMap=_t,r.seqObj=function(){for(var c,p={},E=0,k=(c=arguments,Array.prototype.slice.call(c)),L=k.length,A=0;A<L;A+=1){var M=k[A];if(!I(M)){if(N(M)&&M.length===2&&typeof M[0]=="string"&&I(M[1])){var K=M[0];if(Object.prototype.hasOwnProperty.call(p,K))throw new Error("seqObj: duplicate key "+K);p[K]=!0,E++;continue}throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.")}}if(E===0)throw new Error("seqObj expects at least one named parser, found zero");return r(function(ee,Fe){for(var me,ct={},Ce=0;Ce<L;Ce+=1){var ft,Zt;if(N(k[Ce])?(ft=k[Ce][0],Zt=k[Ce][1]):(ft=null,Zt=k[Ce]),!(me=O(Zt._(ee,Fe),me)).status)return me;ft&&(ct[ft]=me.value),Fe=me.index}return O(w(Fe,ct),me)})},r.string=Mn,r.succeed=Bt,r.takeWhile=function(c){return B(c),r(function(p,E){for(var k=E;k<p.length&&c(G(p,k));)k++;return w(k,p.slice(E,k))})},r.test=jr,r.whitespace=al,r["fantasy-land/empty"]=Ks,r["fantasy-land/of"]=Bt,r.Binary={bitSeq:d,bitSeqObj:function(c){f();var p={},E=0,k=a(function(A){if(N(A)){var M=A;if(M.length!==2)throw new Error("["+M.join(", ")+"] should be length 2, got length "+M.length);if(q(M[0]),x(M[1]),Object.prototype.hasOwnProperty.call(p,M[0]))throw new Error("duplicate key in bitSeqObj: "+M[0]);return p[M[0]]=!0,E++,M}return x(A),[null,A]},c);if(E<1)throw new Error("bitSeqObj expects at least one named pair, got ["+c.join(", ")+"]");var L=a(function(A){return A[0]},k);return d(a(function(A){return A[1]},k)).map(function(A){return o(function(M,K){return K[0]!==null&&(M[K[0]]=K[1]),M},{},a(function(M,K){return[M,A[K]]},L))})},byte:function(c){if(f(),x(c),c>255)throw new Error("Value specified to byte constructor ("+c+"=0x"+c.toString(16)+") is larger in value than a single byte.");var p=(c>15?"0x":"0x0")+c.toString(16);return r(function(E,k){var L=G(E,k);return L===c?w(k+1,L):v(k,p)})},buffer:function(c){return m("buffer",c).map(function(p){return Buffer.from(p)})},encodedString:function(c,p){return m("string",p).map(function(E){return E.toString(c)})},uintBE:b,uint8BE:b(1),uint16BE:b(2),uint32BE:b(4),uintLE:g,uint8LE:g(1),uint16LE:g(2),uint32LE:g(4),intBE:D,int8BE:D(1),int16BE:D(2),int32BE:D(4),intLE:T,int8LE:T(1),int16LE:T(2),int32LE:T(4),floatBE:m("floatBE",4).map(function(c){return c.readFloatBE(0)}),floatLE:m("floatLE",4).map(function(c){return c.readFloatLE(0)}),doubleBE:m("doubleBE",8).map(function(c){return c.readDoubleBE(0)}),doubleLE:m("doubleLE",8).map(function(c){return c.readDoubleLE(0)})},n.exports=r}])})});var Ru=_o(Le=>{"use strict";var Sf=Le&&Le.__extends||function(){var n=function(e,t){return n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(r,s){r.__proto__=s}||function(r,s){for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&(r[i]=s[i])},n(e,t)};return function(e,t){if(typeof t!="function"&&t!==null)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");n(e,t);function r(){this.constructor=e}e.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)}}();Object.defineProperty(Le,"__esModule",{value:!0});Le.EmptyBTree=Le.asSet=Le.simpleComparator=Le.defaultComparator=void 0;function Bu(n,e){if(Number.isFinite(n)&&Number.isFinite(e))return n-e;var t=typeof n,r=typeof e;if(t!==r)return t<r?-1:1;if(t==="object"){if(n===null)return e===null?0:-1;if(e===null)return 1;if(n=n.valueOf(),e=e.valueOf(),t=typeof n,r=typeof e,t!==r)return t<r?-1:1}return n<e?-1:n>e?1:n===e?0:Number.isNaN(n)?Number.isNaN(e)?0:-1:Number.isNaN(e)?1:Array.isArray(n)?0:Number.NaN}Le.defaultComparator=Bu;function kf(n,e){return n>e?1:n<e?-1:0}Le.simpleComparator=kf;var at=function(){function n(e,t,r){this._root=fo,this._size=0,this._maxNodeSize=r>=4?Math.min(r,256):32,this._compare=t||Bu,e&&this.setPairs(e)}return Object.defineProperty(n.prototype,"size",{get:function(){return this._size},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"length",{get:function(){return this._size},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"isEmpty",{get:function(){return this._size===0},enumerable:!1,configurable:!0}),n.prototype.clear=function(){this._root=fo,this._size=0},n.prototype.forEach=function(e,t){var r=this;return t!==void 0&&(e=e.bind(t)),this.forEachPair(function(s,i){return e(i,s,r)})},n.prototype.forEachPair=function(e,t){var r=this.minKey(),s=this.maxKey();return this.forRange(r,s,!0,e,t)},n.prototype.get=function(e,t){return this._root.get(e,t,this)},n.prototype.set=function(e,t,r){this._root.isShared&&(this._root=this._root.clone());var s=this._root.set(e,t,r,this);return s===!0||s===!1?s:(this._root=new vf([this._root,s]),!0)},n.prototype.has=function(e){return this.forRange(e,e,!0,void 0)!==0},n.prototype.delete=function(e){return this.editRange(e,e,!0,Mu)!==0},n.prototype.with=function(e,t,r){var s=this.clone();return s.set(e,t,r)||r?s:this},n.prototype.withPairs=function(e,t){var r=this.clone();return r.setPairs(e,t)!==0||t?r:this},n.prototype.withKeys=function(e,t){for(var r=this.clone(),s=!1,i=0;i<e.length;i++)s=r.set(e[i],void 0,!1)||s;return t&&!s?this:r},n.prototype.without=function(e,t){return this.withoutRange(e,e,!0,t)},n.prototype.withoutKeys=function(e,t){var r=this.clone();return r.deleteKeys(e)||!t?r:this},n.prototype.withoutRange=function(e,t,r,s){var i=this.clone();return i.deleteRange(e,t,r)===0&&s?this:i},n.prototype.filter=function(e,t){var r=this.greedyClone(),s;return r.editAll(function(i,o,a){if(!e(i,o,a))return s=$u}),!s&&t?this:r},n.prototype.mapValues=function(e){var t={},r=this.greedyClone();return r.editAll(function(s,i,o){return t.value=e(i,s,o),t}),r},n.prototype.reduce=function(e,t){for(var r=0,s=t,i=this.entries(this.minKey(),Nr),o;!(o=i.next()).done;)s=e(s,o.value,r++,this);return s},n.prototype.entries=function(e,t){var r=this.findPath(e);if(r===void 0)return Ln();var s=r.nodequeue,i=r.nodeindex,o=r.leaf,a=t!==void 0?1:0,u=e===void 0?-1:o.indexOf(e,0,this._compare)-1;return Ln(function(){e:for(;;)switch(a){case 0:if(++u<o.keys.length)return{done:!1,value:[o.keys[u],o.values[u]]};a=2;continue;case 1:if(++u<o.keys.length)return t[0]=o.keys[u],t[1]=o.values[u],{done:!1,value:t};a=2;case 2:for(var l=-1;;){if(++l>=s.length){a=3;continue e}if(++i[l]<s[l].length)break}for(;l>0;l--)s[l-1]=s[l][i[l]].children,i[l-1]=0;o=s[0][i[0]],u=-1,a=t!==void 0?1:0;continue;case 3:return{done:!0,value:void 0}}})},n.prototype.entriesReversed=function(e,t,r){if(e===void 0&&(e=this.maxKey(),r=void 0,e===void 0))return Ln();var s=this.findPath(e)||this.findPath(this.maxKey()),i=s.nodequeue,o=s.nodeindex,a=s.leaf;Ie(!i[0]||a===i[0][o[0]],"wat!");var u=a.indexOf(e,0,this._compare);!r&&u<a.keys.length&&this._compare(a.keys[u],e)<=0&&u++;var l=t!==void 0?1:0;return Ln(function(){e:for(;;)switch(l){case 0:if(--u>=0)return{done:!1,value:[a.keys[u],a.values[u]]};l=2;continue;case 1:if(--u>=0)return t[0]=a.keys[u],t[1]=a.values[u],{done:!1,value:t};l=2;case 2:for(var f=-1;;){if(++f>=i.length){l=3;continue e}if(--o[f]>=0)break}for(;f>0;f--)i[f-1]=i[f][o[f]].children,o[f-1]=i[f-1].length-1;a=i[0][o[0]],u=a.keys.length,l=t!==void 0?1:0;continue;case 3:return{done:!0,value:void 0}}})},n.prototype.findPath=function(e){var t=this._root,r,s;if(t.isLeaf)r=_u,s=_u;else{r=[],s=[];for(var i=0;!t.isLeaf;i++){if(r[i]=t.children,s[i]=e===void 0?0:t.indexOf(e,0,this._compare),s[i]>=r[i].length)return;t=r[i][s[i]]}r.reverse(),s.reverse()}return{nodequeue:r,nodeindex:s,leaf:t}},n.prototype.diffAgainst=function(e,t,r,s){if(e._compare!==this._compare)throw new Error("Tree comparators are not the same.");if(this.isEmpty||e.isEmpty)return this.isEmpty&&e.isEmpty?void 0:this.isEmpty?r===void 0?void 0:n.stepToEnd(n.makeDiffCursor(e),r):t===void 0?void 0:n.stepToEnd(n.makeDiffCursor(this),t);for(var i=this._compare,o=n.makeDiffCursor(this),a=n.makeDiffCursor(e),u=!0,l=!0,f=n.compare(o,a,i);u&&l;){var d=n.compare(o,a,i),m=o.leaf,h=o.internalSpine,b=o.levelIndices,g=a.leaf,D=a.internalSpine,T=a.levelIndices;if(m||g){if(f!==0){if(d===0){if(m&&g&&s){var I=m.values[b[b.length-1]],N=g.values[T[T.length-1]];if(!Object.is(I,N)){var y=s(o.currentKey,I,N);if(y&&y.break)return y.break}}}else if(d>0){if(g&&r){var w=g.values[T[T.length-1]],y=r(a.currentKey,w);if(y&&y.break)return y.break}}else if(t&&m&&f!==0){var I=m.values[b[b.length-1]],y=t(o.currentKey,I);if(y&&y.break)return y.break}}}else if(!m&&!g&&d===0){var v=h.length-1,O=D.length-1,C=h[v][b[v]],U=D[O][T[O]];if(U===C){f=0,u=n.step(o,!0),l=n.step(a,!0);continue}}f=d,d<0?u=n.step(o):l=n.step(a)}if(u&&t)return n.finishCursorWalk(o,a,i,t);if(l&&r)return n.finishCursorWalk(a,o,i,r)},n.finishCursorWalk=function(e,t,r,s){var i=n.compare(e,t,r);if(i===0){if(!n.step(e))return}else i<0&&Ie(!1,"cursor walk terminated early");return n.stepToEnd(e,s)},n.stepToEnd=function(e,t){for(var r=!0;r;){var s=e.leaf,i=e.levelIndices,o=e.currentKey;if(s){var a=s.values[i[i.length-1]],u=t(o,a);if(u&&u.break)return u.break}r=n.step(e)}},n.makeDiffCursor=function(e){var t=e._root,r=e.height;return{height:r,internalSpine:[[t]],levelIndices:[0],leaf:void 0,currentKey:t.maxKey()}},n.step=function(e,t){var r=e.internalSpine,s=e.levelIndices,i=e.leaf;if(t===!0||i){var o=s.length;if(t===!0||s[o-1]===0){var a=r.length;if(a===0)return!1;for(var u=a-1,l=u;l>=0;){if(s[l]>0)return l<o-1&&(e.leaf=void 0,s.pop()),l<u&&(e.internalSpine=r.slice(0,l+1)),e.currentKey=r[l][--s[l]].maxKey(),!0;l--}return!1}else{var f=--s[o-1];return e.currentKey=i.keys[f],!0}}else{var d=r.length,m=d-1,h=r[m][s[m]];if(h.isLeaf){e.leaf=h;var f=s[d]=h.values.length-1;e.currentKey=h.keys[f]}else{var b=h.children;r[d]=b;var g=b.length-1;s[d]=g,e.currentKey=b[g].maxKey()}return!0}},n.compare=function(e,t,r){var s=e.height,i=e.currentKey,o=e.levelIndices,a=t.height,u=t.currentKey,l=t.levelIndices,f=r(u,i);if(f!==0)return f;var d=s<a?s:a,m=o.length-(s-d),h=l.length-(a-d);return m-h},n.prototype.keys=function(e){var t=this.entries(e,Nr);return Ln(function(){var r=t.next();return r.value&&(r.value=r.value[0]),r})},n.prototype.values=function(e){var t=this.entries(e,Nr);return Ln(function(){var r=t.next();return r.value&&(r.value=r.value[1]),r})},Object.defineProperty(n.prototype,"maxNodeSize",{get:function(){return this._maxNodeSize},enumerable:!1,configurable:!0}),n.prototype.minKey=function(){return this._root.minKey()},n.prototype.maxKey=function(){return this._root.maxKey()},n.prototype.clone=function(){this._root.isShared=!0;var e=new n(void 0,this._compare,this._maxNodeSize);return e._root=this._root,e._size=this._size,e},n.prototype.greedyClone=function(e){var t=new n(void 0,this._compare,this._maxNodeSize);return t._root=this._root.greedyClone(e),t._size=this._size,t},n.prototype.toArray=function(e){e===void 0&&(e=2147483647);var t=this.minKey(),r=this.maxKey();return t!==void 0?this.getRange(t,r,!0,e):[]},n.prototype.keysArray=function(){var e=[];return this._root.forRange(this.minKey(),this.maxKey(),!0,!1,this,0,function(t,r){e.push(t)}),e},n.prototype.valuesArray=function(){var e=[];return this._root.forRange(this.minKey(),this.maxKey(),!0,!1,this,0,function(t,r){e.push(r)}),e},n.prototype.toString=function(){return this.toArray().toString()},n.prototype.setIfNotPresent=function(e,t){return this.set(e,t,!1)},n.prototype.nextHigherPair=function(e,t){return t=t||[],e===void 0?this._root.minPair(t):this._root.getPairOrNextHigher(e,this._compare,!1,t)},n.prototype.nextHigherKey=function(e){var t=this.nextHigherPair(e,Nr);return t&&t[0]},n.prototype.nextLowerPair=function(e,t){return t=t||[],e===void 0?this._root.maxPair(t):this._root.getPairOrNextLower(e,this._compare,!1,t)},n.prototype.nextLowerKey=function(e){var t=this.nextLowerPair(e,Nr);return t&&t[0]},n.prototype.getPairOrNextLower=function(e,t){return this._root.getPairOrNextLower(e,this._compare,!0,t||[])},n.prototype.getPairOrNextHigher=function(e,t){return this._root.getPairOrNextHigher(e,this._compare,!0,t||[])},n.prototype.changeIfPresent=function(e,t){return this.editRange(e,e,!0,function(r,s){return{value:t}})!==0},n.prototype.getRange=function(e,t,r,s){s===void 0&&(s=67108863);var i=[];return this._root.forRange(e,t,r,!1,this,0,function(o,a){return i.push([o,a]),i.length>s?Of:void 0}),i},n.prototype.setPairs=function(e,t){for(var r=0,s=0;s<e.length;s++)this.set(e[s][0],e[s][1],t)&&r++;return r},n.prototype.forRange=function(e,t,r,s,i){var o=this._root.forRange(e,t,r,!1,this,i||0,s);return typeof o=="number"?o:o.break},n.prototype.editRange=function(e,t,r,s,i){var o=this._root;o.isShared&&(this._root=o=o.clone());try{var a=o.forRange(e,t,r,!0,this,i||0,s);return typeof a=="number"?a:a.break}finally{for(var u=void 0;o.keys.length<=1&&!o.isLeaf;)u||(u=o.isShared),this._root=o=o.keys.length===0?fo:o.children[0];u&&(o.isShared=!0)}},n.prototype.editAll=function(e,t){return this.editRange(this.minKey(),this.maxKey(),!0,e,t)},n.prototype.deleteRange=function(e,t,r){return this.editRange(e,t,r,Mu)},n.prototype.deleteKeys=function(e){for(var t=0,r=0;t<e.length;t++)this.delete(e[t])&&r++;return r},Object.defineProperty(n.prototype,"height",{get:function(){for(var e=this._root,t=-1;e;)t++,e=e.isLeaf?void 0:e.children[0];return t},enumerable:!1,configurable:!0}),n.prototype.freeze=function(){var e=this;e.clear=e.set=e.editRange=function(){throw new Error("Attempted to modify a frozen BTree")}},n.prototype.unfreeze=function(){delete this.clear,delete this.set,delete this.editRange},Object.defineProperty(n.prototype,"isFrozen",{get:function(){return this.hasOwnProperty("editRange")},enumerable:!1,configurable:!0}),n.prototype.checkValid=function(){var e=this._root.checkValid(0,this,0);Ie(e===this.size,"size mismatch: counted ",e,"but stored",this.size)},n}();Le.default=at;function Cf(n){return n}Le.asSet=Cf;Symbol&&Symbol.iterator&&(at.prototype[Symbol.iterator]=at.prototype.entries);at.prototype.where=at.prototype.filter;at.prototype.setRange=at.prototype.setPairs;at.prototype.add=at.prototype.set;function Ln(n){n===void 0&&(n=function(){return{done:!0,value:void 0}});var e={next:n};return Symbol&&Symbol.iterator&&(e[Symbol.iterator]=function(){return this}),e}var Pu=function(){function n(e,t){e===void 0&&(e=[]),this.keys=e,this.values=t||pe,this.isShared=void 0}return Object.defineProperty(n.prototype,"isLeaf",{get:function(){return this.children===void 0},enumerable:!1,configurable:!0}),n.prototype.maxKey=function(){return this.keys[this.keys.length-1]},n.prototype.indexOf=function(e,t,r){for(var s=this.keys,i=0,o=s.length,a=o>>1;i<o;){var u=r(s[a],e);if(u<0)i=a+1;else if(u>0)o=a;else{if(u===0)return a;if(e===e)return s.length;throw new Error("BTree: NaN was used as a key")}a=i+o>>1}return a^t},n.prototype.minKey=function(){return this.keys[0]},n.prototype.minPair=function(e){if(this.keys.length!==0)return e[0]=this.keys[0],e[1]=this.values[0],e},n.prototype.maxPair=function(e){if(this.keys.length!==0){var t=this.keys.length-1;return e[0]=this.keys[t],e[1]=this.values[t],e}},n.prototype.clone=function(){var e=this.values;return new n(this.keys.slice(0),e===pe?e:e.slice(0))},n.prototype.greedyClone=function(e){return this.isShared&&!e?this:this.clone()},n.prototype.get=function(e,t,r){var s=this.indexOf(e,-1,r._compare);return s<0?t:this.values[s]},n.prototype.getPairOrNextLower=function(e,t,r,s){var i=this.indexOf(e,-1,t),o=i<0?~i-1:r?i:i-1;if(o>=0)return s[0]=this.keys[o],s[1]=this.values[o],s},n.prototype.getPairOrNextHigher=function(e,t,r,s){var i=this.indexOf(e,-1,t),o=i<0?~i:r?i:i+1,a=this.keys;if(o<a.length)return s[0]=a[o],s[1]=this.values[o],s},n.prototype.checkValid=function(e,t,r){var s=this.keys.length,i=this.values.length;return Ie(this.values===pe?s<=i:s===i,"keys/values length mismatch: depth",e,"with lengths",s,i,"and baseIndex",r),Ie(e==0||s>0,"empty leaf at depth",e,"and baseIndex",r),s},n.prototype.set=function(e,t,r,s){var i=this.indexOf(e,-1,s._compare);if(i<0){if(i=~i,s._size++,this.keys.length<s._maxNodeSize)return this.insertInLeaf(i,e,t,s);var o=this.splitOffRightSide(),a=this;return i>this.keys.length&&(i-=this.keys.length,a=o),a.insertInLeaf(i,e,t,s),o}else return r!==!1&&(t!==void 0&&this.reifyValues(),this.keys[i]=e,this.values[i]=t),!1},n.prototype.reifyValues=function(){return this.values===pe?this.values=this.values.slice(0,this.keys.length):this.values},n.prototype.insertInLeaf=function(e,t,r,s){if(this.keys.splice(e,0,t),this.values===pe){for(;pe.length<s._maxNodeSize;)pe.push(void 0);if(r===void 0)return!0;this.values=pe.slice(0,this.keys.length-1)}return this.values.splice(e,0,r),!0},n.prototype.takeFromRight=function(e){var t=this.values;e.values===pe?t!==pe&&t.push(void 0):(t=this.reifyValues(),t.push(e.values.shift())),this.keys.push(e.keys.shift())},n.prototype.takeFromLeft=function(e){var t=this.values;e.values===pe?t!==pe&&t.unshift(void 0):(t=this.reifyValues(),t.unshift(e.values.pop())),this.keys.unshift(e.keys.pop())},n.prototype.splitOffRightSide=function(){var e=this.keys.length>>1,t=this.keys.splice(e),r=this.values===pe?pe:this.values.splice(e);return new n(t,r)},n.prototype.forRange=function(e,t,r,s,i,o,a){var u=i._compare,l,f;if(t===e){if(!r||(f=(l=this.indexOf(e,-1,u))+1,l<0))return o}else l=this.indexOf(e,0,u),f=this.indexOf(t,-1,u),f<0?f=~f:r===!0&&f++;var d=this.keys,m=this.values;if(a!==void 0)for(var h=l;h<f;h++){var b=d[h],g=a(b,m[h],o++);if(g!==void 0){if(s===!0){if(b!==d[h]||this.isShared===!0)throw new Error("BTree illegally changed or cloned in editRange");g.delete?(this.keys.splice(h,1),this.values!==pe&&this.values.splice(h,1),i._size--,h--,f--):g.hasOwnProperty("value")&&(m[h]=g.value)}if(g.break!==void 0)return g}}else o+=f-l;return o},n.prototype.mergeSibling=function(e,t){if(this.keys.push.apply(this.keys,e.keys),this.values===pe){if(e.values===pe)return;this.values=this.values.slice(0,this.keys.length)}this.values.push.apply(this.values,e.reifyValues())},n}(),vf=function(n){Sf(e,n);function e(t,r){var s=this;if(!r){r=[];for(var i=0;i<t.length;i++)r[i]=t[i].maxKey()}return s=n.call(this,r)||this,s.children=t,s}return e.prototype.clone=function(){for(var t=this.children.slice(0),r=0;r<t.length;r++)t[r].isShared=!0;return new e(t,this.keys.slice(0))},e.prototype.greedyClone=function(t){if(this.isShared&&!t)return this;for(var r=new e(this.children.slice(0),this.keys.slice(0)),s=0;s<r.children.length;s++)r.children[s]=r.children[s].greedyClone(t);return r},e.prototype.minKey=function(){return this.children[0].minKey()},e.prototype.minPair=function(t){return this.children[0].minPair(t)},e.prototype.maxPair=function(t){return this.children[this.children.length-1].maxPair(t)},e.prototype.get=function(t,r,s){var i=this.indexOf(t,0,s._compare),o=this.children;return i<o.length?o[i].get(t,r,s):void 0},e.prototype.getPairOrNextLower=function(t,r,s,i){var o=this.indexOf(t,0,r),a=this.children;if(o>=a.length)return this.maxPair(i);var u=a[o].getPairOrNextLower(t,r,s,i);return u===void 0&&o>0?a[o-1].maxPair(i):u},e.prototype.getPairOrNextHigher=function(t,r,s,i){var o=this.indexOf(t,0,r),a=this.children,u=a.length;if(!(o>=u)){var l=a[o].getPairOrNextHigher(t,r,s,i);return l===void 0&&o<u-1?a[o+1].minPair(i):l}},e.prototype.checkValid=function(t,r,s){var i=this.keys.length,o=this.children.length;Ie(i===o,"keys/children length mismatch: depth",t,"lengths",i,o,"baseIndex",s),Ie(i>1||t>0,"internal node has length",i,"at depth",t,"baseIndex",s);for(var a=0,u=this.children,l=this.keys,f=0,d=0;d<o;d++)a+=u[d].checkValid(t+1,r,s+a),f+=u[d].keys.length,Ie(a>=f,"wtf",s),Ie(d===0||u[d-1].constructor===u[d].constructor,"type mismatch, baseIndex:",s),u[d].maxKey()!=l[d]&&Ie(!1,"keys[",d,"] =",l[d],"is wrong, should be ",u[d].maxKey(),"at depth",t,"baseIndex",s),d===0||r._compare(l[d-1],l[d])<0||Ie(!1,"sort violation at depth",t,"index",d,"keys",l[d-1],l[d]);var m=f===0;return(m||f>r.maxNodeSize*o)&&Ie(!1,m?"too few":"too many","children (",f,a,") at depth",t,"maxNodeSize:",r.maxNodeSize,"children.length:",o,"baseIndex:",s),a},e.prototype.set=function(t,r,s,i){var o=this.children,a=i._maxNodeSize,u=i._compare,l=Math.min(this.indexOf(t,0,u),o.length-1),f=o[l];if(f.isShared&&(o[l]=f=f.clone()),f.keys.length>=a){var d;l>0&&(d=o[l-1]).keys.length<a&&u(f.keys[0],t)<0?(d.isShared&&(o[l-1]=d=d.clone()),d.takeFromRight(f),this.keys[l-1]=d.maxKey()):(d=o[l+1])!==void 0&&d.keys.length<a&&u(f.maxKey(),t)<0&&(d.isShared&&(o[l+1]=d=d.clone()),d.takeFromLeft(f),this.keys[l]=o[l].maxKey())}var m=f.set(t,r,s,i);if(m===!1)return!1;if(this.keys[l]=f.maxKey(),m===!0)return!0;if(this.keys.length<a)return this.insert(l+1,m),!0;var h=this.splitOffRightSide(),b=this;return u(m.maxKey(),this.maxKey())>0&&(b=h,l-=this.keys.length),b.insert(l+1,m),h},e.prototype.insert=function(t,r){this.children.splice(t,0,r),this.keys.splice(t,0,r.maxKey())},e.prototype.splitOffRightSide=function(){var t=this.children.length>>1;return new e(this.children.splice(t),this.keys.splice(t))},e.prototype.takeFromRight=function(t){this.keys.push(t.keys.shift()),this.children.push(t.children.shift())},e.prototype.takeFromLeft=function(t){this.keys.unshift(t.keys.pop()),this.children.unshift(t.children.pop())},e.prototype.forRange=function(t,r,s,i,o,a,u){var l=o._compare,f=this.keys,d=this.children,m=this.indexOf(t,0,l),h=m,b=Math.min(r===t?m:this.indexOf(r,0,l),f.length-1);if(i){if(h<=b)try{for(;h<=b;h++){d[h].isShared&&(d[h]=d[h].clone());var g=d[h].forRange(t,r,s,i,o,a,u);if(f[h]=d[h].maxKey(),typeof g!="number")return g;a=g}}finally{var D=o._maxNodeSize>>1;for(m>0&&m--,h=b;h>=m;h--)d[h].keys.length<=D&&(d[h].keys.length!==0?this.tryMerge(h,o._maxNodeSize):(f.splice(h,1),d.splice(h,1)));d.length!==0&&d[0].keys.length===0&&Ie(!1,"emptiness bug")}}else for(;h<=b;h++){var g=d[h].forRange(t,r,s,i,o,a,u);if(typeof g!="number")return g;a=g}return a},e.prototype.tryMerge=function(t,r){var s=this.children;return t>=0&&t+1<s.length&&s[t].keys.length+s[t+1].keys.length<=r?(s[t].isShared&&(s[t]=s[t].clone()),s[t].mergeSibling(s[t+1],r),s.splice(t+1,1),this.keys.splice(t+1,1),this.keys[t]=s[t].maxKey(),!0):!1},e.prototype.mergeSibling=function(t,r){var s=this.keys.length;this.keys.push.apply(this.keys,t.keys);var i=t.children;if(this.children.push.apply(this.children,i),t.isShared&&!this.isShared)for(var o=0;o<i.length;o++)i[o].isShared=!0;this.tryMerge(s-1,r)},e}(Pu),pe=[],$u={delete:!0},Mu=function(){return $u},Of={break:!0},fo=function(){var n=new Pu;return n.isShared=!0,n}(),_u=[],Nr=[];function Ie(n){for(var e=[],t=1;t<arguments.length;t++)e[t-1]=arguments[t];if(!n)throw e.unshift("B+ tree"),new Error(e.join(" "))}Le.EmptyBTree=function(){var n=new at;return n.freeze(),n}()});var dt=class extends Error{},Ur=class extends dt{constructor(e){super(`Invalid DateTime: ${e.toMessage()}`)}},Kr=class extends dt{constructor(e){super(`Invalid Interval: ${e.toMessage()}`)}},Wr=class extends dt{constructor(e){super(`Invalid Duration: ${e.toMessage()}`)}},ht=class extends dt{},nn=class extends dt{constructor(e){super(`Invalid unit ${e}`)}},le=class extends dt{},$e=class extends dt{constructor(){super("Zone is an abstract class")}};var _="numeric",Re="short",ve="long",rn={year:_,month:_,day:_},Bn={year:_,month:Re,day:_},Gs={year:_,month:Re,day:_,weekday:Re},Pn={year:_,month:ve,day:_},$n={year:_,month:ve,day:_,weekday:ve},Rn={hour:_,minute:_},jn={hour:_,minute:_,second:_},qn={hour:_,minute:_,second:_,timeZoneName:Re},Vn={hour:_,minute:_,second:_,timeZoneName:ve},Un={hour:_,minute:_,hourCycle:"h23"},Kn={hour:_,minute:_,second:_,hourCycle:"h23"},Wn={hour:_,minute:_,second:_,hourCycle:"h23",timeZoneName:Re},Hn={hour:_,minute:_,second:_,hourCycle:"h23",timeZoneName:ve},Jn={year:_,month:_,day:_,hour:_,minute:_},zn={year:_,month:_,day:_,hour:_,minute:_,second:_},Yn={year:_,month:Re,day:_,hour:_,minute:_},Gn={year:_,month:Re,day:_,hour:_,minute:_,second:_},Zs={year:_,month:Re,day:_,weekday:Re,hour:_,minute:_},Zn={year:_,month:ve,day:_,hour:_,minute:_,timeZoneName:Re},Qn={year:_,month:ve,day:_,hour:_,minute:_,second:_,timeZoneName:Re},Xn={year:_,month:ve,day:_,weekday:ve,hour:_,minute:_,timeZoneName:ve},er={year:_,month:ve,day:_,weekday:ve,hour:_,minute:_,second:_,timeZoneName:ve};function H(n){return typeof n=="undefined"}function Xe(n){return typeof n=="number"}function tr(n){return typeof n=="number"&&n%1===0}function Bo(n){return typeof n=="string"}function Po(n){return Object.prototype.toString.call(n)==="[object Date]"}function Hr(){try{return typeof Intl!="undefined"&&!!Intl.RelativeTimeFormat}catch(n){return!1}}function $o(n){return Array.isArray(n)?n:[n]}function Xs(n,e,t){if(n.length!==0)return n.reduce((r,s)=>{let i=[e(s),s];return r&&t(r[0],i[0])===r[0]?r:i},null)[1]}function Ro(n,e){return e.reduce((t,r)=>(t[r]=n[r],t),{})}function Tt(n,e){return Object.prototype.hasOwnProperty.call(n,e)}function et(n,e,t){return tr(n)&&n>=e&&n<=t}function bl(n,e){return n-e*Math.floor(n/e)}function ne(n,e=2){let t=n<0,r;return t?r="-"+(""+-n).padStart(e,"0"):r=(""+n).padStart(e,"0"),r}function mt(n){if(!(H(n)||n===null||n===""))return parseInt(n,10)}function St(n){if(!(H(n)||n===null||n===""))return parseFloat(n)}function nr(n){if(!(H(n)||n===null||n==="")){let e=parseFloat("0."+n)*1e3;return Math.floor(e)}}function sn(n,e,t=!1){let r=10**e;return(t?Math.trunc:Math.round)(n*r)/r}function $t(n){return n%4===0&&(n%100!==0||n%400===0)}function Rt(n){return $t(n)?366:365}function on(n,e){let t=bl(e-1,12)+1,r=n+(e-t)/12;return t===2?$t(r)?29:28:[31,null,31,30,31,30,31,31,30,31,30,31][t-1]}function rr(n){let e=Date.UTC(n.year,n.month-1,n.day,n.hour,n.minute,n.second,n.millisecond);return n.year<100&&n.year>=0&&(e=new Date(e),e.setUTCFullYear(e.getUTCFullYear()-1900)),+e}function an(n){let e=(n+Math.floor(n/4)-Math.floor(n/100)+Math.floor(n/400))%7,t=n-1,r=(t+Math.floor(t/4)-Math.floor(t/100)+Math.floor(t/400))%7;return e===4||r===3?53:52}function sr(n){return n>99?n:n>60?1900+n:2e3+n}function Jr(n,e,t,r=null){let s=new Date(n),i={hourCycle:"h23",year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit"};r&&(i.timeZone=r);let o=R({timeZoneName:e},i),a=new Intl.DateTimeFormat(t,o).formatToParts(s).find(u=>u.type.toLowerCase()==="timezonename");return a?a.value:null}function jt(n,e){let t=parseInt(n,10);Number.isNaN(t)&&(t=0);let r=parseInt(e,10)||0,s=t<0||Object.is(t,-0)?-r:r;return t*60+s}function ei(n){let e=Number(n);if(typeof n=="boolean"||n===""||Number.isNaN(e))throw new le(`Invalid unit value ${n}`);return e}function un(n,e){let t={};for(let r in n)if(Tt(n,r)){let s=n[r];if(s==null)continue;t[e(r)]=ei(s)}return t}function kt(n,e){let t=Math.trunc(Math.abs(n/60)),r=Math.trunc(Math.abs(n%60)),s=n>=0?"+":"-";switch(e){case"short":return`${s}${ne(t,2)}:${ne(r,2)}`;case"narrow":return`${s}${t}${r>0?`:${r}`:""}`;case"techie":return`${s}${ne(t,2)}${ne(r,2)}`;default:throw new RangeError(`Value format ${e} is out of range for property format`)}}function ir(n){return Ro(n,["hour","minute","second","millisecond"])}var ti=/[A-Za-z_+-]{1,256}(?::?\\/[A-Za-z0-9_+-]{1,256}(?:\\/[A-Za-z0-9_+-]{1,256})?)?/;var Fl=["January","February","March","April","May","June","July","August","September","October","November","December"],ni=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],El=["J","F","M","A","M","J","J","A","S","O","N","D"];function ri(n){switch(n){case"narrow":return[...El];case"short":return[...ni];case"long":return[...Fl];case"numeric":return["1","2","3","4","5","6","7","8","9","10","11","12"];case"2-digit":return["01","02","03","04","05","06","07","08","09","10","11","12"];default:return null}}var si=["Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"],ii=["Mon","Tue","Wed","Thu","Fri","Sat","Sun"],wl=["M","T","W","T","F","S","S"];function oi(n){switch(n){case"narrow":return[...wl];case"short":return[...ii];case"long":return[...si];case"numeric":return["1","2","3","4","5","6","7"];default:return null}}var ai=["AM","PM"],Tl=["Before Christ","Anno Domini"],Sl=["BC","AD"],kl=["B","A"];function ui(n){switch(n){case"narrow":return[...kl];case"short":return[...Sl];case"long":return[...Tl];default:return null}}function jo(n){return ai[n.hour<12?0:1]}function qo(n,e){return oi(e)[n.weekday-1]}function Vo(n,e){return ri(e)[n.month-1]}function Uo(n,e){return ui(e)[n.year<0?0:1]}function Ko(n,e,t="always",r=!1){let s={years:["year","yr."],quarters:["quarter","qtr."],months:["month","mo."],weeks:["week","wk."],days:["day","day","days"],hours:["hour","hr."],minutes:["minute","min."],seconds:["second","sec."]},i=["hours","minutes","seconds"].indexOf(n)===-1;if(t==="auto"&&i){let d=n==="days";switch(e){case 1:return d?"tomorrow":`next ${s[n][0]}`;case-1:return d?"yesterday":`last ${s[n][0]}`;case 0:return d?"today":`this ${s[n][0]}`;default:}}let o=Object.is(e,-0)||e<0,a=Math.abs(e),u=a===1,l=s[n],f=r?u?l[1]:l[2]||l[1]:u?s[n][0]:n;return o?`${a} ${f} ago`:`in ${a} ${f}`}function Wo(n,e){let t="";for(let r of n)r.literal?t+=r.val:t+=e(r.val);return t}var Cl={D:rn,DD:Bn,DDD:Pn,DDDD:$n,t:Rn,tt:jn,ttt:qn,tttt:Vn,T:Un,TT:Kn,TTT:Wn,TTTT:Hn,f:Jn,ff:Yn,fff:Zn,ffff:Xn,F:zn,FF:Gn,FFF:Qn,FFFF:er},Ee=class n{static create(e,t={}){return new n(e,t)}static parseFormat(e){let t=null,r="",s=!1,i=[];for(let o=0;o<e.length;o++){let a=e.charAt(o);a==="\'"?(r.length>0&&i.push({literal:s,val:r}),t=null,r="",s=!s):s||a===t?r+=a:(r.length>0&&i.push({literal:!1,val:r}),r=a,t=a)}return r.length>0&&i.push({literal:s,val:r}),i}static macroTokenToFormatOpts(e){return Cl[e]}constructor(e,t){this.opts=t,this.loc=e,this.systemLoc=null}formatWithSystemDefault(e,t){return this.systemLoc===null&&(this.systemLoc=this.loc.redefaultToSystem()),this.systemLoc.dtFormatter(e,R(R({},this.opts),t)).format()}formatDateTime(e,t={}){return this.loc.dtFormatter(e,R(R({},this.opts),t)).format()}formatDateTimeParts(e,t={}){return this.loc.dtFormatter(e,R(R({},this.opts),t)).formatToParts()}resolvedOptions(e,t={}){return this.loc.dtFormatter(e,R(R({},this.opts),t)).resolvedOptions()}num(e,t=0){if(this.opts.forceSimple)return ne(e,t);let r=R({},this.opts);return t>0&&(r.padTo=t),this.loc.numberFormatter(r).format(e)}formatDateTimeFromString(e,t){let r=this.loc.listingMode()==="en",s=this.loc.outputCalendar&&this.loc.outputCalendar!=="gregory",i=(h,b)=>this.loc.extract(e,h,b),o=h=>e.isOffsetFixed&&e.offset===0&&h.allowZ?"Z":e.isValid?e.zone.formatOffset(e.ts,h.format):"",a=()=>r?jo(e):i({hour:"numeric",hourCycle:"h12"},"dayperiod"),u=(h,b)=>r?Vo(e,h):i(b?{month:h}:{month:h,day:"numeric"},"month"),l=(h,b)=>r?qo(e,h):i(b?{weekday:h}:{weekday:h,month:"long",day:"numeric"},"weekday"),f=h=>{let b=n.macroTokenToFormatOpts(h);return b?this.formatWithSystemDefault(e,b):h},d=h=>r?Uo(e,h):i({era:h},"era"),m=h=>{switch(h){case"S":return this.num(e.millisecond);case"u":case"SSS":return this.num(e.millisecond,3);case"s":return this.num(e.second);case"ss":return this.num(e.second,2);case"uu":return this.num(Math.floor(e.millisecond/10),2);case"uuu":return this.num(Math.floor(e.millisecond/100));case"m":return this.num(e.minute);case"mm":return this.num(e.minute,2);case"h":return this.num(e.hour%12===0?12:e.hour%12);case"hh":return this.num(e.hour%12===0?12:e.hour%12,2);case"H":return this.num(e.hour);case"HH":return this.num(e.hour,2);case"Z":return o({format:"narrow",allowZ:this.opts.allowZ});case"ZZ":return o({format:"short",allowZ:this.opts.allowZ});case"ZZZ":return o({format:"techie",allowZ:this.opts.allowZ});case"ZZZZ":return e.zone.offsetName(e.ts,{format:"short",locale:this.loc.locale});case"ZZZZZ":return e.zone.offsetName(e.ts,{format:"long",locale:this.loc.locale});case"z":return e.zoneName;case"a":return a();case"d":return s?i({day:"numeric"},"day"):this.num(e.day);case"dd":return s?i({day:"2-digit"},"day"):this.num(e.day,2);case"c":return this.num(e.weekday);case"ccc":return l("short",!0);case"cccc":return l("long",!0);case"ccccc":return l("narrow",!0);case"E":return this.num(e.weekday);case"EEE":return l("short",!1);case"EEEE":return l("long",!1);case"EEEEE":return l("narrow",!1);case"L":return s?i({month:"numeric",day:"numeric"},"month"):this.num(e.month);case"LL":return s?i({month:"2-digit",day:"numeric"},"month"):this.num(e.month,2);case"LLL":return u("short",!0);case"LLLL":return u("long",!0);case"LLLLL":return u("narrow",!0);case"M":return s?i({month:"numeric"},"month"):this.num(e.month);case"MM":return s?i({month:"2-digit"},"month"):this.num(e.month,2);case"MMM":return u("short",!1);case"MMMM":return u("long",!1);case"MMMMM":return u("narrow",!1);case"y":return s?i({year:"numeric"},"year"):this.num(e.year);case"yy":return s?i({year:"2-digit"},"year"):this.num(e.year.toString().slice(-2),2);case"yyyy":return s?i({year:"numeric"},"year"):this.num(e.year,4);case"yyyyyy":return s?i({year:"numeric"},"year"):this.num(e.year,6);case"G":return d("short");case"GG":return d("long");case"GGGGG":return d("narrow");case"kk":return this.num(e.weekYear.toString().slice(-2),2);case"kkkk":return this.num(e.weekYear,4);case"W":return this.num(e.weekNumber);case"WW":return this.num(e.weekNumber,2);case"o":return this.num(e.ordinal);case"ooo":return this.num(e.ordinal,3);case"q":return this.num(e.quarter);case"qq":return this.num(e.quarter,2);case"X":return this.num(Math.floor(e.ts/1e3));case"x":return this.num(e.ts);default:return f(h)}};return Wo(n.parseFormat(t),m)}formatDurationFromString(e,t){let r=u=>{switch(u[0]){case"S":return"millisecond";case"s":return"second";case"m":return"minute";case"h":return"hour";case"d":return"day";case"w":return"week";case"M":return"month";case"y":return"year";default:return null}},s=u=>l=>{let f=r(l);return f?this.num(u.get(f),l.length):l},i=n.parseFormat(t),o=i.reduce((u,{literal:l,val:f})=>l?u:u.concat(f),[]),a=e.shiftTo(...o.map(r).filter(u=>u));return Wo(i,s(a))}};var ce=class{constructor(e,t){this.reason=e,this.explanation=t}toMessage(){return this.explanation?`${this.reason}: ${this.explanation}`:this.reason}};var Se=class{get type(){throw new $e}get name(){throw new $e}get ianaName(){return this.name}get isUniversal(){throw new $e}offsetName(e,t){throw new $e}formatOffset(e,t){throw new $e}offset(e){throw new $e}equals(e){throw new $e}get isValid(){throw new $e}};var ci=null,ln=class n extends Se{static get instance(){return ci===null&&(ci=new n),ci}get type(){return"system"}get name(){return new Intl.DateTimeFormat().resolvedOptions().timeZone}get isUniversal(){return!1}offsetName(e,{format:t,locale:r}){return Jr(e,t,r)}formatOffset(e,t){return kt(this.offset(e),t)}offset(e){return-new Date(e).getTimezoneOffset()}equals(e){return e.type==="system"}get isValid(){return!0}};var Yr={};function vl(n){return Yr[n]||(Yr[n]=new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:n,year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",era:"short"})),Yr[n]}var Ol={year:0,month:1,day:2,era:3,hour:4,minute:5,second:6};function xl(n,e){let t=n.format(e).replace(/\\u200E/g,""),r=/(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(t),[,s,i,o,a,u,l,f]=r;return[o,s,i,a,u,l,f]}function Il(n,e){let t=n.formatToParts(e),r=[];for(let s=0;s<t.length;s++){let{type:i,value:o}=t[s],a=Ol[i];i==="era"?r[a]=o:H(a)||(r[a]=parseInt(o,10))}return r}var zr={},ye=class n extends Se{static create(e){return zr[e]||(zr[e]=new n(e)),zr[e]}static resetCache(){zr={},Yr={}}static isValidSpecifier(e){return this.isValidZone(e)}static isValidZone(e){if(!e)return!1;try{return new Intl.DateTimeFormat("en-US",{timeZone:e}).format(),!0}catch(t){return!1}}constructor(e){super(),this.zoneName=e,this.valid=n.isValidZone(e)}get type(){return"iana"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(e,{format:t,locale:r}){return Jr(e,t,r,this.name)}formatOffset(e,t){return kt(this.offset(e),t)}offset(e){let t=new Date(e);if(isNaN(t))return NaN;let r=vl(this.name),[s,i,o,a,u,l,f]=r.formatToParts?Il(r,t):xl(r,t);a==="BC"&&(s=-Math.abs(s)+1);let m=rr({year:s,month:i,day:o,hour:u===24?0:u,minute:l,second:f,millisecond:0}),h=+t,b=h%1e3;return h-=b>=0?b:1e3+b,(m-h)/(60*1e3)}equals(e){return e.type==="iana"&&e.name===this.name}get isValid(){return this.valid}};var fi=null,fe=class n extends Se{static get utcInstance(){return fi===null&&(fi=new n(0)),fi}static instance(e){return e===0?n.utcInstance:new n(e)}static parseSpecifier(e){if(e){let t=e.match(/^utc(?:([+-]\\d{1,2})(?::(\\d{2}))?)?$/i);if(t)return new n(jt(t[1],t[2]))}return null}constructor(e){super(),this.fixed=e}get type(){return"fixed"}get name(){return this.fixed===0?"UTC":`UTC${kt(this.fixed,"narrow")}`}get ianaName(){return this.fixed===0?"Etc/UTC":`Etc/GMT${kt(-this.fixed,"narrow")}`}offsetName(){return this.name}formatOffset(e,t){return kt(this.fixed,t)}get isUniversal(){return!0}offset(){return this.fixed}equals(e){return e.type==="fixed"&&e.fixed===this.fixed}get isValid(){return!0}};var cn=class extends Se{constructor(e){super(),this.zoneName=e}get type(){return"invalid"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(){return null}formatOffset(){return""}offset(){return NaN}equals(){return!1}get isValid(){return!1}};function je(n,e){let t;if(H(n)||n===null)return e;if(n instanceof Se)return n;if(Bo(n)){let r=n.toLowerCase();return r==="local"||r==="system"?e:r==="utc"||r==="gmt"?fe.utcInstance:fe.parseSpecifier(r)||ye.create(n)}else return Xe(n)?fe.instance(n):typeof n=="object"&&n.offset&&typeof n.offset=="number"?n:new cn(n)}var Ho=()=>Date.now(),Jo="system",zo=null,Yo=null,Go=null,Zo,X=class{static get now(){return Ho}static set now(e){Ho=e}static set defaultZone(e){Jo=e}static get defaultZone(){return je(Jo,ln.instance)}static get defaultLocale(){return zo}static set defaultLocale(e){zo=e}static get defaultNumberingSystem(){return Yo}static set defaultNumberingSystem(e){Yo=e}static get defaultOutputCalendar(){return Go}static set defaultOutputCalendar(e){Go=e}static get throwOnInvalid(){return Zo}static set throwOnInvalid(e){Zo=e}static resetCaches(){te.resetCache(),ye.resetCache()}};var Qo={};function Ll(n,e={}){let t=JSON.stringify([n,e]),r=Qo[t];return r||(r=new Intl.ListFormat(n,e),Qo[t]=r),r}var di={};function hi(n,e={}){let t=JSON.stringify([n,e]),r=di[t];return r||(r=new Intl.DateTimeFormat(n,e),di[t]=r),r}var mi={};function Nl(n,e={}){let t=JSON.stringify([n,e]),r=mi[t];return r||(r=new Intl.NumberFormat(n,e),mi[t]=r),r}var pi={};function Al(n,e={}){let o=e,{base:t}=o,r=Ys(o,["base"]),s=JSON.stringify([n,r]),i=pi[s];return i||(i=new Intl.RelativeTimeFormat(n,e),pi[s]=i),i}var or=null;function Ml(){return or||(or=new Intl.DateTimeFormat().resolvedOptions().locale,or)}function _l(n){let e=n.indexOf("-u-");if(e===-1)return[n];{let t,r=n.substring(0,e);try{t=hi(n).resolvedOptions()}catch(o){t=hi(r).resolvedOptions()}let{numberingSystem:s,calendar:i}=t;return[r,s,i]}}function Bl(n,e,t){return(t||e)&&(n+="-u",t&&(n+=`-ca-${t}`),e&&(n+=`-nu-${e}`)),n}function Pl(n){let e=[];for(let t=1;t<=12;t++){let r=V.utc(2016,t,1);e.push(n(r))}return e}function $l(n){let e=[];for(let t=1;t<=7;t++){let r=V.utc(2016,11,13+t);e.push(n(r))}return e}function Gr(n,e,t,r,s){let i=n.listingMode(t);return i==="error"?null:i==="en"?r(e):s(e)}function Rl(n){return n.numberingSystem&&n.numberingSystem!=="latn"?!1:n.numberingSystem==="latn"||!n.locale||n.locale.startsWith("en")||new Intl.DateTimeFormat(n.intl).resolvedOptions().numberingSystem==="latn"}var Di=class{constructor(e,t,r){this.padTo=r.padTo||0,this.floor=r.floor||!1;let a=r,{padTo:s,floor:i}=a,o=Ys(a,["padTo","floor"]);if(!t||Object.keys(o).length>0){let u=R({useGrouping:!1},r);r.padTo>0&&(u.minimumIntegerDigits=r.padTo),this.inf=Nl(e,u)}}format(e){if(this.inf){let t=this.floor?Math.floor(e):e;return this.inf.format(t)}else{let t=this.floor?Math.floor(e):sn(e,3);return ne(t,this.padTo)}}},yi=class{constructor(e,t,r){this.opts=r;let s;if(e.zone.isUniversal){let o=-1*(e.offset/60),a=o>=0?`Etc/GMT+${o}`:`Etc/GMT${o}`;e.offset!==0&&ye.create(a).valid?(s=a,this.dt=e):(s="UTC",r.timeZoneName?this.dt=e:this.dt=e.offset===0?e:V.fromMillis(e.ts+e.offset*60*1e3))}else e.zone.type==="system"?this.dt=e:(this.dt=e,s=e.zone.name);let i=R({},this.opts);s&&(i.timeZone=s),this.dtf=hi(t,i)}format(){return this.dtf.format(this.dt.toJSDate())}formatToParts(){return this.dtf.formatToParts(this.dt.toJSDate())}resolvedOptions(){return this.dtf.resolvedOptions()}},gi=class{constructor(e,t,r){this.opts=R({style:"long"},r),!t&&Hr()&&(this.rtf=Al(e,r))}format(e,t){return this.rtf?this.rtf.format(e,t):Ko(t,e,this.opts.numeric,this.opts.style!=="long")}formatToParts(e,t){return this.rtf?this.rtf.formatToParts(e,t):[]}},te=class n{static fromOpts(e){return n.create(e.locale,e.numberingSystem,e.outputCalendar,e.defaultToEN)}static create(e,t,r,s=!1){let i=e||X.defaultLocale,o=i||(s?"en-US":Ml()),a=t||X.defaultNumberingSystem,u=r||X.defaultOutputCalendar;return new n(o,a,u,i)}static resetCache(){or=null,di={},mi={},pi={}}static fromObject({locale:e,numberingSystem:t,outputCalendar:r}={}){return n.create(e,t,r)}constructor(e,t,r,s){let[i,o,a]=_l(e);this.locale=i,this.numberingSystem=t||o||null,this.outputCalendar=r||a||null,this.intl=Bl(this.locale,this.numberingSystem,this.outputCalendar),this.weekdaysCache={format:{},standalone:{}},this.monthsCache={format:{},standalone:{}},this.meridiemCache=null,this.eraCache={},this.specifiedLocale=s,this.fastNumbersCached=null}get fastNumbers(){return this.fastNumbersCached==null&&(this.fastNumbersCached=Rl(this)),this.fastNumbersCached}listingMode(){let e=this.isEnglish(),t=(this.numberingSystem===null||this.numberingSystem==="latn")&&(this.outputCalendar===null||this.outputCalendar==="gregory");return e&&t?"en":"intl"}clone(e){return!e||Object.getOwnPropertyNames(e).length===0?this:n.create(e.locale||this.specifiedLocale,e.numberingSystem||this.numberingSystem,e.outputCalendar||this.outputCalendar,e.defaultToEN||!1)}redefaultToEN(e={}){return this.clone(De(R({},e),{defaultToEN:!0}))}redefaultToSystem(e={}){return this.clone(De(R({},e),{defaultToEN:!1}))}months(e,t=!1,r=!0){return Gr(this,e,r,ri,()=>{let s=t?{month:e,day:"numeric"}:{month:e},i=t?"format":"standalone";return this.monthsCache[i][e]||(this.monthsCache[i][e]=Pl(o=>this.extract(o,s,"month"))),this.monthsCache[i][e]})}weekdays(e,t=!1,r=!0){return Gr(this,e,r,oi,()=>{let s=t?{weekday:e,year:"numeric",month:"long",day:"numeric"}:{weekday:e},i=t?"format":"standalone";return this.weekdaysCache[i][e]||(this.weekdaysCache[i][e]=$l(o=>this.extract(o,s,"weekday"))),this.weekdaysCache[i][e]})}meridiems(e=!0){return Gr(this,void 0,e,()=>ai,()=>{if(!this.meridiemCache){let t={hour:"numeric",hourCycle:"h12"};this.meridiemCache=[V.utc(2016,11,13,9),V.utc(2016,11,13,19)].map(r=>this.extract(r,t,"dayperiod"))}return this.meridiemCache})}eras(e,t=!0){return Gr(this,e,t,ui,()=>{let r={era:e};return this.eraCache[e]||(this.eraCache[e]=[V.utc(-40,1,1),V.utc(2017,1,1)].map(s=>this.extract(s,r,"era"))),this.eraCache[e]})}extract(e,t,r){let s=this.dtFormatter(e,t),i=s.formatToParts(),o=i.find(a=>a.type.toLowerCase()===r);return o?o.value:null}numberFormatter(e={}){return new Di(this.intl,e.forceSimple||this.fastNumbers,e)}dtFormatter(e,t={}){return new yi(e,this.intl,t)}relFormatter(e={}){return new gi(this.intl,this.isEnglish(),e)}listFormatter(e={}){return Ll(this.intl,e)}isEnglish(){return this.locale==="en"||this.locale.toLowerCase()==="en-us"||new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us")}equals(e){return this.locale===e.locale&&this.numberingSystem===e.numberingSystem&&this.outputCalendar===e.outputCalendar}};function dn(...n){let e=n.reduce((t,r)=>t+r.source,"");return RegExp(`^${e}$`)}function hn(...n){return e=>n.reduce(([t,r,s],i)=>{let[o,a,u]=i(e,s);return[R(R({},t),o),a||r,u]},[{},null,1]).slice(0,2)}function mn(n,...e){if(n==null)return[null,null];for(let[t,r]of e){let s=t.exec(n);if(s)return r(s)}return[null,null]}function ea(...n){return(e,t)=>{let r={},s;for(s=0;s<n.length;s++)r[n[s]]=mt(e[t+s]);return[r,null,t+s]}}var ta=/(?:(Z)|([+-]\\d\\d)(?::?(\\d\\d))?)/,jl=`(?:${ta.source}?(?:\\\\[(${ti.source})\\\\])?)?`,bi=/(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:[.,](\\d{1,30}))?)?)?/,na=RegExp(`${bi.source}${jl}`),Fi=RegExp(`(?:T${na.source})?`),ql=/([+-]\\d{6}|\\d{4})(?:-?(\\d\\d)(?:-?(\\d\\d))?)?/,Vl=/(\\d{4})-?W(\\d\\d)(?:-?(\\d))?/,Ul=/(\\d{4})-?(\\d{3})/,Kl=ea("weekYear","weekNumber","weekDay"),Wl=ea("year","ordinal"),Hl=/(\\d{4})-(\\d\\d)-(\\d\\d)/,ra=RegExp(`${bi.source} ?(?:${ta.source}|(${ti.source}))?`),Jl=RegExp(`(?: ${ra.source})?`);function fn(n,e,t){let r=n[e];return H(r)?t:mt(r)}function zl(n,e){return[{year:fn(n,e),month:fn(n,e+1,1),day:fn(n,e+2,1)},null,e+3]}function pn(n,e){return[{hours:fn(n,e,0),minutes:fn(n,e+1,0),seconds:fn(n,e+2,0),milliseconds:nr(n[e+3])},null,e+4]}function ar(n,e){let t=!n[e]&&!n[e+1],r=jt(n[e+1],n[e+2]),s=t?null:fe.instance(r);return[{},s,e+3]}function ur(n,e){let t=n[e]?ye.create(n[e]):null;return[{},t,e+1]}var Yl=RegExp(`^T?${bi.source}$`),Gl=/^-?P(?:(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)Y)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)W)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)D)?(?:T(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)H)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20})(?:[.,](-?\\d{1,20}))?S)?)?)$/;function Zl(n){let[e,t,r,s,i,o,a,u,l]=n,f=e[0]==="-",d=u&&u[0]==="-",m=(h,b=!1)=>h!==void 0&&(b||h&&f)?-h:h;return[{years:m(St(t)),months:m(St(r)),weeks:m(St(s)),days:m(St(i)),hours:m(St(o)),minutes:m(St(a)),seconds:m(St(u),u==="-0"),milliseconds:m(nr(l),d)}]}var Ql={GMT:0,EDT:-4*60,EST:-5*60,CDT:-5*60,CST:-6*60,MDT:-6*60,MST:-7*60,PDT:-7*60,PST:-8*60};function Ei(n,e,t,r,s,i,o){let a={year:e.length===2?sr(mt(e)):mt(e),month:ni.indexOf(t)+1,day:mt(r),hour:mt(s),minute:mt(i)};return o&&(a.second=mt(o)),n&&(a.weekday=n.length>3?si.indexOf(n)+1:ii.indexOf(n)+1),a}var Xl=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\\d\\d)(\\d\\d)))$/;function ec(n){let[,e,t,r,s,i,o,a,u,l,f,d]=n,m=Ei(e,s,r,t,i,o,a),h;return u?h=Ql[u]:l?h=0:h=jt(f,d),[m,new fe(h)]}function tc(n){return n.replace(/\\([^()]*\\)|[\\n\\t]/g," ").replace(/(\\s\\s+)/g," ").trim()}var nc=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\\d\\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,rc=/^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\\d\\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,sc=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \\d|\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) (\\d{4})$/;function Xo(n){let[,e,t,r,s,i,o,a]=n;return[Ei(e,s,r,t,i,o,a),fe.utcInstance]}function ic(n){let[,e,t,r,s,i,o,a]=n;return[Ei(e,a,t,r,s,i,o),fe.utcInstance]}var oc=dn(ql,Fi),ac=dn(Vl,Fi),uc=dn(Ul,Fi),lc=dn(na),sa=hn(zl,pn,ar,ur),cc=hn(Kl,pn,ar,ur),fc=hn(Wl,pn,ar,ur),dc=hn(pn,ar,ur);function ia(n){return mn(n,[oc,sa],[ac,cc],[uc,fc],[lc,dc])}function oa(n){return mn(tc(n),[Xl,ec])}function aa(n){return mn(n,[nc,Xo],[rc,Xo],[sc,ic])}function ua(n){return mn(n,[Gl,Zl])}var hc=hn(pn);function la(n){return mn(n,[Yl,hc])}var mc=dn(Hl,Jl),pc=dn(ra),Dc=hn(pn,ar,ur);function ca(n){return mn(n,[mc,sa],[pc,Dc])}var yc="Invalid Duration",fa={weeks:{days:7,hours:7*24,minutes:7*24*60,seconds:7*24*60*60,milliseconds:7*24*60*60*1e3},days:{hours:24,minutes:24*60,seconds:24*60*60,milliseconds:24*60*60*1e3},hours:{minutes:60,seconds:60*60,milliseconds:60*60*1e3},minutes:{seconds:60,milliseconds:60*1e3},seconds:{milliseconds:1e3}},gc=R({years:{quarters:4,months:12,weeks:52,days:365,hours:365*24,minutes:365*24*60,seconds:365*24*60*60,milliseconds:365*24*60*60*1e3},quarters:{months:3,weeks:13,days:91,hours:91*24,minutes:91*24*60,seconds:91*24*60*60,milliseconds:91*24*60*60*1e3},months:{weeks:4,days:30,hours:30*24,minutes:30*24*60,seconds:30*24*60*60,milliseconds:30*24*60*60*1e3}},fa),Ae=146097/400,Dn=146097/4800,bc=R({years:{quarters:4,months:12,weeks:Ae/7,days:Ae,hours:Ae*24,minutes:Ae*24*60,seconds:Ae*24*60*60,milliseconds:Ae*24*60*60*1e3},quarters:{months:3,weeks:Ae/28,days:Ae/4,hours:Ae*24/4,minutes:Ae*24*60/4,seconds:Ae*24*60*60/4,milliseconds:Ae*24*60*60*1e3/4},months:{weeks:Dn/7,days:Dn,hours:Dn*24,minutes:Dn*24*60,seconds:Dn*24*60*60,milliseconds:Dn*24*60*60*1e3}},fa),Vt=["years","quarters","months","weeks","days","hours","minutes","seconds","milliseconds"],Fc=Vt.slice(0).reverse();function qt(n,e,t=!1){let r={values:t?e.values:R(R({},n.values),e.values||{}),loc:n.loc.clone(e.loc),conversionAccuracy:e.conversionAccuracy||n.conversionAccuracy};return new P(r)}function Ec(n){return n<0?Math.floor(n):Math.ceil(n)}function da(n,e,t,r,s){let i=n[s][t],o=e[t]/i,a=Math.sign(o)===Math.sign(r[s]),u=!a&&r[s]!==0&&Math.abs(o)<=1?Ec(o):Math.trunc(o);r[s]+=u,e[t]-=u*i}function wc(n,e){Fc.reduce((t,r)=>H(e[r])?t:(t&&da(n,e,t,e,r),r),null)}var P=class n{constructor(e){let t=e.conversionAccuracy==="longterm"||!1;this.values=e.values,this.loc=e.loc||te.create(),this.conversionAccuracy=t?"longterm":"casual",this.invalid=e.invalid||null,this.matrix=t?bc:gc,this.isLuxonDuration=!0}static fromMillis(e,t){return n.fromObject({milliseconds:e},t)}static fromObject(e,t={}){if(e==null||typeof e!="object")throw new le(`Duration.fromObject: argument expected to be an object, got ${e===null?"null":typeof e}`);return new n({values:un(e,n.normalizeUnit),loc:te.fromObject(t),conversionAccuracy:t.conversionAccuracy})}static fromDurationLike(e){if(Xe(e))return n.fromMillis(e);if(n.isDuration(e))return e;if(typeof e=="object")return n.fromObject(e);throw new le(`Unknown duration argument ${e} of type ${typeof e}`)}static fromISO(e,t){let[r]=ua(e);return r?n.fromObject(r,t):n.invalid("unparsable",`the input "${e}" can\'t be parsed as ISO 8601`)}static fromISOTime(e,t){let[r]=la(e);return r?n.fromObject(r,t):n.invalid("unparsable",`the input "${e}" can\'t be parsed as ISO 8601`)}static invalid(e,t=null){if(!e)throw new le("need to specify a reason the Duration is invalid");let r=e instanceof ce?e:new ce(e,t);if(X.throwOnInvalid)throw new Wr(r);return new n({invalid:r})}static normalizeUnit(e){let t={year:"years",years:"years",quarter:"quarters",quarters:"quarters",month:"months",months:"months",week:"weeks",weeks:"weeks",day:"days",days:"days",hour:"hours",hours:"hours",minute:"minutes",minutes:"minutes",second:"seconds",seconds:"seconds",millisecond:"milliseconds",milliseconds:"milliseconds"}[e&&e.toLowerCase()];if(!t)throw new nn(e);return t}static isDuration(e){return e&&e.isLuxonDuration||!1}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}toFormat(e,t={}){let r=De(R({},t),{floor:t.round!==!1&&t.floor!==!1});return this.isValid?Ee.create(this.loc,r).formatDurationFromString(this,e):yc}toHuman(e={}){let t=Vt.map(r=>{let s=this.values[r];return H(s)?null:this.loc.numberFormatter(De(R({style:"unit",unitDisplay:"long"},e),{unit:r.slice(0,-1)})).format(s)}).filter(r=>r);return this.loc.listFormatter(R({type:"conjunction",style:e.listStyle||"narrow"},e)).format(t)}toObject(){return this.isValid?R({},this.values):{}}toISO(){if(!this.isValid)return null;let e="P";return this.years!==0&&(e+=this.years+"Y"),(this.months!==0||this.quarters!==0)&&(e+=this.months+this.quarters*3+"M"),this.weeks!==0&&(e+=this.weeks+"W"),this.days!==0&&(e+=this.days+"D"),(this.hours!==0||this.minutes!==0||this.seconds!==0||this.milliseconds!==0)&&(e+="T"),this.hours!==0&&(e+=this.hours+"H"),this.minutes!==0&&(e+=this.minutes+"M"),(this.seconds!==0||this.milliseconds!==0)&&(e+=sn(this.seconds+this.milliseconds/1e3,3)+"S"),e==="P"&&(e+="T0S"),e}toISOTime(e={}){if(!this.isValid)return null;let t=this.toMillis();if(t<0||t>=864e5)return null;e=R({suppressMilliseconds:!1,suppressSeconds:!1,includePrefix:!1,format:"extended"},e);let r=this.shiftTo("hours","minutes","seconds","milliseconds"),s=e.format==="basic"?"hhmm":"hh:mm";(!e.suppressSeconds||r.seconds!==0||r.milliseconds!==0)&&(s+=e.format==="basic"?"ss":":ss",(!e.suppressMilliseconds||r.milliseconds!==0)&&(s+=".SSS"));let i=r.toFormat(s);return e.includePrefix&&(i="T"+i),i}toJSON(){return this.toISO()}toString(){return this.toISO()}toMillis(){return this.as("milliseconds")}valueOf(){return this.toMillis()}plus(e){if(!this.isValid)return this;let t=n.fromDurationLike(e),r={};for(let s of Vt)(Tt(t.values,s)||Tt(this.values,s))&&(r[s]=t.get(s)+this.get(s));return qt(this,{values:r},!0)}minus(e){if(!this.isValid)return this;let t=n.fromDurationLike(e);return this.plus(t.negate())}mapUnits(e){if(!this.isValid)return this;let t={};for(let r of Object.keys(this.values))t[r]=ei(e(this.values[r],r));return qt(this,{values:t},!0)}get(e){return this[n.normalizeUnit(e)]}set(e){if(!this.isValid)return this;let t=R(R({},this.values),un(e,n.normalizeUnit));return qt(this,{values:t})}reconfigure({locale:e,numberingSystem:t,conversionAccuracy:r}={}){let s=this.loc.clone({locale:e,numberingSystem:t}),i={loc:s};return r&&(i.conversionAccuracy=r),qt(this,i)}as(e){return this.isValid?this.shiftTo(e).get(e):NaN}normalize(){if(!this.isValid)return this;let e=this.toObject();return wc(this.matrix,e),qt(this,{values:e},!0)}shiftTo(...e){if(!this.isValid)return this;if(e.length===0)return this;e=e.map(o=>n.normalizeUnit(o));let t={},r={},s=this.toObject(),i;for(let o of Vt)if(e.indexOf(o)>=0){i=o;let a=0;for(let l in r)a+=this.matrix[l][o]*r[l],r[l]=0;Xe(s[o])&&(a+=s[o]);let u=Math.trunc(a);t[o]=u,r[o]=(a*1e3-u*1e3)/1e3;for(let l in s)Vt.indexOf(l)>Vt.indexOf(o)&&da(this.matrix,s,l,t,o)}else Xe(s[o])&&(r[o]=s[o]);for(let o in r)r[o]!==0&&(t[i]+=o===i?r[o]:r[o]/this.matrix[i][o]);return qt(this,{values:t},!0).normalize()}negate(){if(!this.isValid)return this;let e={};for(let t of Object.keys(this.values))e[t]=this.values[t]===0?0:-this.values[t];return qt(this,{values:e},!0)}get years(){return this.isValid?this.values.years||0:NaN}get quarters(){return this.isValid?this.values.quarters||0:NaN}get months(){return this.isValid?this.values.months||0:NaN}get weeks(){return this.isValid?this.values.weeks||0:NaN}get days(){return this.isValid?this.values.days||0:NaN}get hours(){return this.isValid?this.values.hours||0:NaN}get minutes(){return this.isValid?this.values.minutes||0:NaN}get seconds(){return this.isValid?this.values.seconds||0:NaN}get milliseconds(){return this.isValid?this.values.milliseconds||0:NaN}get isValid(){return this.invalid===null}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}equals(e){if(!this.isValid||!e.isValid||!this.loc.equals(e.loc))return!1;function t(r,s){return r===void 0||r===0?s===void 0||s===0:r===s}for(let r of Vt)if(!t(this.values[r],e.values[r]))return!1;return!0}};var lr="Invalid Interval";function Tc(n,e){return!n||!n.isValid?pt.invalid("missing or invalid start"):!e||!e.isValid?pt.invalid("missing or invalid end"):e<n?pt.invalid("end before start",`The end of an interval must be after its start, but you had start=${n.toISO()} and end=${e.toISO()}`):null}var pt=class n{constructor(e){this.s=e.start,this.e=e.end,this.invalid=e.invalid||null,this.isLuxonInterval=!0}static invalid(e,t=null){if(!e)throw new le("need to specify a reason the Interval is invalid");let r=e instanceof ce?e:new ce(e,t);if(X.throwOnInvalid)throw new Kr(r);return new n({invalid:r})}static fromDateTimes(e,t){let r=yn(e),s=yn(t),i=Tc(r,s);return i==null?new n({start:r,end:s}):i}static after(e,t){let r=P.fromDurationLike(t),s=yn(e);return n.fromDateTimes(s,s.plus(r))}static before(e,t){let r=P.fromDurationLike(t),s=yn(e);return n.fromDateTimes(s.minus(r),s)}static fromISO(e,t){let[r,s]=(e||"").split("/",2);if(r&&s){let i,o;try{i=V.fromISO(r,t),o=i.isValid}catch(l){o=!1}let a,u;try{a=V.fromISO(s,t),u=a.isValid}catch(l){u=!1}if(o&&u)return n.fromDateTimes(i,a);if(o){let l=P.fromISO(s,t);if(l.isValid)return n.after(i,l)}else if(u){let l=P.fromISO(r,t);if(l.isValid)return n.before(a,l)}}return n.invalid("unparsable",`the input "${e}" can\'t be parsed as ISO 8601`)}static isInterval(e){return e&&e.isLuxonInterval||!1}get start(){return this.isValid?this.s:null}get end(){return this.isValid?this.e:null}get isValid(){return this.invalidReason===null}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}length(e="milliseconds"){return this.isValid?this.toDuration(e).get(e):NaN}count(e="milliseconds"){if(!this.isValid)return NaN;let t=this.start.startOf(e),r=this.end.startOf(e);return Math.floor(r.diff(t,e).get(e))+1}hasSame(e){return this.isValid?this.isEmpty()||this.e.minus(1).hasSame(this.s,e):!1}isEmpty(){return this.s.valueOf()===this.e.valueOf()}isAfter(e){return this.isValid?this.s>e:!1}isBefore(e){return this.isValid?this.e<=e:!1}contains(e){return this.isValid?this.s<=e&&this.e>e:!1}set({start:e,end:t}={}){return this.isValid?n.fromDateTimes(e||this.s,t||this.e):this}splitAt(...e){if(!this.isValid)return[];let t=e.map(yn).filter(o=>this.contains(o)).sort(),r=[],{s}=this,i=0;for(;s<this.e;){let o=t[i]||this.e,a=+o>+this.e?this.e:o;r.push(n.fromDateTimes(s,a)),s=a,i+=1}return r}splitBy(e){let t=P.fromDurationLike(e);if(!this.isValid||!t.isValid||t.as("milliseconds")===0)return[];let{s:r}=this,s=1,i,o=[];for(;r<this.e;){let a=this.start.plus(t.mapUnits(u=>u*s));i=+a>+this.e?this.e:a,o.push(n.fromDateTimes(r,i)),r=i,s+=1}return o}divideEqually(e){return this.isValid?this.splitBy(this.length()/e).slice(0,e):[]}overlaps(e){return this.e>e.s&&this.s<e.e}abutsStart(e){return this.isValid?+this.e==+e.s:!1}abutsEnd(e){return this.isValid?+e.e==+this.s:!1}engulfs(e){return this.isValid?this.s<=e.s&&this.e>=e.e:!1}equals(e){return!this.isValid||!e.isValid?!1:this.s.equals(e.s)&&this.e.equals(e.e)}intersection(e){if(!this.isValid)return this;let t=this.s>e.s?this.s:e.s,r=this.e<e.e?this.e:e.e;return t>=r?null:n.fromDateTimes(t,r)}union(e){if(!this.isValid)return this;let t=this.s<e.s?this.s:e.s,r=this.e>e.e?this.e:e.e;return n.fromDateTimes(t,r)}static merge(e){let[t,r]=e.sort((s,i)=>s.s-i.s).reduce(([s,i],o)=>i?i.overlaps(o)||i.abutsStart(o)?[s,i.union(o)]:[s.concat([i]),o]:[s,o],[[],null]);return r&&t.push(r),t}static xor(e){let t=null,r=0,s=[],i=e.map(u=>[{time:u.s,type:"s"},{time:u.e,type:"e"}]),o=Array.prototype.concat(...i),a=o.sort((u,l)=>u.time-l.time);for(let u of a)r+=u.type==="s"?1:-1,r===1?t=u.time:(t&&+t!=+u.time&&s.push(n.fromDateTimes(t,u.time)),t=null);return n.merge(s)}difference(...e){return n.xor([this].concat(e)).map(t=>this.intersection(t)).filter(t=>t&&!t.isEmpty())}toString(){return this.isValid?`[${this.s.toISO()} \\u2013 ${this.e.toISO()})`:lr}toISO(e){return this.isValid?`${this.s.toISO(e)}/${this.e.toISO(e)}`:lr}toISODate(){return this.isValid?`${this.s.toISODate()}/${this.e.toISODate()}`:lr}toISOTime(e){return this.isValid?`${this.s.toISOTime(e)}/${this.e.toISOTime(e)}`:lr}toFormat(e,{separator:t=" \\u2013 "}={}){return this.isValid?`${this.s.toFormat(e)}${t}${this.e.toFormat(e)}`:lr}toDuration(e,t){return this.isValid?this.e.diff(this.s,e,t):P.invalid(this.invalidReason)}mapEndpoints(e){return n.fromDateTimes(e(this.s),e(this.e))}};var Dt=class{static hasDST(e=X.defaultZone){let t=V.now().setZone(e).set({month:12});return!e.isUniversal&&t.offset!==t.set({month:6}).offset}static isValidIANAZone(e){return ye.isValidZone(e)}static normalizeZone(e){return je(e,X.defaultZone)}static months(e="long",{locale:t=null,numberingSystem:r=null,locObj:s=null,outputCalendar:i="gregory"}={}){return(s||te.create(t,r,i)).months(e)}static monthsFormat(e="long",{locale:t=null,numberingSystem:r=null,locObj:s=null,outputCalendar:i="gregory"}={}){return(s||te.create(t,r,i)).months(e,!0)}static weekdays(e="long",{locale:t=null,numberingSystem:r=null,locObj:s=null}={}){return(s||te.create(t,r,null)).weekdays(e)}static weekdaysFormat(e="long",{locale:t=null,numberingSystem:r=null,locObj:s=null}={}){return(s||te.create(t,r,null)).weekdays(e,!0)}static meridiems({locale:e=null}={}){return te.create(e).meridiems()}static eras(e="short",{locale:t=null}={}){return te.create(t,null,"gregory").eras(e)}static features(){return{relative:Hr()}}};function ha(n,e){let t=s=>s.toUTC(0,{keepLocalTime:!0}).startOf("day").valueOf(),r=t(e)-t(n);return Math.floor(P.fromMillis(r).as("days"))}function Sc(n,e,t){let r=[["years",(a,u)=>u.year-a.year],["quarters",(a,u)=>u.quarter-a.quarter],["months",(a,u)=>u.month-a.month+(u.year-a.year)*12],["weeks",(a,u)=>{let l=ha(a,u);return(l-l%7)/7}],["days",ha]],s={},i,o;for(let[a,u]of r)if(t.indexOf(a)>=0){i=a;let l=u(n,e);o=n.plus({[a]:l}),o>e?(n=n.plus({[a]:l-1}),l-=1):n=o,s[a]=l}return[n,s,o,i]}function ma(n,e,t,r){let[s,i,o,a]=Sc(n,e,t),u=e-s,l=t.filter(d=>["hours","minutes","seconds","milliseconds"].indexOf(d)>=0);l.length===0&&(o<e&&(o=s.plus({[a]:1})),o!==s&&(i[a]=(i[a]||0)+u/(o-s)));let f=P.fromObject(i,r);return l.length>0?P.fromMillis(u,r).shiftTo(...l).plus(f):f}var wi={arab:"[\\u0660-\\u0669]",arabext:"[\\u06F0-\\u06F9]",bali:"[\\u1B50-\\u1B59]",beng:"[\\u09E6-\\u09EF]",deva:"[\\u0966-\\u096F]",fullwide:"[\\uFF10-\\uFF19]",gujr:"[\\u0AE6-\\u0AEF]",hanidec:"[\\u3007|\\u4E00|\\u4E8C|\\u4E09|\\u56DB|\\u4E94|\\u516D|\\u4E03|\\u516B|\\u4E5D]",khmr:"[\\u17E0-\\u17E9]",knda:"[\\u0CE6-\\u0CEF]",laoo:"[\\u0ED0-\\u0ED9]",limb:"[\\u1946-\\u194F]",mlym:"[\\u0D66-\\u0D6F]",mong:"[\\u1810-\\u1819]",mymr:"[\\u1040-\\u1049]",orya:"[\\u0B66-\\u0B6F]",tamldec:"[\\u0BE6-\\u0BEF]",telu:"[\\u0C66-\\u0C6F]",thai:"[\\u0E50-\\u0E59]",tibt:"[\\u0F20-\\u0F29]",latn:"\\\\d"},pa={arab:[1632,1641],arabext:[1776,1785],bali:[6992,7001],beng:[2534,2543],deva:[2406,2415],fullwide:[65296,65303],gujr:[2790,2799],khmr:[6112,6121],knda:[3302,3311],laoo:[3792,3801],limb:[6470,6479],mlym:[3430,3439],mong:[6160,6169],mymr:[4160,4169],orya:[2918,2927],tamldec:[3046,3055],telu:[3174,3183],thai:[3664,3673],tibt:[3872,3881]},kc=wi.hanidec.replace(/[\\[|\\]]/g,"").split("");function Da(n){let e=parseInt(n,10);if(isNaN(e)){e="";for(let t=0;t<n.length;t++){let r=n.charCodeAt(t);if(n[t].search(wi.hanidec)!==-1)e+=kc.indexOf(n[t]);else for(let s in pa){let[i,o]=pa[s];r>=i&&r<=o&&(e+=r-i)}}return parseInt(e,10)}else return e}function Me({numberingSystem:n},e=""){return new RegExp(`${wi[n||"latn"]}${e}`)}var Cc="missing Intl.DateTimeFormat.formatToParts support";function Z(n,e=t=>t){return{regex:n,deser:([t])=>e(Da(t))}}var vc="\\xA0",ba=`[ ${vc}]`,Fa=new RegExp(ba,"g");function Oc(n){return n.replace(/\\./g,"\\\\.?").replace(Fa,ba)}function ya(n){return n.replace(/\\./g,"").replace(Fa," ").toLowerCase()}function qe(n,e){return n===null?null:{regex:RegExp(n.map(Oc).join("|")),deser:([t])=>n.findIndex(r=>ya(t)===ya(r))+e}}function ga(n,e){return{regex:n,deser:([,t,r])=>jt(t,r),groups:e}}function Ti(n){return{regex:n,deser:([e])=>e}}function xc(n){return n.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g,"\\\\$&")}function Ic(n,e){let t=Me(e),r=Me(e,"{2}"),s=Me(e,"{3}"),i=Me(e,"{4}"),o=Me(e,"{6}"),a=Me(e,"{1,2}"),u=Me(e,"{1,3}"),l=Me(e,"{1,6}"),f=Me(e,"{1,9}"),d=Me(e,"{2,4}"),m=Me(e,"{4,6}"),h=D=>({regex:RegExp(xc(D.val)),deser:([T])=>T,literal:!0}),g=(D=>{if(n.literal)return h(D);switch(D.val){case"G":return qe(e.eras("short",!1),0);case"GG":return qe(e.eras("long",!1),0);case"y":return Z(l);case"yy":return Z(d,sr);case"yyyy":return Z(i);case"yyyyy":return Z(m);case"yyyyyy":return Z(o);case"M":return Z(a);case"MM":return Z(r);case"MMM":return qe(e.months("short",!0,!1),1);case"MMMM":return qe(e.months("long",!0,!1),1);case"L":return Z(a);case"LL":return Z(r);case"LLL":return qe(e.months("short",!1,!1),1);case"LLLL":return qe(e.months("long",!1,!1),1);case"d":return Z(a);case"dd":return Z(r);case"o":return Z(u);case"ooo":return Z(s);case"HH":return Z(r);case"H":return Z(a);case"hh":return Z(r);case"h":return Z(a);case"mm":return Z(r);case"m":return Z(a);case"q":return Z(a);case"qq":return Z(r);case"s":return Z(a);case"ss":return Z(r);case"S":return Z(u);case"SSS":return Z(s);case"u":return Ti(f);case"uu":return Ti(a);case"uuu":return Z(t);case"a":return qe(e.meridiems(),0);case"kkkk":return Z(i);case"kk":return Z(d,sr);case"W":return Z(a);case"WW":return Z(r);case"E":case"c":return Z(t);case"EEE":return qe(e.weekdays("short",!1,!1),1);case"EEEE":return qe(e.weekdays("long",!1,!1),1);case"ccc":return qe(e.weekdays("short",!0,!1),1);case"cccc":return qe(e.weekdays("long",!0,!1),1);case"Z":case"ZZ":return ga(new RegExp(`([+-]${a.source})(?::(${r.source}))?`),2);case"ZZZ":return ga(new RegExp(`([+-]${a.source})(${r.source})?`),2);case"z":return Ti(/[a-z_+-/]{1,256}?/i);default:return h(D)}})(n)||{invalidReason:Cc};return g.token=n,g}var Lc={year:{"2-digit":"yy",numeric:"yyyyy"},month:{numeric:"M","2-digit":"MM",short:"MMM",long:"MMMM"},day:{numeric:"d","2-digit":"dd"},weekday:{short:"EEE",long:"EEEE"},dayperiod:"a",dayPeriod:"a",hour:{numeric:"h","2-digit":"hh"},minute:{numeric:"m","2-digit":"mm"},second:{numeric:"s","2-digit":"ss"}};function Nc(n,e,t){let{type:r,value:s}=n;if(r==="literal")return{literal:!0,val:s};let i=t[r],o=Lc[r];if(typeof o=="object"&&(o=o[i]),o)return{literal:!1,val:o}}function Ac(n){return[`^${n.map(t=>t.regex).reduce((t,r)=>`${t}(${r.source})`,"")}$`,n]}function Mc(n,e,t){let r=n.match(e);if(r){let s={},i=1;for(let o in t)if(Tt(t,o)){let a=t[o],u=a.groups?a.groups+1:1;!a.literal&&a.token&&(s[a.token.val[0]]=a.deser(r.slice(i,i+u))),i+=u}return[r,s]}else return[r,{}]}function _c(n){let e=i=>{switch(i){case"S":return"millisecond";case"s":return"second";case"m":return"minute";case"h":case"H":return"hour";case"d":return"day";case"o":return"ordinal";case"L":case"M":return"month";case"y":return"year";case"E":case"c":return"weekday";case"W":return"weekNumber";case"k":return"weekYear";case"q":return"quarter";default:return null}},t=null,r;return H(n.z)||(t=ye.create(n.z)),H(n.Z)||(t||(t=new fe(n.Z)),r=n.Z),H(n.q)||(n.M=(n.q-1)*3+1),H(n.h)||(n.h<12&&n.a===1?n.h+=12:n.h===12&&n.a===0&&(n.h=0)),n.G===0&&n.y&&(n.y=-n.y),H(n.u)||(n.S=nr(n.u)),[Object.keys(n).reduce((i,o)=>{let a=e(o);return a&&(i[a]=n[o]),i},{}),t,r]}var Si=null;function Bc(){return Si||(Si=V.fromMillis(1555555555555)),Si}function Pc(n,e){if(n.literal)return n;let t=Ee.macroTokenToFormatOpts(n.val);if(!t)return n;let i=Ee.create(e,t).formatDateTimeParts(Bc()).map(o=>Nc(o,e,t));return i.includes(void 0)?n:i}function $c(n,e){return Array.prototype.concat(...n.map(t=>Pc(t,e)))}function ki(n,e,t){let r=$c(Ee.parseFormat(t),n),s=r.map(o=>Ic(o,n)),i=s.find(o=>o.invalidReason);if(i)return{input:e,tokens:r,invalidReason:i.invalidReason};{let[o,a]=Ac(s),u=RegExp(o,"i"),[l,f]=Mc(e,u,a),[d,m,h]=f?_c(f):[null,null,void 0];if(Tt(f,"a")&&Tt(f,"H"))throw new ht("Can\'t include meridiem when specifying 24-hour format");return{input:e,tokens:r,regex:u,rawMatches:l,matches:f,result:d,zone:m,specificOffset:h}}}function Ea(n,e,t){let{result:r,zone:s,specificOffset:i,invalidReason:o}=ki(n,e,t);return[r,s,i,o]}var wa=[0,31,59,90,120,151,181,212,243,273,304,334],Ta=[0,31,60,91,121,152,182,213,244,274,305,335];function _e(n,e){return new ce("unit out of range",`you specified ${e} (of type ${typeof e}) as a ${n}, which is invalid`)}function Sa(n,e,t){let r=new Date(Date.UTC(n,e-1,t));n<100&&n>=0&&r.setUTCFullYear(r.getUTCFullYear()-1900);let s=r.getUTCDay();return s===0?7:s}function ka(n,e,t){return t+($t(n)?Ta:wa)[e-1]}function Ca(n,e){let t=$t(n)?Ta:wa,r=t.findIndex(i=>i<e),s=e-t[r];return{month:r+1,day:s}}function Zr(n){let{year:e,month:t,day:r}=n,s=ka(e,t,r),i=Sa(e,t,r),o=Math.floor((s-i+10)/7),a;return o<1?(a=e-1,o=an(a)):o>an(e)?(a=e+1,o=1):a=e,R({weekYear:a,weekNumber:o,weekday:i},ir(n))}function Ci(n){let{weekYear:e,weekNumber:t,weekday:r}=n,s=Sa(e,1,4),i=Rt(e),o=t*7+r-s-3,a;o<1?(a=e-1,o+=Rt(a)):o>i?(a=e+1,o-=Rt(e)):a=e;let{month:u,day:l}=Ca(a,o);return R({year:a,month:u,day:l},ir(n))}function Qr(n){let{year:e,month:t,day:r}=n,s=ka(e,t,r);return R({year:e,ordinal:s},ir(n))}function vi(n){let{year:e,ordinal:t}=n,{month:r,day:s}=Ca(e,t);return R({year:e,month:r,day:s},ir(n))}function va(n){let e=tr(n.weekYear),t=et(n.weekNumber,1,an(n.weekYear)),r=et(n.weekday,1,7);return e?t?r?!1:_e("weekday",n.weekday):_e("week",n.week):_e("weekYear",n.weekYear)}function Oa(n){let e=tr(n.year),t=et(n.ordinal,1,Rt(n.year));return e?t?!1:_e("ordinal",n.ordinal):_e("year",n.year)}function Oi(n){let e=tr(n.year),t=et(n.month,1,12),r=et(n.day,1,on(n.year,n.month));return e?t?r?!1:_e("day",n.day):_e("month",n.month):_e("year",n.year)}function xi(n){let{hour:e,minute:t,second:r,millisecond:s}=n,i=et(e,0,23)||e===24&&t===0&&r===0&&s===0,o=et(t,0,59),a=et(r,0,59),u=et(s,0,999);return i?o?a?u?!1:_e("millisecond",s):_e("second",r):_e("minute",t):_e("hour",e)}var Ii="Invalid DateTime",xa=864e13;function Xr(n){return new ce("unsupported zone",`the zone "${n.name}" is not supported`)}function Li(n){return n.weekData===null&&(n.weekData=Zr(n.c)),n.weekData}function cr(n,e){let t={ts:n.ts,zone:n.zone,c:n.c,o:n.o,loc:n.loc,invalid:n.invalid};return new V(De(R(R({},t),e),{old:t}))}function Pa(n,e,t){let r=n-e*60*1e3,s=t.offset(r);if(e===s)return[r,e];r-=(s-e)*60*1e3;let i=t.offset(r);return s===i?[r,s]:[n-Math.min(s,i)*60*1e3,Math.max(s,i)]}function Ia(n,e){n+=e*60*1e3;let t=new Date(n);return{year:t.getUTCFullYear(),month:t.getUTCMonth()+1,day:t.getUTCDate(),hour:t.getUTCHours(),minute:t.getUTCMinutes(),second:t.getUTCSeconds(),millisecond:t.getUTCMilliseconds()}}function ts(n,e,t){return Pa(rr(n),e,t)}function La(n,e){let t=n.o,r=n.c.year+Math.trunc(e.years),s=n.c.month+Math.trunc(e.months)+Math.trunc(e.quarters)*3,i=De(R({},n.c),{year:r,month:s,day:Math.min(n.c.day,on(r,s))+Math.trunc(e.days)+Math.trunc(e.weeks)*7}),o=P.fromObject({years:e.years-Math.trunc(e.years),quarters:e.quarters-Math.trunc(e.quarters),months:e.months-Math.trunc(e.months),weeks:e.weeks-Math.trunc(e.weeks),days:e.days-Math.trunc(e.days),hours:e.hours,minutes:e.minutes,seconds:e.seconds,milliseconds:e.milliseconds}).as("milliseconds"),a=rr(i),[u,l]=Pa(a,t,n.zone);return o!==0&&(u+=o,l=n.zone.offset(u)),{ts:u,o:l}}function fr(n,e,t,r,s,i){let{setZone:o,zone:a}=t;if(n&&Object.keys(n).length!==0){let u=e||a,l=V.fromObject(n,De(R({},t),{zone:u,specificOffset:i}));return o?l:l.setZone(a)}else return V.invalid(new ce("unparsable",`the input "${s}" can\'t be parsed as ${r}`))}function es(n,e,t=!0){return n.isValid?Ee.create(te.create("en-US"),{allowZ:t,forceSimple:!0}).formatDateTimeFromString(n,e):null}function Ni(n,e){let t=n.c.year>9999||n.c.year<0,r="";return t&&n.c.year>=0&&(r+="+"),r+=ne(n.c.year,t?6:4),e?(r+="-",r+=ne(n.c.month),r+="-",r+=ne(n.c.day)):(r+=ne(n.c.month),r+=ne(n.c.day)),r}function Na(n,e,t,r,s,i){let o=ne(n.c.hour);return e?(o+=":",o+=ne(n.c.minute),(n.c.second!==0||!t)&&(o+=":")):o+=ne(n.c.minute),(n.c.second!==0||!t)&&(o+=ne(n.c.second),(n.c.millisecond!==0||!r)&&(o+=".",o+=ne(n.c.millisecond,3))),s&&(n.isOffsetFixed&&n.offset===0&&!i?o+="Z":n.o<0?(o+="-",o+=ne(Math.trunc(-n.o/60)),o+=":",o+=ne(Math.trunc(-n.o%60))):(o+="+",o+=ne(Math.trunc(n.o/60)),o+=":",o+=ne(Math.trunc(n.o%60)))),i&&(o+="["+n.zone.ianaName+"]"),o}var $a={month:1,day:1,hour:0,minute:0,second:0,millisecond:0},Rc={weekNumber:1,weekday:1,hour:0,minute:0,second:0,millisecond:0},jc={ordinal:1,hour:0,minute:0,second:0,millisecond:0},Ra=["year","month","day","hour","minute","second","millisecond"],qc=["weekYear","weekNumber","weekday","hour","minute","second","millisecond"],Vc=["year","ordinal","hour","minute","second","millisecond"];function Aa(n){let e={year:"year",years:"year",month:"month",months:"month",day:"day",days:"day",hour:"hour",hours:"hour",minute:"minute",minutes:"minute",quarter:"quarter",quarters:"quarter",second:"second",seconds:"second",millisecond:"millisecond",milliseconds:"millisecond",weekday:"weekday",weekdays:"weekday",weeknumber:"weekNumber",weeksnumber:"weekNumber",weeknumbers:"weekNumber",weekyear:"weekYear",weekyears:"weekYear",ordinal:"ordinal"}[n.toLowerCase()];if(!e)throw new nn(n);return e}function Ma(n,e){let t=je(e.zone,X.defaultZone),r=te.fromObject(e),s=X.now(),i,o;if(H(n.year))i=s;else{for(let l of Ra)H(n[l])&&(n[l]=$a[l]);let a=Oi(n)||xi(n);if(a)return V.invalid(a);let u=t.offset(s);[i,o]=ts(n,u,t)}return new V({ts:i,zone:t,loc:r,o})}function _a(n,e,t){let r=H(t.round)?!0:t.round,s=(o,a)=>(o=sn(o,r||t.calendary?0:2,!0),e.loc.clone(t).relFormatter(t).format(o,a)),i=o=>t.calendary?e.hasSame(n,o)?0:e.startOf(o).diff(n.startOf(o),o).get(o):e.diff(n,o).get(o);if(t.unit)return s(i(t.unit),t.unit);for(let o of t.units){let a=i(o);if(Math.abs(a)>=1)return s(a,o)}return s(n>e?-0:0,t.units[t.units.length-1])}function Ba(n){let e={},t;return n.length>0&&typeof n[n.length-1]=="object"?(e=n[n.length-1],t=Array.from(n).slice(0,n.length-1)):t=Array.from(n),[e,t]}var V=class n{constructor(e){let t=e.zone||X.defaultZone,r=e.invalid||(Number.isNaN(e.ts)?new ce("invalid input"):null)||(t.isValid?null:Xr(t));this.ts=H(e.ts)?X.now():e.ts;let s=null,i=null;if(!r)if(e.old&&e.old.ts===this.ts&&e.old.zone.equals(t))[s,i]=[e.old.c,e.old.o];else{let a=t.offset(this.ts);s=Ia(this.ts,a),r=Number.isNaN(s.year)?new ce("invalid input"):null,s=r?null:s,i=r?null:a}this._zone=t,this.loc=e.loc||te.create(),this.invalid=r,this.weekData=null,this.c=s,this.o=i,this.isLuxonDateTime=!0}static now(){return new n({})}static local(){let[e,t]=Ba(arguments),[r,s,i,o,a,u,l]=t;return Ma({year:r,month:s,day:i,hour:o,minute:a,second:u,millisecond:l},e)}static utc(){let[e,t]=Ba(arguments),[r,s,i,o,a,u,l]=t;return e.zone=fe.utcInstance,Ma({year:r,month:s,day:i,hour:o,minute:a,second:u,millisecond:l},e)}static fromJSDate(e,t={}){let r=Po(e)?e.valueOf():NaN;if(Number.isNaN(r))return n.invalid("invalid input");let s=je(t.zone,X.defaultZone);return s.isValid?new n({ts:r,zone:s,loc:te.fromObject(t)}):n.invalid(Xr(s))}static fromMillis(e,t={}){if(Xe(e))return e<-xa||e>xa?n.invalid("Timestamp out of range"):new n({ts:e,zone:je(t.zone,X.defaultZone),loc:te.fromObject(t)});throw new le(`fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`)}static fromSeconds(e,t={}){if(Xe(e))return new n({ts:e*1e3,zone:je(t.zone,X.defaultZone),loc:te.fromObject(t)});throw new le("fromSeconds requires a numerical input")}static fromObject(e,t={}){e=e||{};let r=je(t.zone,X.defaultZone);if(!r.isValid)return n.invalid(Xr(r));let s=X.now(),i=H(t.specificOffset)?r.offset(s):t.specificOffset,o=un(e,Aa),a=!H(o.ordinal),u=!H(o.year),l=!H(o.month)||!H(o.day),f=u||l,d=o.weekYear||o.weekNumber,m=te.fromObject(t);if((f||a)&&d)throw new ht("Can\'t mix weekYear/weekNumber units with year/month/day or ordinals");if(l&&a)throw new ht("Can\'t mix ordinal dates with month/day");let h=d||o.weekday&&!f,b,g,D=Ia(s,i);h?(b=qc,g=Rc,D=Zr(D)):a?(b=Vc,g=jc,D=Qr(D)):(b=Ra,g=$a);let T=!1;for(let C of b){let U=o[C];H(U)?T?o[C]=g[C]:o[C]=D[C]:T=!0}let I=h?va(o):a?Oa(o):Oi(o),N=I||xi(o);if(N)return n.invalid(N);let y=h?Ci(o):a?vi(o):o,[w,v]=ts(y,i,r),O=new n({ts:w,zone:r,o:v,loc:m});return o.weekday&&f&&e.weekday!==O.weekday?n.invalid("mismatched weekday",`you can\'t specify both a weekday of ${o.weekday} and a date of ${O.toISO()}`):O}static fromISO(e,t={}){let[r,s]=ia(e);return fr(r,s,t,"ISO 8601",e)}static fromRFC2822(e,t={}){let[r,s]=oa(e);return fr(r,s,t,"RFC 2822",e)}static fromHTTP(e,t={}){let[r,s]=aa(e);return fr(r,s,t,"HTTP",t)}static fromFormat(e,t,r={}){if(H(e)||H(t))throw new le("fromFormat requires an input string and a format");let{locale:s=null,numberingSystem:i=null}=r,o=te.fromOpts({locale:s,numberingSystem:i,defaultToEN:!0}),[a,u,l,f]=Ea(o,e,t);return f?n.invalid(f):fr(a,u,r,`format ${t}`,e,l)}static fromString(e,t,r={}){return n.fromFormat(e,t,r)}static fromSQL(e,t={}){let[r,s]=ca(e);return fr(r,s,t,"SQL",e)}static invalid(e,t=null){if(!e)throw new le("need to specify a reason the DateTime is invalid");let r=e instanceof ce?e:new ce(e,t);if(X.throwOnInvalid)throw new Ur(r);return new n({invalid:r})}static isDateTime(e){return e&&e.isLuxonDateTime||!1}get(e){return this[e]}get isValid(){return this.invalid===null}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}get outputCalendar(){return this.isValid?this.loc.outputCalendar:null}get zone(){return this._zone}get zoneName(){return this.isValid?this.zone.name:null}get year(){return this.isValid?this.c.year:NaN}get quarter(){return this.isValid?Math.ceil(this.c.month/3):NaN}get month(){return this.isValid?this.c.month:NaN}get day(){return this.isValid?this.c.day:NaN}get hour(){return this.isValid?this.c.hour:NaN}get minute(){return this.isValid?this.c.minute:NaN}get second(){return this.isValid?this.c.second:NaN}get millisecond(){return this.isValid?this.c.millisecond:NaN}get weekYear(){return this.isValid?Li(this).weekYear:NaN}get weekNumber(){return this.isValid?Li(this).weekNumber:NaN}get weekday(){return this.isValid?Li(this).weekday:NaN}get ordinal(){return this.isValid?Qr(this.c).ordinal:NaN}get monthShort(){return this.isValid?Dt.months("short",{locObj:this.loc})[this.month-1]:null}get monthLong(){return this.isValid?Dt.months("long",{locObj:this.loc})[this.month-1]:null}get weekdayShort(){return this.isValid?Dt.weekdays("short",{locObj:this.loc})[this.weekday-1]:null}get weekdayLong(){return this.isValid?Dt.weekdays("long",{locObj:this.loc})[this.weekday-1]:null}get offset(){return this.isValid?+this.o:NaN}get offsetNameShort(){return this.isValid?this.zone.offsetName(this.ts,{format:"short",locale:this.locale}):null}get offsetNameLong(){return this.isValid?this.zone.offsetName(this.ts,{format:"long",locale:this.locale}):null}get isOffsetFixed(){return this.isValid?this.zone.isUniversal:null}get isInDST(){return this.isOffsetFixed?!1:this.offset>this.set({month:1,day:1}).offset||this.offset>this.set({month:5}).offset}get isInLeapYear(){return $t(this.year)}get daysInMonth(){return on(this.year,this.month)}get daysInYear(){return this.isValid?Rt(this.year):NaN}get weeksInWeekYear(){return this.isValid?an(this.weekYear):NaN}resolvedLocaleOptions(e={}){let{locale:t,numberingSystem:r,calendar:s}=Ee.create(this.loc.clone(e),e).resolvedOptions(this);return{locale:t,numberingSystem:r,outputCalendar:s}}toUTC(e=0,t={}){return this.setZone(fe.instance(e),t)}toLocal(){return this.setZone(X.defaultZone)}setZone(e,{keepLocalTime:t=!1,keepCalendarTime:r=!1}={}){if(e=je(e,X.defaultZone),e.equals(this.zone))return this;if(e.isValid){let s=this.ts;if(t||r){let i=e.offset(this.ts),o=this.toObject();[s]=ts(o,i,e)}return cr(this,{ts:s,zone:e})}else return n.invalid(Xr(e))}reconfigure({locale:e,numberingSystem:t,outputCalendar:r}={}){let s=this.loc.clone({locale:e,numberingSystem:t,outputCalendar:r});return cr(this,{loc:s})}setLocale(e){return this.reconfigure({locale:e})}set(e){if(!this.isValid)return this;let t=un(e,Aa),r=!H(t.weekYear)||!H(t.weekNumber)||!H(t.weekday),s=!H(t.ordinal),i=!H(t.year),o=!H(t.month)||!H(t.day),a=i||o,u=t.weekYear||t.weekNumber;if((a||s)&&u)throw new ht("Can\'t mix weekYear/weekNumber units with year/month/day or ordinals");if(o&&s)throw new ht("Can\'t mix ordinal dates with month/day");let l;r?l=Ci(R(R({},Zr(this.c)),t)):H(t.ordinal)?(l=R(R({},this.toObject()),t),H(t.day)&&(l.day=Math.min(on(l.year,l.month),l.day))):l=vi(R(R({},Qr(this.c)),t));let[f,d]=ts(l,this.o,this.zone);return cr(this,{ts:f,o:d})}plus(e){if(!this.isValid)return this;let t=P.fromDurationLike(e);return cr(this,La(this,t))}minus(e){if(!this.isValid)return this;let t=P.fromDurationLike(e).negate();return cr(this,La(this,t))}startOf(e){if(!this.isValid)return this;let t={},r=P.normalizeUnit(e);switch(r){case"years":t.month=1;case"quarters":case"months":t.day=1;case"weeks":case"days":t.hour=0;case"hours":t.minute=0;case"minutes":t.second=0;case"seconds":t.millisecond=0;break;case"milliseconds":break}if(r==="weeks"&&(t.weekday=1),r==="quarters"){let s=Math.ceil(this.month/3);t.month=(s-1)*3+1}return this.set(t)}endOf(e){return this.isValid?this.plus({[e]:1}).startOf(e).minus(1):this}toFormat(e,t={}){return this.isValid?Ee.create(this.loc.redefaultToEN(t)).formatDateTimeFromString(this,e):Ii}toLocaleString(e=rn,t={}){return this.isValid?Ee.create(this.loc.clone(t),e).formatDateTime(this):Ii}toLocaleParts(e={}){return this.isValid?Ee.create(this.loc.clone(e),e).formatDateTimeParts(this):[]}toISO({format:e="extended",suppressSeconds:t=!1,suppressMilliseconds:r=!1,includeOffset:s=!0,extendedZone:i=!1}={}){if(!this.isValid)return null;let o=e==="extended",a=Ni(this,o);return a+="T",a+=Na(this,o,t,r,s,i),a}toISODate({format:e="extended"}={}){return this.isValid?Ni(this,e==="extended"):null}toISOWeekDate(){return es(this,"kkkk-\'W\'WW-c")}toISOTime({suppressMilliseconds:e=!1,suppressSeconds:t=!1,includeOffset:r=!0,includePrefix:s=!1,extendedZone:i=!1,format:o="extended"}={}){return this.isValid?(s?"T":"")+Na(this,o==="extended",t,e,r,i):null}toRFC2822(){return es(this,"EEE, dd LLL yyyy HH:mm:ss ZZZ",!1)}toHTTP(){return es(this.toUTC(),"EEE, dd LLL yyyy HH:mm:ss \'GMT\'")}toSQLDate(){return this.isValid?Ni(this,!0):null}toSQLTime({includeOffset:e=!0,includeZone:t=!1,includeOffsetSpace:r=!0}={}){let s="HH:mm:ss.SSS";return(t||e)&&(r&&(s+=" "),t?s+="z":e&&(s+="ZZ")),es(this,s,!0)}toSQL(e={}){return this.isValid?`${this.toSQLDate()} ${this.toSQLTime(e)}`:null}toString(){return this.isValid?this.toISO():Ii}valueOf(){return this.toMillis()}toMillis(){return this.isValid?this.ts:NaN}toSeconds(){return this.isValid?this.ts/1e3:NaN}toUnixInteger(){return this.isValid?Math.floor(this.ts/1e3):NaN}toJSON(){return this.toISO()}toBSON(){return this.toJSDate()}toObject(e={}){if(!this.isValid)return{};let t=R({},this.c);return e.includeConfig&&(t.outputCalendar=this.outputCalendar,t.numberingSystem=this.loc.numberingSystem,t.locale=this.loc.locale),t}toJSDate(){return new Date(this.isValid?this.ts:NaN)}diff(e,t="milliseconds",r={}){if(!this.isValid||!e.isValid)return P.invalid("created by diffing an invalid DateTime");let s=R({locale:this.locale,numberingSystem:this.numberingSystem},r),i=$o(t).map(P.normalizeUnit),o=e.valueOf()>this.valueOf(),a=o?this:e,u=o?e:this,l=ma(a,u,i,s);return o?l.negate():l}diffNow(e="milliseconds",t={}){return this.diff(n.now(),e,t)}until(e){return this.isValid?pt.fromDateTimes(this,e):this}hasSame(e,t){if(!this.isValid)return!1;let r=e.valueOf(),s=this.setZone(e.zone,{keepLocalTime:!0});return s.startOf(t)<=r&&r<=s.endOf(t)}equals(e){return this.isValid&&e.isValid&&this.valueOf()===e.valueOf()&&this.zone.equals(e.zone)&&this.loc.equals(e.loc)}toRelative(e={}){if(!this.isValid)return null;let t=e.base||n.fromObject({},{zone:this.zone}),r=e.padding?this<t?-e.padding:e.padding:0,s=["years","months","days","hours","minutes","seconds"],i=e.unit;return Array.isArray(e.unit)&&(s=e.unit,i=void 0),_a(t,this.plus(r),De(R({},e),{numeric:"always",units:s,unit:i}))}toRelativeCalendar(e={}){return this.isValid?_a(e.base||n.fromObject({},{zone:this.zone}),this,De(R({},e),{numeric:"auto",units:["years","months","days"],calendary:!0})):null}static min(...e){if(!e.every(n.isDateTime))throw new le("min requires all arguments be DateTimes");return Xs(e,t=>t.valueOf(),Math.min)}static max(...e){if(!e.every(n.isDateTime))throw new le("max requires all arguments be DateTimes");return Xs(e,t=>t.valueOf(),Math.max)}static fromFormatExplain(e,t,r={}){let{locale:s=null,numberingSystem:i=null}=r,o=te.fromOpts({locale:s,numberingSystem:i,defaultToEN:!0});return ki(o,e,t)}static fromStringExplain(e,t,r={}){return n.fromFormatExplain(e,t,r)}static get DATE_SHORT(){return rn}static get DATE_MED(){return Bn}static get DATE_MED_WITH_WEEKDAY(){return Gs}static get DATE_FULL(){return Pn}static get DATE_HUGE(){return $n}static get TIME_SIMPLE(){return Rn}static get TIME_WITH_SECONDS(){return jn}static get TIME_WITH_SHORT_OFFSET(){return qn}static get TIME_WITH_LONG_OFFSET(){return Vn}static get TIME_24_SIMPLE(){return Un}static get TIME_24_WITH_SECONDS(){return Kn}static get TIME_24_WITH_SHORT_OFFSET(){return Wn}static get TIME_24_WITH_LONG_OFFSET(){return Hn}static get DATETIME_SHORT(){return Jn}static get DATETIME_SHORT_WITH_SECONDS(){return zn}static get DATETIME_MED(){return Yn}static get DATETIME_MED_WITH_SECONDS(){return Gn}static get DATETIME_MED_WITH_WEEKDAY(){return Zs}static get DATETIME_FULL(){return Zn}static get DATETIME_FULL_WITH_SECONDS(){return Qn}static get DATETIME_HUGE(){return Xn}static get DATETIME_HUGE_WITH_SECONDS(){return er}};function yn(n){if(V.isDateTime(n))return n;if(n&&n.valueOf&&Xe(n.valueOf()))return V.fromJSDate(n);if(n&&typeof n=="object")return V.fromObject(n);throw new le(`Unknown datetime argument: ${n}, of type ${typeof n}`)}var yt=Vr(ns());var gn=()=>/[#*0-9]\\uFE0F?\\u20E3|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26AA\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C8\\u26CF\\u26D1\\u26E9\\u26F0-\\u26F5\\u26F7\\u26F8\\u26FA\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2757\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B55\\u3030\\u303D\\u3297\\u3299]\\uFE0F?|[\\u261D\\u270C\\u270D](?:\\uD83C[\\uDFFB-\\uDFFF]|\\uFE0F)?|[\\u270A\\u270B](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u2693\\u26A1\\u26AB\\u26C5\\u26CE\\u26D4\\u26EA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2795-\\u2797\\u27B0\\u27BF\\u2B50]|\\u26D3\\uFE0F?(?:\\u200D\\uD83D\\uDCA5)?|\\u26F9(?:\\uD83C[\\uDFFB-\\uDFFF]|\\uFE0F)?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\u2764\\uFE0F?(?:\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79))?|\\uD83C(?:[\\uDC04\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]\\uFE0F?|[\\uDF85\\uDFC2\\uDFC7](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDFC4\\uDFCA](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDFCB\\uDFCC](?:\\uD83C[\\uDFFB-\\uDFFF]|\\uFE0F)?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF43\\uDF45-\\uDF4A\\uDF4C-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uDDE6\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF]|\\uDDE7\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF]|\\uDDE8\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF7\\uDDFA-\\uDDFF]|\\uDDE9\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF]|\\uDDEA\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA]|\\uDDEB\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7]|\\uDDEC\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE]|\\uDDED\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA]|\\uDDEE\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9]|\\uDDEF\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5]|\\uDDF0\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF]|\\uDDF1\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE]|\\uDDF2\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF]|\\uDDF3\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF]|\\uDDF4\\uD83C\\uDDF2|\\uDDF5\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE]|\\uDDF6\\uD83C\\uDDE6|\\uDDF7\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC]|\\uDDF8\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF]|\\uDDF9\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF]|\\uDDFA\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF]|\\uDDFB\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA]|\\uDDFC\\uD83C[\\uDDEB\\uDDF8]|\\uDDFD\\uD83C\\uDDF0|\\uDDFE\\uD83C[\\uDDEA\\uDDF9]|\\uDDFF\\uD83C[\\uDDE6\\uDDF2\\uDDFC]|\\uDF44(?:\\u200D\\uD83D\\uDFEB)?|\\uDF4B(?:\\u200D\\uD83D\\uDFE9)?|\\uDFC3(?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D(?:[\\u2640\\u2642]\\uFE0F?(?:\\u200D\\u27A1\\uFE0F?)?|\\u27A1\\uFE0F?))?|\\uDFF3\\uFE0F?(?:\\u200D(?:\\u26A7\\uFE0F?|\\uD83C\\uDF08))?|\\uDFF4(?:\\u200D\\u2620\\uFE0F?|\\uDB40\\uDC67\\uDB40\\uDC62\\uDB40(?:\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73)\\uDB40\\uDC7F)?)|\\uD83D(?:[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3]\\uFE0F?|[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4\\uDEB5](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDD74\\uDD90](?:\\uD83C[\\uDFFB-\\uDFFF]|\\uFE0F)?|[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC25\\uDC27-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE41\\uDE43\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEDC-\\uDEDF\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB\\uDFF0]|\\uDC08(?:\\u200D\\u2B1B)?|\\uDC15(?:\\u200D\\uD83E\\uDDBA)?|\\uDC26(?:\\u200D(?:\\u2B1B|\\uD83D\\uDD25))?|\\uDC3B(?:\\u200D\\u2744\\uFE0F?)?|\\uDC41\\uFE0F?(?:\\u200D\\uD83D\\uDDE8\\uFE0F?)?|\\uDC68(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDC68\\uDC69]\\u200D\\uD83D(?:\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?)|[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?)|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFC-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB-\\uDFFE])))?))?|\\uDC69(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?[\\uDC68\\uDC69]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?|\\uDC69\\u200D\\uD83D(?:\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?))|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFC-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB-\\uDFFE])))?))?|\\uDC6F(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\uDD75(?:\\uD83C[\\uDFFB-\\uDFFF]|\\uFE0F)?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\uDE2E(?:\\u200D\\uD83D\\uDCA8)?|\\uDE35(?:\\u200D\\uD83D\\uDCAB)?|\\uDE36(?:\\u200D\\uD83C\\uDF2B\\uFE0F?)?|\\uDE42(?:\\u200D[\\u2194\\u2195]\\uFE0F?)?|\\uDEB6(?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D(?:[\\u2640\\u2642]\\uFE0F?(?:\\u200D\\u27A1\\uFE0F?)?|\\u27A1\\uFE0F?))?)|\\uD83E(?:[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5\\uDEC3-\\uDEC5\\uDEF0\\uDEF2-\\uDEF8](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD\\uDDCF\\uDDD4\\uDDD6-\\uDDDD](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDDDE\\uDDDF](?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCC\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE7C\\uDE80-\\uDE89\\uDE8F-\\uDEC2\\uDEC6\\uDECE-\\uDEDC\\uDEDF-\\uDEE9]|\\uDD3C(?:\\u200D[\\u2640\\u2642]\\uFE0F?|\\uD83C[\\uDFFB-\\uDFFF])?|\\uDDCE(?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D(?:[\\u2640\\u2642]\\uFE0F?(?:\\u200D\\u27A1\\uFE0F?)?|\\u27A1\\uFE0F?))?|\\uDDD1(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1|\\uDDD1\\u200D\\uD83E\\uDDD2(?:\\u200D\\uD83E\\uDDD2)?|\\uDDD2(?:\\u200D\\uD83E\\uDDD2)?))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFC-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFD-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFD\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFE]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?))?|\\uDEF1(?:\\uD83C(?:\\uDFFB(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFC-\\uDFFF])?|\\uDFFC(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])?|\\uDFFD(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])?|\\uDFFE(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])?|\\uDFFF(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB-\\uDFFE])?))?)/g;function Mi(n){return n==null?n:n.shiftTo("years","months","weeks","days","hours","minutes","seconds","milliseconds").normalize()}function ja(n,e,t,r){return n.second==0&&n.minute==0&&n.hour==0?n.toLocal().toFormat(e,{locale:r}):n.toLocal().toFormat(t,{locale:r})}function qa(n){n=Mi(n);let e="";return n.years&&(e+=`${n.years} years, `),n.months&&(e+=`${n.months} months, `),n.weeks&&(e+=`${n.weeks} weeks, `),n.days&&(e+=`${n.days} days, `),n.hours&&(e+=`${n.hours} hours, `),n.minutes&&(e+=`${n.minutes} minutes, `),n.seconds&&(e+=`${Math.round(n.seconds)} seconds, `),n.milliseconds&&(e+=`${Math.round(n.milliseconds)} ms, `),e.endsWith(", ")&&(e=e.substring(0,e.length-2)),e}function bn(n){return n.includes("/")&&(n=n.substring(n.lastIndexOf("/")+1)),n.endsWith(".md")&&(n=n.substring(0,n.length-3)),n}function Va(n){return n.includes(".")?n.substring(n.lastIndexOf(".")+1):""}var Uc=yt.alt(yt.regex(new RegExp(gn(),"")),yt.regex(/[0-9\\p{Letter}_-]+/u),yt.whitespace.map(n=>" "),yt.any.map(n=>" ")).many().map(n=>n.join("").split(/\\s+/).join(" ").trim());function Ua(n){return Uc.tryParse(n)}var Oe=class n{static file(e,t=!1,r){return new n({path:e,embed:t,display:r,subpath:void 0,type:"file"})}static infer(e,t=!1,r){if(e.includes("#^")){let s=e.split("#^");return n.block(s[0],s[1],t,r)}else if(e.includes("#")){let s=e.split("#");return n.header(s[0],s[1],t,r)}else return n.file(e,t,r)}static header(e,t,r,s){return new n({path:e,embed:r,display:s,subpath:Ua(t),type:"header"})}static block(e,t,r,s){return new n({path:e,embed:r,display:s,subpath:t,type:"block"})}static fromObject(e){return new n(e)}static parseInner(e){let[t,r]=Kc(e);return n.infer(t,!1,r)}constructor(e){Object.assign(this,e)}withPath(e){return new n(Object.assign({},this,{path:e}))}withDisplay(e){return new n(Object.assign({},this,{display:e}))}withEmbed(e){return this.embed==e?this:new n(Object.assign({},this,{embed:e}))}withHeader(e){return n.header(this.path,e,this.embed,this.display)}withBlock(e){return n.block(this.path,e,this.embed,this.display)}equals(e){return e==null||e==null?!1:this.path==e.path&&this.type==e.type&&this.subpath==e.subpath}toString(){return this.markdown()}toObject(){return{path:this.path,type:this.type,subpath:this.subpath,display:this.display,embed:this.embed}}toFile(){return n.file(this.path,this.embed,this.display)}toEmbed(){return this.withEmbed(!0)}fromEmbed(){return this.withEmbed(!1)}markdown(){let e=(this.embed?"!":"")+"[["+this.obsidianLink();return e+="|",e+=this.displayOrDefault(),e+="]]",e}displayOrDefault(){if(this.display)return this.display;{let e=bn(this.path);return(this.type=="header"||this.type=="block")&&(e+=" > "+this.subpath),e}}obsidianLink(){var t,r;let e=this.path.replace("|","\\\\|");return this.type=="header"?e+"#"+((t=this.subpath)==null?void 0:t.replace("|","\\\\|")):this.type=="block"?e+"#^"+((r=this.subpath)==null?void 0:r.replace("|","\\\\|")):e}fileName(){return bn(this.path)}};function Kc(n){let e=-1;for(;(e=n.indexOf("|",e+1))>=0;)if(!(e>0&&n[e-1]=="\\\\"))return[n.substring(0,e).replace(/\\\\\\|/g,"|"),n.substring(e+1)];return[n.replace(/\\\\\\|/g,"|"),void 0]}var rs=Symbol.for("yaml.alias"),ss=Symbol.for("yaml.document"),Ve=Symbol.for("yaml.map"),_i=Symbol.for("yaml.pair"),xe=Symbol.for("yaml.scalar"),gt=Symbol.for("yaml.seq"),we=Symbol.for("yaml.node.type"),Ue=n=>!!n&&typeof n=="object"&&n[we]===rs,tt=n=>!!n&&typeof n=="object"&&n[we]===ss,Ke=n=>!!n&&typeof n=="object"&&n[we]===Ve,J=n=>!!n&&typeof n=="object"&&n[we]===_i,W=n=>!!n&&typeof n=="object"&&n[we]===xe,We=n=>!!n&&typeof n=="object"&&n[we]===gt;function Q(n){if(n&&typeof n=="object")switch(n[we]){case Ve:case gt:return!0}return!1}function z(n){if(n&&typeof n=="object")switch(n[we]){case rs:case Ve:case xe:case gt:return!0}return!1}var Ka=n=>(W(n)||Q(n))&&!!n.anchor;var ke=Symbol("break visit"),Wa=Symbol("skip children"),nt=Symbol("remove node");function He(n,e){let t=Ha(e);tt(n)?Fn(null,n.contents,t,Object.freeze([n]))===nt&&(n.contents=null):Fn(null,n,t,Object.freeze([]))}He.BREAK=ke;He.SKIP=Wa;He.REMOVE=nt;function Fn(n,e,t,r){let s=Ja(n,e,t,r);if(z(s)||J(s))return za(n,r,s),Fn(n,s,t,r);if(typeof s!="symbol"){if(Q(e)){r=Object.freeze(r.concat(e));for(let i=0;i<e.items.length;++i){let o=Fn(i,e.items[i],t,r);if(typeof o=="number")i=o-1;else{if(o===ke)return ke;o===nt&&(e.items.splice(i,1),i-=1)}}}else if(J(e)){r=Object.freeze(r.concat(e));let i=Fn("key",e.key,t,r);if(i===ke)return ke;i===nt&&(e.key=null);let o=Fn("value",e.value,t,r);if(o===ke)return ke;o===nt&&(e.value=null)}}return s}async function is(n,e){let t=Ha(e);tt(n)?await En(null,n.contents,t,Object.freeze([n]))===nt&&(n.contents=null):await En(null,n,t,Object.freeze([]))}is.BREAK=ke;is.SKIP=Wa;is.REMOVE=nt;async function En(n,e,t,r){let s=await Ja(n,e,t,r);if(z(s)||J(s))return za(n,r,s),En(n,s,t,r);if(typeof s!="symbol"){if(Q(e)){r=Object.freeze(r.concat(e));for(let i=0;i<e.items.length;++i){let o=await En(i,e.items[i],t,r);if(typeof o=="number")i=o-1;else{if(o===ke)return ke;o===nt&&(e.items.splice(i,1),i-=1)}}}else if(J(e)){r=Object.freeze(r.concat(e));let i=await En("key",e.key,t,r);if(i===ke)return ke;i===nt&&(e.key=null);let o=await En("value",e.value,t,r);if(o===ke)return ke;o===nt&&(e.value=null)}}return s}function Ha(n){return typeof n=="object"&&(n.Collection||n.Node||n.Value)?Object.assign({Alias:n.Node,Map:n.Node,Scalar:n.Node,Seq:n.Node},n.Value&&{Map:n.Value,Scalar:n.Value,Seq:n.Value},n.Collection&&{Map:n.Collection,Seq:n.Collection},n):n}function Ja(n,e,t,r){var s,i,o,a,u;if(typeof t=="function")return t(n,e,r);if(Ke(e))return(s=t.Map)==null?void 0:s.call(t,n,e,r);if(We(e))return(i=t.Seq)==null?void 0:i.call(t,n,e,r);if(J(e))return(o=t.Pair)==null?void 0:o.call(t,n,e,r);if(W(e))return(a=t.Scalar)==null?void 0:a.call(t,n,e,r);if(Ue(e))return(u=t.Alias)==null?void 0:u.call(t,n,e,r)}function za(n,e,t){let r=e[e.length-1];if(Q(r))r.items[n]=t;else if(J(r))n==="key"?r.key=t:r.value=t;else if(tt(r))r.contents=t;else{let s=Ue(r)?"alias":"scalar";throw new Error(`Cannot replace node with ${s} parent`)}}var Wc={"!":"%21",",":"%2C","[":"%5B","]":"%5D","{":"%7B","}":"%7D"},Hc=n=>n.replace(/[!,[\\]{}]/g,e=>Wc[e]),rt=class n{constructor(e,t){this.docStart=null,this.docEnd=!1,this.yaml=Object.assign({},n.defaultYaml,e),this.tags=Object.assign({},n.defaultTags,t)}clone(){let e=new n(this.yaml,this.tags);return e.docStart=this.docStart,e}atDocument(){let e=new n(this.yaml,this.tags);switch(this.yaml.version){case"1.1":this.atNextDocument=!0;break;case"1.2":this.atNextDocument=!1,this.yaml={explicit:n.defaultYaml.explicit,version:"1.2"},this.tags=Object.assign({},n.defaultTags);break}return e}add(e,t){this.atNextDocument&&(this.yaml={explicit:n.defaultYaml.explicit,version:"1.1"},this.tags=Object.assign({},n.defaultTags),this.atNextDocument=!1);let r=e.trim().split(/[ \\t]+/),s=r.shift();switch(s){case"%TAG":{if(r.length!==2&&(t(0,"%TAG directive should contain exactly two parts"),r.length<2))return!1;let[i,o]=r;return this.tags[i]=o,!0}case"%YAML":{if(this.yaml.explicit=!0,r.length!==1)return t(0,"%YAML directive should contain exactly one part"),!1;let[i]=r;if(i==="1.1"||i==="1.2")return this.yaml.version=i,!0;{let o=/^\\d+\\.\\d+$/.test(i);return t(6,`Unsupported YAML version ${i}`,o),!1}}default:return t(0,`Unknown directive ${s}`,!0),!1}}tagName(e,t){if(e==="!")return"!";if(e[0]!=="!")return t(`Not a valid tag: ${e}`),null;if(e[1]==="<"){let o=e.slice(2,-1);return o==="!"||o==="!!"?(t(`Verbatim tags aren\'t resolved, so ${e} is invalid.`),null):(e[e.length-1]!==">"&&t("Verbatim tags must end with a >"),o)}let[,r,s]=e.match(new RegExp("^(.*!)([^!]*)$","s"));s||t(`The ${e} tag has no suffix`);let i=this.tags[r];if(i)try{return i+decodeURIComponent(s)}catch(o){return t(String(o)),null}return r==="!"?e:(t(`Could not resolve tag: ${e}`),null)}tagString(e){for(let[t,r]of Object.entries(this.tags))if(e.startsWith(r))return t+Hc(e.substring(r.length));return e[0]==="!"?e:`!<${e}>`}toString(e){let t=this.yaml.explicit?[`%YAML ${this.yaml.version||"1.2"}`]:[],r=Object.entries(this.tags),s;if(e&&r.length>0&&z(e.contents)){let i={};He(e.contents,(o,a)=>{z(a)&&a.tag&&(i[a.tag]=!0)}),s=Object.keys(i)}else s=[];for(let[i,o]of r)i==="!!"&&o==="tag:yaml.org,2002:"||(!e||s.some(a=>a.startsWith(o)))&&t.push(`%TAG ${i} ${o}`);return t.join(`\n`)}};rt.defaultYaml={explicit:!1,version:"1.2"};rt.defaultTags={"!!":"tag:yaml.org,2002:"};function os(n){if(/[\\x00-\\x19\\s,[\\]{}]/.test(n)){let t=`Anchor must not contain whitespace or control characters: ${JSON.stringify(n)}`;throw new Error(t)}return!0}function Bi(n){let e=new Set;return He(n,{Value(t,r){r.anchor&&e.add(r.anchor)}}),e}function Pi(n,e){for(let t=1;;++t){let r=`${n}${t}`;if(!e.has(r))return r}}function Ya(n,e){let t=[],r=new Map,s=null;return{onAnchor:i=>{t.push(i),s||(s=Bi(n));let o=Pi(e,s);return s.add(o),o},setAnchors:()=>{for(let i of t){let o=r.get(i);if(typeof o=="object"&&o.anchor&&(W(o.node)||Q(o.node)))o.node.anchor=o.anchor;else{let a=new Error("Failed to resolve repeated object (this should not happen)");throw a.source=i,a}}},sourceObjects:r}}function Ct(n,e,t,r){if(r&&typeof r=="object")if(Array.isArray(r))for(let s=0,i=r.length;s<i;++s){let o=r[s],a=Ct(n,r,String(s),o);a===void 0?delete r[s]:a!==o&&(r[s]=a)}else if(r instanceof Map)for(let s of Array.from(r.keys())){let i=r.get(s),o=Ct(n,r,s,i);o===void 0?r.delete(s):o!==i&&r.set(s,o)}else if(r instanceof Set)for(let s of Array.from(r)){let i=Ct(n,r,s,s);i===void 0?r.delete(s):i!==s&&(r.delete(s),r.add(i))}else for(let[s,i]of Object.entries(r)){let o=Ct(n,r,s,i);o===void 0?delete r[s]:o!==i&&(r[s]=o)}return n.call(e,t,r)}function ue(n,e,t){if(Array.isArray(n))return n.map((r,s)=>ue(r,String(s),t));if(n&&typeof n.toJSON=="function"){if(!t||!Ka(n))return n.toJSON(e,t);let r={aliasCount:0,count:1,res:void 0};t.anchors.set(n,r),t.onCreate=i=>{r.res=i,delete t.onCreate};let s=n.toJSON(e,t);return t.onCreate&&t.onCreate(s),s}return typeof n=="bigint"&&!(t!=null&&t.keep)?Number(n):n}var vt=class{constructor(e){Object.defineProperty(this,we,{value:e})}clone(){let e=Object.create(Object.getPrototypeOf(this),Object.getOwnPropertyDescriptors(this));return this.range&&(e.range=this.range.slice()),e}toJS(e,{mapAsMap:t,maxAliasCount:r,onAnchor:s,reviver:i}={}){if(!tt(e))throw new TypeError("A document argument is required");let o={anchors:new Map,doc:e,keep:!0,mapAsMap:t===!0,mapKeyWarned:!1,maxAliasCount:typeof r=="number"?r:100},a=ue(this,"",o);if(typeof s=="function")for(let{count:u,res:l}of o.anchors.values())s(l,u);return typeof i=="function"?Ct(i,{"":a},"",a):a}};var bt=class extends vt{constructor(e){super(rs),this.source=e,Object.defineProperty(this,"tag",{set(){throw new Error("Alias nodes cannot have tags")}})}resolve(e){let t;return He(e,{Node:(r,s)=>{if(s===this)return He.BREAK;s.anchor===this.source&&(t=s)}}),t}toJSON(e,t){if(!t)return{source:this.source};let{anchors:r,doc:s,maxAliasCount:i}=t,o=this.resolve(s);if(!o){let u=`Unresolved alias (the anchor must be set before the alias): ${this.source}`;throw new ReferenceError(u)}let a=r.get(o);if(a||(ue(o,null,t),a=r.get(o)),!a||a.res===void 0){let u="This should not happen: Alias anchor was not resolved?";throw new ReferenceError(u)}if(i>=0&&(a.count+=1,a.aliasCount===0&&(a.aliasCount=as(s,o,r)),a.count*a.aliasCount>i)){let u="Excessive alias count indicates a resource exhaustion attack";throw new ReferenceError(u)}return a.res}toString(e,t,r){let s=`*${this.source}`;if(e){if(os(this.source),e.options.verifyAliasOrder&&!e.anchors.has(this.source)){let i=`Unresolved alias (the anchor must be set before the alias): ${this.source}`;throw new Error(i)}if(e.implicitKey)return`${s} `}return s}};function as(n,e,t){if(Ue(e)){let r=e.resolve(n),s=t&&r&&t.get(r);return s?s.count*s.aliasCount:0}else if(Q(e)){let r=0;for(let s of e.items){let i=as(n,s,t);i>r&&(r=i)}return r}else if(J(e)){let r=as(n,e.key,t),s=as(n,e.value,t);return Math.max(r,s)}return 1}var us=n=>!n||typeof n!="function"&&typeof n!="object",$=class extends vt{constructor(e){super(xe),this.value=e}toJSON(e,t){return t!=null&&t.keep?this.value:ue(this.value,e,t)}toString(){return String(this.value)}};$.BLOCK_FOLDED="BLOCK_FOLDED";$.BLOCK_LITERAL="BLOCK_LITERAL";$.PLAIN="PLAIN";$.QUOTE_DOUBLE="QUOTE_DOUBLE";$.QUOTE_SINGLE="QUOTE_SINGLE";var Jc="tag:yaml.org,2002:";function zc(n,e,t){var r;if(e){let s=t.filter(o=>o.tag===e),i=(r=s.find(o=>!o.format))!=null?r:s[0];if(!i)throw new Error(`Tag ${e} not found`);return i}return t.find(s=>{var i;return((i=s.identify)==null?void 0:i.call(s,n))&&!s.format})}function Ft(n,e,t){var d,m,h;if(tt(n)&&(n=n.contents),z(n))return n;if(J(n)){let b=(m=(d=t.schema[Ve]).createNode)==null?void 0:m.call(d,t.schema,null,t);return b.items.push(n),b}(n instanceof String||n instanceof Number||n instanceof Boolean||typeof BigInt!="undefined"&&n instanceof BigInt)&&(n=n.valueOf());let{aliasDuplicateObjects:r,onAnchor:s,onTagObj:i,schema:o,sourceObjects:a}=t,u;if(r&&n&&typeof n=="object"){if(u=a.get(n),u)return u.anchor||(u.anchor=s(n)),new bt(u.anchor);u={anchor:null,node:null},a.set(n,u)}e!=null&&e.startsWith("!!")&&(e=Jc+e.slice(2));let l=zc(n,e,o.tags);if(!l){if(n&&typeof n.toJSON=="function"&&(n=n.toJSON()),!n||typeof n!="object"){let b=new $(n);return u&&(u.node=b),b}l=n instanceof Map?o[Ve]:Symbol.iterator in Object(n)?o[gt]:o[Ve]}i&&(i(l),delete t.onTagObj);let f=l!=null&&l.createNode?l.createNode(t.schema,n,t):typeof((h=l==null?void 0:l.nodeClass)==null?void 0:h.from)=="function"?l.nodeClass.from(t.schema,n,t):new $(n);return e?f.tag=e:l.default||(f.tag=l.tag),u&&(u.node=f),f}function hr(n,e,t){let r=t;for(let s=e.length-1;s>=0;--s){let i=e[s];if(typeof i=="number"&&Number.isInteger(i)&&i>=0){let o=[];o[i]=r,r=o}else r=new Map([[i,r]])}return Ft(r,void 0,{aliasDuplicateObjects:!1,keepUndefined:!1,onAnchor:()=>{throw new Error("This should not happen, please report a bug.")},schema:n,sourceObjects:new Map})}var Tn=n=>n==null||typeof n=="object"&&!!n[Symbol.iterator]().next().done,wn=class extends vt{constructor(e,t){super(e),Object.defineProperty(this,"schema",{value:t,configurable:!0,enumerable:!1,writable:!0})}clone(e){let t=Object.create(Object.getPrototypeOf(this),Object.getOwnPropertyDescriptors(this));return e&&(t.schema=e),t.items=t.items.map(r=>z(r)||J(r)?r.clone(e):r),this.range&&(t.range=this.range.slice()),t}addIn(e,t){if(Tn(e))this.add(t);else{let[r,...s]=e,i=this.get(r,!0);if(Q(i))i.addIn(s,t);else if(i===void 0&&this.schema)this.set(r,hr(this.schema,s,t));else throw new Error(`Expected YAML collection at ${r}. Remaining path: ${s}`)}}deleteIn(e){let[t,...r]=e;if(r.length===0)return this.delete(t);let s=this.get(t,!0);if(Q(s))return s.deleteIn(r);throw new Error(`Expected YAML collection at ${t}. Remaining path: ${r}`)}getIn(e,t){let[r,...s]=e,i=this.get(r,!0);return s.length===0?!t&&W(i)?i.value:i:Q(i)?i.getIn(s,t):void 0}hasAllNullValues(e){return this.items.every(t=>{if(!J(t))return!1;let r=t.value;return r==null||e&&W(r)&&r.value==null&&!r.commentBefore&&!r.comment&&!r.tag})}hasIn(e){let[t,...r]=e;if(r.length===0)return this.has(t);let s=this.get(t,!0);return Q(s)?s.hasIn(r):!1}setIn(e,t){let[r,...s]=e;if(s.length===0)this.set(r,t);else{let i=this.get(r,!0);if(Q(i))i.setIn(s,t);else if(i===void 0&&this.schema)this.set(r,hr(this.schema,s,t));else throw new Error(`Expected YAML collection at ${r}. Remaining path: ${s}`)}}};var Ga=n=>n.replace(/^(?!$)(?: $)?/gm,"#");function Be(n,e){return/^\\n+$/.test(n)?n.substring(1):e?n.replace(/^(?! *$)/gm,e):n}var st=(n,e,t)=>n.endsWith(`\n`)?Be(t,e):t.includes(`\n`)?`\n`+Be(t,e):(n.endsWith(" ")?"":" ")+t;var $i="flow",ls="block",mr="quoted";function pr(n,e,t="flow",{indentAtStart:r,lineWidth:s=80,minContentWidth:i=20,onFold:o,onOverflow:a}={}){if(!s||s<0)return n;s<i&&(i=0);let u=Math.max(1+i,1+s-e.length);if(n.length<=u)return n;let l=[],f={},d=s-e.length;typeof r=="number"&&(r>s-Math.max(2,i)?l.push(0):d=s-r);let m,h,b=!1,g=-1,D=-1,T=-1;t===ls&&(g=Za(n,g,e.length),g!==-1&&(d=g+u));for(let N;N=n[g+=1];){if(t===mr&&N==="\\\\"){switch(D=g,n[g+1]){case"x":g+=3;break;case"u":g+=5;break;case"U":g+=9;break;default:g+=1}T=g}if(N===`\n`)t===ls&&(g=Za(n,g,e.length)),d=g+e.length+u,m=void 0;else{if(N===" "&&h&&h!==" "&&h!==`\n`&&h!=="	"){let y=n[g+1];y&&y!==" "&&y!==`\n`&&y!=="	"&&(m=g)}if(g>=d)if(m)l.push(m),d=m+u,m=void 0;else if(t===mr){for(;h===" "||h==="	";)h=N,N=n[g+=1],b=!0;let y=g>T+1?g-2:D-1;if(f[y])return n;l.push(y),f[y]=!0,d=y+u,m=void 0}else b=!0}h=N}if(b&&a&&a(),l.length===0)return n;o&&o();let I=n.slice(0,l[0]);for(let N=0;N<l.length;++N){let y=l[N],w=l[N+1]||n.length;y===0?I=`\n${e}${n.slice(0,w)}`:(t===mr&&f[y]&&(I+=`${n[y]}\\\\`),I+=`\n${e}${n.slice(y+1,w)}`)}return I}function Za(n,e,t){let r=e,s=e+1,i=n[s];for(;i===" "||i==="	";)if(e<s+t)i=n[++e];else{do i=n[++e];while(i&&i!==`\n`);r=e,s=e+1,i=n[s]}return r}var fs=(n,e)=>({indentAtStart:e?n.indent.length:n.indentAtStart,lineWidth:n.options.lineWidth,minContentWidth:n.options.minContentWidth}),ds=n=>/^(%|---|\\.\\.\\.)/m.test(n);function Yc(n,e,t){if(!e||e<0)return!1;let r=e-t,s=n.length;if(s<=r)return!1;for(let i=0,o=0;i<s;++i)if(n[i]===`\n`){if(i-o>r)return!0;if(o=i+1,s-o<=r)return!1}return!0}function Dr(n,e){let t=JSON.stringify(n);if(e.options.doubleQuotedAsJSON)return t;let{implicitKey:r}=e,s=e.options.doubleQuotedMinMultiLineLength,i=e.indent||(ds(n)?"  ":""),o="",a=0;for(let u=0,l=t[u];l;l=t[++u])if(l===" "&&t[u+1]==="\\\\"&&t[u+2]==="n"&&(o+=t.slice(a,u)+"\\\\ ",u+=1,a=u,l="\\\\"),l==="\\\\")switch(t[u+1]){case"u":{o+=t.slice(a,u);let f=t.substr(u+2,4);switch(f){case"0000":o+="\\\\0";break;case"0007":o+="\\\\a";break;case"000b":o+="\\\\v";break;case"001b":o+="\\\\e";break;case"0085":o+="\\\\N";break;case"00a0":o+="\\\\_";break;case"2028":o+="\\\\L";break;case"2029":o+="\\\\P";break;default:f.substr(0,2)==="00"?o+="\\\\x"+f.substr(2):o+=t.substr(u,6)}u+=5,a=u+1}break;case"n":if(r||t[u+2]===\'"\'||t.length<s)u+=1;else{for(o+=t.slice(a,u)+`\n\n`;t[u+2]==="\\\\"&&t[u+3]==="n"&&t[u+4]!==\'"\';)o+=`\n`,u+=2;o+=i,t[u+2]===" "&&(o+="\\\\"),u+=1,a=u+1}break;default:u+=1}return o=a?o+t.slice(a):t,r?o:pr(o,i,mr,fs(e,!1))}function Ri(n,e){if(e.options.singleQuote===!1||e.implicitKey&&n.includes(`\n`)||/[ \\t]\\n|\\n[ \\t]/.test(n))return Dr(n,e);let t=e.indent||(ds(n)?"  ":""),r="\'"+n.replace(/\'/g,"\'\'").replace(/\\n+/g,`$&\n${t}`)+"\'";return e.implicitKey?r:pr(r,t,$i,fs(e,!1))}function Sn(n,e){let{singleQuote:t}=e.options,r;if(t===!1)r=Dr;else{let s=n.includes(\'"\'),i=n.includes("\'");s&&!i?r=Ri:i&&!s?r=Dr:r=t?Ri:Dr}return r(n,e)}var ji;try{ji=new RegExp(`(^|(?<!\n))\n+(?!\n|$)`,"g")}catch(n){ji=/\\n+(?!\\n|$)/g}function cs({comment:n,type:e,value:t},r,s,i){let{blockQuote:o,commentString:a,lineWidth:u}=r.options;if(!o||/\\n[\\t ]+$/.test(t)||/^\\s*$/.test(t))return Sn(t,r);let l=r.indent||(r.forceBlockIndent||ds(t)?"  ":""),f=o==="literal"?!0:o==="folded"||e===$.BLOCK_FOLDED?!1:e===$.BLOCK_LITERAL?!0:!Yc(t,u,l.length);if(!t)return f?`|\n`:`>\n`;let d,m;for(m=t.length;m>0;--m){let v=t[m-1];if(v!==`\n`&&v!=="	"&&v!==" ")break}let h=t.substring(m),b=h.indexOf(`\n`);b===-1?d="-":t===h||b!==h.length-1?(d="+",i&&i()):d="",h&&(t=t.slice(0,-h.length),h[h.length-1]===`\n`&&(h=h.slice(0,-1)),h=h.replace(ji,`$&${l}`));let g=!1,D,T=-1;for(D=0;D<t.length;++D){let v=t[D];if(v===" ")g=!0;else if(v===`\n`)T=D;else break}let I=t.substring(0,T<D?T+1:D);I&&(t=t.substring(I.length),I=I.replace(/\\n+/g,`$&${l}`));let y=(f?"|":">")+(g?l?"2":"1":"")+d;if(n&&(y+=" "+a(n.replace(/ ?[\\r\\n]+/g," ")),s&&s()),f)return t=t.replace(/\\n+/g,`$&${l}`),`${y}\n${l}${I}${t}${h}`;t=t.replace(/\\n+/g,`\n$&`).replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g,"$1$2").replace(/\\n+/g,`$&${l}`);let w=pr(`${I}${t}${h}`,l,ls,fs(r,!0));return`${y}\n${l}${w}`}function Gc(n,e,t,r){let{type:s,value:i}=n,{actualString:o,implicitKey:a,indent:u,indentStep:l,inFlow:f}=e;if(a&&i.includes(`\n`)||f&&/[[\\]{},]/.test(i))return Sn(i,e);if(!i||/^[\\n\\t ,[\\]{}#&*!|>\'"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(i))return a||f||!i.includes(`\n`)?Sn(i,e):cs(n,e,t,r);if(!a&&!f&&s!==$.PLAIN&&i.includes(`\n`))return cs(n,e,t,r);if(ds(i)){if(u==="")return e.forceBlockIndent=!0,cs(n,e,t,r);if(a&&u===l)return Sn(i,e)}let d=i.replace(/\\n+/g,`$&\n${u}`);if(o){let m=g=>{var D;return g.default&&g.tag!=="tag:yaml.org,2002:str"&&((D=g.test)==null?void 0:D.test(d))},{compat:h,tags:b}=e.doc.schema;if(b.some(m)||h!=null&&h.some(m))return Sn(i,e)}return a?d:pr(d,u,$i,fs(e,!1))}function Ut(n,e,t,r){let{implicitKey:s,inFlow:i}=e,o=typeof n.value=="string"?n:Object.assign({},n,{value:String(n.value)}),{type:a}=n;a!==$.QUOTE_DOUBLE&&/[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f\\u{D800}-\\u{DFFF}]/u.test(o.value)&&(a=$.QUOTE_DOUBLE);let u=f=>{switch(f){case $.BLOCK_FOLDED:case $.BLOCK_LITERAL:return s||i?Sn(o.value,e):cs(o,e,t,r);case $.QUOTE_DOUBLE:return Dr(o.value,e);case $.QUOTE_SINGLE:return Ri(o.value,e);case $.PLAIN:return Gc(o,e,t,r);default:return null}},l=u(a);if(l===null){let{defaultKeyType:f,defaultStringType:d}=e.options,m=s&&f||d;if(l=u(m),l===null)throw new Error(`Unsupported default string type ${m}`)}return l}function hs(n,e){let t=Object.assign({blockQuote:!0,commentString:Ga,defaultKeyType:null,defaultStringType:"PLAIN",directives:null,doubleQuotedAsJSON:!1,doubleQuotedMinMultiLineLength:40,falseStr:"false",flowCollectionPadding:!0,indentSeq:!0,lineWidth:80,minContentWidth:20,nullStr:"null",simpleKeys:!1,singleQuote:null,trueStr:"true",verifyAliasOrder:!0},n.schema.toStringOptions,e),r;switch(t.collectionStyle){case"block":r=!1;break;case"flow":r=!0;break;default:r=null}return{anchors:new Set,doc:n,flowCollectionPadding:t.flowCollectionPadding?" ":"",indent:"",indentStep:typeof t.indent=="number"?" ".repeat(t.indent):"  ",inFlow:r,options:t}}function Zc(n,e){var s,i,o,a;if(e.tag){let u=n.filter(l=>l.tag===e.tag);if(u.length>0)return(s=u.find(l=>l.format===e.format))!=null?s:u[0]}let t,r;if(W(e)){r=e.value;let u=n.filter(l=>{var f;return(f=l.identify)==null?void 0:f.call(l,r)});if(u.length>1){let l=u.filter(f=>f.test);l.length>0&&(u=l)}t=(i=u.find(l=>l.format===e.format))!=null?i:u.find(l=>!l.format)}else r=e,t=n.find(u=>u.nodeClass&&r instanceof u.nodeClass);if(!t){let u=(a=(o=r==null?void 0:r.constructor)==null?void 0:o.name)!=null?a:typeof r;throw new Error(`Tag not resolved for ${u} value`)}return t}function Qc(n,e,{anchors:t,doc:r}){if(!r.directives)return"";let s=[],i=(W(n)||Q(n))&&n.anchor;i&&os(i)&&(t.add(i),s.push(`&${i}`));let o=n.tag?n.tag:e.default?null:e.tag;return o&&s.push(r.directives.tagString(o)),s.join(" ")}function Et(n,e,t,r){var u,l;if(J(n))return n.toString(e,t,r);if(Ue(n)){if(e.doc.directives)return n.toString(e);if((u=e.resolvedAliases)!=null&&u.has(n))throw new TypeError("Cannot stringify circular structure without alias nodes");e.resolvedAliases?e.resolvedAliases.add(n):e.resolvedAliases=new Set([n]),n=n.resolve(e.doc)}let s,i=z(n)?n:e.doc.createNode(n,{onTagObj:f=>s=f});s||(s=Zc(e.doc.schema.tags,i));let o=Qc(i,s,e);o.length>0&&(e.indentAtStart=((l=e.indentAtStart)!=null?l:0)+o.length+1);let a=typeof s.stringify=="function"?s.stringify(i,e,t,r):W(i)?Ut(i,e,t,r):i.toString(e,t,r);return o?W(i)||a[0]==="{"||a[0]==="["?`${o} ${a}`:`${o}\n${e.indent}${a}`:a}function Qa({key:n,value:e},t,r,s){var O,C;let{allNullValues:i,doc:o,indent:a,indentStep:u,options:{commentString:l,indentSeq:f,simpleKeys:d}}=t,m=z(n)&&n.comment||null;if(d){if(m)throw new Error("With simple keys, key nodes cannot have comments");if(Q(n)||!z(n)&&typeof n=="object"){let U="With simple keys, collection cannot be used as a key value";throw new Error(U)}}let h=!d&&(!n||m&&e==null&&!t.inFlow||Q(n)||(W(n)?n.type===$.BLOCK_FOLDED||n.type===$.BLOCK_LITERAL:typeof n=="object"));t=Object.assign({},t,{allNullValues:!1,implicitKey:!h&&(d||!i),indent:a+u});let b=!1,g=!1,D=Et(n,t,()=>b=!0,()=>g=!0);if(!h&&!t.inFlow&&D.length>1024){if(d)throw new Error("With simple keys, single line scalar must not span more than 1024 characters");h=!0}if(t.inFlow){if(i||e==null)return b&&r&&r(),D===""?"?":h?`? ${D}`:D}else if(i&&!d||e==null&&h)return D=`? ${D}`,m&&!b?D+=st(D,t.indent,l(m)):g&&s&&s(),D;b&&(m=null),h?(m&&(D+=st(D,t.indent,l(m))),D=`? ${D}\n${a}:`):(D=`${D}:`,m&&(D+=st(D,t.indent,l(m))));let T,I,N;z(e)?(T=!!e.spaceBefore,I=e.commentBefore,N=e.comment):(T=!1,I=null,N=null,e&&typeof e=="object"&&(e=o.createNode(e))),t.implicitKey=!1,!h&&!m&&W(e)&&(t.indentAtStart=D.length+1),g=!1,!f&&u.length>=2&&!t.inFlow&&!h&&We(e)&&!e.flow&&!e.tag&&!e.anchor&&(t.indent=t.indent.substring(2));let y=!1,w=Et(e,t,()=>y=!0,()=>g=!0),v=" ";if(m||T||I){if(v=T?`\n`:"",I){let U=l(I);v+=`\n${Be(U,t.indent)}`}w===""&&!t.inFlow?v===`\n`&&(v=`\n\n`):v+=`\n${t.indent}`}else if(!h&&Q(e)){let U=w[0],j=w.indexOf(`\n`),G=j!==-1,x=(C=(O=t.inFlow)!=null?O:e.flow)!=null?C:e.items.length===0;if(G||!x){let B=!1;if(G&&(U==="&"||U==="!")){let q=w.indexOf(" ");U==="&"&&q!==-1&&q<j&&w[q+1]==="!"&&(q=w.indexOf(" ",q+1)),(q===-1||j<q)&&(B=!0)}B||(v=`\n${t.indent}`)}}else(w===""||w[0]===`\n`)&&(v="");return D+=v+w,t.inFlow?y&&r&&r():N&&!y?D+=st(D,t.indent,l(N)):g&&s&&s(),D}function ms(n,e){(n==="debug"||n==="warn")&&(typeof process!="undefined"&&process.emitWarning?process.emitWarning(e):console.warn(e))}var ps="<<",Je={identify:n=>n===ps||typeof n=="symbol"&&n.description===ps,default:"key",tag:"tag:yaml.org,2002:merge",test:/^<<$/,resolve:()=>Object.assign(new $(Symbol(ps)),{addToJSMap:Vi}),stringify:()=>ps},Xa=(n,e)=>(Je.identify(e)||W(e)&&(!e.type||e.type===$.PLAIN)&&Je.identify(e.value))&&(n==null?void 0:n.doc.schema.tags.some(t=>t.tag===Je.tag&&t.default));function Vi(n,e,t){if(t=n&&Ue(t)?t.resolve(n.doc):t,We(t))for(let r of t.items)qi(n,e,r);else if(Array.isArray(t))for(let r of t)qi(n,e,r);else qi(n,e,t)}function qi(n,e,t){let r=n&&Ue(t)?t.resolve(n.doc):t;if(!Ke(r))throw new Error("Merge sources must be maps or map aliases");let s=r.toJSON(null,n,Map);for(let[i,o]of s)e instanceof Map?e.has(i)||e.set(i,o):e instanceof Set?e.add(i):Object.prototype.hasOwnProperty.call(e,i)||Object.defineProperty(e,i,{value:o,writable:!0,enumerable:!0,configurable:!0});return e}function Ds(n,e,{key:t,value:r}){if(z(t)&&t.addToJSMap)t.addToJSMap(n,e,r);else if(Xa(n,t))Vi(n,e,r);else{let s=ue(t,"",n);if(e instanceof Map)e.set(s,ue(r,s,n));else if(e instanceof Set)e.add(s);else{let i=Xc(t,s,n),o=ue(r,i,n);i in e?Object.defineProperty(e,i,{value:o,writable:!0,enumerable:!0,configurable:!0}):e[i]=o}}return e}function Xc(n,e,t){if(e===null)return"";if(typeof e!="object")return String(e);if(z(n)&&(t!=null&&t.doc)){let r=hs(t.doc,{});r.anchors=new Set;for(let i of t.anchors.keys())r.anchors.add(i.anchor);r.inFlow=!0,r.inStringifyKey=!0;let s=n.toString(r);if(!t.mapKeyWarned){let i=JSON.stringify(s);i.length>40&&(i=i.substring(0,36)+\'..."\'),ms(t.doc.options.logLevel,`Keys with collection values will be stringified due to JS Object restrictions: ${i}. Set mapAsMap: true to use object keys.`),t.mapKeyWarned=!0}return s}return JSON.stringify(e)}function kn(n,e,t){let r=Ft(n,void 0,t),s=Ft(e,void 0,t);return new se(r,s)}var se=class n{constructor(e,t=null){Object.defineProperty(this,we,{value:_i}),this.key=e,this.value=t}clone(e){let{key:t,value:r}=this;return z(t)&&(t=t.clone(e)),z(r)&&(r=r.clone(e)),new n(t,r)}toJSON(e,t){let r=t!=null&&t.mapAsMap?new Map:{};return Ds(t,r,this)}toString(e,t,r){return e!=null&&e.doc?Qa(this,e,t,r):JSON.stringify(this)}};function gs(n,e,t){var i;return(((i=e.inFlow)!=null?i:n.flow)?tf:ef)(n,e,t)}function ef({comment:n,items:e},t,{blockItemPrefix:r,flowChars:s,itemIndent:i,onChompKeep:o,onComment:a}){let{indent:u,options:{commentString:l}}=t,f=Object.assign({},t,{indent:i,type:null}),d=!1,m=[];for(let b=0;b<e.length;++b){let g=e[b],D=null;if(z(g))!d&&g.spaceBefore&&m.push(""),ys(t,m,g.commentBefore,d),g.comment&&(D=g.comment);else if(J(g)){let I=z(g.key)?g.key:null;I&&(!d&&I.spaceBefore&&m.push(""),ys(t,m,I.commentBefore,d))}d=!1;let T=Et(g,f,()=>D=null,()=>d=!0);D&&(T+=st(T,i,l(D))),d&&D&&(d=!1),m.push(r+T)}let h;if(m.length===0)h=s.start+s.end;else{h=m[0];for(let b=1;b<m.length;++b){let g=m[b];h+=g?`\n${u}${g}`:`\n`}}return n?(h+=`\n`+Be(l(n),u),a&&a()):d&&o&&o(),h}function tf({items:n},e,{flowChars:t,itemIndent:r}){let{indent:s,indentStep:i,flowCollectionPadding:o,options:{commentString:a}}=e;r+=i;let u=Object.assign({},e,{indent:r,inFlow:!0,type:null}),l=!1,f=0,d=[];for(let b=0;b<n.length;++b){let g=n[b],D=null;if(z(g))g.spaceBefore&&d.push(""),ys(e,d,g.commentBefore,!1),g.comment&&(D=g.comment);else if(J(g)){let I=z(g.key)?g.key:null;I&&(I.spaceBefore&&d.push(""),ys(e,d,I.commentBefore,!1),I.comment&&(l=!0));let N=z(g.value)?g.value:null;N?(N.comment&&(D=N.comment),N.commentBefore&&(l=!0)):g.value==null&&(I!=null&&I.comment)&&(D=I.comment)}D&&(l=!0);let T=Et(g,u,()=>D=null);b<n.length-1&&(T+=","),D&&(T+=st(T,r,a(D))),!l&&(d.length>f||T.includes(`\n`))&&(l=!0),d.push(T),f=d.length}let{start:m,end:h}=t;if(d.length===0)return m+h;if(!l){let b=d.reduce((g,D)=>g+D.length+2,2);l=e.options.lineWidth>0&&b>e.options.lineWidth}if(l){let b=m;for(let g of d)b+=g?`\n${i}${s}${g}`:`\n`;return`${b}\n${s}${h}`}else return`${m}${o}${d.join(" ")}${o}${h}`}function ys({indent:n,options:{commentString:e}},t,r,s){if(r&&s&&(r=r.replace(/^\\n+/,"")),r){let i=Be(e(r),n);t.push(i.trimStart())}}function Ot(n,e){let t=W(e)?e.value:e;for(let r of n)if(J(r)&&(r.key===e||r.key===t||W(r.key)&&r.key.value===t))return r}var ie=class extends wn{static get tagName(){return"tag:yaml.org,2002:map"}constructor(e){super(Ve,e),this.items=[]}static from(e,t,r){let{keepUndefined:s,replacer:i}=r,o=new this(e),a=(u,l)=>{if(typeof i=="function")l=i.call(t,u,l);else if(Array.isArray(i)&&!i.includes(u))return;(l!==void 0||s)&&o.items.push(kn(u,l,r))};if(t instanceof Map)for(let[u,l]of t)a(u,l);else if(t&&typeof t=="object")for(let u of Object.keys(t))a(u,t[u]);return typeof e.sortMapEntries=="function"&&o.items.sort(e.sortMapEntries),o}add(e,t){var o;let r;J(e)?r=e:!e||typeof e!="object"||!("key"in e)?r=new se(e,e==null?void 0:e.value):r=new se(e.key,e.value);let s=Ot(this.items,r.key),i=(o=this.schema)==null?void 0:o.sortMapEntries;if(s){if(!t)throw new Error(`Key ${r.key} already set`);W(s.value)&&us(r.value)?s.value.value=r.value:s.value=r.value}else if(i){let a=this.items.findIndex(u=>i(r,u)<0);a===-1?this.items.push(r):this.items.splice(a,0,r)}else this.items.push(r)}delete(e){let t=Ot(this.items,e);return t?this.items.splice(this.items.indexOf(t),1).length>0:!1}get(e,t){var i;let r=Ot(this.items,e),s=r==null?void 0:r.value;return(i=!t&&W(s)?s.value:s)!=null?i:void 0}has(e){return!!Ot(this.items,e)}set(e,t){this.add(new se(e,t),!0)}toJSON(e,t,r){let s=r?new r:t!=null&&t.mapAsMap?new Map:{};t!=null&&t.onCreate&&t.onCreate(s);for(let i of this.items)Ds(t,s,i);return s}toString(e,t,r){if(!e)return JSON.stringify(this);for(let s of this.items)if(!J(s))throw new Error(`Map items must all be pairs; found ${JSON.stringify(s)} instead`);return!e.allNullValues&&this.hasAllNullValues(!1)&&(e=Object.assign({},e,{allNullValues:!0})),gs(this,e,{blockItemPrefix:"",flowChars:{start:"{",end:"}"},itemIndent:e.indent||"",onChompKeep:r,onComment:t})}};var ze={collection:"map",default:!0,nodeClass:ie,tag:"tag:yaml.org,2002:map",resolve(n,e){return Ke(n)||e("Expected a mapping for this tag"),n},createNode:(n,e,t)=>ie.from(n,e,t)};var ge=class extends wn{static get tagName(){return"tag:yaml.org,2002:seq"}constructor(e){super(gt,e),this.items=[]}add(e){this.items.push(e)}delete(e){let t=bs(e);return typeof t!="number"?!1:this.items.splice(t,1).length>0}get(e,t){let r=bs(e);if(typeof r!="number")return;let s=this.items[r];return!t&&W(s)?s.value:s}has(e){let t=bs(e);return typeof t=="number"&&t<this.items.length}set(e,t){let r=bs(e);if(typeof r!="number")throw new Error(`Expected a valid index, not ${e}.`);let s=this.items[r];W(s)&&us(t)?s.value=t:this.items[r]=t}toJSON(e,t){let r=[];t!=null&&t.onCreate&&t.onCreate(r);let s=0;for(let i of this.items)r.push(ue(i,String(s++),t));return r}toString(e,t,r){return e?gs(this,e,{blockItemPrefix:"- ",flowChars:{start:"[",end:"]"},itemIndent:(e.indent||"")+"  ",onChompKeep:r,onComment:t}):JSON.stringify(this)}static from(e,t,r){let{replacer:s}=r,i=new this(e);if(t&&Symbol.iterator in Object(t)){let o=0;for(let a of t){if(typeof s=="function"){let u=t instanceof Set?a:String(o++);a=s.call(t,u,a)}i.items.push(Ft(a,void 0,r))}}return i}};function bs(n){let e=W(n)?n.value:n;return e&&typeof e=="string"&&(e=Number(e)),typeof e=="number"&&Number.isInteger(e)&&e>=0?e:null}var Ye={collection:"seq",default:!0,nodeClass:ge,tag:"tag:yaml.org,2002:seq",resolve(n,e){return We(n)||e("Expected a sequence for this tag"),n},createNode:(n,e,t)=>ge.from(n,e,t)};var xt={identify:n=>typeof n=="string",default:!0,tag:"tag:yaml.org,2002:str",resolve:n=>n,stringify(n,e,t,r){return e=Object.assign({actualString:!0},e),Ut(n,e,t,r)}};var Kt={identify:n=>n==null,createNode:()=>new $(null),default:!0,tag:"tag:yaml.org,2002:null",test:/^(?:~|[Nn]ull|NULL)?$/,resolve:()=>new $(null),stringify:({source:n},e)=>typeof n=="string"&&Kt.test.test(n)?n:e.options.nullStr};var yr={identify:n=>typeof n=="boolean",default:!0,tag:"tag:yaml.org,2002:bool",test:/^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,resolve:n=>new $(n[0]==="t"||n[0]==="T"),stringify({source:n,value:e},t){if(n&&yr.test.test(n)){let r=n[0]==="t"||n[0]==="T";if(e===r)return n}return e?t.options.trueStr:t.options.falseStr}};function be({format:n,minFractionDigits:e,tag:t,value:r}){if(typeof r=="bigint")return String(r);let s=typeof r=="number"?r:Number(r);if(!isFinite(s))return isNaN(s)?".nan":s<0?"-.inf":".inf";let i=JSON.stringify(r);if(!n&&e&&(!t||t==="tag:yaml.org,2002:float")&&/^\\d/.test(i)){let o=i.indexOf(".");o<0&&(o=i.length,i+=".");let a=e-(i.length-o-1);for(;a-- >0;)i+="0"}return i}var Fs={identify:n=>typeof n=="number",default:!0,tag:"tag:yaml.org,2002:float",test:/^(?:[-+]?\\.(?:inf|Inf|INF)|\\.nan|\\.NaN|\\.NAN)$/,resolve:n=>n.slice(-3).toLowerCase()==="nan"?NaN:n[0]==="-"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,stringify:be},Es={identify:n=>typeof n=="number",default:!0,tag:"tag:yaml.org,2002:float",format:"EXP",test:/^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,resolve:n=>parseFloat(n),stringify(n){let e=Number(n.value);return isFinite(e)?e.toExponential():be(n)}},ws={identify:n=>typeof n=="number",default:!0,tag:"tag:yaml.org,2002:float",test:/^[-+]?(?:\\.[0-9]+|[0-9]+\\.[0-9]*)$/,resolve(n){let e=new $(parseFloat(n)),t=n.indexOf(".");return t!==-1&&n[n.length-1]==="0"&&(e.minFractionDigits=n.length-t-1),e},stringify:be};var Ts=n=>typeof n=="bigint"||Number.isInteger(n),Ui=(n,e,t,{intAsBigInt:r})=>r?BigInt(n):parseInt(n.substring(e),t);function eu(n,e,t){let{value:r}=n;return Ts(r)&&r>=0?t+r.toString(e):be(n)}var Ss={identify:n=>Ts(n)&&n>=0,default:!0,tag:"tag:yaml.org,2002:int",format:"OCT",test:/^0o[0-7]+$/,resolve:(n,e,t)=>Ui(n,2,8,t),stringify:n=>eu(n,8,"0o")},ks={identify:Ts,default:!0,tag:"tag:yaml.org,2002:int",test:/^[-+]?[0-9]+$/,resolve:(n,e,t)=>Ui(n,0,10,t),stringify:be},Cs={identify:n=>Ts(n)&&n>=0,default:!0,tag:"tag:yaml.org,2002:int",format:"HEX",test:/^0x[0-9a-fA-F]+$/,resolve:(n,e,t)=>Ui(n,2,16,t),stringify:n=>eu(n,16,"0x")};var tu=[ze,Ye,xt,Kt,yr,Ss,ks,Cs,Fs,Es,ws];function nu(n){return typeof n=="bigint"||Number.isInteger(n)}var vs=({value:n})=>JSON.stringify(n),nf=[{identify:n=>typeof n=="string",default:!0,tag:"tag:yaml.org,2002:str",resolve:n=>n,stringify:vs},{identify:n=>n==null,createNode:()=>new $(null),default:!0,tag:"tag:yaml.org,2002:null",test:/^null$/,resolve:()=>null,stringify:vs},{identify:n=>typeof n=="boolean",default:!0,tag:"tag:yaml.org,2002:bool",test:/^true|false$/,resolve:n=>n==="true",stringify:vs},{identify:nu,default:!0,tag:"tag:yaml.org,2002:int",test:/^-?(?:0|[1-9][0-9]*)$/,resolve:(n,e,{intAsBigInt:t})=>t?BigInt(n):parseInt(n,10),stringify:({value:n})=>nu(n)?n.toString():JSON.stringify(n)},{identify:n=>typeof n=="number",default:!0,tag:"tag:yaml.org,2002:float",test:/^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,resolve:n=>parseFloat(n),stringify:vs}],rf={default:!0,tag:"",test:/^/,resolve(n,e){return e(`Unresolved plain scalar ${JSON.stringify(n)}`),n}},ru=[ze,Ye].concat(nf,rf);var gr={identify:n=>n instanceof Uint8Array,default:!1,tag:"tag:yaml.org,2002:binary",resolve(n,e){if(typeof Buffer=="function")return Buffer.from(n,"base64");if(typeof atob=="function"){let t=atob(n.replace(/[\\n\\r]/g,"")),r=new Uint8Array(t.length);for(let s=0;s<t.length;++s)r[s]=t.charCodeAt(s);return r}else return e("This environment does not support reading binary tags; either Buffer or atob is required"),n},stringify({comment:n,type:e,value:t},r,s,i){let o=t,a;if(typeof Buffer=="function")a=o instanceof Buffer?o.toString("base64"):Buffer.from(o.buffer).toString("base64");else if(typeof btoa=="function"){let u="";for(let l=0;l<o.length;++l)u+=String.fromCharCode(o[l]);a=btoa(u)}else throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");if(e||(e=$.BLOCK_LITERAL),e!==$.QUOTE_DOUBLE){let u=Math.max(r.options.lineWidth-r.indent.length,r.options.minContentWidth),l=Math.ceil(a.length/u),f=new Array(l);for(let d=0,m=0;d<l;++d,m+=u)f[d]=a.substr(m,u);a=f.join(e===$.BLOCK_LITERAL?`\n`:" ")}return Ut({comment:n,type:e,value:a},r,s,i)}};function Ki(n,e){var t;if(We(n))for(let r=0;r<n.items.length;++r){let s=n.items[r];if(!J(s)){if(Ke(s)){s.items.length>1&&e("Each pair must have its own sequence indicator");let i=s.items[0]||new se(new $(null));if(s.commentBefore&&(i.key.commentBefore=i.key.commentBefore?`${s.commentBefore}\n${i.key.commentBefore}`:s.commentBefore),s.comment){let o=(t=i.value)!=null?t:i.key;o.comment=o.comment?`${s.comment}\n${o.comment}`:s.comment}s=i}n.items[r]=J(s)?s:new se(s)}}else e("Expected a sequence for this tag");return n}function Wi(n,e,t){let{replacer:r}=t,s=new ge(n);s.tag="tag:yaml.org,2002:pairs";let i=0;if(e&&Symbol.iterator in Object(e))for(let o of e){typeof r=="function"&&(o=r.call(e,String(i++),o));let a,u;if(Array.isArray(o))if(o.length===2)a=o[0],u=o[1];else throw new TypeError(`Expected [key, value] tuple: ${o}`);else if(o&&o instanceof Object){let l=Object.keys(o);if(l.length===1)a=l[0],u=o[a];else throw new TypeError(`Expected tuple with one key, not ${l.length} keys`)}else a=o;s.items.push(kn(a,u,t))}return s}var br={collection:"seq",default:!1,tag:"tag:yaml.org,2002:pairs",resolve:Ki,createNode:Wi};var Cn=class n extends ge{constructor(){super(),this.add=ie.prototype.add.bind(this),this.delete=ie.prototype.delete.bind(this),this.get=ie.prototype.get.bind(this),this.has=ie.prototype.has.bind(this),this.set=ie.prototype.set.bind(this),this.tag=n.tag}toJSON(e,t){if(!t)return super.toJSON(e);let r=new Map;t!=null&&t.onCreate&&t.onCreate(r);for(let s of this.items){let i,o;if(J(s)?(i=ue(s.key,"",t),o=ue(s.value,i,t)):i=ue(s,"",t),r.has(i))throw new Error("Ordered maps must not include duplicate keys");r.set(i,o)}return r}static from(e,t,r){let s=Wi(e,t,r),i=new this;return i.items=s.items,i}};Cn.tag="tag:yaml.org,2002:omap";var Fr={collection:"seq",identify:n=>n instanceof Map,nodeClass:Cn,default:!1,tag:"tag:yaml.org,2002:omap",resolve(n,e){let t=Ki(n,e),r=[];for(let{key:s}of t.items)W(s)&&(r.includes(s.value)?e(`Ordered maps must not include duplicate keys: ${s.value}`):r.push(s.value));return Object.assign(new Cn,t)},createNode:(n,e,t)=>Cn.from(n,e,t)};function su({value:n,source:e},t){return e&&(n?Hi:Ji).test.test(e)?e:n?t.options.trueStr:t.options.falseStr}var Hi={identify:n=>n===!0,default:!0,tag:"tag:yaml.org,2002:bool",test:/^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,resolve:()=>new $(!0),stringify:su},Ji={identify:n=>n===!1,default:!0,tag:"tag:yaml.org,2002:bool",test:/^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,resolve:()=>new $(!1),stringify:su};var iu={identify:n=>typeof n=="number",default:!0,tag:"tag:yaml.org,2002:float",test:/^(?:[-+]?\\.(?:inf|Inf|INF)|\\.nan|\\.NaN|\\.NAN)$/,resolve:n=>n.slice(-3).toLowerCase()==="nan"?NaN:n[0]==="-"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,stringify:be},ou={identify:n=>typeof n=="number",default:!0,tag:"tag:yaml.org,2002:float",format:"EXP",test:/^[-+]?(?:[0-9][0-9_]*)?(?:\\.[0-9_]*)?[eE][-+]?[0-9]+$/,resolve:n=>parseFloat(n.replace(/_/g,"")),stringify(n){let e=Number(n.value);return isFinite(e)?e.toExponential():be(n)}},au={identify:n=>typeof n=="number",default:!0,tag:"tag:yaml.org,2002:float",test:/^[-+]?(?:[0-9][0-9_]*)?\\.[0-9_]*$/,resolve(n){let e=new $(parseFloat(n.replace(/_/g,""))),t=n.indexOf(".");if(t!==-1){let r=n.substring(t+1).replace(/_/g,"");r[r.length-1]==="0"&&(e.minFractionDigits=r.length)}return e},stringify:be};var Er=n=>typeof n=="bigint"||Number.isInteger(n);function Os(n,e,t,{intAsBigInt:r}){let s=n[0];if((s==="-"||s==="+")&&(e+=1),n=n.substring(e).replace(/_/g,""),r){switch(t){case 2:n=`0b${n}`;break;case 8:n=`0o${n}`;break;case 16:n=`0x${n}`;break}let o=BigInt(n);return s==="-"?BigInt(-1)*o:o}let i=parseInt(n,t);return s==="-"?-1*i:i}function zi(n,e,t){let{value:r}=n;if(Er(r)){let s=r.toString(e);return r<0?"-"+t+s.substr(1):t+s}return be(n)}var uu={identify:Er,default:!0,tag:"tag:yaml.org,2002:int",format:"BIN",test:/^[-+]?0b[0-1_]+$/,resolve:(n,e,t)=>Os(n,2,2,t),stringify:n=>zi(n,2,"0b")},lu={identify:Er,default:!0,tag:"tag:yaml.org,2002:int",format:"OCT",test:/^[-+]?0[0-7_]+$/,resolve:(n,e,t)=>Os(n,1,8,t),stringify:n=>zi(n,8,"0")},cu={identify:Er,default:!0,tag:"tag:yaml.org,2002:int",test:/^[-+]?[0-9][0-9_]*$/,resolve:(n,e,t)=>Os(n,0,10,t),stringify:be},fu={identify:Er,default:!0,tag:"tag:yaml.org,2002:int",format:"HEX",test:/^[-+]?0x[0-9a-fA-F_]+$/,resolve:(n,e,t)=>Os(n,2,16,t),stringify:n=>zi(n,16,"0x")};var vn=class n extends ie{constructor(e){super(e),this.tag=n.tag}add(e){let t;J(e)?t=e:e&&typeof e=="object"&&"key"in e&&"value"in e&&e.value===null?t=new se(e.key,null):t=new se(e,null),Ot(this.items,t.key)||this.items.push(t)}get(e,t){let r=Ot(this.items,e);return!t&&J(r)?W(r.key)?r.key.value:r.key:r}set(e,t){if(typeof t!="boolean")throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof t}`);let r=Ot(this.items,e);r&&!t?this.items.splice(this.items.indexOf(r),1):!r&&t&&this.items.push(new se(e))}toJSON(e,t){return super.toJSON(e,t,Set)}toString(e,t,r){if(!e)return JSON.stringify(this);if(this.hasAllNullValues(!0))return super.toString(Object.assign({},e,{allNullValues:!0}),t,r);throw new Error("Set items must all have null values")}static from(e,t,r){let{replacer:s}=r,i=new this(e);if(t&&Symbol.iterator in Object(t))for(let o of t)typeof s=="function"&&(o=s.call(t,o,o)),i.items.push(kn(o,null,r));return i}};vn.tag="tag:yaml.org,2002:set";var wr={collection:"map",identify:n=>n instanceof Set,nodeClass:vn,default:!1,tag:"tag:yaml.org,2002:set",createNode:(n,e,t)=>vn.from(n,e,t),resolve(n,e){if(Ke(n)){if(n.hasAllNullValues(!0))return Object.assign(new vn,n);e("Set items must all have null values")}else e("Expected a mapping for this tag");return n}};function Yi(n,e){let t=n[0],r=t==="-"||t==="+"?n.substring(1):n,s=o=>e?BigInt(o):Number(o),i=r.replace(/_/g,"").split(":").reduce((o,a)=>o*s(60)+s(a),s(0));return t==="-"?s(-1)*i:i}function du(n){let{value:e}=n,t=o=>o;if(typeof e=="bigint")t=o=>BigInt(o);else if(isNaN(e)||!isFinite(e))return be(n);let r="";e<0&&(r="-",e*=t(-1));let s=t(60),i=[e%s];return e<60?i.unshift(0):(e=(e-i[0])/s,i.unshift(e%s),e>=60&&(e=(e-i[0])/s,i.unshift(e))),r+i.map(o=>String(o).padStart(2,"0")).join(":").replace(/000000\\d*$/,"")}var xs={identify:n=>typeof n=="bigint"||Number.isInteger(n),default:!0,tag:"tag:yaml.org,2002:int",format:"TIME",test:/^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,resolve:(n,e,{intAsBigInt:t})=>Yi(n,t),stringify:du},Is={identify:n=>typeof n=="number",default:!0,tag:"tag:yaml.org,2002:float",format:"TIME",test:/^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*$/,resolve:n=>Yi(n,!1),stringify:du},On={identify:n=>n instanceof Date,default:!0,tag:"tag:yaml.org,2002:timestamp",test:RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\\\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),resolve(n){let e=n.match(On.test);if(!e)throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");let[,t,r,s,i,o,a]=e.map(Number),u=e[7]?Number((e[7]+"00").substr(1,3)):0,l=Date.UTC(t,r-1,s,i||0,o||0,a||0,u),f=e[8];if(f&&f!=="Z"){let d=Yi(f,!1);Math.abs(d)<30&&(d*=60),l-=6e4*d}return new Date(l)},stringify:({value:n})=>n.toISOString().replace(/((T00:00)?:00)?\\.000Z$/,"")};var Gi=[ze,Ye,xt,Kt,Hi,Ji,uu,lu,cu,fu,iu,ou,au,gr,Je,Fr,br,wr,xs,Is,On];var hu=new Map([["core",tu],["failsafe",[ze,Ye,xt]],["json",ru],["yaml11",Gi],["yaml-1.1",Gi]]),mu={binary:gr,bool:yr,float:ws,floatExp:Es,floatNaN:Fs,floatTime:Is,int:ks,intHex:Cs,intOct:Ss,intTime:xs,map:ze,merge:Je,null:Kt,omap:Fr,pairs:br,seq:Ye,set:wr,timestamp:On},pu={"tag:yaml.org,2002:binary":gr,"tag:yaml.org,2002:merge":Je,"tag:yaml.org,2002:omap":Fr,"tag:yaml.org,2002:pairs":br,"tag:yaml.org,2002:set":wr,"tag:yaml.org,2002:timestamp":On};function Ls(n,e,t){let r=hu.get(e);if(r&&!n)return t&&!r.includes(Je)?r.concat(Je):r.slice();let s=r;if(!s)if(Array.isArray(n))s=[];else{let i=Array.from(hu.keys()).filter(o=>o!=="yaml11").map(o=>JSON.stringify(o)).join(", ");throw new Error(`Unknown schema "${e}"; use one of ${i} or define customTags array`)}if(Array.isArray(n))for(let i of n)s=s.concat(i);else typeof n=="function"&&(s=n(s.slice()));return t&&(s=s.concat(Je)),s.reduce((i,o)=>{let a=typeof o=="string"?mu[o]:o;if(!a){let u=JSON.stringify(o),l=Object.keys(mu).map(f=>JSON.stringify(f)).join(", ");throw new Error(`Unknown custom tag ${u}; use one of ${l}`)}return i.includes(a)||i.push(a),i},[])}var sf=(n,e)=>n.key<e.key?-1:n.key>e.key?1:0,Tr=class n{constructor({compat:e,customTags:t,merge:r,resolveKnownTags:s,schema:i,sortMapEntries:o,toStringDefaults:a}){this.compat=Array.isArray(e)?Ls(e,"compat"):e?Ls(null,e):null,this.name=typeof i=="string"&&i||"core",this.knownTags=s?pu:{},this.tags=Ls(t,this.name,r),this.toStringOptions=a!=null?a:null,Object.defineProperty(this,Ve,{value:ze}),Object.defineProperty(this,xe,{value:xt}),Object.defineProperty(this,gt,{value:Ye}),this.sortMapEntries=typeof o=="function"?o:o===!0?sf:null}clone(){let e=Object.create(n.prototype,Object.getOwnPropertyDescriptors(this));return e.tags=this.tags.slice(),e}};function Du(n,e){var u;let t=[],r=e.directives===!0;if(e.directives!==!1&&n.directives){let l=n.directives.toString(n);l?(t.push(l),r=!0):n.directives.docStart&&(r=!0)}r&&t.push("---");let s=hs(n,e),{commentString:i}=s.options;if(n.commentBefore){t.length!==1&&t.unshift("");let l=i(n.commentBefore);t.unshift(Be(l,""))}let o=!1,a=null;if(n.contents){if(z(n.contents)){if(n.contents.spaceBefore&&r&&t.push(""),n.contents.commentBefore){let d=i(n.contents.commentBefore);t.push(Be(d,""))}s.forceBlockIndent=!!n.comment,a=n.contents.comment}let l=a?void 0:()=>o=!0,f=Et(n.contents,s,()=>a=null,l);a&&(f+=st(f,"",i(a))),(f[0]==="|"||f[0]===">")&&t[t.length-1]==="---"?t[t.length-1]=`--- ${f}`:t.push(f)}else t.push(Et(n.contents,s));if((u=n.directives)!=null&&u.docEnd)if(n.comment){let l=i(n.comment);l.includes(`\n`)?(t.push("..."),t.push(Be(l,""))):t.push(`... ${l}`)}else t.push("...");else{let l=n.comment;l&&o&&(l=l.replace(/^\\n+/,"")),l&&((!o||a)&&t[t.length-1]!==""&&t.push(""),t.push(Be(i(l),"")))}return t.join(`\n`)+`\n`}var It=class n{constructor(e,t,r){this.commentBefore=null,this.comment=null,this.errors=[],this.warnings=[],Object.defineProperty(this,we,{value:ss});let s=null;typeof t=="function"||Array.isArray(t)?s=t:r===void 0&&t&&(r=t,t=void 0);let i=Object.assign({intAsBigInt:!1,keepSourceTokens:!1,logLevel:"warn",prettyErrors:!0,strict:!0,stringKeys:!1,uniqueKeys:!0,version:"1.2"},r);this.options=i;let{version:o}=i;r!=null&&r._directives?(this.directives=r._directives.atDocument(),this.directives.yaml.explicit&&(o=this.directives.yaml.version)):this.directives=new rt({version:o}),this.setSchema(o,r),this.contents=e===void 0?null:this.createNode(e,s,r)}clone(){let e=Object.create(n.prototype,{[we]:{value:ss}});return e.commentBefore=this.commentBefore,e.comment=this.comment,e.errors=this.errors.slice(),e.warnings=this.warnings.slice(),e.options=Object.assign({},this.options),this.directives&&(e.directives=this.directives.clone()),e.schema=this.schema.clone(),e.contents=z(this.contents)?this.contents.clone(e.schema):this.contents,this.range&&(e.range=this.range.slice()),e}add(e){xn(this.contents)&&this.contents.add(e)}addIn(e,t){xn(this.contents)&&this.contents.addIn(e,t)}createAlias(e,t){if(!e.anchor){let r=Bi(this);e.anchor=!t||r.has(t)?Pi(t||"a",r):t}return new bt(e.anchor)}createNode(e,t,r){let s;if(typeof t=="function")e=t.call({"":e},"",e),s=t;else if(Array.isArray(t)){let D=I=>typeof I=="number"||I instanceof String||I instanceof Number,T=t.filter(D).map(String);T.length>0&&(t=t.concat(T)),s=t}else r===void 0&&t&&(r=t,t=void 0);let{aliasDuplicateObjects:i,anchorPrefix:o,flow:a,keepUndefined:u,onTagObj:l,tag:f}=r!=null?r:{},{onAnchor:d,setAnchors:m,sourceObjects:h}=Ya(this,o||"a"),b={aliasDuplicateObjects:i!=null?i:!0,keepUndefined:u!=null?u:!1,onAnchor:d,onTagObj:l,replacer:s,schema:this.schema,sourceObjects:h},g=Ft(e,f,b);return a&&Q(g)&&(g.flow=!0),m(),g}createPair(e,t,r={}){let s=this.createNode(e,null,r),i=this.createNode(t,null,r);return new se(s,i)}delete(e){return xn(this.contents)?this.contents.delete(e):!1}deleteIn(e){return Tn(e)?this.contents==null?!1:(this.contents=null,!0):xn(this.contents)?this.contents.deleteIn(e):!1}get(e,t){return Q(this.contents)?this.contents.get(e,t):void 0}getIn(e,t){return Tn(e)?!t&&W(this.contents)?this.contents.value:this.contents:Q(this.contents)?this.contents.getIn(e,t):void 0}has(e){return Q(this.contents)?this.contents.has(e):!1}hasIn(e){return Tn(e)?this.contents!==void 0:Q(this.contents)?this.contents.hasIn(e):!1}set(e,t){this.contents==null?this.contents=hr(this.schema,[e],t):xn(this.contents)&&this.contents.set(e,t)}setIn(e,t){Tn(e)?this.contents=t:this.contents==null?this.contents=hr(this.schema,Array.from(e),t):xn(this.contents)&&this.contents.setIn(e,t)}setSchema(e,t={}){typeof e=="number"&&(e=String(e));let r;switch(e){case"1.1":this.directives?this.directives.yaml.version="1.1":this.directives=new rt({version:"1.1"}),r={resolveKnownTags:!1,schema:"yaml-1.1"};break;case"1.2":case"next":this.directives?this.directives.yaml.version=e:this.directives=new rt({version:e}),r={resolveKnownTags:!0,schema:"core"};break;case null:this.directives&&delete this.directives,r=null;break;default:{let s=JSON.stringify(e);throw new Error(`Expected \'1.1\', \'1.2\' or null as first argument, but found: ${s}`)}}if(t.schema instanceof Object)this.schema=t.schema;else if(r)this.schema=new Tr(Object.assign(r,t));else throw new Error("With a null YAML version, the { schema: Schema } option is required")}toJS({json:e,jsonArg:t,mapAsMap:r,maxAliasCount:s,onAnchor:i,reviver:o}={}){let a={anchors:new Map,doc:this,keep:!e,mapAsMap:r===!0,mapKeyWarned:!1,maxAliasCount:typeof s=="number"?s:100},u=ue(this.contents,t!=null?t:"",a);if(typeof i=="function")for(let{count:l,res:f}of a.anchors.values())i(f,l);return typeof o=="function"?Ct(o,{"":u},"",u):u}toJSON(e,t){return this.toJS({json:!0,jsonArg:e,mapAsMap:!1,onAnchor:t})}toString(e={}){if(this.errors.length>0)throw new Error("Document with errors cannot be stringified");if("indent"in e&&(!Number.isInteger(e.indent)||Number(e.indent)<=0)){let t=JSON.stringify(e.indent);throw new Error(`"indent" option must be a positive integer, not ${t}`)}return Du(this,e)}};function xn(n){if(Q(n))return!0;throw new Error("Expected a YAML collection as document contents")}var Sr=class extends Error{constructor(e,t,r,s){super(),this.name=e,this.code=r,this.message=s,this.pos=t}},Ge=class extends Sr{constructor(e,t,r){super("YAMLParseError",e,t,r)}},kr=class extends Sr{constructor(e,t,r){super("YAMLWarning",e,t,r)}},Zi=(n,e)=>t=>{if(t.pos[0]===-1)return;t.linePos=t.pos.map(a=>e.linePos(a));let{line:r,col:s}=t.linePos[0];t.message+=` at line ${r}, column ${s}`;let i=s-1,o=n.substring(e.lineStarts[r-1],e.lineStarts[r]).replace(/[\\n\\r]+$/,"");if(i>=60&&o.length>80){let a=Math.min(i-39,o.length-79);o="\\u2026"+o.substring(a),i-=a-1}if(o.length>80&&(o=o.substring(0,79)+"\\u2026"),r>1&&/^ *$/.test(o.substring(0,i))){let a=n.substring(e.lineStarts[r-2],e.lineStarts[r-1]);a.length>80&&(a=a.substring(0,79)+`\\u2026\n`),o=a+o}if(/[^ ]/.test(o)){let a=1,u=t.linePos[1];u&&u.line===r&&u.col>s&&(a=Math.max(1,Math.min(u.col-s,80-i)));let l=" ".repeat(i)+"^".repeat(a);t.message+=`:\n\n${o}\n${l}\n`}};function it(n,{flow:e,indicator:t,next:r,offset:s,onError:i,parentIndent:o,startOnNewline:a}){let u=!1,l=a,f=a,d="",m="",h=!1,b=!1,g=null,D=null,T=null,I=null,N=null,y=null,w=null;for(let C of n)switch(b&&(C.type!=="space"&&C.type!=="newline"&&C.type!=="comma"&&i(C.offset,"MISSING_CHAR","Tags and anchors must be separated from the next token by white space"),b=!1),g&&(l&&C.type!=="comment"&&C.type!=="newline"&&i(g,"TAB_AS_INDENT","Tabs are not allowed as indentation"),g=null),C.type){case"space":!e&&(t!=="doc-start"||(r==null?void 0:r.type)!=="flow-collection")&&C.source.includes("	")&&(g=C),f=!0;break;case"comment":{f||i(C,"MISSING_CHAR","Comments must be separated from other tokens by white space characters");let U=C.source.substring(1)||" ";d?d+=m+U:d=U,m="",l=!1;break}case"newline":l?d?d+=C.source:u=!0:m+=C.source,l=!0,h=!0,(D||T)&&(I=C),f=!0;break;case"anchor":D&&i(C,"MULTIPLE_ANCHORS","A node can have at most one anchor"),C.source.endsWith(":")&&i(C.offset+C.source.length-1,"BAD_ALIAS","Anchor ending in : is ambiguous",!0),D=C,w===null&&(w=C.offset),l=!1,f=!1,b=!0;break;case"tag":{T&&i(C,"MULTIPLE_TAGS","A node can have at most one tag"),T=C,w===null&&(w=C.offset),l=!1,f=!1,b=!0;break}case t:(D||T)&&i(C,"BAD_PROP_ORDER",`Anchors and tags must be after the ${C.source} indicator`),y&&i(C,"UNEXPECTED_TOKEN",`Unexpected ${C.source} in ${e!=null?e:"collection"}`),y=C,l=t==="seq-item-ind"||t==="explicit-key-ind",f=!1;break;case"comma":if(e){N&&i(C,"UNEXPECTED_TOKEN",`Unexpected , in ${e}`),N=C,l=!1,f=!1;break}default:i(C,"UNEXPECTED_TOKEN",`Unexpected ${C.type} token`),l=!1,f=!1}let v=n[n.length-1],O=v?v.offset+v.source.length:s;return b&&r&&r.type!=="space"&&r.type!=="newline"&&r.type!=="comma"&&(r.type!=="scalar"||r.source!=="")&&i(r.offset,"MISSING_CHAR","Tags and anchors must be separated from the next token by white space"),g&&(l&&g.indent<=o||(r==null?void 0:r.type)==="block-map"||(r==null?void 0:r.type)==="block-seq")&&i(g,"TAB_AS_INDENT","Tabs are not allowed as indentation"),{comma:N,found:y,spaceBefore:u,comment:d,hasNewline:h,anchor:D,tag:T,newlineAfterProp:I,end:O,start:w!=null?w:O}}function Lt(n){if(!n)return null;switch(n.type){case"alias":case"scalar":case"double-quoted-scalar":case"single-quoted-scalar":if(n.source.includes(`\n`))return!0;if(n.end){for(let e of n.end)if(e.type==="newline")return!0}return!1;case"flow-collection":for(let e of n.items){for(let t of e.start)if(t.type==="newline")return!0;if(e.sep){for(let t of e.sep)if(t.type==="newline")return!0}if(Lt(e.key)||Lt(e.value))return!0}return!1;default:return!0}}function Cr(n,e,t){if((e==null?void 0:e.type)==="flow-collection"){let r=e.end[0];r.indent===n&&(r.source==="]"||r.source==="}")&&Lt(e)&&t(r,"BAD_INDENT","Flow end indicator should be more indented than parent",!0)}}function Ns(n,e,t){let{uniqueKeys:r}=n.options;if(r===!1)return!1;let s=typeof r=="function"?r:(i,o)=>i===o||W(i)&&W(o)&&i.value===o.value;return e.some(i=>s(i.key,t))}var yu="All mapping items must start at the same column";function gu({composeNode:n,composeEmptyNode:e},t,r,s,i){var f,d;let o=(f=i==null?void 0:i.nodeClass)!=null?f:ie,a=new o(t.schema);t.atRoot&&(t.atRoot=!1);let u=r.offset,l=null;for(let m of r.items){let{start:h,key:b,sep:g,value:D}=m,T=it(h,{indicator:"explicit-key-ind",next:b!=null?b:g==null?void 0:g[0],offset:u,onError:s,parentIndent:r.indent,startOnNewline:!0}),I=!T.found;if(I){if(b&&(b.type==="block-seq"?s(u,"BLOCK_AS_IMPLICIT_KEY","A block sequence may not be used as an implicit map key"):"indent"in b&&b.indent!==r.indent&&s(u,"BAD_INDENT",yu)),!T.anchor&&!T.tag&&!g){l=T.end,T.comment&&(a.comment?a.comment+=`\n`+T.comment:a.comment=T.comment);continue}(T.newlineAfterProp||Lt(b))&&s(b!=null?b:h[h.length-1],"MULTILINE_IMPLICIT_KEY","Implicit keys need to be on a single line")}else((d=T.found)==null?void 0:d.indent)!==r.indent&&s(u,"BAD_INDENT",yu);t.atKey=!0;let N=T.end,y=b?n(t,b,T,s):e(t,N,h,null,T,s);t.schema.compat&&Cr(r.indent,b,s),t.atKey=!1,Ns(t,a.items,y)&&s(N,"DUPLICATE_KEY","Map keys must be unique");let w=it(g!=null?g:[],{indicator:"map-value-ind",next:D,offset:y.range[2],onError:s,parentIndent:r.indent,startOnNewline:!b||b.type==="block-scalar"});if(u=w.end,w.found){I&&((D==null?void 0:D.type)==="block-map"&&!w.hasNewline&&s(u,"BLOCK_AS_IMPLICIT_KEY","Nested mappings are not allowed in compact mappings"),t.options.strict&&T.start<w.found.offset-1024&&s(y.range,"KEY_OVER_1024_CHARS","The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));let v=D?n(t,D,w,s):e(t,u,g,null,w,s);t.schema.compat&&Cr(r.indent,D,s),u=v.range[2];let O=new se(y,v);t.options.keepSourceTokens&&(O.srcToken=m),a.items.push(O)}else{I&&s(y.range,"MISSING_CHAR","Implicit map keys need to be followed by map values"),w.comment&&(y.comment?y.comment+=`\n`+w.comment:y.comment=w.comment);let v=new se(y);t.options.keepSourceTokens&&(v.srcToken=m),a.items.push(v)}}return l&&l<u&&s(l,"IMPOSSIBLE","Map comment with trailing content"),a.range=[r.offset,u,l!=null?l:u],a}function bu({composeNode:n,composeEmptyNode:e},t,r,s,i){var f;let o=(f=i==null?void 0:i.nodeClass)!=null?f:ge,a=new o(t.schema);t.atRoot&&(t.atRoot=!1),t.atKey&&(t.atKey=!1);let u=r.offset,l=null;for(let{start:d,value:m}of r.items){let h=it(d,{indicator:"seq-item-ind",next:m,offset:u,onError:s,parentIndent:r.indent,startOnNewline:!0});if(!h.found)if(h.anchor||h.tag||m)m&&m.type==="block-seq"?s(h.end,"BAD_INDENT","All sequence items must start at the same column"):s(u,"MISSING_CHAR","Sequence item without - indicator");else{l=h.end,h.comment&&(a.comment=h.comment);continue}let b=m?n(t,m,h,s):e(t,h.end,d,null,h,s);t.schema.compat&&Cr(r.indent,m,s),u=b.range[2],a.items.push(b)}return a.range=[r.offset,u,l!=null?l:u],a}function ot(n,e,t,r){let s="";if(n){let i=!1,o="";for(let a of n){let{source:u,type:l}=a;switch(l){case"space":i=!0;break;case"comment":{t&&!i&&r(a,"MISSING_CHAR","Comments must be separated from other tokens by white space characters");let f=u.substring(1)||" ";s?s+=o+f:s=f,o="";break}case"newline":s&&(o+=u),i=!0;break;default:r(a,"UNEXPECTED_TOKEN",`Unexpected ${l} at node end`)}e+=u.length}}return{comment:s,offset:e}}var Qi="Block collections are not allowed within flow collections",Xi=n=>n&&(n.type==="block-map"||n.type==="block-seq");function Fu({composeNode:n,composeEmptyNode:e},t,r,s,i){var D,T;let o=r.start.source==="{",a=o?"flow map":"flow sequence",u=(D=i==null?void 0:i.nodeClass)!=null?D:o?ie:ge,l=new u(t.schema);l.flow=!0;let f=t.atRoot;f&&(t.atRoot=!1),t.atKey&&(t.atKey=!1);let d=r.offset+r.start.source.length;for(let I=0;I<r.items.length;++I){let N=r.items[I],{start:y,key:w,sep:v,value:O}=N,C=it(y,{flow:a,indicator:"explicit-key-ind",next:w!=null?w:v==null?void 0:v[0],offset:d,onError:s,parentIndent:r.indent,startOnNewline:!1});if(!C.found){if(!C.anchor&&!C.tag&&!v&&!O){I===0&&C.comma?s(C.comma,"UNEXPECTED_TOKEN",`Unexpected , in ${a}`):I<r.items.length-1&&s(C.start,"UNEXPECTED_TOKEN",`Unexpected empty item in ${a}`),C.comment&&(l.comment?l.comment+=`\n`+C.comment:l.comment=C.comment),d=C.end;continue}!o&&t.options.strict&&Lt(w)&&s(w,"MULTILINE_IMPLICIT_KEY","Implicit keys of flow sequence pairs need to be on a single line")}if(I===0)C.comma&&s(C.comma,"UNEXPECTED_TOKEN",`Unexpected , in ${a}`);else if(C.comma||s(C.start,"MISSING_CHAR",`Missing , between ${a} items`),C.comment){let U="";e:for(let j of y)switch(j.type){case"comma":case"space":break;case"comment":U=j.source.substring(1);break e;default:break e}if(U){let j=l.items[l.items.length-1];J(j)&&(j=(T=j.value)!=null?T:j.key),j.comment?j.comment+=`\n`+U:j.comment=U,C.comment=C.comment.substring(U.length+1)}}if(!o&&!v&&!C.found){let U=O?n(t,O,C,s):e(t,C.end,v,null,C,s);l.items.push(U),d=U.range[2],Xi(O)&&s(U.range,"BLOCK_IN_FLOW",Qi)}else{t.atKey=!0;let U=C.end,j=w?n(t,w,C,s):e(t,U,y,null,C,s);Xi(w)&&s(j.range,"BLOCK_IN_FLOW",Qi),t.atKey=!1;let G=it(v!=null?v:[],{flow:a,indicator:"map-value-ind",next:O,offset:j.range[2],onError:s,parentIndent:r.indent,startOnNewline:!1});if(G.found){if(!o&&!C.found&&t.options.strict){if(v)for(let q of v){if(q===G.found)break;if(q.type==="newline"){s(q,"MULTILINE_IMPLICIT_KEY","Implicit keys of flow sequence pairs need to be on a single line");break}}C.start<G.found.offset-1024&&s(G.found,"KEY_OVER_1024_CHARS","The : indicator must be at most 1024 chars after the start of an implicit flow sequence key")}}else O&&("source"in O&&O.source&&O.source[0]===":"?s(O,"MISSING_CHAR",`Missing space after : in ${a}`):s(G.start,"MISSING_CHAR",`Missing , or : between ${a} items`));let x=O?n(t,O,G,s):G.found?e(t,G.end,v,null,G,s):null;x?Xi(O)&&s(x.range,"BLOCK_IN_FLOW",Qi):G.comment&&(j.comment?j.comment+=`\n`+G.comment:j.comment=G.comment);let B=new se(j,x);if(t.options.keepSourceTokens&&(B.srcToken=N),o){let q=l;Ns(t,q.items,j)&&s(U,"DUPLICATE_KEY","Map keys must be unique"),q.items.push(B)}else{let q=new ie(t.schema);q.flow=!0,q.items.push(B);let de=(x!=null?x:j).range;q.range=[j.range[0],de[1],de[2]],l.items.push(q)}d=x?x.range[2]:G.end}}let m=o?"}":"]",[h,...b]=r.end,g=d;if(h&&h.source===m)g=h.offset+h.source.length;else{let I=a[0].toUpperCase()+a.substring(1),N=f?`${I} must end with a ${m}`:`${I} in block collection must be sufficiently indented and end with a ${m}`;s(d,f?"MISSING_CHAR":"BAD_INDENT",N),h&&h.source.length!==1&&b.unshift(h)}if(b.length>0){let I=ot(b,g,t.options.strict,s);I.comment&&(l.comment?l.comment+=`\n`+I.comment:l.comment=I.comment),l.range=[r.offset,g,I.offset]}else l.range=[r.offset,g,g];return l}function eo(n,e,t,r,s,i){let o=t.type==="block-map"?gu(n,e,t,r,i):t.type==="block-seq"?bu(n,e,t,r,i):Fu(n,e,t,r,i),a=o.constructor;return s==="!"||s===a.tagName?(o.tag=a.tagName,o):(s&&(o.tag=s),o)}function Eu(n,e,t,r,s){var m,h;let i=r.tag,o=i?e.directives.tagName(i.source,b=>s(i,"TAG_RESOLVE_FAILED",b)):null;if(t.type==="block-seq"){let{anchor:b,newlineAfterProp:g}=r,D=b&&i?b.offset>i.offset?b:i:b!=null?b:i;D&&(!g||g.offset<D.offset)&&s(D,"MISSING_CHAR","Missing newline after block sequence props")}let a=t.type==="block-map"?"map":t.type==="block-seq"?"seq":t.start.source==="{"?"map":"seq";if(!i||!o||o==="!"||o===ie.tagName&&a==="map"||o===ge.tagName&&a==="seq")return eo(n,e,t,s,o);let u=e.schema.tags.find(b=>b.tag===o&&b.collection===a);if(!u){let b=e.schema.knownTags[o];if(b&&b.collection===a)e.schema.tags.push(Object.assign({},b,{default:!1})),u=b;else return b!=null&&b.collection?s(i,"BAD_COLLECTION_TYPE",`${b.tag} used for ${a} collection, but expects ${b.collection}`,!0):s(i,"TAG_RESOLVE_FAILED",`Unresolved tag: ${o}`,!0),eo(n,e,t,s,o)}let l=eo(n,e,t,s,o,u),f=(h=(m=u.resolve)==null?void 0:m.call(u,l,b=>s(i,"TAG_RESOLVE_FAILED",b),e.options))!=null?h:l,d=z(f)?f:new $(f);return d.range=l.range,d.tag=o,u!=null&&u.format&&(d.format=u.format),d}function to(n,e,t){let r=e.offset,s=of(e,n.options.strict,t);if(!s)return{value:"",type:null,comment:"",range:[r,r,r]};let i=s.mode===">"?$.BLOCK_FOLDED:$.BLOCK_LITERAL,o=e.source?af(e.source):[],a=o.length;for(let g=o.length-1;g>=0;--g){let D=o[g][1];if(D===""||D==="\\r")a=g;else break}if(a===0){let g=s.chomp==="+"&&o.length>0?`\n`.repeat(Math.max(1,o.length-1)):"",D=r+s.length;return e.source&&(D+=e.source.length),{value:g,type:i,comment:s.comment,range:[r,D,D]}}let u=e.indent+s.indent,l=e.offset+s.length,f=0;for(let g=0;g<a;++g){let[D,T]=o[g];if(T===""||T==="\\r")s.indent===0&&D.length>u&&(u=D.length);else{D.length<u&&t(l+D.length,"MISSING_CHAR","Block scalars with more-indented leading empty lines must use an explicit indentation indicator"),s.indent===0&&(u=D.length),f=g,u===0&&!n.atRoot&&t(l,"BAD_INDENT","Block scalar values in collections must be indented");break}l+=D.length+T.length+1}for(let g=o.length-1;g>=a;--g)o[g][0].length>u&&(a=g+1);let d="",m="",h=!1;for(let g=0;g<f;++g)d+=o[g][0].slice(u)+`\n`;for(let g=f;g<a;++g){let[D,T]=o[g];l+=D.length+T.length+1;let I=T[T.length-1]==="\\r";if(I&&(T=T.slice(0,-1)),T&&D.length<u){let y=`Block scalar lines must not be less indented than their ${s.indent?"explicit indentation indicator":"first line"}`;t(l-T.length-(I?2:1),"BAD_INDENT",y),D=""}i===$.BLOCK_LITERAL?(d+=m+D.slice(u)+T,m=`\n`):D.length>u||T[0]==="	"?(m===" "?m=`\n`:!h&&m===`\n`&&(m=`\n\n`),d+=m+D.slice(u)+T,m=`\n`,h=!0):T===""?m===`\n`?d+=`\n`:m=`\n`:(d+=m+T,m=" ",h=!1)}switch(s.chomp){case"-":break;case"+":for(let g=a;g<o.length;++g)d+=`\n`+o[g][0].slice(u);d[d.length-1]!==`\n`&&(d+=`\n`);break;default:d+=`\n`}let b=r+s.length+e.source.length;return{value:d,type:i,comment:s.comment,range:[r,b,b]}}function of({offset:n,props:e},t,r){if(e[0].type!=="block-scalar-header")return r(e[0],"IMPOSSIBLE","Block scalar header not found"),null;let{source:s}=e[0],i=s[0],o=0,a="",u=-1;for(let m=1;m<s.length;++m){let h=s[m];if(!a&&(h==="-"||h==="+"))a=h;else{let b=Number(h);!o&&b?o=b:u===-1&&(u=n+m)}}u!==-1&&r(u,"UNEXPECTED_TOKEN",`Block scalar header includes extra characters: ${s}`);let l=!1,f="",d=s.length;for(let m=1;m<e.length;++m){let h=e[m];switch(h.type){case"space":l=!0;case"newline":d+=h.source.length;break;case"comment":t&&!l&&r(h,"MISSING_CHAR","Comments must be separated from other tokens by white space characters"),d+=h.source.length,f=h.source.substring(1);break;case"error":r(h,"UNEXPECTED_TOKEN",h.message),d+=h.source.length;break;default:{let b=`Unexpected token in block scalar header: ${h.type}`;r(h,"UNEXPECTED_TOKEN",b);let g=h.source;g&&typeof g=="string"&&(d+=g.length)}}}return{mode:i,indent:o,chomp:a,comment:f,length:d}}function af(n){let e=n.split(/\\n( *)/),t=e[0],r=t.match(/^( *)/),i=[r!=null&&r[1]?[r[1],t.slice(r[1].length)]:["",t]];for(let o=1;o<e.length;o+=2)i.push([e[o],e[o+1]]);return i}function no(n,e,t){let{offset:r,type:s,source:i,end:o}=n,a,u,l=(m,h,b)=>t(r+m,h,b);switch(s){case"scalar":a=$.PLAIN,u=uf(i,l);break;case"single-quoted-scalar":a=$.QUOTE_SINGLE,u=lf(i,l);break;case"double-quoted-scalar":a=$.QUOTE_DOUBLE,u=cf(i,l);break;default:return t(n,"UNEXPECTED_TOKEN",`Expected a flow scalar value, but found: ${s}`),{value:"",type:null,comment:"",range:[r,r+i.length,r+i.length]}}let f=r+i.length,d=ot(o,f,e,t);return{value:u,type:a,comment:d.comment,range:[r,f,d.offset]}}function uf(n,e){let t="";switch(n[0]){case"	":t="a tab character";break;case",":t="flow indicator character ,";break;case"%":t="directive indicator character %";break;case"|":case">":{t=`block scalar indicator ${n[0]}`;break}case"@":case"`":{t=`reserved character ${n[0]}`;break}}return t&&e(0,"BAD_SCALAR_START",`Plain value cannot start with ${t}`),wu(n)}function lf(n,e){return(n[n.length-1]!=="\'"||n.length===1)&&e(n.length,"MISSING_CHAR","Missing closing \'quote"),wu(n.slice(1,-1)).replace(/\'\'/g,"\'")}function wu(n){var u;let e,t;try{e=new RegExp(`(.*?)(?<![ 	])[ 	]*\\r?\n`,"sy"),t=new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\\r?\n`,"sy")}catch(l){e=new RegExp("(.*?)[ \\\\t]*\\\\r?\\\\n","sy"),t=new RegExp("[ \\\\t]*(.*?)[ \\\\t]*\\\\r?\\\\n","sy")}let r=e.exec(n);if(!r)return n;let s=r[1],i=" ",o=e.lastIndex;for(t.lastIndex=o;r=t.exec(n);)r[1]===""?i===`\n`?s+=i:i=`\n`:(s+=i+r[1],i=" "),o=t.lastIndex;let a=new RegExp("[ \\\\t]*(.*)","sy");return a.lastIndex=o,r=a.exec(n),s+i+((u=r==null?void 0:r[1])!=null?u:"")}function cf(n,e){let t="";for(let r=1;r<n.length-1;++r){let s=n[r];if(!(s==="\\r"&&n[r+1]===`\n`))if(s===`\n`){let{fold:i,offset:o}=ff(n,r);t+=i,r=o}else if(s==="\\\\"){let i=n[++r],o=df[i];if(o)t+=o;else if(i===`\n`)for(i=n[r+1];i===" "||i==="	";)i=n[++r+1];else if(i==="\\r"&&n[r+1]===`\n`)for(i=n[++r+1];i===" "||i==="	";)i=n[++r+1];else if(i==="x"||i==="u"||i==="U"){let a={x:2,u:4,U:8}[i];t+=hf(n,r+1,a,e),r+=a}else{let a=n.substr(r-1,2);e(r-1,"BAD_DQ_ESCAPE",`Invalid escape sequence ${a}`),t+=a}}else if(s===" "||s==="	"){let i=r,o=n[r+1];for(;o===" "||o==="	";)o=n[++r+1];o!==`\n`&&!(o==="\\r"&&n[r+2]===`\n`)&&(t+=r>i?n.slice(i,r+1):s)}else t+=s}return(n[n.length-1]!==\'"\'||n.length===1)&&e(n.length,"MISSING_CHAR",\'Missing closing "quote\'),t}function ff(n,e){let t="",r=n[e+1];for(;(r===" "||r==="	"||r===`\n`||r==="\\r")&&!(r==="\\r"&&n[e+2]!==`\n`);)r===`\n`&&(t+=`\n`),e+=1,r=n[e+1];return t||(t=" "),{fold:t,offset:e}}var df={0:"\\0",a:"\\x07",b:"\\b",e:"\\x1B",f:"\\f",n:`\n`,r:"\\r",t:"	",v:"\\v",N:"\\x85",_:"\\xA0",L:"\\u2028",P:"\\u2029"," ":" ",\'"\':\'"\',"/":"/","\\\\":"\\\\","	":"	"};function hf(n,e,t,r){let s=n.substr(e,t),o=s.length===t&&/^[0-9a-fA-F]+$/.test(s)?parseInt(s,16):NaN;if(isNaN(o)){let a=n.substr(e-2,t+2);return r(e-2,"BAD_DQ_ESCAPE",`Invalid escape sequence ${a}`),a}return String.fromCodePoint(o)}function ro(n,e,t,r){let{value:s,type:i,comment:o,range:a}=e.type==="block-scalar"?to(n,e,r):no(e,n.options.strict,r),u=t?n.directives.tagName(t.source,d=>r(t,"TAG_RESOLVE_FAILED",d)):null,l;n.options.stringKeys&&n.atKey?l=n.schema[xe]:u?l=mf(n.schema,s,u,t,r):e.type==="scalar"?l=pf(n,s,e,r):l=n.schema[xe];let f;try{let d=l.resolve(s,m=>r(t!=null?t:e,"TAG_RESOLVE_FAILED",m),n.options);f=W(d)?d:new $(d)}catch(d){let m=d instanceof Error?d.message:String(d);r(t!=null?t:e,"TAG_RESOLVE_FAILED",m),f=new $(s)}return f.range=a,f.source=s,i&&(f.type=i),u&&(f.tag=u),l.format&&(f.format=l.format),o&&(f.comment=o),f}function mf(n,e,t,r,s){var a;if(t==="!")return n[xe];let i=[];for(let u of n.tags)if(!u.collection&&u.tag===t)if(u.default&&u.test)i.push(u);else return u;for(let u of i)if((a=u.test)!=null&&a.test(e))return u;let o=n.knownTags[t];return o&&!o.collection?(n.tags.push(Object.assign({},o,{default:!1,test:void 0})),o):(s(r,"TAG_RESOLVE_FAILED",`Unresolved tag: ${t}`,t!=="tag:yaml.org,2002:str"),n[xe])}function pf({atKey:n,directives:e,schema:t},r,s,i){var a;let o=t.tags.find(u=>{var l;return(u.default===!0||n&&u.default==="key")&&((l=u.test)==null?void 0:l.test(r))})||t[xe];if(t.compat){let u=(a=t.compat.find(l=>{var f;return l.default&&((f=l.test)==null?void 0:f.test(r))}))!=null?a:t[xe];if(o.tag!==u.tag){let l=e.tagString(o.tag),f=e.tagString(u.tag),d=`Value may be parsed as either ${l} or ${f}`;i(s,"TAG_RESOLVE_FAILED",d,!0)}}return o}function Tu(n,e,t){if(e){t===null&&(t=e.length);for(let r=t-1;r>=0;--r){let s=e[r];switch(s.type){case"space":case"comment":case"newline":n-=s.source.length;continue}for(s=e[++r];(s==null?void 0:s.type)==="space";)n+=s.source.length,s=e[++r];break}}return n}var Df={composeNode:so,composeEmptyNode:As};function so(n,e,t,r){let s=n.atKey,{spaceBefore:i,comment:o,anchor:a,tag:u}=t,l,f=!0;switch(e.type){case"alias":l=yf(n,e,r),(a||u)&&r(e,"ALIAS_PROPS","An alias node must not specify any properties");break;case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":case"block-scalar":l=ro(n,e,u,r),a&&(l.anchor=a.source.substring(1));break;case"block-map":case"block-seq":case"flow-collection":l=Eu(Df,n,e,t,r),a&&(l.anchor=a.source.substring(1));break;default:{let d=e.type==="error"?e.message:`Unsupported token (type: ${e.type})`;r(e,"UNEXPECTED_TOKEN",d),l=As(n,e.offset,void 0,null,t,r),f=!1}}return a&&l.anchor===""&&r(a,"BAD_ALIAS","Anchor cannot be an empty string"),s&&n.options.stringKeys&&(!W(l)||typeof l.value!="string"||l.tag&&l.tag!=="tag:yaml.org,2002:str")&&r(u!=null?u:e,"NON_STRING_KEY","With stringKeys, all keys must be strings"),i&&(l.spaceBefore=!0),o&&(e.type==="scalar"&&e.source===""?l.comment=o:l.commentBefore=o),n.options.keepSourceTokens&&f&&(l.srcToken=e),l}function As(n,e,t,r,{spaceBefore:s,comment:i,anchor:o,tag:a,end:u},l){let f={type:"scalar",offset:Tu(e,t,r),indent:-1,source:""},d=ro(n,f,a,l);return o&&(d.anchor=o.source.substring(1),d.anchor===""&&l(o,"BAD_ALIAS","Anchor cannot be an empty string")),s&&(d.spaceBefore=!0),i&&(d.comment=i,d.range[2]=u),d}function yf({options:n},{offset:e,source:t,end:r},s){let i=new bt(t.substring(1));i.source===""&&s(e,"BAD_ALIAS","Alias cannot be an empty string"),i.source.endsWith(":")&&s(e+t.length-1,"BAD_ALIAS","Alias ending in : is ambiguous",!0);let o=e+t.length,a=ot(r,o,n.strict,s);return i.range=[e,o,a.offset],a.comment&&(i.comment=a.comment),i}function Su(n,e,{offset:t,start:r,value:s,end:i},o){let a=Object.assign({_directives:e},n),u=new It(void 0,a),l={atKey:!1,atRoot:!0,directives:u.directives,options:u.options,schema:u.schema},f=it(r,{indicator:"doc-start",next:s!=null?s:i==null?void 0:i[0],offset:t,onError:o,parentIndent:0,startOnNewline:!0});f.found&&(u.directives.docStart=!0,s&&(s.type==="block-map"||s.type==="block-seq")&&!f.hasNewline&&o(f.end,"MISSING_CHAR","Block collection cannot start on same line with directives-end marker")),u.contents=s?so(l,s,f,o):As(l,f.end,r,null,f,o);let d=u.contents.range[2],m=ot(i,d,!1,o);return m.comment&&(u.comment=m.comment),u.range=[t,d,m.offset],u}function vr(n){if(typeof n=="number")return[n,n+1];if(Array.isArray(n))return n.length===2?n:[n[0],n[1]];let{offset:e,source:t}=n;return[e,e+(typeof t=="string"?t.length:1)]}function ku(n){var s;let e="",t=!1,r=!1;for(let i=0;i<n.length;++i){let o=n[i];switch(o[0]){case"#":e+=(e===""?"":r?`\n\n`:`\n`)+(o.substring(1)||" "),t=!0,r=!1;break;case"%":((s=n[i+1])==null?void 0:s[0])!=="#"&&(i+=1),t=!1;break;default:t||(r=!0),t=!1}}return{comment:e,afterEmptyLine:r}}var Or=class{constructor(e={}){this.doc=null,this.atDirectives=!1,this.prelude=[],this.errors=[],this.warnings=[],this.onError=(t,r,s,i)=>{let o=vr(t);i?this.warnings.push(new kr(o,r,s)):this.errors.push(new Ge(o,r,s))},this.directives=new rt({version:e.version||"1.2"}),this.options=e}decorate(e,t){let{comment:r,afterEmptyLine:s}=ku(this.prelude);if(r){let i=e.contents;if(t)e.comment=e.comment?`${e.comment}\n${r}`:r;else if(s||e.directives.docStart||!i)e.commentBefore=r;else if(Q(i)&&!i.flow&&i.items.length>0){let o=i.items[0];J(o)&&(o=o.key);let a=o.commentBefore;o.commentBefore=a?`${r}\n${a}`:r}else{let o=i.commentBefore;i.commentBefore=o?`${r}\n${o}`:r}}t?(Array.prototype.push.apply(e.errors,this.errors),Array.prototype.push.apply(e.warnings,this.warnings)):(e.errors=this.errors,e.warnings=this.warnings),this.prelude=[],this.errors=[],this.warnings=[]}streamInfo(){return{comment:ku(this.prelude).comment,directives:this.directives,errors:this.errors,warnings:this.warnings}}*compose(e,t=!1,r=-1){for(let s of e)yield*S(this.next(s));yield*S(this.end(t,r))}*next(e){switch(e.type){case"directive":this.directives.add(e.source,(t,r,s)=>{let i=vr(e);i[0]+=t,this.onError(i,"BAD_DIRECTIVE",r,s)}),this.prelude.push(e.source),this.atDirectives=!0;break;case"document":{let t=Su(this.options,this.directives,e,this.onError);this.atDirectives&&!t.directives.docStart&&this.onError(e,"MISSING_CHAR","Missing directives-end/doc-start indicator line"),this.decorate(t,!1),this.doc&&(yield this.doc),this.doc=t,this.atDirectives=!1;break}case"byte-order-mark":case"space":break;case"comment":case"newline":this.prelude.push(e.source);break;case"error":{let t=e.source?`${e.message}: ${JSON.stringify(e.source)}`:e.message,r=new Ge(vr(e),"UNEXPECTED_TOKEN",t);this.atDirectives||!this.doc?this.errors.push(r):this.doc.errors.push(r);break}case"doc-end":{if(!this.doc){let r="Unexpected doc-end without preceding document";this.errors.push(new Ge(vr(e),"UNEXPECTED_TOKEN",r));break}this.doc.directives.docEnd=!0;let t=ot(e.end,e.offset+e.source.length,this.doc.options.strict,this.onError);if(this.decorate(this.doc,!0),t.comment){let r=this.doc.comment;this.doc.comment=r?`${r}\n${t.comment}`:t.comment}this.doc.range[2]=t.offset;break}default:this.errors.push(new Ge(vr(e),"UNEXPECTED_TOKEN",`Unsupported token ${e.type}`))}}*end(e=!1,t=-1){if(this.doc)this.decorate(this.doc,!0),yield this.doc,this.doc=null;else if(e){let r=Object.assign({_directives:this.directives},this.options),s=new It(void 0,r);this.atDirectives&&this.onError(t,"MISSING_CHAR","Missing directives-end indicator line"),s.range=[0,t,t],this.decorate(s,!1),yield s}}};var io=Symbol("break visit"),gf=Symbol("skip children"),Cu=Symbol("remove item");function Wt(n,e){"type"in n&&n.type==="document"&&(n={start:n.start,value:n.value}),vu(Object.freeze([]),n,e)}Wt.BREAK=io;Wt.SKIP=gf;Wt.REMOVE=Cu;Wt.itemAtPath=(n,e)=>{let t=n;for(let[r,s]of e){let i=t==null?void 0:t[r];if(i&&"items"in i)t=i.items[s];else return}return t};Wt.parentCollection=(n,e)=>{let t=Wt.itemAtPath(n,e.slice(0,-1)),r=e[e.length-1][0],s=t==null?void 0:t[r];if(s&&"items"in s)return s;throw new Error("Parent collection not found")};function vu(n,e,t){let r=t(e,n);if(typeof r=="symbol")return r;for(let s of["key","value"]){let i=e[s];if(i&&"items"in i){for(let o=0;o<i.items.length;++o){let a=vu(Object.freeze(n.concat([[s,o]])),i.items[o],t);if(typeof a=="number")o=a-1;else{if(a===io)return io;a===Cu&&(i.items.splice(o,1),o-=1)}}typeof r=="function"&&s==="key"&&(r=r(e,n))}}return typeof r=="function"?r(e,n):r}var oo="\\uFEFF",ao="",uo="",Ms="";function Ou(n){switch(n){case oo:return"byte-order-mark";case ao:return"doc-mode";case uo:return"flow-error-end";case Ms:return"scalar";case"---":return"doc-start";case"...":return"doc-end";case"":case`\n`:case`\\r\n`:return"newline";case"-":return"seq-item-ind";case"?":return"explicit-key-ind";case":":return"map-value-ind";case"{":return"flow-map-start";case"}":return"flow-map-end";case"[":return"flow-seq-start";case"]":return"flow-seq-end";case",":return"comma"}switch(n[0]){case" ":case"	":return"space";case"#":return"comment";case"%":return"directive-line";case"*":return"alias";case"&":return"anchor";case"!":return"tag";case"\'":return"single-quoted-scalar";case\'"\':return"double-quoted-scalar";case"|":case">":return"block-scalar-header"}return null}function Ze(n){switch(n){case void 0:case" ":case`\n`:case"\\r":case"	":return!0;default:return!1}}var xu=new Set("0123456789ABCDEFabcdef"),Ff=new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*\'()"),_s=new Set(",[]{}"),Ef=new Set(` ,[]{}\n\\r	`),lo=n=>!n||Ef.has(n),xr=class{constructor(){this.atEnd=!1,this.blockScalarIndent=-1,this.blockScalarKeep=!1,this.buffer="",this.flowKey=!1,this.flowLevel=0,this.indentNext=0,this.indentValue=0,this.lineEndPos=null,this.next=null,this.pos=0}*lex(e,t=!1){var s;if(e){if(typeof e!="string")throw TypeError("source is not a string");this.buffer=this.buffer?this.buffer+e:e,this.lineEndPos=null}this.atEnd=!t;let r=(s=this.next)!=null?s:"stream";for(;r&&(t||this.hasChars(1));)r=yield*S(this.parseNext(r))}atLineEnd(){let e=this.pos,t=this.buffer[e];for(;t===" "||t==="	";)t=this.buffer[++e];return!t||t==="#"||t===`\n`?!0:t==="\\r"?this.buffer[e+1]===`\n`:!1}charAt(e){return this.buffer[this.pos+e]}continueScalar(e){let t=this.buffer[e];if(this.indentNext>0){let r=0;for(;t===" ";)t=this.buffer[++r+e];if(t==="\\r"){let s=this.buffer[r+e+1];if(s===`\n`||!s&&!this.atEnd)return e+r+1}return t===`\n`||r>=this.indentNext||!t&&!this.atEnd?e+r:-1}if(t==="-"||t==="."){let r=this.buffer.substr(e,3);if((r==="---"||r==="...")&&Ze(this.buffer[e+3]))return-1}return e}getLine(){let e=this.lineEndPos;return(typeof e!="number"||e!==-1&&e<this.pos)&&(e=this.buffer.indexOf(`\n`,this.pos),this.lineEndPos=e),e===-1?this.atEnd?this.buffer.substring(this.pos):null:(this.buffer[e-1]==="\\r"&&(e-=1),this.buffer.substring(this.pos,e))}hasChars(e){return this.pos+e<=this.buffer.length}setNext(e){return this.buffer=this.buffer.substring(this.pos),this.pos=0,this.lineEndPos=null,this.next=e,null}peek(e){return this.buffer.substr(this.pos,e)}*parseNext(e){switch(e){case"stream":return yield*S(this.parseStream());case"line-start":return yield*S(this.parseLineStart());case"block-start":return yield*S(this.parseBlockStart());case"doc":return yield*S(this.parseDocument());case"flow":return yield*S(this.parseFlowCollection());case"quoted-scalar":return yield*S(this.parseQuotedScalar());case"block-scalar":return yield*S(this.parseBlockScalar());case"plain-scalar":return yield*S(this.parsePlainScalar())}}*parseStream(){let e=this.getLine();if(e===null)return this.setNext("stream");if(e[0]===oo&&(yield*S(this.pushCount(1)),e=e.substring(1)),e[0]==="%"){let t=e.length,r=e.indexOf("#");for(;r!==-1;){let i=e[r-1];if(i===" "||i==="	"){t=r-1;break}else r=e.indexOf("#",r+1)}for(;;){let i=e[t-1];if(i===" "||i==="	")t-=1;else break}let s=(yield*S(this.pushCount(t)))+(yield*S(this.pushSpaces(!0)));return yield*S(this.pushCount(e.length-s)),this.pushNewline(),"stream"}if(this.atLineEnd()){let t=yield*S(this.pushSpaces(!0));return yield*S(this.pushCount(e.length-t)),yield*S(this.pushNewline()),"stream"}return yield ao,yield*S(this.parseLineStart())}*parseLineStart(){let e=this.charAt(0);if(!e&&!this.atEnd)return this.setNext("line-start");if(e==="-"||e==="."){if(!this.atEnd&&!this.hasChars(4))return this.setNext("line-start");let t=this.peek(3);if((t==="---"||t==="...")&&Ze(this.charAt(3)))return yield*S(this.pushCount(3)),this.indentValue=0,this.indentNext=0,t==="---"?"doc":"stream"}return this.indentValue=yield*S(this.pushSpaces(!1)),this.indentNext>this.indentValue&&!Ze(this.charAt(1))&&(this.indentNext=this.indentValue),yield*S(this.parseBlockStart())}*parseBlockStart(){let[e,t]=this.peek(2);if(!t&&!this.atEnd)return this.setNext("block-start");if((e==="-"||e==="?"||e===":")&&Ze(t)){let r=(yield*S(this.pushCount(1)))+(yield*S(this.pushSpaces(!0)));return this.indentNext=this.indentValue+1,this.indentValue+=r,yield*S(this.parseBlockStart())}return"doc"}*parseDocument(){yield*S(this.pushSpaces(!0));let e=this.getLine();if(e===null)return this.setNext("doc");let t=yield*S(this.pushIndicators());switch(e[t]){case"#":yield*S(this.pushCount(e.length-t));case void 0:return yield*S(this.pushNewline()),yield*S(this.parseLineStart());case"{":case"[":return yield*S(this.pushCount(1)),this.flowKey=!1,this.flowLevel=1,"flow";case"}":case"]":return yield*S(this.pushCount(1)),"doc";case"*":return yield*S(this.pushUntil(lo)),"doc";case\'"\':case"\'":return yield*S(this.parseQuotedScalar());case"|":case">":return t+=yield*S(this.parseBlockScalarHeader()),t+=yield*S(this.pushSpaces(!0)),yield*S(this.pushCount(e.length-t)),yield*S(this.pushNewline()),yield*S(this.parseBlockScalar());default:return yield*S(this.parsePlainScalar())}}*parseFlowCollection(){let e,t,r=-1;do e=yield*S(this.pushNewline()),e>0?(t=yield*S(this.pushSpaces(!1)),this.indentValue=r=t):t=0,t+=yield*S(this.pushSpaces(!0));while(e+t>0);let s=this.getLine();if(s===null)return this.setNext("flow");if((r!==-1&&r<this.indentNext&&s[0]!=="#"||r===0&&(s.startsWith("---")||s.startsWith("..."))&&Ze(s[3]))&&!(r===this.indentNext-1&&this.flowLevel===1&&(s[0]==="]"||s[0]==="}")))return this.flowLevel=0,yield uo,yield*S(this.parseLineStart());let i=0;for(;s[i]===",";)i+=yield*S(this.pushCount(1)),i+=yield*S(this.pushSpaces(!0)),this.flowKey=!1;switch(i+=yield*S(this.pushIndicators()),s[i]){case void 0:return"flow";case"#":return yield*S(this.pushCount(s.length-i)),"flow";case"{":case"[":return yield*S(this.pushCount(1)),this.flowKey=!1,this.flowLevel+=1,"flow";case"}":case"]":return yield*S(this.pushCount(1)),this.flowKey=!0,this.flowLevel-=1,this.flowLevel?"flow":"doc";case"*":return yield*S(this.pushUntil(lo)),"flow";case\'"\':case"\'":return this.flowKey=!0,yield*S(this.parseQuotedScalar());case":":{let o=this.charAt(1);if(this.flowKey||Ze(o)||o===",")return this.flowKey=!1,yield*S(this.pushCount(1)),yield*S(this.pushSpaces(!0)),"flow"}default:return this.flowKey=!1,yield*S(this.parsePlainScalar())}}*parseQuotedScalar(){let e=this.charAt(0),t=this.buffer.indexOf(e,this.pos+1);if(e==="\'")for(;t!==-1&&this.buffer[t+1]==="\'";)t=this.buffer.indexOf("\'",t+2);else for(;t!==-1;){let i=0;for(;this.buffer[t-1-i]==="\\\\";)i+=1;if(i%2===0)break;t=this.buffer.indexOf(\'"\',t+1)}let r=this.buffer.substring(0,t),s=r.indexOf(`\n`,this.pos);if(s!==-1){for(;s!==-1;){let i=this.continueScalar(s+1);if(i===-1)break;s=r.indexOf(`\n`,i)}s!==-1&&(t=s-(r[s-1]==="\\r"?2:1))}if(t===-1){if(!this.atEnd)return this.setNext("quoted-scalar");t=this.buffer.length}return yield*S(this.pushToIndex(t+1,!1)),this.flowLevel?"flow":"doc"}*parseBlockScalarHeader(){this.blockScalarIndent=-1,this.blockScalarKeep=!1;let e=this.pos;for(;;){let t=this.buffer[++e];if(t==="+")this.blockScalarKeep=!0;else if(t>"0"&&t<="9")this.blockScalarIndent=Number(t)-1;else if(t!=="-")break}return yield*S(this.pushUntil(t=>Ze(t)||t==="#"))}*parseBlockScalar(){let e=this.pos-1,t=0,r;e:for(let i=this.pos;r=this.buffer[i];++i)switch(r){case" ":t+=1;break;case`\n`:e=i,t=0;break;case"\\r":{let o=this.buffer[i+1];if(!o&&!this.atEnd)return this.setNext("block-scalar");if(o===`\n`)break}default:break e}if(!r&&!this.atEnd)return this.setNext("block-scalar");if(t>=this.indentNext){this.blockScalarIndent===-1?this.indentNext=t:this.indentNext=this.blockScalarIndent+(this.indentNext===0?1:this.indentNext);do{let i=this.continueScalar(e+1);if(i===-1)break;e=this.buffer.indexOf(`\n`,i)}while(e!==-1);if(e===-1){if(!this.atEnd)return this.setNext("block-scalar");e=this.buffer.length}}let s=e+1;for(r=this.buffer[s];r===" ";)r=this.buffer[++s];if(r==="	"){for(;r==="	"||r===" "||r==="\\r"||r===`\n`;)r=this.buffer[++s];e=s-1}else if(!this.blockScalarKeep)do{let i=e-1,o=this.buffer[i];o==="\\r"&&(o=this.buffer[--i]);let a=i;for(;o===" ";)o=this.buffer[--i];if(o===`\n`&&i>=this.pos&&i+1+t>a)e=i;else break}while(!0);return yield Ms,yield*S(this.pushToIndex(e+1,!0)),yield*S(this.parseLineStart())}*parsePlainScalar(){let e=this.flowLevel>0,t=this.pos-1,r=this.pos-1,s;for(;s=this.buffer[++r];)if(s===":"){let i=this.buffer[r+1];if(Ze(i)||e&&_s.has(i))break;t=r}else if(Ze(s)){let i=this.buffer[r+1];if(s==="\\r"&&(i===`\n`?(r+=1,s=`\n`,i=this.buffer[r+1]):t=r),i==="#"||e&&_s.has(i))break;if(s===`\n`){let o=this.continueScalar(r+1);if(o===-1)break;r=Math.max(r,o-2)}}else{if(e&&_s.has(s))break;t=r}return!s&&!this.atEnd?this.setNext("plain-scalar"):(yield Ms,yield*S(this.pushToIndex(t+1,!0)),e?"flow":"doc")}*pushCount(e){return e>0?(yield this.buffer.substr(this.pos,e),this.pos+=e,e):0}*pushToIndex(e,t){let r=this.buffer.slice(this.pos,e);return r?(yield r,this.pos+=r.length,r.length):(t&&(yield""),0)}*pushIndicators(){switch(this.charAt(0)){case"!":return(yield*S(this.pushTag()))+(yield*S(this.pushSpaces(!0)))+(yield*S(this.pushIndicators()));case"&":return(yield*S(this.pushUntil(lo)))+(yield*S(this.pushSpaces(!0)))+(yield*S(this.pushIndicators()));case"-":case"?":case":":{let e=this.flowLevel>0,t=this.charAt(1);if(Ze(t)||e&&_s.has(t))return e?this.flowKey&&(this.flowKey=!1):this.indentNext=this.indentValue+1,(yield*S(this.pushCount(1)))+(yield*S(this.pushSpaces(!0)))+(yield*S(this.pushIndicators()))}}return 0}*pushTag(){if(this.charAt(1)==="<"){let e=this.pos+2,t=this.buffer[e];for(;!Ze(t)&&t!==">";)t=this.buffer[++e];return yield*S(this.pushToIndex(t===">"?e+1:e,!1))}else{let e=this.pos+1,t=this.buffer[e];for(;t;)if(Ff.has(t))t=this.buffer[++e];else if(t==="%"&&xu.has(this.buffer[e+1])&&xu.has(this.buffer[e+2]))t=this.buffer[e+=3];else break;return yield*S(this.pushToIndex(e,!1))}}*pushNewline(){let e=this.buffer[this.pos];return e===`\n`?yield*S(this.pushCount(1)):e==="\\r"&&this.charAt(1)===`\n`?yield*S(this.pushCount(2)):0}*pushSpaces(e){let t=this.pos-1,r;do r=this.buffer[++t];while(r===" "||e&&r==="	");let s=t-this.pos;return s>0&&(yield this.buffer.substr(this.pos,s),this.pos=t),s}*pushUntil(e){let t=this.pos,r=this.buffer[t];for(;!e(r);)r=this.buffer[++t];return yield*S(this.pushToIndex(t,!1))}};var Ir=class{constructor(){this.lineStarts=[],this.addNewLine=e=>this.lineStarts.push(e),this.linePos=e=>{let t=0,r=this.lineStarts.length;for(;t<r;){let i=t+r>>1;this.lineStarts[i]<e?t=i+1:r=i}if(this.lineStarts[t]===e)return{line:t+1,col:1};if(t===0)return{line:0,col:e};let s=this.lineStarts[t-1];return{line:t,col:e-s+1}}}};function Ht(n,e){for(let t=0;t<n.length;++t)if(n[t].type===e)return!0;return!1}function Iu(n){for(let e=0;e<n.length;++e)switch(n[e].type){case"space":case"comment":case"newline":break;default:return e}return-1}function Nu(n){switch(n==null?void 0:n.type){case"alias":case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":case"flow-collection":return!0;default:return!1}}function Bs(n){var e;switch(n.type){case"document":return n.start;case"block-map":{let t=n.items[n.items.length-1];return(e=t.sep)!=null?e:t.start}case"block-seq":return n.items[n.items.length-1].start;default:return[]}}function In(n){var t;if(n.length===0)return[];let e=n.length;e:for(;--e>=0;)switch(n[e].type){case"doc-start":case"explicit-key-ind":case"map-value-ind":case"seq-item-ind":case"newline":break e}for(;((t=n[++e])==null?void 0:t.type)==="space";);return n.splice(e,n.length)}function Lu(n){if(n.start.type==="flow-seq-start")for(let e of n.items)e.sep&&!e.value&&!Ht(e.start,"explicit-key-ind")&&!Ht(e.sep,"map-value-ind")&&(e.key&&(e.value=e.key),delete e.key,Nu(e.value)?e.value.end?Array.prototype.push.apply(e.value.end,e.sep):e.value.end=e.sep:Array.prototype.push.apply(e.start,e.sep),delete e.sep)}var Lr=class{constructor(e){this.atNewLine=!0,this.atScalar=!1,this.indent=0,this.offset=0,this.onKeyLine=!1,this.stack=[],this.source="",this.type="",this.lexer=new xr,this.onNewLine=e}*parse(e,t=!1){this.onNewLine&&this.offset===0&&this.onNewLine(0);for(let r of this.lexer.lex(e,t))yield*S(this.next(r));t||(yield*S(this.end()))}*next(e){if(this.source=e,this.atScalar){this.atScalar=!1,yield*S(this.step()),this.offset+=e.length;return}let t=Ou(e);if(t)if(t==="scalar")this.atNewLine=!1,this.atScalar=!0,this.type="scalar";else{switch(this.type=t,yield*S(this.step()),t){case"newline":this.atNewLine=!0,this.indent=0,this.onNewLine&&this.onNewLine(this.offset+e.length);break;case"space":this.atNewLine&&e[0]===" "&&(this.indent+=e.length);break;case"explicit-key-ind":case"map-value-ind":case"seq-item-ind":this.atNewLine&&(this.indent+=e.length);break;case"doc-mode":case"flow-error-end":return;default:this.atNewLine=!1}this.offset+=e.length}else{let r=`Not a YAML token: ${e}`;yield*S(this.pop({type:"error",offset:this.offset,message:r,source:e})),this.offset+=e.length}}*end(){for(;this.stack.length>0;)yield*S(this.pop())}get sourceToken(){return{type:this.type,offset:this.offset,indent:this.indent,source:this.source}}*step(){let e=this.peek(1);if(this.type==="doc-end"&&(!e||e.type!=="doc-end")){for(;this.stack.length>0;)yield*S(this.pop());this.stack.push({type:"doc-end",offset:this.offset,source:this.source});return}if(!e)return yield*S(this.stream());switch(e.type){case"document":return yield*S(this.document(e));case"alias":case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":return yield*S(this.scalar(e));case"block-scalar":return yield*S(this.blockScalar(e));case"block-map":return yield*S(this.blockMap(e));case"block-seq":return yield*S(this.blockSequence(e));case"flow-collection":return yield*S(this.flowCollection(e));case"doc-end":return yield*S(this.documentEnd(e))}yield*S(this.pop())}peek(e){return this.stack[this.stack.length-e]}*pop(e){let t=e!=null?e:this.stack.pop();if(!t)yield{type:"error",offset:this.offset,source:"",message:"Tried to pop an empty stack"};else if(this.stack.length===0)yield t;else{let r=this.peek(1);switch(t.type==="block-scalar"?t.indent="indent"in r?r.indent:0:t.type==="flow-collection"&&r.type==="document"&&(t.indent=0),t.type==="flow-collection"&&Lu(t),r.type){case"document":r.value=t;break;case"block-scalar":r.props.push(t);break;case"block-map":{let s=r.items[r.items.length-1];if(s.value){r.items.push({start:[],key:t,sep:[]}),this.onKeyLine=!0;return}else if(s.sep)s.value=t;else{Object.assign(s,{key:t,sep:[]}),this.onKeyLine=!s.explicitKey;return}break}case"block-seq":{let s=r.items[r.items.length-1];s.value?r.items.push({start:[],value:t}):s.value=t;break}case"flow-collection":{let s=r.items[r.items.length-1];!s||s.value?r.items.push({start:[],key:t,sep:[]}):s.sep?s.value=t:Object.assign(s,{key:t,sep:[]});return}default:yield*S(this.pop()),yield*S(this.pop(t))}if((r.type==="document"||r.type==="block-map"||r.type==="block-seq")&&(t.type==="block-map"||t.type==="block-seq")){let s=t.items[t.items.length-1];s&&!s.sep&&!s.value&&s.start.length>0&&Iu(s.start)===-1&&(t.indent===0||s.start.every(i=>i.type!=="comment"||i.indent<t.indent))&&(r.type==="document"?r.end=s.start:r.items.push({start:s.start}),t.items.splice(-1,1))}}}*stream(){switch(this.type){case"directive-line":yield{type:"directive",offset:this.offset,source:this.source};return;case"byte-order-mark":case"space":case"comment":case"newline":yield this.sourceToken;return;case"doc-mode":case"doc-start":{let e={type:"document",offset:this.offset,start:[]};this.type==="doc-start"&&e.start.push(this.sourceToken),this.stack.push(e);return}}yield{type:"error",offset:this.offset,message:`Unexpected ${this.type} token in YAML stream`,source:this.source}}*document(e){if(e.value)return yield*S(this.lineEnd(e));switch(this.type){case"doc-start":{Iu(e.start)!==-1?(yield*S(this.pop()),yield*S(this.step())):e.start.push(this.sourceToken);return}case"anchor":case"tag":case"space":case"comment":case"newline":e.start.push(this.sourceToken);return}let t=this.startBlockValue(e);t?this.stack.push(t):yield{type:"error",offset:this.offset,message:`Unexpected ${this.type} token in YAML document`,source:this.source}}*scalar(e){if(this.type==="map-value-ind"){let t=Bs(this.peek(2)),r=In(t),s;e.end?(s=e.end,s.push(this.sourceToken),delete e.end):s=[this.sourceToken];let i={type:"block-map",offset:e.offset,indent:e.indent,items:[{start:r,key:e,sep:s}]};this.onKeyLine=!0,this.stack[this.stack.length-1]=i}else yield*S(this.lineEnd(e))}*blockScalar(e){switch(this.type){case"space":case"comment":case"newline":e.props.push(this.sourceToken);return;case"scalar":if(e.source=this.source,this.atNewLine=!0,this.indent=0,this.onNewLine){let t=this.source.indexOf(`\n`)+1;for(;t!==0;)this.onNewLine(this.offset+t),t=this.source.indexOf(`\n`,t)+1}yield*S(this.pop());break;default:yield*S(this.pop()),yield*S(this.step())}}*blockMap(e){var r;let t=e.items[e.items.length-1];switch(this.type){case"newline":if(this.onKeyLine=!1,t.value){let s="end"in t.value?t.value.end:void 0,i=Array.isArray(s)?s[s.length-1]:void 0;(i==null?void 0:i.type)==="comment"?s==null||s.push(this.sourceToken):e.items.push({start:[this.sourceToken]})}else t.sep?t.sep.push(this.sourceToken):t.start.push(this.sourceToken);return;case"space":case"comment":if(t.value)e.items.push({start:[this.sourceToken]});else if(t.sep)t.sep.push(this.sourceToken);else{if(this.atIndentedComment(t.start,e.indent)){let s=e.items[e.items.length-2],i=(r=s==null?void 0:s.value)==null?void 0:r.end;if(Array.isArray(i)){Array.prototype.push.apply(i,t.start),i.push(this.sourceToken),e.items.pop();return}}t.start.push(this.sourceToken)}return}if(this.indent>=e.indent){let s=!this.onKeyLine&&this.indent===e.indent,i=s&&(t.sep||t.explicitKey)&&this.type!=="seq-item-ind",o=[];if(i&&t.sep&&!t.value){let a=[];for(let u=0;u<t.sep.length;++u){let l=t.sep[u];switch(l.type){case"newline":a.push(u);break;case"space":break;case"comment":l.indent>e.indent&&(a.length=0);break;default:a.length=0}}a.length>=2&&(o=t.sep.splice(a[1]))}switch(this.type){case"anchor":case"tag":i||t.value?(o.push(this.sourceToken),e.items.push({start:o}),this.onKeyLine=!0):t.sep?t.sep.push(this.sourceToken):t.start.push(this.sourceToken);return;case"explicit-key-ind":!t.sep&&!t.explicitKey?(t.start.push(this.sourceToken),t.explicitKey=!0):i||t.value?(o.push(this.sourceToken),e.items.push({start:o,explicitKey:!0})):this.stack.push({type:"block-map",offset:this.offset,indent:this.indent,items:[{start:[this.sourceToken],explicitKey:!0}]}),this.onKeyLine=!0;return;case"map-value-ind":if(t.explicitKey)if(t.sep)if(t.value)e.items.push({start:[],key:null,sep:[this.sourceToken]});else if(Ht(t.sep,"map-value-ind"))this.stack.push({type:"block-map",offset:this.offset,indent:this.indent,items:[{start:o,key:null,sep:[this.sourceToken]}]});else if(Nu(t.key)&&!Ht(t.sep,"newline")){let a=In(t.start),u=t.key,l=t.sep;l.push(this.sourceToken),delete t.key,delete t.sep,this.stack.push({type:"block-map",offset:this.offset,indent:this.indent,items:[{start:a,key:u,sep:l}]})}else o.length>0?t.sep=t.sep.concat(o,this.sourceToken):t.sep.push(this.sourceToken);else if(Ht(t.start,"newline"))Object.assign(t,{key:null,sep:[this.sourceToken]});else{let a=In(t.start);this.stack.push({type:"block-map",offset:this.offset,indent:this.indent,items:[{start:a,key:null,sep:[this.sourceToken]}]})}else t.sep?t.value||i?e.items.push({start:o,key:null,sep:[this.sourceToken]}):Ht(t.sep,"map-value-ind")?this.stack.push({type:"block-map",offset:this.offset,indent:this.indent,items:[{start:[],key:null,sep:[this.sourceToken]}]}):t.sep.push(this.sourceToken):Object.assign(t,{key:null,sep:[this.sourceToken]});this.onKeyLine=!0;return;case"alias":case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":{let a=this.flowScalar(this.type);i||t.value?(e.items.push({start:o,key:a,sep:[]}),this.onKeyLine=!0):t.sep?this.stack.push(a):(Object.assign(t,{key:a,sep:[]}),this.onKeyLine=!0);return}default:{let a=this.startBlockValue(e);if(a){s&&a.type!=="block-seq"&&e.items.push({start:o}),this.stack.push(a);return}}}}yield*S(this.pop()),yield*S(this.step())}*blockSequence(e){var r;let t=e.items[e.items.length-1];switch(this.type){case"newline":if(t.value){let s="end"in t.value?t.value.end:void 0,i=Array.isArray(s)?s[s.length-1]:void 0;(i==null?void 0:i.type)==="comment"?s==null||s.push(this.sourceToken):e.items.push({start:[this.sourceToken]})}else t.start.push(this.sourceToken);return;case"space":case"comment":if(t.value)e.items.push({start:[this.sourceToken]});else{if(this.atIndentedComment(t.start,e.indent)){let s=e.items[e.items.length-2],i=(r=s==null?void 0:s.value)==null?void 0:r.end;if(Array.isArray(i)){Array.prototype.push.apply(i,t.start),i.push(this.sourceToken),e.items.pop();return}}t.start.push(this.sourceToken)}return;case"anchor":case"tag":if(t.value||this.indent<=e.indent)break;t.start.push(this.sourceToken);return;case"seq-item-ind":if(this.indent!==e.indent)break;t.value||Ht(t.start,"seq-item-ind")?e.items.push({start:[this.sourceToken]}):t.start.push(this.sourceToken);return}if(this.indent>e.indent){let s=this.startBlockValue(e);if(s){this.stack.push(s);return}}yield*S(this.pop()),yield*S(this.step())}*flowCollection(e){let t=e.items[e.items.length-1];if(this.type==="flow-error-end"){let r;do yield*S(this.pop()),r=this.peek(1);while(r&&r.type==="flow-collection")}else if(e.end.length===0){switch(this.type){case"comma":case"explicit-key-ind":!t||t.sep?e.items.push({start:[this.sourceToken]}):t.start.push(this.sourceToken);return;case"map-value-ind":!t||t.value?e.items.push({start:[],key:null,sep:[this.sourceToken]}):t.sep?t.sep.push(this.sourceToken):Object.assign(t,{key:null,sep:[this.sourceToken]});return;case"space":case"comment":case"newline":case"anchor":case"tag":!t||t.value?e.items.push({start:[this.sourceToken]}):t.sep?t.sep.push(this.sourceToken):t.start.push(this.sourceToken);return;case"alias":case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":{let s=this.flowScalar(this.type);!t||t.value?e.items.push({start:[],key:s,sep:[]}):t.sep?this.stack.push(s):Object.assign(t,{key:s,sep:[]});return}case"flow-map-end":case"flow-seq-end":e.end.push(this.sourceToken);return}let r=this.startBlockValue(e);r?this.stack.push(r):(yield*S(this.pop()),yield*S(this.step()))}else{let r=this.peek(2);if(r.type==="block-map"&&(this.type==="map-value-ind"&&r.indent===e.indent||this.type==="newline"&&!r.items[r.items.length-1].sep))yield*S(this.pop()),yield*S(this.step());else if(this.type==="map-value-ind"&&r.type!=="flow-collection"){let s=Bs(r),i=In(s);Lu(e);let o=e.end.splice(1,e.end.length);o.push(this.sourceToken);let a={type:"block-map",offset:e.offset,indent:e.indent,items:[{start:i,key:e,sep:o}]};this.onKeyLine=!0,this.stack[this.stack.length-1]=a}else yield*S(this.lineEnd(e))}}flowScalar(e){if(this.onNewLine){let t=this.source.indexOf(`\n`)+1;for(;t!==0;)this.onNewLine(this.offset+t),t=this.source.indexOf(`\n`,t)+1}return{type:e,offset:this.offset,indent:this.indent,source:this.source}}startBlockValue(e){switch(this.type){case"alias":case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":return this.flowScalar(this.type);case"block-scalar-header":return{type:"block-scalar",offset:this.offset,indent:this.indent,props:[this.sourceToken],source:""};case"flow-map-start":case"flow-seq-start":return{type:"flow-collection",offset:this.offset,indent:this.indent,start:this.sourceToken,items:[],end:[]};case"seq-item-ind":return{type:"block-seq",offset:this.offset,indent:this.indent,items:[{start:[this.sourceToken]}]};case"explicit-key-ind":{this.onKeyLine=!0;let t=Bs(e),r=In(t);return r.push(this.sourceToken),{type:"block-map",offset:this.offset,indent:this.indent,items:[{start:r,explicitKey:!0}]}}case"map-value-ind":{this.onKeyLine=!0;let t=Bs(e),r=In(t);return{type:"block-map",offset:this.offset,indent:this.indent,items:[{start:r,key:null,sep:[this.sourceToken]}]}}}return null}atIndentedComment(e,t){return this.type!=="comment"||this.indent<=t?!1:e.every(r=>r.type==="newline"||r.type==="space")}*documentEnd(e){this.type!=="doc-mode"&&(e.end?e.end.push(this.sourceToken):e.end=[this.sourceToken],this.type==="newline"&&(yield*S(this.pop())))}*lineEnd(e){switch(this.type){case"comma":case"doc-start":case"doc-end":case"flow-seq-end":case"flow-map-end":case"map-value-ind":yield*S(this.pop()),yield*S(this.step());break;case"newline":this.onKeyLine=!1;case"space":case"comment":default:e.end?e.end.push(this.sourceToken):e.end=[this.sourceToken],this.type==="newline"&&(yield*S(this.pop()))}}};function wf(n){let e=n.prettyErrors!==!1;return{lineCounter:n.lineCounter||e&&new Ir||null,prettyErrors:e}}function Au(n,e={}){let{lineCounter:t,prettyErrors:r}=wf(e),s=new Lr(t==null?void 0:t.addNewLine),i=new Or(e),o=null;for(let a of i.compose(s.parse(n),!0,n.length))if(!o)o=a;else if(o.options.logLevel!=="silent"){o.errors.push(new Ge(a.range.slice(0,2),"MULTIPLE_DOCS","Source contains multiple documents; please use YAML.parseAllDocuments()"));break}return r&&t&&(o.errors.forEach(Zi(n,t)),o.warnings.forEach(Zi(n,t))),o}function co(n,e,t){let r;typeof e=="function"?r=e:t===void 0&&e&&typeof e=="object"&&(t=e);let s=Au(n,t);if(!s)return null;if(s.warnings.forEach(i=>ms(s.options.logLevel,i)),s.errors.length>0){if(s.options.logLevel!=="silent")throw s.errors[0];s.errors=[]}return s.toJS(Object.assign({reviver:r},t))}var js=Vr(Ru());var F=Vr(ns());var Qe;(N=>{N.DEFAULT_TO_STRING={nullRepresentation:"-",dateFormat:"MMMM dd, yyyy",dateTimeFormat:"h:mm a - MMMM dd, yyyy"};function e(y,w=N.DEFAULT_TO_STRING,v=!1){let O=t(y);if(!O)return w.nullRepresentation;switch(O.type){case"null":return w.nullRepresentation;case"string":return O.value;case"number":case"boolean":return""+O.value;case"link":return O.value.markdown();case"function":return"<function>";case"array":let C="";return v&&(C+="["),C+=O.value.map(U=>e(U,w,!0)).join(", "),v&&(C+="]"),C;case"object":return"{ "+Object.entries(O.value).map(U=>U[0]+": "+e(U[1],w,!0)).join(", ")+" }";case"date":return ja(O.value,w.dateFormat,w.dateTimeFormat);case"duration":return qa(O.value)}}N.toString=e;function t(y){return h(y)?{type:"null",value:y}:f(y)?{type:"number",value:y}:l(y)?{type:"string",value:y}:g(y)?{type:"boolean",value:y}:m(y)?{type:"duration",value:y}:d(y)?{type:"date",value:y}:b(y)?{type:"array",value:y}:D(y)?{type:"link",value:y}:I(y)?{type:"function",value:y}:T(y)?{type:"object",value:y}:void 0}N.wrapValue=t;function r(y,w){if(T(y)){let v={};for(let[O,C]of Object.entries(y))v[O]=r(C,w);return v}else if(b(y)){let v=[];for(let O of y)v.push(r(O,w));return v}else return w(y)}N.mapLeaves=r;function s(y,w){return i(y,w)==0}N.equals=s;function i(y,w,v){var U,j;if(y===w||(y===void 0&&(y=null),w===void 0&&(w=null),y===null&&w===null))return 0;if(y===null)return-1;if(w===null)return 1;let O=t(y),C=t(w);if(O===void 0&&C===void 0)return 0;if(O===void 0)return-1;if(C===void 0)return 1;if(O.type!=C.type)return O.type.localeCompare(C.type);if(O.value===C.value)return 0;switch(O.type){case"string":return O.value.localeCompare(C.value);case"number":return O.value<C.value?-1:O.value==C.value?0:1;case"null":return 0;case"boolean":return O.value==C.value?0:O.value?1:-1;case"link":let G=O.value,x=C.value,B=v!=null?v:Ne=>Ne,q=B(G.path).localeCompare(B(x.path));if(q!=0)return q;let de=G.type.localeCompare(x.type);return de!=0?de:G.subpath&&!x.subpath?1:!G.subpath&&x.subpath?-1:!G.subpath&&!x.subpath?0:((U=G.subpath)!=null?U:"").localeCompare((j=x.subpath)!=null?j:"");case"date":return O.value<C.value?-1:O.value.equals(C.value)?0:1;case"duration":return O.value<C.value?-1:O.value.equals(C.value)?0:1;case"array":let he=O.value,oe=C.value;for(let Ne=0;Ne<Math.min(he.length,oe.length);Ne++){let Mt=i(he[Ne],oe[Ne]);if(Mt!=0)return Mt}return he.length-oe.length;case"object":let Mr=O.value,_r=C.value,Gt=Array.from(Object.keys(Mr)),Nt=Array.from(Object.keys(_r));Gt.sort(),Nt.sort();let At=i(Gt,Nt);if(At!=0)return At;for(let Ne of Gt){let Mt=i(Mr[Ne],_r[Ne]);if(Mt!=0)return Mt}return 0;case"function":return 0}}N.compare=i;function o(y){var w;return(w=t(y))==null?void 0:w.type}N.typeOf=o;function a(y){let w=t(y);if(!w)return!1;switch(w.type){case"number":return w.value!=0;case"string":return w.value.length>0;case"boolean":return w.value;case"link":return!!w.value.path;case"date":return w.value.toMillis()!=0;case"duration":return w.value.as("seconds")!=0;case"object":return Object.keys(w.value).length>0;case"array":return w.value.length>0;case"null":return!1;case"function":return!0}}N.isTruthy=a;function u(y){if(y==null)return y;if(N.isArray(y))return[].concat(y.map(w=>u(w)));if(N.isObject(y)){let w={};for(let[v,O]of Object.entries(y))w[v]=u(O);return w}else return y}N.deepCopy=u;function l(y){return typeof y=="string"}N.isString=l;function f(y){return typeof y=="number"}N.isNumber=f;function d(y){return y instanceof V}N.isDate=d;function m(y){return y instanceof P}N.isDuration=m;function h(y){return y==null}N.isNull=h;function b(y){return Array.isArray(y)}N.isArray=b;function g(y){return typeof y=="boolean"}N.isBoolean=g;function D(y){return y instanceof Oe}N.isLink=D;function T(y){return y!==void 0&&typeof y=="object"&&!b(y)&&!m(y)&&!d(y)&&!D(y)&&!h(y)}N.isObject=T;function I(y){return typeof y=="function"}N.isFunction=I})(Qe||(Qe={}));var ju;(i=>{function n(o){return Qe.isObject(o)&&Object.keys(o).length==2&&"key"in o&&"rows"in o}i.isElementGroup=n;function e(o){for(let a of o)if(!n(a))return!1;return!0}i.isGrouping=e;function t(o){for(let a of o)if(n(a))return!1;return!0}i.isLeaf=t;function r(o){if(n(o))return r(o.rows);if(e(o)){let a=0;for(let u of o)a+=r(u.rows);return a}else return o.length}i.count=r;function s(o,a,u){if(u<=a)return[];if(t(o))return o.slice(a,u);let l=0,f=0;for(;l<o.length&&f+r(o[l])<=a;)f+=r(o[l]),l++;if(l>=o.length)return[];let d=[];for(;l<o.length&&f<u;){let m=o[l],h=r(m),b=Math.max(f,a),g=Math.min(h+f,u);d.push({key:m.key,rows:s(m.rows,b-f,g-f)}),f+=h,l++}return d}i.slice=s})(ju||(ju={}));var ho=class n{constructor(e){this.value=e;this.successful=!0}map(e){return new n(e(this.value))}flatMap(e){return e(this.value)}mapErr(e){return this}bimap(e,t){return this.map(e)}orElse(e){return this.value}cast(){return this}orElseThrow(e){return this.value}},mo=class n{constructor(e){this.error=e;this.successful=!1}map(e){return this}flatMap(e){return this}mapErr(e){return new n(e(this.error))}bimap(e,t){return this.mapErr(t)}orElse(e){return e}cast(){return this}orElseThrow(e){throw e?new Error(e(this.error)):new Error(""+this.error)}},Te;(a=>{function n(u){return new ho(u)}a.success=n;function e(u){return new mo(u)}a.failure=e;function t(u,l,f){return u.successful?l.successful?f(u.value,l.value):e(l.error):e(u.error)}a.flatMap2=t;function r(u,l,f){return t(u,l,(d,m)=>n(f(d,m)))}a.map2=r;function s(u,l){let f=[];for(let d of u){let m=l(d);if(!m.successful)return m.cast();f.push(m.value)}return a.success(f)}a.mapAll=s;function i(u){try{return a.success(u())}catch(l){return a.failure(l)}}a.trying=i;async function o(u){try{return a.success(await u)}catch(l){return a.failure(l)}}a.async=o})(Te||(Te={}));var Jt;(N=>{N.EVERYTHING={type:"everything"},N.NOTHING={type:"nothing"},N.EMPTY_SET=new Set;function r(y){return y.size==0?N.NOTHING:{type:"atom",value:y}}N.atom=r;function s(y){return y?N.EVERYTHING:N.NOTHING}N.constant=s;function i(y){return y!==void 0?r(y):N.NOTHING}N.nullableAtom=i;function o(y){return y.size==0?N.EVERYTHING:{type:"negated",value:y}}N.negated=o;function a(y){switch(y.type){case"everything":return N.NOTHING;case"nothing":return N.EVERYTHING;case"atom":return o(y.value);case"negated":return r(y.value)}}N.negate=a;function u(y){switch(y.type){case"everything":return!1;case"negated":return!1;case"atom":return y.value.size==0;case"nothing":return!0}}N.empty=u;function l(y,w){switch(y.type){case"everything":return w;case"nothing":return N.EMPTY_SET;case"atom":return y.value;case"negated":return I(w,y.value)}}N.resolve=l;function f(y){return d(y,w=>w)}N.intersect=f;function d(y,w){return m(y,v=>Te.success(w(v))).orElseThrow()}N.lazyIntersect=d;function m(y,w){let v=[],O=[];for(let C of y){let U=w(C);if(!U.successful)return U.cast();let j=U.value;if(j!==void 0){if(u(j))return Te.success(N.NOTHING);j.type!=="everything"&&(j.type=="atom"?v.push(j.value):j.type=="negated"&&O.push(j.value))}}return v.length==0&&O.length==0?Te.success(N.EVERYTHING):v.length>0&&O.length==0?Te.success(r(D(v))):v.length==0&&O.length>0?Te.success(o(T(O))):Te.success(N.atom(I(D(v),T(O))))}N.lazyFailableIntersection=m;function h(y){return b(y,w=>w)}N.union=h;function b(y,w){return g(y,v=>Te.success(w(v))).orElseThrow()}N.lazyUnion=b;function g(y,w){let v=[],O=[];for(let C of y){let U=w(C);if(!U.successful)return U.cast();let j=U.value;if(j!==void 0){if(j.type==="everything")return Te.success(N.EVERYTHING);u(j)||(j.type=="atom"?v.push(j.value):j.type=="negated"&&O.push(j.value))}}return v.length==0&&O.length==0?Te.success(N.NOTHING):v.length>0&&O.length==0?Te.success(N.atom(T(v))):v.length==0&&O.length>0?Te.success(N.negated(D(O))):Te.success(o(I(D(O),T(v))))}N.lazyFailableUnion=g;function D(y){if(y.length==0)return new Set;if(y.length==1)return y[0];let w=[].concat(y).sort((v,O)=>v.size-O.size);for(;w.length>1;){let v=new Set,O=w.pop();for(let C of w[0])O.has(C)&&v.add(C);w[0]=v}return w[0]}N.setIntersect=D;function T(y){if(y.length==0)return new Set;if(y.length==1)return y[0];let w=new Set;for(let v of y)for(let O of v)w.add(O);return w}N.setUnion=T;function I(y,w){if(y.size>w.size){let v=new Set(y);for(let O of w)v.delete(O);return v}else{let v=new Set;for(let O of y)w.has(O)||v.add(O);return v}}N.setIntersectNegation=I})(Jt||(Jt={}));var re;(g=>{g.ROW="$row";function e(D){return{type:"variable",name:D}}g.variable=e;function t(D){return{type:"literal",value:D}}g.literal=t;function r(D,T,I){return{type:"binaryop",left:D,op:T,right:I}}g.binaryOp=r;function s(D,T){return{type:"binaryop",left:D,right:T,op:"index"}}g.index=s;function i(D){let T=D.split("."),I=g.variable(T[0]);for(let N=1;N<T.length;N++)I=g.index(I,g.literal(T[N]));return I}g.indexVariable=i;function o(D,T){return{type:"lambda",arguments:D,value:T}}g.lambda=o;function a(D,T){return{type:"function",func:D,arguments:T}}g.func=a;function u(D){return{type:"list",values:D}}g.list=u;function l(D){return{type:"object",values:D}}g.object=l;function f(D){return{type:"negated",child:D}}g.negate=f;function d(D){return D=="<="||D=="<"||D==">"||D==">="||D=="!="||D=="="}g.isCompareOp=d;function m(D,T=new Set([g.ROW])){switch(D.type){case"binaryop":return D.op==="index"&&D.left.type=="variable"&&D.left.name==g.ROW&&D.right.type=="literal"&&Qe.isString(D.right.value)?T.has(D.right.value)?new Set:new Set([D.right.value]):Jt.setUnion([m(D.left,T),m(D.right,T)]);case"function":return Jt.setUnion(D.arguments.map(N=>m(N,T)));case"lambda":let I=T!=null?T:new Set;for(let N of D.arguments)I.add(N);return m(D.value,I);case"list":return Jt.setUnion(D.values.map(N=>m(N,T)));case"negated":return m(D.child,T);case"object":return Jt.setUnion(Object.values(D.values).map(N=>m(N,T)));case"variable":return T&&T.has(D.name)?new Set:new Set([D.name]);case"literal":return new Set}}g.unboundVariables=m;function h(D){switch(D.type){case"binaryop":return D.op==="index"?`${h(D.left)}[${h(D.right)}]`:`${h(D.left)} ${D.op} ${h(D.right)}`;case"function":return`${h(D.func)}(${D.arguments.map(h).join(", ")})`;case"lambda":return`(${D.arguments.join(", ")}) => ${h(D.value)}`;case"list":return`[${D.values.map(h).join(", ")}]`;case"negated":return`!${h(D.child)}`;case"object":return`{${Object.entries(D.values).map(([I,N])=>`${I}: ${h(N)}`).join(", ")}}`;case"variable":return D.name;case"literal":let T=Qe.wrapValue(D.value);if(!T)return"null";switch(T.type){case"string":return`"${T.value}"`;default:return Qe.toString(T.value)}}}g.toString=h,g.NULL=g.literal(null)})(re||(re={}));var Y=F.createLanguage({number:n=>F.regexp(/-?[0-9]+(\\.[0-9]+)?/).map(e=>Number.parseFloat(e)).desc("number"),string:n=>F.string(\'"\').then(F.alt(n.escapeCharacter,F.noneOf(\'"\\\\\')).atLeast(0).map(e=>e.join(""))).skip(F.string(\'"\')).desc("string"),escapeCharacter:n=>F.string("\\\\").then(F.any).map(e=>e===\'"\'?\'"\':e==="\\\\"?"\\\\":"\\\\"+e),bool:n=>F.regexp(/true|false|True|False/).map(e=>e.toLowerCase()=="true").desc("boolean"),tag:n=>F.seqMap(F.string("#"),F.alt(F.regexp(/[^\\u2000-\\u206F\\u2E00-\\u2E7F\'!"#$%&()*+,.:;<=>?@^`{|}~\\[\\]\\\\\\s]/).desc("text")).many(),(e,t)=>e+t.join("")).desc("tag"),identifier:n=>F.seqMap(F.alt(F.regexp(/[\\p{Letter}$]/u),F.regexp(qu).desc("text")),F.alt(F.regexp(/[0-9\\p{Letter}$_-]/u),F.regexp(qu).desc("text")).many(),(e,t)=>e+t.join("")).desc("variable"),link:n=>F.regexp(/\\[\\[([^\\[\\]]*?)\\]\\]/u,1).map(e=>Oe.parseInner(e)).desc("file link"),embedLink:n=>F.seqMap(F.string("!").atMost(1),n.link,(e,t)=>(e.length>0&&(t.embed=!0),t)).desc("file link"),binaryPlusMinus:n=>F.regexp(/\\+|-/).map(e=>e).desc("\'+\' or \'-\'"),binaryMulDiv:n=>F.regexp(/\\*|\\/|%/).map(e=>e).desc("\'*\' or \'/\' or \'%\'"),binaryCompareOp:n=>F.regexp(/>=|<=|!=|>|<|=/).map(e=>e).desc("\'>=\' or \'<=\' or \'!=\' or \'=\' or \'>\' or \'<\'"),binaryAndOp:n=>F.regexp(/and|&/i).map(e=>"&").desc("\'and\'"),binaryOrOp:n=>F.regexp(/or|\\|/i).map(e=>"|").desc("\'or\'"),rootDate:n=>F.seqMap(F.regexp(/\\d{4}/),F.string("-"),F.regexp(/\\d{2}/),(e,t,r)=>V.fromObject({year:Number.parseInt(e),month:Number.parseInt(r)})).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),dateShorthand:n=>F.alt(...Object.keys(Uu).sort((e,t)=>t.length-e.length).map(F.string)),date:n=>xf(n.rootDate,e=>F.seqMap(F.string("-"),F.regexp(/\\d{2}/),(t,r)=>e.set({day:Number.parseInt(r)})),e=>F.seqMap(F.string("T"),F.regexp(/\\d{2}/),(t,r)=>e.set({hour:Number.parseInt(r)})),e=>F.seqMap(F.string(":"),F.regexp(/\\d{2}/),(t,r)=>e.set({minute:Number.parseInt(r)})),e=>F.seqMap(F.string(":"),F.regexp(/\\d{2}/),(t,r)=>e.set({second:Number.parseInt(r)})),e=>F.alt(F.seqMap(F.string("."),F.regexp(/\\d{3}/),(t,r)=>e.set({millisecond:Number.parseInt(r)})),F.succeed(e)),e=>F.alt(F.seqMap(F.string("+").or(F.string("-")),F.regexp(/\\d{1,2}(:\\d{2})?/),(t,r)=>e.setZone("UTC"+t+r,{keepLocalTime:!0})),F.seqMap(F.string("Z"),()=>e.setZone("utc",{keepLocalTime:!0})),F.seqMap(F.string("["),F.regexp(/[0-9A-Za-z+-\\/]+/u),F.string("]"),(t,r,s)=>e.setZone(r,{keepLocalTime:!0})))).assert(e=>e.isValid,"valid date").desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),datePlus:n=>F.alt(n.dateShorthand.map(e=>Uu[e]()),n.date).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS] or in shorthand"),durationType:n=>F.alt(...Object.keys(Vu).sort((e,t)=>t.length-e.length).map(F.string)),duration:n=>F.seqMap(n.number,F.optWhitespace,n.durationType,(e,t,r)=>Vu[r].mapUnits(s=>s*e)).sepBy1(F.string(",").trim(F.optWhitespace).or(F.optWhitespace)).map(e=>e.reduce((t,r)=>t.plus(r))).desc("duration like 4hr2min"),rawNull:n=>F.string("null"),atomInlineField:n=>F.alt(n.date,n.duration.map(e=>Mi(e)),n.string,n.tag,n.embedLink,n.bool,n.number,n.rawNull),inlineFieldList:n=>n.atomInlineField.sepBy(F.string(",").trim(F.optWhitespace).lookahead(n.atomInlineField)),inlineField:n=>F.alt(F.seqMap(n.atomInlineField,F.string(",").trim(F.optWhitespace),n.inlineFieldList,(e,t,r)=>[e].concat(r)),n.atomInlineField)}),qu=new RegExp(gn(),""),Vu={year:P.fromObject({years:1}),years:P.fromObject({years:1}),yr:P.fromObject({years:1}),yrs:P.fromObject({years:1}),month:P.fromObject({months:1}),months:P.fromObject({months:1}),mo:P.fromObject({months:1}),mos:P.fromObject({months:1}),week:P.fromObject({weeks:1}),weeks:P.fromObject({weeks:1}),wk:P.fromObject({weeks:1}),wks:P.fromObject({weeks:1}),w:P.fromObject({weeks:1}),day:P.fromObject({days:1}),days:P.fromObject({days:1}),d:P.fromObject({days:1}),hour:P.fromObject({hours:1}),hours:P.fromObject({hours:1}),hr:P.fromObject({hours:1}),hrs:P.fromObject({hours:1}),h:P.fromObject({hours:1}),minute:P.fromObject({minutes:1}),minutes:P.fromObject({minutes:1}),min:P.fromObject({minutes:1}),mins:P.fromObject({minutes:1}),m:P.fromObject({minutes:1}),second:P.fromObject({seconds:1}),seconds:P.fromObject({seconds:1}),sec:P.fromObject({seconds:1}),secs:P.fromObject({seconds:1}),s:P.fromObject({seconds:1})},Uu={now:()=>V.local(),today:()=>V.local().startOf("day"),yesterday:()=>V.local().startOf("day").minus(P.fromObject({days:1})),tomorrow:()=>V.local().startOf("day").plus(P.fromObject({days:1})),sow:()=>V.local().startOf("week"),"start-of-week":()=>V.local().startOf("week"),eow:()=>V.local().endOf("week"),"end-of-week":()=>V.local().endOf("week"),soy:()=>V.local().startOf("year"),"start-of-year":()=>V.local().startOf("year"),eoy:()=>V.local().endOf("year"),"end-of-year":()=>V.local().endOf("year"),som:()=>V.local().startOf("month"),"start-of-month":()=>V.local().startOf("month"),eom:()=>V.local().endOf("month"),"end-of-month":()=>V.local().endOf("month")},Ku=F.createLanguage({variable:n=>Y.identifier.map(re.variable).desc("variable"),number:n=>Y.number.map(re.literal).desc("number"),string:n=>Y.string.map(re.literal).desc("string"),bool:n=>Y.bool.map(re.literal).desc("boolean"),date:n=>wt("date",Y.datePlus).map(([e,t])=>re.literal(t)).desc("date"),duration:n=>wt("dur",Y.duration).map(([e,t])=>re.literal(t)).desc("duration"),null:n=>Y.rawNull.map(e=>re.NULL),link:n=>Y.link.map(re.literal),list:n=>n.expression.sepBy(F.string(",").trim(F.optWhitespace)).wrap(F.string("[").skip(F.optWhitespace),F.optWhitespace.then(F.string("]"))).map(e=>re.list(e)).desc("list"),object:n=>F.seqMap(Y.identifier.or(Y.string),F.string(":").trim(F.optWhitespace),n.expression,(e,t,r)=>({name:e,value:r})).sepBy(F.string(",").trim(F.optWhitespace)).wrap(F.string("{").skip(F.optWhitespace),F.optWhitespace.then(F.string("}"))).map(e=>{let t={};for(let r of e)t[r.name]=r.value;return re.object(t)}).desc("object (\'{ a: 1, b: 2 }\')"),atom:n=>F.alt(Y.embedLink.map(e=>re.literal(e)),n.negated,n.link,n.list,n.object,n.lambda,n.parens,n.bool,n.number,n.string,n.date,n.duration,n.null,n.variable),index:n=>F.seqMap(n.atom,F.alt(n.dotPostfix,n.indexPostfix,n.functionPostfix).many(),(e,t)=>{let r=e;for(let s of t)switch(s.type){case"dot":r=re.index(r,re.literal(s.expr));break;case"index":r=re.index(r,s.expr);break;case"function":r=re.func(r,s.exprs);break}return r}),negated:n=>F.seqMap(F.string("!"),n.index,(e,t)=>re.negate(t)).desc("negated field"),parens:n=>n.expression.trim(F.optWhitespace).wrap(F.string("("),F.string(")")),lambda:n=>F.seqMap(Y.identifier.sepBy(F.string(",").trim(F.optWhitespace)).wrap(F.string("(").trim(F.optWhitespace),F.string(")").trim(F.optWhitespace)),F.string("=>").trim(F.optWhitespace),n.expression,(e,t,r)=>({type:"lambda",arguments:e,value:r})),dotPostfix:n=>F.seqMap(F.string("."),Y.identifier,(e,t)=>({type:"dot",expr:t})),indexPostfix:n=>F.seqMap(F.string("["),F.optWhitespace,n.expression,F.optWhitespace,F.string("]"),(e,t,r,s,i)=>({type:"index",expr:r})),functionPostfix:n=>F.seqMap(F.string("("),F.optWhitespace,n.expression.sepBy(F.string(",").trim(F.optWhitespace)),F.optWhitespace,F.string(")"),(e,t,r,s,i)=>({type:"function",exprs:r})),binaryMulDiv:n=>Nn(n.index,Y.binaryMulDiv,re.binaryOp),binaryPlusMinus:n=>Nn(n.binaryMulDiv,Y.binaryPlusMinus,re.binaryOp),binaryCompare:n=>Nn(n.binaryPlusMinus,Y.binaryCompareOp,re.binaryOp),binaryBoolean:n=>Nn(n.binaryCompare,Y.binaryAndOp.or(Y.binaryOrOp),re.binaryOp),binaryOp:n=>n.binaryBoolean,expression:n=>n.binaryOp}),lb=F.createLanguage({queryTag:n=>Y.tag.map(e=>({type:"tagged",value:e})),queryId:n=>wt("id",Y.string).map(([e,t])=>({type:"id",value:t})),queryType:n=>F.string("@").then(Y.identifier).map(e=>({type:"typed",value:e})),queryPath:n=>wt(F.regexp(/e?path/i).desc("[e]path"),Y.string).map(([e,t])=>({type:"path",value:t,exact:e.toLowerCase()==="epath"})),queryParentOf:n=>wt(F.regexp(/parentof|supertree/i).desc("parentof"),n.query).map(([e,t])=>({type:"parent-of",children:t,inclusive:e.toLowerCase()==="supertree"})),queryChildOf:n=>wt(F.regexp(/childof|subtree/i).desc("childof"),n.query).map(([e,t])=>({type:"child-of",parents:t,inclusive:e.toLowerCase()==="subtree"})),querySimpleLinked:n=>Y.link.map(e=>({type:"linked",source:{type:"link",value:e},direction:"incoming"})),queryLinked:n=>wt(F.regexp(/linksto|linkedfrom|connected/i).desc("connected"),n.query).map(([e,t])=>({type:"linked",source:t,direction:e.toLowerCase()=="linksto"?"incoming":e.toLowerCase()=="linkedfrom"?"outgoing":"both"})),queryExists:n=>wt(F.regexp(/exists/i).desc("exists"),Y.identifier.or(Y.string)).map(([e,t])=>({type:"field",value:t})),queryQuotedExpression:n=>wt(F.regexp(/expr/i).desc("expr"),Ku.expression).map(([e,t])=>({type:"expression",expression:t})),queryRawExpression:n=>Ku.binaryCompare.map(e=>({type:"expression",expression:e})),queryParens:n=>n.query.trim(F.optWhitespace).wrap(F.string("("),F.string(")")),queryNegate:n=>F.string("!").skip(F.optWhitespace).then(n.queryAtom).map(e=>({type:"not",element:e})),queryAtom:n=>F.alt(n.queryParens,n.queryNegate,n.querySimpleLinked,n.queryTag,n.queryType,n.queryId,n.queryExists,n.queryChildOf,n.queryParentOf,n.queryLinked,n.queryPath,n.queryQuotedExpression,n.queryRawExpression),queryAnds:n=>Nn(n.queryAtom,Y.binaryAndOp,(e,t,r)=>({type:"and",elements:[e,r]})),queryOrs:n=>Nn(n.queryAnds,Y.binaryOrOp,(e,t,r)=>({type:"or",elements:[e,r]})),query:n=>n.queryOrs.trim(F.optWhitespace)});function Nn(n,e,t){return F.seqMap(n,F.seq(F.optWhitespace,e,F.optWhitespace,n).many(),(r,s)=>{if(s.length==0)return r;let i=t(r,s[0][1],s[0][3]);for(let o=1;o<s.length;o++)i=t(i,s[o][1],s[o][3]);return i})}function wt(n,e){let t=typeof n=="string"?F.string(n):n;return F.seqMap(t.skip(F.optWhitespace),e.trim(F.optWhitespace).wrap(F.string("("),F.string(")")),(r,s)=>[r,s])}function xf(n,...e){return F.custom((t,r)=>(s,i)=>{let o=n._(s,i);if(!o.status)return o;for(let a of e){let u=a(o.value)._(s,o.index);if(!u.status)return o;o=u}return o})}var Yt=Vr(ns());function zt(n,e){let t={};for(let[r,s]of Object.entries(n))t[r]=e(s);return t}var An;(r=>{r.NOOP_NORMALIZER=s=>s;function e(s){let i=Qe.wrapValue(s);if(!i)return null;switch(i==null?void 0:i.type){case"array":return i.value.map(r.json);case"object":return zt(i.value,r.json);case"date":return{$_type:"date",value:i.value.toISO({extendedZone:!0,includeOffset:!0})};case"link":return{$_type:"link",value:i.value.toObject()};case"duration":return{$_type:"duration",value:i.value.toISO()};case"boolean":case"number":case"string":return i.value;case"function":case"null":return null}}r.json=e;function t(s,i=r.NOOP_NORMALIZER){if(s==null)return null;if(Array.isArray(s))return i(s.map(o=>r.value(o,i)));if(typeof s=="object"){if(!("$_type"in s))return zt(s,a=>r.value(a,i));let o=s.$_type;switch(o){case"date":return i(V.fromISO(s.value));case"duration":return i(P.fromISO(s.value));case"link":return i(Oe.fromObject(s.value));default:throw new Error(`Unrecognized serialized type \'${o}\'!`)}}return i(s)}r.value=t})(An||(An={}));function Wu(n){return Object.assign({},n,{value:An.json(n.value)})}function $s(n,e){return Array.isArray(n)?n.map(t=>$s(t,e)):{key:n.key,raw:n.value,value:Nf(n.value),position:{line:e,start:n.start,startValue:n.startValue,end:n.end},wrapping:n.wrapping}}var Ps=Object.freeze({"[":"]","(":")"});function If(n,e,t,r){let s=0,i=!1;for(let o=e;o<n.length;o++){let a=n.charAt(o);if(a=="\\\\"){i=!i;continue}if(i){i=!1;continue}if(a==t?s++:a==r&&s--,s<0)return{value:n.substring(e,o).trim(),endIndex:o+1};i=!1}}function Hu(n,e){let t=n.indexOf("::",e);if(!(t<0))return{key:n.substring(e,t).trim(),valueIndex:t+2}}function Lf(n,e){let t=n.charAt(e),r=Hu(n,e+1);if(r===void 0)return;for(let i of Object.keys(Ps).concat(Object.values(Ps)))if(r.key.includes(i))return;let s=If(n,r.valueIndex,t,Ps[t]);if(s!==void 0)return{key:r.key,value:s.value,start:e,startValue:r.valueIndex,end:s.endIndex,wrapping:t}}function Nf(n){if(n.trim()=="")return null;let e=Y.inlineField.parse(n);return e.status?e.value:n}function Ju(n,e=!1){let t=[];for(let s of Object.keys(Ps)){let i=n.indexOf(s);for(;i>=0;){let o=Lf(n,i);if(!o){i=n.indexOf(s,i+1);continue}t.push(o),i=n.indexOf(s,o.end)}}e&&(t=t.concat(qf(n))),t.sort((s,i)=>s.start-i.start);let r=[];for(let s=0;s<t.length;s++)(s==0||r[r.length-1].end<t[s].start)&&r.push(t[s]);return r}var Af=Yt.alt(Yt.regexp(new RegExp(gn(),"u")),Yt.regexp(/[0-9\\p{Letter}\\w\\s_/-]+/u)).many().map(n=>n.join("")),Mf=Yt.regexp(/[^0-9\\w\\p{Letter}]*/u).then(Af).skip(Yt.regexp(/[_\\*~`]*/u));function zu(n){let e=Hu(n,0);if(!e)return;let t=Mf.parse(e.key);if(t.status)return{key:t.value,value:n.substring(e.valueIndex).trim(),start:0,startValue:e.valueIndex,end:n.length}}var _f=/\\u{2795}\\s*(\\d{4}-\\d{2}-\\d{2})/u,Bf=/(?:\\u{1F4C5}|\\u{1F4C6}|\\u{1F5D3}\\u{FE0F}?)\\s*(\\d{4}-\\d{2}-\\d{2})/u,Pf=/\\u{2705}\\s*(\\d{4}-\\d{2}-\\d{2})/u,$f=/[\\u{23F3}\\u{231B}]\\s*(\\d{4}-\\d{2}-\\d{2})/u,Rf=/\\u{1F6EB}\\s*(\\d{4}-\\d{2}-\\d{2})/u,jf=[{regex:_f,key:"created"},{regex:Rf,key:"start"},{regex:$f,key:"scheduled"},{regex:Bf,key:"due"},{regex:Pf,key:"completion"}];function qf(n){let e=[];for(let{regex:t,key:r}of jf){let s=t.exec(n);s&&e.push({key:r,value:s[1],start:s.index,startValue:s.index+1,end:s.index+s[0].length,wrapping:"emoji-shorthand"})}return e}var Rs;(t=>{function n(r){let s=Qe.wrapValue(r);if(!s)return null;switch(s.type){case"string":case"boolean":case"null":case"number":return s.value;case"array":return s.value.map(n);case"date":return s.value.toISO();case"duration":return s.value.toHuman();case"function":return null;case"link":return s.value.markdown();case"object":return zt(s.value,n)}}t.yaml=n;function e(r){if(r==null)return null;if(typeof r=="object")if(Array.isArray(r)){let s=[];for(let i of r)s.push(e(i));return s}else{if(r instanceof Date)return V.fromJSDate(r);{let s=r,i={};for(let o in s)i[o]=e(s[o]);return i}}else{if(typeof r=="number")return r;if(typeof r=="boolean")return r;if(typeof r=="string"){let s=Y.date.parse(r);if(s.status)return s.value;let i=Y.duration.parse(r);if(i.status)return i.value;let o=Y.link.parse(r);return o.status?o.value:r}}return null}t.literal=e})(Rs||(Rs={}));var Vf=/```yaml:data/i,Uf=/^(?:```|~~~)(.*)$/im,Kf=new RegExp("^[\\\\s>]*(\\\\d+\\\\.|\\\\d+\\\\)|\\\\*|-|\\\\+)\\\\s*(\\\\[.{0,1}\\\\])?\\\\s*(.*)","msu");function Zu(n,e,t,r){let{lines:s,metadata:i,frontmatter:o,sections:a}=Fo(n,e,t);return new po(n,r,s.length,i,a,o).build()}function Fo(n,e,t){var m,h,b,g,D,T,I,N,y,w,v,O,C,U,j,G;let r=t.frontmatter?Gu(t.frontmatter):void 0,s=e.split(/\\r\\n|\\r|\\n/),i=new Pe,o=[],a=(m=t.headings)!=null?m:[];a.sort((x,B)=>x.position.start.line-B.position.start.line);let u=new js.default(void 0,(x,B)=>x-B);for(let x=0;x<a.length;x++){let B=a[x],q=B.position.start.line,de=x==a.length-1?s.length:a[x+1].position.start.line,he=new Ar(q,de,B.heading,B.level,x+1);u.set(q,he)}if(u.size==0){if(!Yu(s,0,s.length)){let x=new Ar(0,s.length,bn(n),1,0);u.set(0,x)}}else{let x=(h=u.getPairOrNextHigher(0))==null?void 0:h[1];if(x.start>0&&!Yu(s,0,x.start)){let B=new Ar(0,x.start,bn(n),1,0);u.set(0,B)}}let l=new js.default(void 0,(x,B)=>x-B),f=1;for(let x of t.sections||[]){if(x.type==="heading")continue;let B=x.position.start.line,q=x.position.end.line+1,de=s[B];if(x.type==="list")l.set(B,new Do(B,q,f++,x.id));else if(x.type=="code"&&Vf.test(de)){let he=s.slice(B+1,q-1).join(`\n`).replace(/\\t/gm,"  "),oe=Gu(co(he));l.set(B,new yo(B,q,f++,oe,x.id))}else if(x.type==="code"){let he=de==null?void 0:de.match(Uf);if(!he)l.set(B,new qs(B,q,f++,[],"indent",B,q,x.id));else{let oe=he.length>1&&he[1]?he[1].split(","):[];l.set(B,new qs(B,q,f++,oe,"fenced",B+1,q-1,x.id))}}else l.set(B,new go(B,q,f++,x.type,x.id))}for(let x of l.values())(b=ut(x.start,u))==null||b.block(x);let d=new js.default(void 0,(x,B)=>x-B);for(let x of t.listItems||[]){let B=s.slice(x.position.start.line,x.position.end.line+1).join(`\n`),q=B==null?void 0:B.match(Kf),de,he;q&&(de=q[1],he=q[3]);let oe=new bo(x.position.start.line,x.position.end.line+1,x.parent,de,x.id,x.task,he);d.set(oe.start,oe)}for(let x of d.values())if(x.parentLine<0){let B=l.get(-x.parentLine);if(!B||B.type!=="list")continue;B.items.push(x)}else(g=d.get(x.parentLine))==null||g.elements.push(x);for(let x of(D=t.tags)!=null?D:[]){let B=x.tag.startsWith("#")?x.tag:"#"+x.tag,q=x.position.start.line;i.tag(B),(T=ut(q,u))==null||T.metadata.tag(B),(I=ut(q,l))==null||I.metadata.tag(B),(N=ut(q,d))==null||N.metadata.tag(B)}if(t.frontmatter)for(let x of Wf(t.frontmatter)){let B=x.startsWith("#")?x:"#"+x;i.tag(B)}for(let x of(y=t.links)!=null?y:[]){let B=Oe.infer(x.link),q=x.position.start.line;i.link(B),(w=ut(q,u))==null||w.metadata.link(B),(v=ut(q,l))==null||v.metadata.link(B),(O=ut(q,d))==null||O.metadata.link(B)}for(let x of(C=t.frontmatterLinks)!=null?C:[])i.link(Oe.infer(x.link,!1,x.displayText));for(let x of Eo(s)){let B=x.position.line;i.inlineField(x),(U=ut(B,u))==null||U.metadata.inlineField(x),(j=ut(B,l))==null||j.metadata.inlineField(x),(G=ut(B,d))==null||G.metadata.inlineField(x)}return o.push(...u.values()),{lines:s,frontmatter:r,metadata:i,sections:o}}function Yu(n,e,t){for(let r=e;r<t;r++)if(n[r].trim()!=="")return!1;return!0}function*Eo(n){for(let e=0;e<n.length;e++){let t=n[e];if(t.length>32768||!t.includes("::"))continue;let r=Ju(t);if(r.length>0)for(let s of r)yield $s(s,e);else{let s=zu(t);s&&(yield $s(s,e))}}}function Gu(n){let e={};for(let t of Object.keys(n)){let r=n[t];e[t.toLowerCase()]={key:t,value:An.json(Rs.literal(r)),raw:r}}return e}function ut(n,e){var r;let t=(r=e.getPairOrNextLower(n))==null?void 0:r[1];if(t&&t.end>=n)return t}function Wf(n){return Object.keys(n).filter(t=>t.toLowerCase()=="tags"||t.toLowerCase()=="tag").map(t=>Qu(n[t],/[,\\s]+/)).reduce((t,r)=>t.concat(r),[]).map(t=>t.startsWith("#")?t:"#"+t)}function Qu(n,e){return n==null||n==null?[]:Array.isArray(n)?n.filter(t=>!!t).map(t=>Qu(t,e)).reduce((t,r)=>t.concat(r),[]):(""+n).split(e).filter(t=>!!t).map(t=>t.trim()).filter(t=>t.length>0)}var Pe=class{constructor(){this.tags=new Set;this.links=[];this.inlineFields={}}tag(e){this.tags.add(e)}link(e){this.links.find(t=>t.equals(e))||this.links.push(e)}inlineField(e){let t=e.key.toLowerCase();Object.keys(this.inlineFields).some(r=>r.toLowerCase()==t)||(this.inlineFields[t]=e)}finishTags(){return Array.from(this.tags)}finishLinks(){return this.links.map(e=>e.toObject())}finishInlineFields(){return zt(this.inlineFields,Wu)}},po=class{constructor(e,t,r,s,i,o){this.path=e;this.stats=t;this.length=r;this.metadata=s;this.sections=i;this.frontmatter=o}build(){return{$path:this.path,$ctime:this.stats.ctime,$mtime:this.stats.mtime,$size:this.stats.size,$extension:Va(this.path),$position:{start:0,end:this.length},$tags:this.metadata.finishTags(),$links:this.metadata.finishLinks(),$infields:this.metadata.finishInlineFields(),$sections:this.sections.map(e=>e.build()),$frontmatter:this.frontmatter}}},Ar=class{constructor(e,t,r,s,i){this.start=e;this.end=t;this.title=r;this.level=s;this.ordinal=i;this.blocks=[];this.metadata=new Pe}block(e){this.blocks.push(e)}build(){return{$title:this.title,$ordinal:this.ordinal,$level:this.level,$tags:this.metadata.finishTags(),$infields:this.metadata.finishInlineFields(),$links:this.metadata.finishLinks(),$position:{start:this.start,end:this.end},$blocks:this.blocks.map(e=>e.build())}}},Do=class{constructor(e,t,r,s){this.start=e;this.end=t;this.ordinal=r;this.blockId=s;this.type="list";this.metadata=new Pe;this.items=[]}build(){return{$ordinal:this.ordinal,$position:{start:this.start,end:this.end},$infields:this.metadata.finishInlineFields(),$tags:this.metadata.finishTags(),$links:this.metadata.finishLinks(),$type:"list",$blockId:this.blockId,$elements:this.items.map(e=>e.build())}}},qs=class{constructor(e,t,r,s,i,o,a,u){this.start=e;this.end=t;this.ordinal=r;this.languages=s;this.style=i;this.contentStart=o;this.contentEnd=a;this.blockId=u;this.type="codeblock";this.metadata=new Pe}build(){return{$type:"codeblock",$ordinal:this.ordinal,$position:{start:this.start,end:this.end},$infields:this.metadata.finishInlineFields(),$tags:this.metadata.finishTags(),$links:this.metadata.finishLinks(),$blockId:this.blockId,$languages:this.languages,$style:this.style,$contentPosition:{start:this.contentStart,end:this.contentEnd}}}},yo=class{constructor(e,t,r,s,i){this.start=e;this.end=t;this.ordinal=r;this.data=s;this.blockId=i;this.type="datablock";this.metadata=new Pe}build(){return{$type:"datablock",$ordinal:this.ordinal,$position:{start:this.start,end:this.end},$infields:this.metadata.finishInlineFields(),$tags:this.metadata.finishTags(),$links:this.metadata.finishLinks(),$blockId:this.blockId,$data:this.data}}},go=class{constructor(e,t,r,s,i){this.start=e;this.end=t;this.ordinal=r;this.type=s;this.blockId=i;this.metadata=new Pe}build(){return{$type:this.type,$ordinal:this.ordinal,$position:{start:this.start,end:this.end},$infields:this.metadata.finishInlineFields(),$tags:this.metadata.finishTags(),$links:this.metadata.finishLinks(),$blockId:this.blockId}}},bo=class{constructor(e,t,r,s,i,o,a){this.start=e;this.end=t;this.parentLine=r;this.symbol=s;this.blockId=i;this.status=o;this.text=a;this.metadata=new Pe;this.elements=[]}build(){return{$parentLine:this.parentLine,$position:{start:this.start,end:this.end},$blockId:this.blockId,$elements:this.elements.map(e=>e.build()),$type:this.status?"task":"list",$infields:this.metadata.finishInlineFields(),$tags:this.metadata.finishTags(),$links:this.metadata.finishLinks(),$status:this.status,$symbol:this.symbol,$text:this.text}}};function Xu(n,e,t,r){var o;let s=new To(n,r),i=JSON.parse(e);for(let a of i.nodes)if(a.type!="group")if(a.type=="text"){let{frontmatter:u,metadata:l,lines:f,sections:d}=Fo(n,a.text,t.caches[a.id]),m=new Vs(n,a.id,a,u);d.forEach(h=>m.section(h)),s.card(m);for(let h in l.tags)s.metadata.tag(h);for(let h of(o=l.links)!=null?o:[])s.metadata.link(h);for(let h of Eo(f))s.metadata.inlineField(h)}else{let u=new Vs(n,a.id,a);s.card(u)}return s.build()}var wo=class{constructor(e,t,r){this.path=e;this.id=t;this.nodeJson=r;this.metadata=new Pe}build(){return{$file:this.path,$id:this.id,$position:{x:this.nodeJson.x,y:this.nodeJson.y},$dimensions:{width:this.nodeJson.width,height:this.nodeJson.height},$color:this.nodeJson.color,$link:Oe.file(this.path).withBlock(this.id).toObject()}}},Vs=class extends wo{constructor(t,r,s,i){super(t,r,s);this.path=t;this.id=r;this.nodeJson=s;this.frontmatter=i;this.sections=[]}section(t){return this.sections.push(t),t}build(){switch(this.nodeJson.type){case"text":return De(R({},super.build()),{$infields:this.metadata.finishInlineFields(),$frontmatter:this.frontmatter,$sections:this.sections.map(t=>t.build()),$tags:this.metadata.finishTags(),$links:this.metadata.finishLinks(),$type:"text-card",$color:this.nodeJson.color});case"file":return De(R({},super.build()),{$linkedFile:this.nodeJson.file});case"link":return De(R({},super.build()),{$url:this.nodeJson.url})}}},To=class{constructor(e,t){this.path=e;this.stats=t;this.cards=[];this.metadata=new Pe}card(e){return this.cards.push(e),e}build(){return{$cards:this.cards.map(e=>e.build()),$ctime:this.stats.ctime,$mtime:this.stats.mtime,$infields:this.metadata.finishInlineFields(),$links:this.metadata.finishLinks(),$tags:this.metadata.finishTags(),$path:this.path,$size:this.stats.size}}};onmessage=async n=>{try{let e=n.data;if(e.type==="markdown"){let t=Zu(e.path,e.contents,e.metadata,e.stat);postMessage({type:"markdown",result:t})}else if(e.type==="canvas"){let t=Xu(e.path,e.contents,e.index,e.stat);postMessage({type:"canvas",result:t})}else postMessage({$error:"Unsupported import method."})}catch(e){console.error(`Datacore Indexer failed to index ${n.data.path}: ${e}`),postMessage({$error:e.message})}};\n');
}

// src/index/web-worker/importer.ts
var import_obsidian6 = require("obsidian");
var import_queue = __toESM(require_queue2());
var DEFAULT_THROTTLE = {
  workers: 2,
  utilization: 0.75
};
var FileImporter = class extends import_obsidian6.Component {
  constructor(vault, fileManager, metadataCache, throttle) {
    super();
    this.vault = vault;
    this.fileManager = fileManager;
    this.metadataCache = metadataCache;
    this.workers = /* @__PURE__ */ new Map();
    this.shutdown = false;
    this.nextWorkerId = 0;
    this.throttle = throttle != null ? throttle : () => DEFAULT_THROTTLE;
    this.queue = new import_queue.Queue();
    this.outstanding = /* @__PURE__ */ new Map();
  }
  /**
   * Queue the given file for importing. Multiple import requests for the same file in a short time period will be de-bounced
   * and all be resolved by a single actual file reload.
   */
  import(file) {
    let existing = this.outstanding.get(file.path);
    if (existing) return existing;
    let promise = deferred();
    this.outstanding.set(file.path, promise);
    this.queue.enqueue([file, promise]);
    this.schedule();
    return promise;
  }
  /** Reset any active throttles on the importer (such as if the utilization changes). */
  unthrottle() {
    for (let worker of this.workers.values()) {
      worker.availableAt = Date.now();
    }
  }
  /** Poll from the queue and execute if there is an available worker. */
  async schedule() {
    if (this.queue.size() == 0 || this.shutdown) return;
    const worker = this.availableWorker();
    if (!worker) return;
    const [file, promise] = this.queue.dequeue();
    worker.active = [file, promise, Date.now()];
    try {
      switch (file.extension) {
        case "markdown":
        case "md": {
          const contents = await this.vault.cachedRead(file);
          worker.worker.postMessage({
            type: "markdown",
            path: file.path,
            contents,
            stat: file.stat,
            metadata: this.metadataCache.getFileCache(file)
          });
          break;
        }
        case "canvas": {
          const contents = await this.vault.cachedRead(file);
          worker.worker.postMessage({
            type: "canvas",
            path: file.path,
            contents,
            stat: file.stat,
            index: this.fileManager.linkUpdaters.canvas.canvas.index.index[file.path]
          });
          break;
        }
      }
    } catch (ex) {
      console.log("Datacore: Background file reloading failed. " + ex);
      worker.active = void 0;
    }
  }
  /** Finish the parsing of a file, potentially queueing a new file. */
  finish(worker, data) {
    if (!worker.active) {
      console.log("Datacore: Received a stale worker message. Ignoring.", data);
      return;
    }
    const [file, promise, start] = worker.active;
    if ("$error" in data) promise.reject(data["$error"]);
    else promise.resolve(data);
    this.outstanding.delete(file.path);
    if (this.workers.size > this.throttle().workers) {
      this.workers.delete(worker.id);
      terminate(worker);
    } else {
      const now2 = Date.now();
      const throttle = Math.max(0.1, this.throttle().utilization) - 1;
      const delay = (now2 - start) * throttle;
      worker.active = void 0;
      if (delay <= 1e-10) {
        worker.availableAt = now2;
        this.schedule();
      } else {
        worker.availableAt = now2 + delay;
        setTimeout(this.schedule.bind(this), delay);
      }
    }
  }
  /** Obtain an available worker, returning undefined if one does not exist. */
  availableWorker() {
    const now2 = Date.now();
    for (let worker of this.workers.values()) {
      if (!worker.active && worker.availableAt <= now2) {
        return worker;
      }
    }
    if (this.workers.size < this.throttle().workers) {
      let worker = this.newWorker();
      this.workers.set(worker.id, worker);
      return worker;
    }
    return void 0;
  }
  /** Create a new worker bound to this importer. */
  newWorker() {
    let worker = {
      id: this.nextWorkerId++,
      availableAt: Date.now(),
      worker: new Worker2()
    };
    worker.worker.onmessage = (evt) => this.finish(worker, evt.data);
    return worker;
  }
  /** Reject all outstanding promises and close all workers on close. */
  onunload() {
    for (let worker of this.workers.values()) {
      terminate(worker);
    }
    while (!this.queue.isEmpty()) {
      const [_file, promise] = this.queue.pop();
      promise.reject("Terminated");
    }
    this.shutdown = true;
  }
};
function terminate(worker) {
  worker.worker.terminate();
  if (worker.active) worker.active[1].reject("Terminated");
  worker.active = void 0;
}

// src/index/datacore.ts
var import_obsidian8 = require("obsidian");

// src/index/types/files.ts
var _GenericFile = class _GenericFile {
  constructor(path, ctime, mtime, size2) {
    this.$types = _GenericFile.TYPES;
    this.$typename = "File";
    this.$path = path;
    this.$ctime = ctime;
    this.$mtime = mtime;
    this.$size = size2;
    const lastDot = path.lastIndexOf(".");
    this.$extension = lastDot < 0 ? "" : path.substring(lastDot + 1);
  }
  get fields() {
    return _GenericFile.FIELD_DEF(this);
  }
  field(key) {
    var _a;
    return (_a = _GenericFile.FIELD_DEF(this, key)) == null ? void 0 : _a[0];
  }
  /** Get the value for the given field. */
  value(key) {
    var _a;
    return (_a = this.field(key)) == null ? void 0 : _a.value;
  }
  /** Unique ID for this object. */
  get $id() {
    return this.$path;
  }
  /** The file for the file is the file. */
  get $file() {
    return this.$path;
  }
  /** A link to the file. */
  get $link() {
    return Link.file(this.$path);
  }
};
_GenericFile.TYPES = [FILE_TYPE, FIELDBEARING_TYPE, LINKABLE_TYPE];
_GenericFile.FIELD_DEF = Extractors.intrinsics();
var GenericFile = _GenericFile;

// src/index/embed-queue.ts
var import_queue2 = __toESM(require_queue2());
var import_obsidian7 = require("obsidian");
var EmbedQueue = class extends import_obsidian7.Component {
  constructor(vault, concurrency) {
    super();
    this.vault = vault;
    this.concurrency = concurrency;
    /** Set of pending loads. */
    this.queue = new import_queue2.Queue();
    /** Set of promises waiting on each path. */
    this.promises = /* @__PURE__ */ new Map();
    /** Active set of loads. */
    this.active = /* @__PURE__ */ new Map();
    /** If true, prevent any further loads. */
    this.shutdown = false;
  }
  /** Read a file asynchronously, controlling concurrency to prevent too many files being loaded simultaneously. */
  async read(file) {
    if (this.shutdown) return Promise.reject("Embed queue is shutdown.");
    const promise = deferred();
    if (!this.promises.has(file.path)) {
      this.queue.push(file);
      this.promises.set(file.path, [promise]);
    } else {
      this.promises.get(file.path).push(promise);
    }
    this.schedule();
    return promise;
  }
  /** Schedule more loads from the queue into the active set if there is available space. */
  schedule() {
    while (this.active.size < this.concurrency() && this.queue.size() > 0) {
      const file = this.queue.pop();
      const read = this.vault.cachedRead(file);
      this.active.set(file.path, read);
      read.then((content) => this.finish(file, Result.success(content))).catch(
        (error) => this.finish(file, Result.failure(error))
      );
    }
  }
  /** Communicate the result of a loaded file and then schedule more files to be loaded. */
  finish(file, result) {
    var _a;
    this.active.delete(file.path);
    const promises = (_a = this.promises.get(file.path)) != null ? _a : [];
    this.promises.delete(file.path);
    if (result.successful) {
      promises.forEach((promise) => promise.resolve(result.value));
    } else {
      promises.forEach((promise) => promise.reject(result.error));
    }
    this.schedule();
  }
  /** Cancell all outstanding loads on unload. */
  onunload() {
    for (const promises of this.promises.values()) {
      promises.forEach((promise) => promise.reject("Embed queue is shutting down."));
    }
    this.shutdown = true;
  }
};

// src/index/types/canvas.ts
var _Canvas = class _Canvas {
  constructor(init) {
    this.$types = _Canvas.TYPES;
    this.$typename = "Canvas";
    this.$extension = "canvas";
    this.$cards = [];
    this.$size = 0;
    Object.assign(this, init);
  }
  get $file() {
    return this.$path;
  }
  get $id() {
    return this.$path;
  }
  get $link() {
    return Link.file(this.$path);
  }
  get fields() {
    return _Canvas.FIELD_DEF(this);
  }
  field(key) {
    var _a;
    return (_a = _Canvas.FIELD_DEF(this, key)) == null ? void 0 : _a[0];
  }
  json() {
    return {
      $cards: this.$cards.map((x4) => x4.json()),
      $ctime: this.$ctime.toMillis(),
      $mtime: this.$mtime.toMillis(),
      $size: this.$size,
      $links: this.$links,
      $path: this.$path,
      $infields: this.$infields,
      $tags: this.$tags
    };
  }
  static from(raw, normalizer = NOOP_NORMALIZER) {
    const cards = raw.$cards.map((s4) => {
      switch (s4.$type) {
        case "text-card":
          return CanvasTextCard.from(s4, raw.$path, normalizer);
        case "file-card":
          return CanvasFileCard.from(s4);
        case "web-card":
          return CanvasWebCard.from(s4, raw.$path);
      }
      return null;
    }).filter((x4) => !!x4);
    return new _Canvas({
      $cards: cards,
      $ctime: DateTime.fromMillis(raw.$ctime),
      $mtime: DateTime.fromMillis(raw.$mtime),
      $size: raw.$size,
      $extension: "canvas",
      $path: raw.$path,
      $links: raw.$links.map((l4) => normalizer(Link.fromObject(l4))),
      $infields: raw.$infields,
      $tags: raw.$tags
    });
  }
};
_Canvas.TYPES = [FILE_TYPE, "canvas", TAGGABLE_TYPE, LINKABLE_TYPE, FIELDBEARING_TYPE];
_Canvas.FIELD_DEF = Extractors.merge(
  Extractors.inlineFields((f4) => f4.$infields),
  Extractors.intrinsics()
);
var Canvas = _Canvas;
var BaseCanvasCard = class {
  constructor(init) {
    Object.assign(this, init);
  }
  get $link() {
    return Link.file(this.$file).withBlock(this.$id);
  }
  json() {
    const { $id, $position, $color, $dimensions, $file, $link } = this;
    return {
      $id,
      $position,
      $color,
      $dimensions,
      $file,
      $link: $link.toObject()
    };
  }
};
var _CanvasTextCard = class _CanvasTextCard extends BaseCanvasCard {
  constructor(init) {
    super(init);
    this.$types = _CanvasTextCard.TYPES;
    this.$typename = "Text Card";
    this.$type = "canvas-card";
  }
  get fields() {
    return _CanvasTextCard.FIELD_DEF(this);
  }
  field(key) {
    var _a;
    return (_a = _CanvasTextCard.FIELD_DEF(this, key)) == null ? void 0 : _a[0];
  }
  json() {
    return Object.assign(super.json(), {
      $infields: this.$infields,
      $links: this.$links,
      $tags: this.$tags,
      $type: "text-card",
      $sections: this.$sections.map((a4) => a4.json())
    });
  }
  static from(raw, file, normalizer = NOOP_NORMALIZER) {
    let $sections = raw.$sections.map((s4) => MarkdownSection.from(s4, file, normalizer));
    return new _CanvasTextCard({
      $file: file,
      $id: raw.$id,
      $sections,
      $links: raw.$links.map((l4) => normalizer(Link.fromObject(l4))),
      $dimensions: raw.$dimensions,
      $position: raw.$position,
      $frontmatter: raw.$frontmatter ? mapObjectValues(raw.$frontmatter, (fm) => normalizeLinks(valueFrontmatterEntry(fm), normalizer)) : void 0,
      $infields: raw.$infields,
      $tags: raw.$tags
    });
  }
};
_CanvasTextCard.TYPES = ["canvas-card", "markdown", "canvas-text-card", TAGGABLE_TYPE, LINKABLE_TYPE, FIELDBEARING_TYPE];
_CanvasTextCard.FIELD_DEF = Extractors.merge(
  Extractors.intrinsics(),
  Extractors.inlineFields((f4) => f4.$infields),
  Extractors.frontmatter((f4) => f4.$frontmatter)
);
var CanvasTextCard = _CanvasTextCard;
var _CanvasFileCard = class _CanvasFileCard extends BaseCanvasCard {
  constructor(init) {
    super(init);
    this.$types = CanvasTextCard.TYPES;
    this.$typename = "File Card";
    this.$type = "file-card";
  }
  json() {
    return Object.assign(super.json(), {
      $linkedFile: this.$linkedFile,
      $type: "file-card"
    });
  }
  static from(raw) {
    return new _CanvasFileCard({
      $file: raw.$file,
      $id: raw.$id,
      $position: raw.$position,
      $dimensions: raw.$dimensions,
      $linkedFile: raw.$linkedFile
    });
  }
};
_CanvasFileCard.TYPES = ["canvas-card", "markdown", "canvas-file-card", TAGGABLE_TYPE, LINKABLE_TYPE, FIELDBEARING_TYPE];
var CanvasFileCard = _CanvasFileCard;
var _CanvasWebCard = class _CanvasWebCard extends BaseCanvasCard {
  constructor(init) {
    super(init);
    this.$types = CanvasTextCard.TYPES;
    this.$type = "web-card";
    this.$typename = "Web Card";
  }
  json() {
    return Object.assign(super.json(), {
      $url: this.$url,
      $type: "web-card"
    });
  }
  static from(raw, file) {
    return new _CanvasWebCard({
      $dimensions: raw.$dimensions,
      $position: raw.$position,
      $file: file,
      $id: raw.$id,
      $url: raw.$url
    });
  }
};
_CanvasWebCard.TYPES = ["canvas-card", "markdown", "canvas-web-card", TAGGABLE_TYPE, LINKABLE_TYPE, FIELDBEARING_TYPE];
var CanvasWebCard = _CanvasWebCard;

// src/index/datacore.ts
var Datacore = class extends import_obsidian8.Component {
  constructor(app, version, settings) {
    super();
    this.app = app;
    this.version = version;
    this.settings = settings;
    this.vault = app.vault;
    this.metadataCache = app.metadataCache;
    this.persister = new LocalStorageCache("primary", version);
    this.events = new import_obsidian8.Events();
    this.datastore = new Datastore(app.vault, app.metadataCache, settings);
    this.initialized = false;
    this.addChild(
      this.importer = new FileImporter(app.vault, app.fileManager, app.metadataCache, () => {
        return {
          workers: settings.importerNumThreads,
          utilization: Math.max(0.1, Math.min(1, settings.importerUtilization))
        };
      })
    );
    this.addChild(this.reads = new EmbedQueue(app.vault, () => 8));
  }
  /** Obtain the current index revision, for determining if anything has changed. */
  get revision() {
    return this.datastore.revision;
  }
  /** Initialize datacore by scanning persisted caches and all available files, and queueing parses as needed. */
  initialize() {
    this.registerEvent(this.metadataCache.on("resolve", (file) => this.reload(file)));
    this.registerEvent(this.vault.on("rename", this.rename, this));
    this.registerEvent(
      this.vault.on("create", (file) => {
        if (!(file instanceof import_obsidian8.TFile)) return;
        if (INDEXABLE_EXTENSIONS.has(file.extension.toLowerCase())) return;
        this.reload(file);
      })
    );
    this.registerEvent(
      this.vault.on("modify", (file) => {
        if (!(file instanceof import_obsidian8.TFile)) return;
        if (INDEXABLE_EXTENSIONS.has(file.extension.toLowerCase())) return;
        this.reload(file);
      })
    );
    this.registerEvent(
      this.vault.on("delete", (file) => {
        if (file instanceof import_obsidian8.TFile) {
          this.datastore.delete(file.path);
        }
      })
    );
    this.index();
  }
  /** Starts the background initializer. */
  index() {
    const init = this.initializer = new DatacoreInitializer(this);
    init.finished().then((stats) => {
      this.initialized = true;
      this.initializer = void 0;
      this.removeChild(init);
      const durationSecs = (stats.durationMs / 1e3).toFixed(3);
      console.log(
        `Datacore: Imported all files in the vault in ${durationSecs}s (${stats.imported} imported, ${stats.cached} cached, ${stats.skipped} skipped).`
      );
      this.datastore.touch();
      this.trigger("update", this.revision);
      this.trigger("initialized");
      const currentFiles = this.vault.getFiles().map((file) => file.path);
      this.persister.synchronize(currentFiles).then((cleared) => console.log(`Datacore: dropped ${cleared.size} out-of-date file metadata blocks.`));
    });
    this.addChild(init);
  }
  rename(file, oldPath) {
    if (!(file instanceof import_obsidian8.TFile)) {
      return;
    }
    this.datastore.delete(oldPath);
    this.reload(file);
  }
  /**
   * Read a file from the Obsidian cache efficiently, limiting the number of concurrent request and debouncing
   * multiple requests for the same file.
   */
  async read(file) {
    return this.reads.read(file);
  }
  /** Queue a file for reloading; this is done asynchronously in the background and may take a few seconds. */
  async reload(file) {
    if (!INDEXABLE_EXTENSIONS.has(file.extension)) {
      const result2 = new GenericFile(
        file.path,
        DateTime.fromMillis(file.stat.ctime),
        DateTime.fromMillis(file.stat.mtime),
        file.stat.size
      );
      this.datastore.store(result2);
      return result2;
    }
    const result = await this.importer.import(file);
    if (result.type === "error") {
      throw new Error(`Failed to import file '${file.name}: ${result.$error}`);
    } else if (result.type === "markdown") {
      const parsed = MarkdownPage.from(result.result, (link) => {
        const rpath = this.metadataCache.getFirstLinkpathDest(link.path, result.result.$path);
        if (rpath) return link.withPath(rpath.path);
        else return link;
      });
      this.storeMarkdown(parsed);
      this.persister.storeFile(parsed.$path, parsed.json());
      this.trigger("update", this.revision);
      return parsed;
    } else if (result.type === "canvas") {
      const parsed = Canvas.from(result.result, (link) => {
        const rpath = this.metadataCache.getFirstLinkpathDest(link.path, result.result.$path);
        if (rpath) return link.withPath(rpath.path);
        else return link;
      });
      this.storeCanvas(parsed);
      this.persister.storeFile(parsed.$path, parsed.json());
      this.trigger("update", this.revision);
      return parsed;
    }
    throw new Error("Encountered unrecognized import result type: " + result.type);
  }
  storeCanvas(data) {
    this.datastore.store(data, (object, store) => {
      store(object.$cards, (card, store2) => {
        if (card instanceof CanvasTextCard) {
          store2(card.$sections, (section, store3) => {
            store3(section.$blocks, (block, store4) => {
              if (block instanceof MarkdownListBlock) {
                const storeRec = (item, store5) => store5(item.$elements, storeRec);
                store4(block.$elements, storeRec);
              }
            });
          });
        }
      });
    });
  }
  /** Store a markdown document. */
  storeMarkdown(data) {
    this.datastore.store(data, (object, store) => {
      store(object.$sections, (section, store2) => {
        store2(section.$blocks, (block, store3) => {
          if (block instanceof MarkdownListBlock) {
            const storeRec = (item, store4) => store4(item.$elements, storeRec);
            store3(block.$elements, storeRec);
          }
        });
      });
    });
  }
  on(evt, callback, context) {
    return this.events.on(evt, callback, context);
  }
  /** Unsubscribe from an event using the event and original callback. */
  off(evt, callback) {
    this.events.off(evt, callback);
  }
  /** Unsubscribe from an event using the event reference.  */
  offref(ref) {
    this.events.offref(ref);
  }
  /** Trigger an event. */
  trigger(evt, ...args) {
    console.log("triggering", evt);
    this.events.trigger(evt, ...args);
  }
};
var _DatacoreInitializer = class _DatacoreInitializer extends import_obsidian8.Component {
  constructor(core) {
    super();
    this.core = core;
    this.active = false;
    this.queue = this.core.vault.getFiles();
    this.targetTotal = this.queue.length;
    this.files = this.queue.length;
    this.start = Date.now();
    this.current = [];
    this.done = deferred();
    this.initialized = this.imported = this.skipped = this.cached = 0;
  }
  async onload() {
    this.active = true;
    this.runNext();
  }
  /** Promise which resolves when the initialization completes. */
  finished() {
    return this.done;
  }
  /** Cancel initialization. */
  onunload() {
    if (this.active) {
      this.active = false;
      this.done.reject("Initialization was cancelled before completing.");
    }
  }
  /** Poll for another task to execute from the queue. */
  runNext() {
    if (!this.active || this.current.length >= _DatacoreInitializer.BATCH_SIZE) {
      return;
    }
    const next3 = this.queue.pop();
    if (next3) {
      this.current.push(next3);
      this.init(next3).then((result) => this.handleResult(next3, result)).catch((result) => this.handleResult(next3, result));
      this.runNext();
    } else if (!next3 && this.current.length == 0) {
      this.active = false;
      this.done.resolve({
        durationMs: Date.now() - this.start,
        files: this.files,
        imported: this.imported,
        skipped: this.skipped,
        cached: this.cached
      });
    }
  }
  /** Process the result of an initialization and queue more runs. */
  handleResult(file, result) {
    this.current.remove(file);
    this.initialized++;
    if (result.status === "skipped") this.skipped++;
    else if (result.status === "imported") this.imported++;
    else if (result.status === "cached") this.cached++;
    this.runNext();
  }
  /** Initialize a specific file. */
  async init(file) {
    try {
      const cached = await this.core.persister.loadFile(file.path);
      if (cached && cached.time >= file.stat.mtime && cached.version == this.core.version) {
        if (file.extension === "md") {
          const data = MarkdownPage.from(cached.data, (link) => link);
          this.core.storeMarkdown(data);
          return { status: "cached" };
        }
      }
      await this.core.reload(file);
      return { status: "imported" };
    } catch (ex) {
      console.log("Datacore: Failed to import file: ", ex);
      return { status: "skipped" };
    }
  }
};
/** Number of concurrent operations the initializer will perform. */
_DatacoreInitializer.BATCH_SIZE = 8;
var DatacoreInitializer = _DatacoreInitializer;

// src/main.ts
var import_obsidian10 = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = Object.freeze({
  importerNumThreads: 2,
  importerUtilization: 0.75,
  enableJs: false,
  defaultPagingEnabled: true,
  defaultPageSize: 50,
  scrollOnPageChange: false,
  maxRecursiveRenderDepth: 5,
  defaultDateFormat: "MMMM dd, yyyy",
  defaultDateTimeFormat: "h:mm a - MMMM dd, yyyy",
  renderNullAs: "-",
  indexInlineFields: true,
  indexListItems: true,
  recursiveTaskCompletion: false,
  taskCompletionText: "completedAt",
  taskCompletionUseEmojiShorthand: false
});

// src/ui/view-page.tsx
var import_obsidian9 = require("obsidian");
var import_commands2 = require("@codemirror/commands");
var import_language4 = require("@codemirror/language");
var import_search2 = require("@codemirror/search");

// node_modules/@codemirror/autocomplete/dist/index.js
var import_state4 = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_language = require("@codemirror/language");
var CompletionContext = class {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(state2, pos, explicit, view) {
    this.state = state2;
    this.pos = pos;
    this.explicit = explicit;
    this.view = view;
    this.abortListeners = [];
    this.abortOnDocChange = false;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(types) {
    let token2 = (0, import_language.syntaxTree)(this.state).resolveInner(this.pos, -1);
    while (token2 && types.indexOf(token2.name) < 0)
      token2 = token2.parent;
    return token2 ? {
      from: token2.from,
      to: this.pos,
      text: this.state.sliceDoc(token2.from, this.pos),
      type: token2.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(expr) {
    let line2 = this.state.doc.lineAt(this.pos);
    let start = Math.max(line2.from, this.pos - 250);
    let str = line2.text.slice(start - line2.from, this.pos - line2.from);
    let found = str.search(ensureAnchor(expr, false));
    return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(type, listener2, options2) {
    if (type == "abort" && this.abortListeners) {
      this.abortListeners.push(listener2);
      if (options2 && options2.onDocChange)
        this.abortOnDocChange = true;
    }
  }
};
function toSet(chars) {
  let flat = Object.keys(chars).join("");
  let words = /\w/.test(flat);
  if (words)
    flat = flat.replace(/\w/g, "");
  return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options2) {
  let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
  for (let { label } of options2) {
    first[label[0]] = true;
    for (let i4 = 1; i4 < label.length; i4++)
      rest[label[i4]] = true;
  }
  let source = toSet(first) + toSet(rest) + "*$";
  return [new RegExp("^" + source), new RegExp(source)];
}
function completeFromList(list) {
  let options2 = list.map((o4) => typeof o4 == "string" ? { label: o4 } : o4);
  let [validFor, match4] = options2.every((o4) => /^\w+$/.test(o4.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options2);
  return (context) => {
    let token2 = context.matchBefore(match4);
    return token2 || context.explicit ? { from: token2 ? token2.from : context.pos, options: options2, validFor } : null;
  };
}
function ifNotIn(nodes, source) {
  return (context) => {
    for (let pos = (0, import_language.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {
      if (nodes.indexOf(pos.name) > -1)
        return null;
      if (pos.type.isTop)
        break;
    }
    return source(context);
  };
}
var Option3 = class {
  constructor(completion, source, match4, score2) {
    this.completion = completion;
    this.source = source;
    this.match = match4;
    this.score = score2;
  }
};
function cur(state2) {
  return state2.selection.main.from;
}
function ensureAnchor(expr, start) {
  var _a;
  let { source } = expr;
  let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
  if (!addStart && !addEnd)
    return expr;
  return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? "i" : "");
}
var pickedCompletion = /* @__PURE__ */ import_state4.Annotation.define();
function insertCompletionText(state2, text2, from2, to) {
  let { main } = state2.selection, fromOff = from2 - main.from, toOff = to - main.from;
  return Object.assign(Object.assign({}, state2.changeByRange((range) => {
    if (range != main && from2 != to && state2.sliceDoc(range.from + fromOff, range.from + toOff) != state2.sliceDoc(from2, to))
      return { range };
    let lines = state2.toText(text2);
    return {
      changes: { from: range.from + fromOff, to: to == main.from ? range.to : range.from + toOff, insert: lines },
      range: import_state4.EditorSelection.cursor(range.from + fromOff + lines.length)
    };
  })), { scrollIntoView: true, userEvent: "input.complete" });
}
var SourceCache = /* @__PURE__ */ new WeakMap();
function asSource(source) {
  if (!Array.isArray(source))
    return source;
  let known = SourceCache.get(source);
  if (!known)
    SourceCache.set(source, known = completeFromList(source));
  return known;
}
var startCompletionEffect = /* @__PURE__ */ import_state4.StateEffect.define();
var closeCompletionEffect = /* @__PURE__ */ import_state4.StateEffect.define();
var FuzzyMatcher = class {
  constructor(pattern) {
    this.pattern = pattern;
    this.chars = [];
    this.folded = [];
    this.any = [];
    this.precise = [];
    this.byWord = [];
    this.score = 0;
    this.matched = [];
    for (let p3 = 0; p3 < pattern.length; ) {
      let char2 = (0, import_state4.codePointAt)(pattern, p3), size2 = (0, import_state4.codePointSize)(char2);
      this.chars.push(char2);
      let part = pattern.slice(p3, p3 + size2), upper = part.toUpperCase();
      this.folded.push((0, import_state4.codePointAt)(upper == part ? part.toLowerCase() : upper, 0));
      p3 += size2;
    }
    this.astral = pattern.length != this.chars.length;
  }
  ret(score2, matched) {
    this.score = score2;
    this.matched = matched;
    return this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(word) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (word.length < this.pattern.length)
      return null;
    let { chars, folded, any: any3, precise, byWord } = this;
    if (chars.length == 1) {
      let first = (0, import_state4.codePointAt)(word, 0), firstSize = (0, import_state4.codePointSize)(first);
      let score2 = firstSize == word.length ? 0 : -100;
      if (first == chars[0]) ;
      else if (first == folded[0])
        score2 += -200;
      else
        return null;
      return this.ret(score2, [0, firstSize]);
    }
    let direct = word.indexOf(this.pattern);
    if (direct == 0)
      return this.ret(word.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let len = chars.length, anyTo = 0;
    if (direct < 0) {
      for (let i4 = 0, e3 = Math.min(word.length, 200); i4 < e3 && anyTo < len; ) {
        let next3 = (0, import_state4.codePointAt)(word, i4);
        if (next3 == chars[anyTo] || next3 == folded[anyTo])
          any3[anyTo++] = i4;
        i4 += (0, import_state4.codePointSize)(next3);
      }
      if (anyTo < len)
        return null;
    }
    let preciseTo = 0;
    let byWordTo = 0, byWordFolded = false;
    let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
    let hasLower = /[a-z]/.test(word), wordAdjacent = true;
    for (let i4 = 0, e3 = Math.min(word.length, 200), prevType = 0; i4 < e3 && byWordTo < len; ) {
      let next3 = (0, import_state4.codePointAt)(word, i4);
      if (direct < 0) {
        if (preciseTo < len && next3 == chars[preciseTo])
          precise[preciseTo++] = i4;
        if (adjacentTo < len) {
          if (next3 == chars[adjacentTo] || next3 == folded[adjacentTo]) {
            if (adjacentTo == 0)
              adjacentStart = i4;
            adjacentEnd = i4 + 1;
            adjacentTo++;
          } else {
            adjacentTo = 0;
          }
        }
      }
      let ch, type = next3 < 255 ? next3 >= 48 && next3 <= 57 || next3 >= 97 && next3 <= 122 ? 2 : next3 >= 65 && next3 <= 90 ? 1 : 0 : (ch = (0, import_state4.fromCodePoint)(next3)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
      if (!i4 || type == 1 && hasLower || prevType == 0 && type != 0) {
        if (chars[byWordTo] == next3 || folded[byWordTo] == next3 && (byWordFolded = true))
          byWord[byWordTo++] = i4;
        else if (byWord.length)
          wordAdjacent = false;
      }
      prevType = type;
      i4 += (0, import_state4.codePointSize)(next3);
    }
    if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
      return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
    if (adjacentTo == len && adjacentStart == 0)
      return this.ret(-200 - word.length + (adjacentEnd == word.length ? 0 : -100), [0, adjacentEnd]);
    if (direct > -1)
      return this.ret(-700 - word.length, [direct, direct + this.pattern.length]);
    if (adjacentTo == len)
      return this.ret(-200 + -700 - word.length, [adjacentStart, adjacentEnd]);
    if (byWordTo == len)
      return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
    return chars.length == 2 ? null : this.result((any3[0] ? -700 : 0) + -200 + -1100, any3, word);
  }
  result(score2, positions, word) {
    let result = [], i4 = 0;
    for (let pos of positions) {
      let to = pos + (this.astral ? (0, import_state4.codePointSize)((0, import_state4.codePointAt)(word, pos)) : 1);
      if (i4 && result[i4 - 1] == pos)
        result[i4 - 1] = to;
      else {
        result[i4++] = pos;
        result[i4++] = to;
      }
    }
    return this.ret(score2 - word.length, result);
  }
};
var StrictMatcher = class {
  constructor(pattern) {
    this.pattern = pattern;
    this.matched = [];
    this.score = 0;
    this.folded = pattern.toLowerCase();
  }
  match(word) {
    if (word.length < this.pattern.length)
      return null;
    let start = word.slice(0, this.pattern.length);
    let match4 = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 : null;
    if (match4 == null)
      return null;
    this.matched = [0, start.length];
    this.score = match4 + (word.length == this.pattern.length ? 0 : -100);
    return this;
  }
};
var completionConfig = /* @__PURE__ */ import_state4.Facet.define({
  combine(configs) {
    return (0, import_state4.combineConfig)(configs, {
      activateOnTyping: true,
      activateOnCompletion: () => false,
      activateOnTypingDelay: 100,
      selectOnOpen: true,
      override: null,
      closeOnBlur: true,
      maxRenderedOptions: 100,
      defaultKeymap: true,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: false,
      icons: true,
      addToOptions: [],
      positionInfo: defaultPositionInfo,
      filterStrict: false,
      compareCompletions: (a4, b3) => a4.label.localeCompare(b3.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (a4, b3) => a4 && b3,
      closeOnBlur: (a4, b3) => a4 && b3,
      icons: (a4, b3) => a4 && b3,
      tooltipClass: (a4, b3) => (c4) => joinClass(a4(c4), b3(c4)),
      optionClass: (a4, b3) => (c4) => joinClass(a4(c4), b3(c4)),
      addToOptions: (a4, b3) => a4.concat(b3),
      filterStrict: (a4, b3) => a4 || b3
    });
  }
});
function joinClass(a4, b3) {
  return a4 ? b3 ? a4 + " " + b3 : a4 : b3;
}
function defaultPositionInfo(view, list, option, info, space2, tooltip) {
  let rtl = view.textDirection == import_view.Direction.RTL, left = rtl, narrow = false;
  let side = "top", offset3, maxWidth;
  let spaceLeft = list.left - space2.left, spaceRight = space2.right - list.right;
  let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;
  if (left && spaceLeft < Math.min(infoWidth, spaceRight))
    left = false;
  else if (!left && spaceRight < Math.min(infoWidth, spaceLeft))
    left = true;
  if (infoWidth <= (left ? spaceLeft : spaceRight)) {
    offset3 = Math.max(space2.top, Math.min(option.top, space2.bottom - infoHeight)) - list.top;
    maxWidth = Math.min(400, left ? spaceLeft : spaceRight);
  } else {
    narrow = true;
    maxWidth = Math.min(
      400,
      (rtl ? list.right : space2.right - list.left) - 30
      /* Info.Margin */
    );
    let spaceBelow = space2.bottom - list.bottom;
    if (spaceBelow >= infoHeight || spaceBelow > list.top) {
      offset3 = option.bottom - list.top;
    } else {
      side = "bottom";
      offset3 = list.bottom - option.top;
    }
  }
  let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;
  let scaleX = (list.right - list.left) / tooltip.offsetWidth;
  return {
    style: `${side}: ${offset3 / scaleY}px; max-width: ${maxWidth / scaleX}px`,
    class: "cm-completionInfo-" + (narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right")
  };
}
function optionContent(config3) {
  let content = config3.addToOptions.slice();
  if (config3.icons)
    content.push({
      render(completion) {
        let icon2 = document.createElement("div");
        icon2.classList.add("cm-completionIcon");
        if (completion.type)
          icon2.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
        icon2.setAttribute("aria-hidden", "true");
        return icon2;
      },
      position: 20
    });
  content.push({
    render(completion, _s, _v, match4) {
      let labelElt = document.createElement("span");
      labelElt.className = "cm-completionLabel";
      let label = completion.displayLabel || completion.label, off2 = 0;
      for (let j4 = 0; j4 < match4.length; ) {
        let from2 = match4[j4++], to = match4[j4++];
        if (from2 > off2)
          labelElt.appendChild(document.createTextNode(label.slice(off2, from2)));
        let span = labelElt.appendChild(document.createElement("span"));
        span.appendChild(document.createTextNode(label.slice(from2, to)));
        span.className = "cm-completionMatchedText";
        off2 = to;
      }
      if (off2 < label.length)
        labelElt.appendChild(document.createTextNode(label.slice(off2)));
      return labelElt;
    },
    position: 50
  }, {
    render(completion) {
      if (!completion.detail)
        return null;
      let detailElt = document.createElement("span");
      detailElt.className = "cm-completionDetail";
      detailElt.textContent = completion.detail;
      return detailElt;
    },
    position: 80
  });
  return content.sort((a4, b3) => a4.position - b3.position).map((a4) => a4.render);
}
function rangeAroundSelected(total, selected, max2) {
  if (total <= max2)
    return { from: 0, to: total };
  if (selected < 0)
    selected = 0;
  if (selected <= total >> 1) {
    let off3 = Math.floor(selected / max2);
    return { from: off3 * max2, to: (off3 + 1) * max2 };
  }
  let off2 = Math.floor((total - selected) / max2);
  return { from: total - (off2 + 1) * max2, to: total - off2 * max2 };
}
var CompletionTooltip = class {
  constructor(view, stateField, applyCompletion2) {
    this.view = view;
    this.stateField = stateField;
    this.applyCompletion = applyCompletion2;
    this.info = null;
    this.infoDestroy = null;
    this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (pos) => this.placeInfo(pos),
      key: this
    };
    this.space = null;
    this.currentClass = "";
    let cState = view.state.field(stateField);
    let { options: options2, selected } = cState.open;
    let config3 = view.state.facet(completionConfig);
    this.optionContent = optionContent(config3);
    this.optionClass = config3.optionClass;
    this.tooltipClass = config3.tooltipClass;
    this.range = rangeAroundSelected(options2.length, selected, config3.maxRenderedOptions);
    this.dom = document.createElement("div");
    this.dom.className = "cm-tooltip-autocomplete";
    this.updateTooltipClass(view.state);
    this.dom.addEventListener("mousedown", (e3) => {
      let { options: options3 } = view.state.field(stateField).open;
      for (let dom2 = e3.target, match4; dom2 && dom2 != this.dom; dom2 = dom2.parentNode) {
        if (dom2.nodeName == "LI" && (match4 = /-(\d+)$/.exec(dom2.id)) && +match4[1] < options3.length) {
          this.applyCompletion(view, options3[+match4[1]]);
          e3.preventDefault();
          return;
        }
      }
    });
    this.dom.addEventListener("focusout", (e3) => {
      let state2 = view.state.field(this.stateField, false);
      if (state2 && state2.tooltip && view.state.facet(completionConfig).closeOnBlur && e3.relatedTarget != view.contentDOM)
        view.dispatch({ effects: closeCompletionEffect.of(null) });
    });
    this.showOptions(options2, cState.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(options2, id2) {
    if (this.list)
      this.list.remove();
    this.list = this.dom.appendChild(this.createListBox(options2, id2, this.range));
    this.list.addEventListener("scroll", () => {
      if (this.info)
        this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(update) {
    var _a;
    let cState = update.state.field(this.stateField);
    let prevState = update.startState.field(this.stateField);
    this.updateTooltipClass(update.state);
    if (cState != prevState) {
      let { options: options2, selected, disabled: disabled2 } = cState.open;
      if (!prevState.open || prevState.open.options != options2) {
        this.range = rangeAroundSelected(options2.length, selected, update.state.facet(completionConfig).maxRenderedOptions);
        this.showOptions(options2, cState.id);
      }
      this.updateSel();
      if (disabled2 != ((_a = prevState.open) === null || _a === void 0 ? void 0 : _a.disabled))
        this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!disabled2);
    }
  }
  updateTooltipClass(state2) {
    let cls = this.tooltipClass(state2);
    if (cls != this.currentClass) {
      for (let c4 of this.currentClass.split(" "))
        if (c4)
          this.dom.classList.remove(c4);
      for (let c4 of cls.split(" "))
        if (c4)
          this.dom.classList.add(c4);
      this.currentClass = cls;
    }
  }
  positioned(space2) {
    this.space = space2;
    if (this.info)
      this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let cState = this.view.state.field(this.stateField), open = cState.open;
    if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
      this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
      this.showOptions(open.options, cState.id);
    }
    if (this.updateSelectedOption(open.selected)) {
      this.destroyInfo();
      let { completion } = open.options[open.selected];
      let { info } = completion;
      if (!info)
        return;
      let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
      if (!infoResult)
        return;
      if ("then" in infoResult) {
        infoResult.then((obj) => {
          if (obj && this.view.state.field(this.stateField, false) == cState)
            this.addInfoPane(obj, completion);
        }).catch((e3) => (0, import_view.logException)(this.view.state, e3, "completion info"));
      } else {
        this.addInfoPane(infoResult, completion);
      }
    }
  }
  addInfoPane(content, completion) {
    this.destroyInfo();
    let wrap = this.info = document.createElement("div");
    wrap.className = "cm-tooltip cm-completionInfo";
    if (content.nodeType != null) {
      wrap.appendChild(content);
      this.infoDestroy = null;
    } else {
      let { dom: dom2, destroy } = content;
      wrap.appendChild(dom2);
      this.infoDestroy = destroy || null;
    }
    this.dom.appendChild(wrap);
    this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(selected) {
    let set = null;
    for (let opt2 = this.list.firstChild, i4 = this.range.from; opt2; opt2 = opt2.nextSibling, i4++) {
      if (opt2.nodeName != "LI" || !opt2.id) {
        i4--;
      } else if (i4 == selected) {
        if (!opt2.hasAttribute("aria-selected")) {
          opt2.setAttribute("aria-selected", "true");
          set = opt2;
        }
      } else {
        if (opt2.hasAttribute("aria-selected"))
          opt2.removeAttribute("aria-selected");
      }
    }
    if (set)
      scrollIntoView2(this.list, set);
    return set;
  }
  measureInfo() {
    let sel = this.dom.querySelector("[aria-selected]");
    if (!sel || !this.info)
      return null;
    let listRect = this.dom.getBoundingClientRect();
    let infoRect = this.info.getBoundingClientRect();
    let selRect = sel.getBoundingClientRect();
    let space2 = this.space;
    if (!space2) {
      let win = this.dom.ownerDocument.defaultView || window;
      space2 = { left: 0, top: 0, right: win.innerWidth, bottom: win.innerHeight };
    }
    if (selRect.top > Math.min(space2.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space2.top, listRect.top) + 10)
      return null;
    return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space2, this.dom);
  }
  placeInfo(pos) {
    if (this.info) {
      if (pos) {
        if (pos.style)
          this.info.style.cssText = pos.style;
        this.info.className = "cm-tooltip cm-completionInfo " + (pos.class || "");
      } else {
        this.info.style.cssText = "top: -1e6px";
      }
    }
  }
  createListBox(options2, id2, range) {
    const ul = document.createElement("ul");
    ul.id = id2;
    ul.setAttribute("role", "listbox");
    ul.setAttribute("aria-expanded", "true");
    ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let curSection = null;
    for (let i4 = range.from; i4 < range.to; i4++) {
      let { completion, match: match4 } = options2[i4], { section } = completion;
      if (section) {
        let name = typeof section == "string" ? section : section.name;
        if (name != curSection && (i4 > range.from || range.from == 0)) {
          curSection = name;
          if (typeof section != "string" && section.header) {
            ul.appendChild(section.header(section));
          } else {
            let header = ul.appendChild(document.createElement("completion-section"));
            header.textContent = name;
          }
        }
      }
      const li = ul.appendChild(document.createElement("li"));
      li.id = id2 + "-" + i4;
      li.setAttribute("role", "option");
      let cls = this.optionClass(completion);
      if (cls)
        li.className = cls;
      for (let source of this.optionContent) {
        let node2 = source(completion, this.view.state, this.view, match4);
        if (node2)
          li.appendChild(node2);
      }
    }
    if (range.from)
      ul.classList.add("cm-completionListIncompleteTop");
    if (range.to < options2.length)
      ul.classList.add("cm-completionListIncompleteBottom");
    return ul;
  }
  destroyInfo() {
    if (this.info) {
      if (this.infoDestroy)
        this.infoDestroy();
      this.info.remove();
      this.info = null;
    }
  }
  destroy() {
    this.destroyInfo();
  }
};
function completionTooltip(stateField, applyCompletion2) {
  return (view) => new CompletionTooltip(view, stateField, applyCompletion2);
}
function scrollIntoView2(container, element) {
  let parent = container.getBoundingClientRect();
  let self2 = element.getBoundingClientRect();
  let scaleY = parent.height / container.offsetHeight;
  if (self2.top < parent.top)
    container.scrollTop -= (parent.top - self2.top) / scaleY;
  else if (self2.bottom > parent.bottom)
    container.scrollTop += (self2.bottom - parent.bottom) / scaleY;
}
function score(option) {
  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
}
function sortOptions(active, state2) {
  let options2 = [];
  let sections = null;
  let addOption = (option) => {
    options2.push(option);
    let { section } = option.completion;
    if (section) {
      if (!sections)
        sections = [];
      let name = typeof section == "string" ? section : section.name;
      if (!sections.some((s4) => s4.name == name))
        sections.push(typeof section == "string" ? { name } : section);
    }
  };
  let conf = state2.facet(completionConfig);
  for (let a4 of active)
    if (a4.hasResult()) {
      let getMatch = a4.result.getMatch;
      if (a4.result.filter === false) {
        for (let option of a4.result.options) {
          addOption(new Option3(option, a4.source, getMatch ? getMatch(option) : [], 1e9 - options2.length));
        }
      } else {
        let pattern = state2.sliceDoc(a4.from, a4.to), match4;
        let matcher = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);
        for (let option of a4.result.options)
          if (match4 = matcher.match(option.label)) {
            let matched = !option.displayLabel ? match4.matched : getMatch ? getMatch(option, match4.matched) : [];
            addOption(new Option3(option, a4.source, matched, match4.score + (option.boost || 0)));
          }
      }
    }
  if (sections) {
    let sectionOrder = /* @__PURE__ */ Object.create(null), pos = 0;
    let cmp = (a4, b3) => {
      var _a, _b;
      return ((_a = a4.rank) !== null && _a !== void 0 ? _a : 1e9) - ((_b = b3.rank) !== null && _b !== void 0 ? _b : 1e9) || (a4.name < b3.name ? -1 : 1);
    };
    for (let s4 of sections.sort(cmp)) {
      pos -= 1e5;
      sectionOrder[s4.name] = pos;
    }
    for (let option of options2) {
      let { section } = option.completion;
      if (section)
        option.score += sectionOrder[typeof section == "string" ? section : section.name];
    }
  }
  let result = [], prev2 = null;
  let compare = conf.compareCompletions;
  for (let opt2 of options2.sort((a4, b3) => b3.score - a4.score || compare(a4.completion, b3.completion))) {
    let cur2 = opt2.completion;
    if (!prev2 || prev2.label != cur2.label || prev2.detail != cur2.detail || prev2.type != null && cur2.type != null && prev2.type != cur2.type || prev2.apply != cur2.apply || prev2.boost != cur2.boost)
      result.push(opt2);
    else if (score(opt2.completion) > score(prev2))
      result[result.length - 1] = opt2;
    prev2 = opt2.completion;
  }
  return result;
}
var CompletionDialog = class _CompletionDialog {
  constructor(options2, attrs, tooltip, timestamp, selected, disabled2) {
    this.options = options2;
    this.attrs = attrs;
    this.tooltip = tooltip;
    this.timestamp = timestamp;
    this.selected = selected;
    this.disabled = disabled2;
  }
  setSelected(selected, id2) {
    return selected == this.selected || selected >= this.options.length ? this : new _CompletionDialog(this.options, makeAttrs(id2, selected), this.tooltip, this.timestamp, selected, this.disabled);
  }
  static build(active, state2, id2, prev2, conf, didSetActive) {
    if (prev2 && !didSetActive && active.some(
      (s4) => s4.state == 1
      /* State.Pending */
    ))
      return prev2.setDisabled();
    let options2 = sortOptions(active, state2);
    if (!options2.length)
      return prev2 && active.some(
        (a4) => a4.state == 1
        /* State.Pending */
      ) ? prev2.setDisabled() : null;
    let selected = state2.facet(completionConfig).selectOnOpen ? 0 : -1;
    if (prev2 && prev2.selected != selected && prev2.selected != -1) {
      let selectedValue = prev2.options[prev2.selected].completion;
      for (let i4 = 0; i4 < options2.length; i4++)
        if (options2[i4].completion == selectedValue) {
          selected = i4;
          break;
        }
    }
    return new _CompletionDialog(options2, makeAttrs(id2, selected), {
      pos: active.reduce((a4, b3) => b3.hasResult() ? Math.min(a4, b3.from) : a4, 1e8),
      create: createTooltip,
      above: conf.aboveCursor
    }, prev2 ? prev2.timestamp : Date.now(), selected, false);
  }
  map(changes) {
    return new _CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new _CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);
  }
};
var CompletionState = class _CompletionState {
  constructor(active, id2, open) {
    this.active = active;
    this.id = id2;
    this.open = open;
  }
  static start() {
    return new _CompletionState(none, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(tr) {
    let { state: state2 } = tr, conf = state2.facet(completionConfig);
    let sources = conf.override || state2.languageDataAt("autocomplete", cur(state2)).map(asSource);
    let active = sources.map((source) => {
      let value = this.active.find((s4) => s4.source == source) || new ActiveSource(
        source,
        this.active.some(
          (a4) => a4.state != 0
          /* State.Inactive */
        ) ? 1 : 0
        /* State.Inactive */
      );
      return value.update(tr, conf);
    });
    if (active.length == this.active.length && active.every((a4, i4) => a4 == this.active[i4]))
      active = this.active;
    let open = this.open, didSet = tr.effects.some((e3) => e3.is(setActiveEffect));
    if (open && tr.docChanged)
      open = open.map(tr.changes);
    if (tr.selection || active.some((a4) => a4.hasResult() && tr.changes.touchesRange(a4.from, a4.to)) || !sameResults(active, this.active) || didSet)
      open = CompletionDialog.build(active, state2, this.id, open, conf, didSet);
    else if (open && open.disabled && !active.some(
      (a4) => a4.state == 1
      /* State.Pending */
    ))
      open = null;
    if (!open && active.every(
      (a4) => a4.state != 1
      /* State.Pending */
    ) && active.some((a4) => a4.hasResult()))
      active = active.map((a4) => a4.hasResult() ? new ActiveSource(
        a4.source,
        0
        /* State.Inactive */
      ) : a4);
    for (let effect of tr.effects)
      if (effect.is(setSelectedEffect))
        open = open && open.setSelected(effect.value, this.id);
    return active == this.active && open == this.open ? this : new _CompletionState(active, this.id, open);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs;
  }
};
function sameResults(a4, b3) {
  if (a4 == b3)
    return true;
  for (let iA = 0, iB = 0; ; ) {
    while (iA < a4.length && !a4[iA].hasResult)
      iA++;
    while (iB < b3.length && !b3[iB].hasResult)
      iB++;
    let endA = iA == a4.length, endB = iB == b3.length;
    if (endA || endB)
      return endA == endB;
    if (a4[iA++].result != b3[iB++].result)
      return false;
  }
}
var baseAttrs = {
  "aria-autocomplete": "list"
};
var noAttrs = {};
function makeAttrs(id2, selected) {
  let result = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": id2
  };
  if (selected > -1)
    result["aria-activedescendant"] = id2 + "-" + selected;
  return result;
}
var none = [];
function getUpdateType(tr, conf) {
  if (tr.isUserEvent("input.complete")) {
    let completion = tr.annotation(pickedCompletion);
    if (completion && conf.activateOnCompletion(completion))
      return 4 | 8;
  }
  let typing = tr.isUserEvent("input.type");
  return typing && conf.activateOnTyping ? 4 | 1 : typing ? 1 : tr.isUserEvent("delete.backward") ? 2 : tr.selection ? 8 : tr.docChanged ? 16 : 0;
}
var ActiveSource = class _ActiveSource {
  constructor(source, state2, explicitPos = -1) {
    this.source = source;
    this.state = state2;
    this.explicitPos = explicitPos;
  }
  hasResult() {
    return false;
  }
  update(tr, conf) {
    let type = getUpdateType(tr, conf), value = this;
    if (type & 8 || type & 16 && this.touches(tr))
      value = new _ActiveSource(
        value.source,
        0
        /* State.Inactive */
      );
    if (type & 4 && value.state == 0)
      value = new _ActiveSource(
        this.source,
        1
        /* State.Pending */
      );
    value = value.updateFor(tr, type);
    for (let effect of tr.effects) {
      if (effect.is(startCompletionEffect))
        value = new _ActiveSource(value.source, 1, effect.value ? cur(tr.state) : -1);
      else if (effect.is(closeCompletionEffect))
        value = new _ActiveSource(
          value.source,
          0
          /* State.Inactive */
        );
      else if (effect.is(setActiveEffect)) {
        for (let active of effect.value)
          if (active.source == value.source)
            value = active;
      }
    }
    return value;
  }
  updateFor(tr, type) {
    return this.map(tr.changes);
  }
  map(changes) {
    return changes.empty || this.explicitPos < 0 ? this : new _ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
  }
  touches(tr) {
    return tr.changes.touchesRange(cur(tr.state));
  }
};
var ActiveResult = class _ActiveResult extends ActiveSource {
  constructor(source, explicitPos, result, from2, to) {
    super(source, 2, explicitPos);
    this.result = result;
    this.from = from2;
    this.to = to;
  }
  hasResult() {
    return true;
  }
  updateFor(tr, type) {
    var _a;
    if (!(type & 3))
      return this.map(tr.changes);
    let result = this.result;
    if (result.map && !tr.changes.empty)
      result = result.map(result, tr.changes);
    let from2 = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
    let pos = cur(tr.state);
    if ((this.explicitPos < 0 ? pos <= from2 : pos < this.from) || pos > to || !result || type & 2 && cur(tr.startState) == this.from)
      return new ActiveSource(
        this.source,
        type & 4 ? 1 : 0
        /* State.Inactive */
      );
    let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos);
    if (checkValid(result.validFor, tr.state, from2, to))
      return new _ActiveResult(this.source, explicitPos, result, from2, to);
    if (result.update && (result = result.update(result, from2, to, new CompletionContext(tr.state, pos, explicitPos >= 0))))
      return new _ActiveResult(this.source, explicitPos, result, result.from, (_a = result.to) !== null && _a !== void 0 ? _a : cur(tr.state));
    return new ActiveSource(this.source, 1, explicitPos);
  }
  map(mapping) {
    if (mapping.empty)
      return this;
    let result = this.result.map ? this.result.map(this.result, mapping) : this.result;
    if (!result)
      return new ActiveSource(
        this.source,
        0
        /* State.Inactive */
      );
    return new _ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
  }
  touches(tr) {
    return tr.changes.touchesRange(this.from, this.to);
  }
};
function checkValid(validFor, state2, from2, to) {
  if (!validFor)
    return false;
  let text2 = state2.sliceDoc(from2, to);
  return typeof validFor == "function" ? validFor(text2, from2, to, state2) : ensureAnchor(validFor, true).test(text2);
}
var setActiveEffect = /* @__PURE__ */ import_state4.StateEffect.define({
  map(sources, mapping) {
    return sources.map((s4) => s4.map(mapping));
  }
});
var setSelectedEffect = /* @__PURE__ */ import_state4.StateEffect.define();
var completionState = /* @__PURE__ */ import_state4.StateField.define({
  create() {
    return CompletionState.start();
  },
  update(value, tr) {
    return value.update(tr);
  },
  provide: (f4) => [
    import_view.showTooltip.from(f4, (val) => val.tooltip),
    import_view.EditorView.contentAttributes.from(f4, (state2) => state2.attrs)
  ]
});
function applyCompletion(view, option) {
  const apply = option.completion.apply || option.completion.label;
  let result = view.state.field(completionState).active.find((a4) => a4.source == option.source);
  if (!(result instanceof ActiveResult))
    return false;
  if (typeof apply == "string")
    view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));
  else
    apply(view, option.completion, result.from, result.to);
  return true;
}
var createTooltip = /* @__PURE__ */ completionTooltip(completionState, applyCompletion);
function moveCompletionSelection(forward, by = "option") {
  return (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
      return false;
    let step = 1, tooltip;
    if (by == "page" && (tooltip = (0, import_view.getTooltip)(view, cState.open.tooltip)))
      step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
    let { length: length2 } = cState.open.options;
    let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length2 - 1;
    if (selected < 0)
      selected = by == "page" ? 0 : length2 - 1;
    else if (selected >= length2)
      selected = by == "page" ? length2 - 1 : 0;
    view.dispatch({ effects: setSelectedEffect.of(selected) });
    return true;
  };
}
var acceptCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
    return false;
  return applyCompletion(view, cState.open.options[cState.open.selected]);
};
var startCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState)
    return false;
  view.dispatch({ effects: startCompletionEffect.of(true) });
  return true;
};
var closeCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState || !cState.active.some(
    (a4) => a4.state != 0
    /* State.Inactive */
  ))
    return false;
  view.dispatch({ effects: closeCompletionEffect.of(null) });
  return true;
};
var windows = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform);
var baseTheme = /* @__PURE__ */ import_view.EditorView.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"\xB7\xB7\xB7"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: `${400}px`,
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'\u0192'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'\u25CB'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'\u25CC'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'\u{1D465}'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'\u{1D436}'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'\u{1D461}'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'\u222A'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'\u25A1'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'\u{1F511}\uFE0E'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'\u25A2'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
var FieldPos = class {
  constructor(field, line2, from2, to) {
    this.field = field;
    this.line = line2;
    this.from = from2;
    this.to = to;
  }
};
var FieldRange = class _FieldRange {
  constructor(field, from2, to) {
    this.field = field;
    this.from = from2;
    this.to = to;
  }
  map(changes) {
    let from2 = changes.mapPos(this.from, -1, import_state4.MapMode.TrackDel);
    let to = changes.mapPos(this.to, 1, import_state4.MapMode.TrackDel);
    return from2 == null || to == null ? null : new _FieldRange(this.field, from2, to);
  }
};
var Snippet = class _Snippet {
  constructor(lines, fieldPositions) {
    this.lines = lines;
    this.fieldPositions = fieldPositions;
  }
  instantiate(state2, pos) {
    let text2 = [], lineStart = [pos];
    let lineObj = state2.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.text)[0];
    for (let line2 of this.lines) {
      if (text2.length) {
        let indent = baseIndent, tabs = /^\t*/.exec(line2)[0].length;
        for (let i4 = 0; i4 < tabs; i4++)
          indent += state2.facet(import_language.indentUnit);
        lineStart.push(pos + indent.length - tabs);
        line2 = indent + line2.slice(tabs);
      }
      text2.push(line2);
      pos += line2.length + 1;
    }
    let ranges = this.fieldPositions.map((pos2) => new FieldRange(pos2.field, lineStart[pos2.line] + pos2.from, lineStart[pos2.line] + pos2.to));
    return { text: text2, ranges };
  }
  static parse(template) {
    let fields = [];
    let lines = [], positions = [], m3;
    for (let line2 of template.split(/\r\n?|\n/)) {
      while (m3 = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(line2)) {
        let seq2 = m3[1] ? +m3[1] : null, rawName = m3[2] || m3[3] || "", found = -1;
        let name = rawName.replace(/\\[{}]/g, (m4) => m4[1]);
        for (let i4 = 0; i4 < fields.length; i4++) {
          if (seq2 != null ? fields[i4].seq == seq2 : name ? fields[i4].name == name : false)
            found = i4;
        }
        if (found < 0) {
          let i4 = 0;
          while (i4 < fields.length && (seq2 == null || fields[i4].seq != null && fields[i4].seq < seq2))
            i4++;
          fields.splice(i4, 0, { seq: seq2, name });
          found = i4;
          for (let pos of positions)
            if (pos.field >= found)
              pos.field++;
        }
        positions.push(new FieldPos(found, lines.length, m3.index, m3.index + name.length));
        line2 = line2.slice(0, m3.index) + rawName + line2.slice(m3.index + m3[0].length);
      }
      line2 = line2.replace(/\\([{}])/g, (_3, brace, index2) => {
        for (let pos of positions)
          if (pos.line == lines.length && pos.from > index2) {
            pos.from--;
            pos.to--;
          }
        return brace;
      });
      lines.push(line2);
    }
    return new _Snippet(lines, positions);
  }
};
var fieldMarker = /* @__PURE__ */ import_view.Decoration.widget({ widget: /* @__PURE__ */ new class extends import_view.WidgetType {
  toDOM() {
    let span = document.createElement("span");
    span.className = "cm-snippetFieldPosition";
    return span;
  }
  ignoreEvent() {
    return false;
  }
}() });
var fieldRange = /* @__PURE__ */ import_view.Decoration.mark({ class: "cm-snippetField" });
var ActiveSnippet = class _ActiveSnippet {
  constructor(ranges, active) {
    this.ranges = ranges;
    this.active = active;
    this.deco = import_view.Decoration.set(ranges.map((r4) => (r4.from == r4.to ? fieldMarker : fieldRange).range(r4.from, r4.to)));
  }
  map(changes) {
    let ranges = [];
    for (let r4 of this.ranges) {
      let mapped = r4.map(changes);
      if (!mapped)
        return null;
      ranges.push(mapped);
    }
    return new _ActiveSnippet(ranges, this.active);
  }
  selectionInsideField(sel) {
    return sel.ranges.every((range) => this.ranges.some((r4) => r4.field == this.active && r4.from <= range.from && r4.to >= range.to));
  }
};
var setActive = /* @__PURE__ */ import_state4.StateEffect.define({
  map(value, changes) {
    return value && value.map(changes);
  }
});
var moveToField = /* @__PURE__ */ import_state4.StateEffect.define();
var snippetState = /* @__PURE__ */ import_state4.StateField.define({
  create() {
    return null;
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setActive))
        return effect.value;
      if (effect.is(moveToField) && value)
        return new ActiveSnippet(value.ranges, effect.value);
    }
    if (value && tr.docChanged)
      value = value.map(tr.changes);
    if (value && tr.selection && !value.selectionInsideField(tr.selection))
      value = null;
    return value;
  },
  provide: (f4) => import_view.EditorView.decorations.from(f4, (val) => val ? val.deco : import_view.Decoration.none)
});
function fieldSelection(ranges, field) {
  return import_state4.EditorSelection.create(ranges.filter((r4) => r4.field == field).map((r4) => import_state4.EditorSelection.range(r4.from, r4.to)));
}
function snippet(template) {
  let snippet2 = Snippet.parse(template);
  return (editor, completion, from2, to) => {
    let { text: text2, ranges } = snippet2.instantiate(editor.state, from2);
    let spec = {
      changes: { from: from2, to, insert: import_state4.Text.of(text2) },
      scrollIntoView: true,
      annotations: completion ? [pickedCompletion.of(completion), import_state4.Transaction.userEvent.of("input.complete")] : void 0
    };
    if (ranges.length)
      spec.selection = fieldSelection(ranges, 0);
    if (ranges.some((r4) => r4.field > 0)) {
      let active = new ActiveSnippet(ranges, 0);
      let effects = spec.effects = [setActive.of(active)];
      if (editor.state.field(snippetState, false) === void 0)
        effects.push(import_state4.StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme]));
    }
    editor.dispatch(editor.state.update(spec));
  };
}
function moveField(dir) {
  return ({ state: state2, dispatch }) => {
    let active = state2.field(snippetState, false);
    if (!active || dir < 0 && active.active == 0)
      return false;
    let next3 = active.active + dir, last = dir > 0 && !active.ranges.some((r4) => r4.field == next3 + dir);
    dispatch(state2.update({
      selection: fieldSelection(active.ranges, next3),
      effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next3)),
      scrollIntoView: true
    }));
    return true;
  };
}
var clearSnippet = ({ state: state2, dispatch }) => {
  let active = state2.field(snippetState, false);
  if (!active)
    return false;
  dispatch(state2.update({ effects: setActive.of(null) }));
  return true;
};
var nextSnippetField = /* @__PURE__ */ moveField(1);
var prevSnippetField = /* @__PURE__ */ moveField(-1);
var defaultSnippetKeymap = [
  { key: "Tab", run: nextSnippetField, shift: prevSnippetField },
  { key: "Escape", run: clearSnippet }
];
var snippetKeymap = /* @__PURE__ */ import_state4.Facet.define({
  combine(maps) {
    return maps.length ? maps[0] : defaultSnippetKeymap;
  }
});
var addSnippetKeymap = /* @__PURE__ */ import_state4.Prec.highest(/* @__PURE__ */ import_view.keymap.compute([snippetKeymap], (state2) => state2.facet(snippetKeymap)));
function snippetCompletion(template, completion) {
  return Object.assign(Object.assign({}, completion), { apply: snippet(template) });
}
var snippetPointerHandler = /* @__PURE__ */ import_view.EditorView.domEventHandlers({
  mousedown(event, view) {
    let active = view.state.field(snippetState, false), pos;
    if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)
      return false;
    let match4 = active.ranges.find((r4) => r4.from <= pos && r4.to >= pos);
    if (!match4 || match4.field == active.active)
      return false;
    view.dispatch({
      selection: fieldSelection(active.ranges, match4.field),
      effects: setActive.of(active.ranges.some((r4) => r4.field > match4.field) ? new ActiveSnippet(active.ranges, match4.field) : null),
      scrollIntoView: true
    });
    return true;
  }
});
var defaults = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
};
var closeBracketEffect = /* @__PURE__ */ import_state4.StateEffect.define({
  map(value, mapping) {
    let mapped = mapping.mapPos(value, -1, import_state4.MapMode.TrackAfter);
    return mapped == null ? void 0 : mapped;
  }
});
var closedBracket = /* @__PURE__ */ new class extends import_state4.RangeValue {
}();
closedBracket.startSide = 1;
closedBracket.endSide = -1;
var bracketState = /* @__PURE__ */ import_state4.StateField.define({
  create() {
    return import_state4.RangeSet.empty;
  },
  update(value, tr) {
    value = value.map(tr.changes);
    if (tr.selection) {
      let line2 = tr.state.doc.lineAt(tr.selection.main.head);
      value = value.update({ filter: (from2) => from2 >= line2.from && from2 <= line2.to });
    }
    for (let effect of tr.effects)
      if (effect.is(closeBracketEffect))
        value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
    return value;
  }
});
function closeBrackets() {
  return [inputHandler, bracketState];
}
var definedClosing = "()[]{}<>";
function closing(ch) {
  for (let i4 = 0; i4 < definedClosing.length; i4 += 2)
    if (definedClosing.charCodeAt(i4) == ch)
      return definedClosing.charAt(i4 + 1);
  return (0, import_state4.fromCodePoint)(ch < 128 ? ch : ch + 1);
}
function config2(state2, pos) {
  return state2.languageDataAt("closeBrackets", pos)[0] || defaults;
}
var android = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
var inputHandler = /* @__PURE__ */ import_view.EditorView.inputHandler.of((view, from2, to, insert) => {
  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
    return false;
  let sel = view.state.selection.main;
  if (insert.length > 2 || insert.length == 2 && (0, import_state4.codePointSize)((0, import_state4.codePointAt)(insert, 0)) == 1 || from2 != sel.from || to != sel.to)
    return false;
  let tr = insertBracket(view.state, insert);
  if (!tr)
    return false;
  view.dispatch(tr);
  return true;
});
var deleteBracketPair = ({ state: state2, dispatch }) => {
  if (state2.readOnly)
    return false;
  let conf = config2(state2, state2.selection.main.head);
  let tokens = conf.brackets || defaults.brackets;
  let dont = null, changes = state2.changeByRange((range) => {
    if (range.empty) {
      let before = prevChar(state2.doc, range.head);
      for (let token2 of tokens) {
        if (token2 == before && nextChar(state2.doc, range.head) == closing((0, import_state4.codePointAt)(token2, 0)))
          return {
            changes: { from: range.head - token2.length, to: range.head + token2.length },
            range: import_state4.EditorSelection.cursor(range.head - token2.length)
          };
      }
    }
    return { range: dont = range };
  });
  if (!dont)
    dispatch(state2.update(changes, { scrollIntoView: true, userEvent: "delete.backward" }));
  return !dont;
};
var closeBracketsKeymap = [
  { key: "Backspace", run: deleteBracketPair }
];
function insertBracket(state2, bracket) {
  let conf = config2(state2, state2.selection.main.head);
  let tokens = conf.brackets || defaults.brackets;
  for (let tok of tokens) {
    let closed = closing((0, import_state4.codePointAt)(tok, 0));
    if (bracket == tok)
      return closed == tok ? handleSame(state2, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state2, tok, closed, conf.before || defaults.before);
    if (bracket == closed && closedBracketAt(state2, state2.selection.main.from))
      return handleClose(state2, tok, closed);
  }
  return null;
}
function closedBracketAt(state2, pos) {
  let found = false;
  state2.field(bracketState).between(0, state2.doc.length, (from2) => {
    if (from2 == pos)
      found = true;
  });
  return found;
}
function nextChar(doc, pos) {
  let next3 = doc.sliceString(pos, pos + 2);
  return next3.slice(0, (0, import_state4.codePointSize)((0, import_state4.codePointAt)(next3, 0)));
}
function prevChar(doc, pos) {
  let prev2 = doc.sliceString(pos - 2, pos);
  return (0, import_state4.codePointSize)((0, import_state4.codePointAt)(prev2, 0)) == prev2.length ? prev2 : prev2.slice(1);
}
function handleOpen(state2, open, close, closeBefore) {
  let dont = null, changes = state2.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
        effects: closeBracketEffect.of(range.to + open.length),
        range: import_state4.EditorSelection.range(range.anchor + open.length, range.head + open.length)
      };
    let next3 = nextChar(state2.doc, range.head);
    if (!next3 || /\s/.test(next3) || closeBefore.indexOf(next3) > -1)
      return {
        changes: { insert: open + close, from: range.head },
        effects: closeBracketEffect.of(range.head + open.length),
        range: import_state4.EditorSelection.cursor(range.head + open.length)
      };
    return { range: dont = range };
  });
  return dont ? null : state2.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleClose(state2, _open, close) {
  let dont = null, changes = state2.changeByRange((range) => {
    if (range.empty && nextChar(state2.doc, range.head) == close)
      return {
        changes: { from: range.head, to: range.head + close.length, insert: close },
        range: import_state4.EditorSelection.cursor(range.head + close.length)
      };
    return dont = { range };
  });
  return dont ? null : state2.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleSame(state2, token2, allowTriple, config3) {
  let stringPrefixes = config3.stringPrefixes || defaults.stringPrefixes;
  let dont = null, changes = state2.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: token2, from: range.from }, { insert: token2, from: range.to }],
        effects: closeBracketEffect.of(range.to + token2.length),
        range: import_state4.EditorSelection.range(range.anchor + token2.length, range.head + token2.length)
      };
    let pos = range.head, next3 = nextChar(state2.doc, pos), start;
    if (next3 == token2) {
      if (nodeStart(state2, pos)) {
        return {
          changes: { insert: token2 + token2, from: pos },
          effects: closeBracketEffect.of(pos + token2.length),
          range: import_state4.EditorSelection.cursor(pos + token2.length)
        };
      } else if (closedBracketAt(state2, pos)) {
        let isTriple = allowTriple && state2.sliceDoc(pos, pos + token2.length * 3) == token2 + token2 + token2;
        let content = isTriple ? token2 + token2 + token2 : token2;
        return {
          changes: { from: pos, to: pos + content.length, insert: content },
          range: import_state4.EditorSelection.cursor(pos + content.length)
        };
      }
    } else if (allowTriple && state2.sliceDoc(pos - 2 * token2.length, pos) == token2 + token2 && (start = canStartStringAt(state2, pos - 2 * token2.length, stringPrefixes)) > -1 && nodeStart(state2, start)) {
      return {
        changes: { insert: token2 + token2 + token2 + token2, from: pos },
        effects: closeBracketEffect.of(pos + token2.length),
        range: import_state4.EditorSelection.cursor(pos + token2.length)
      };
    } else if (state2.charCategorizer(pos)(next3) != import_state4.CharCategory.Word) {
      if (canStartStringAt(state2, pos, stringPrefixes) > -1 && !probablyInString(state2, pos, token2, stringPrefixes))
        return {
          changes: { insert: token2 + token2, from: pos },
          effects: closeBracketEffect.of(pos + token2.length),
          range: import_state4.EditorSelection.cursor(pos + token2.length)
        };
    }
    return { range: dont = range };
  });
  return dont ? null : state2.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function nodeStart(state2, pos) {
  let tree = (0, import_language.syntaxTree)(state2).resolveInner(pos + 1);
  return tree.parent && tree.from == pos;
}
function probablyInString(state2, pos, quoteToken, prefixes2) {
  let node2 = (0, import_language.syntaxTree)(state2).resolveInner(pos, -1);
  let maxPrefix = prefixes2.reduce((m3, p3) => Math.max(m3, p3.length), 0);
  for (let i4 = 0; i4 < 5; i4++) {
    let start = state2.sliceDoc(node2.from, Math.min(node2.to, node2.from + quoteToken.length + maxPrefix));
    let quotePos = start.indexOf(quoteToken);
    if (!quotePos || quotePos > -1 && prefixes2.indexOf(start.slice(0, quotePos)) > -1) {
      let first = node2.firstChild;
      while (first && first.from == node2.from && first.to - first.from > quoteToken.length + quotePos) {
        if (state2.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
          return false;
        first = first.firstChild;
      }
      return true;
    }
    let parent = node2.to == pos && node2.parent;
    if (!parent)
      break;
    node2 = parent;
  }
  return false;
}
function canStartStringAt(state2, pos, prefixes2) {
  let charCat = state2.charCategorizer(pos);
  if (charCat(state2.sliceDoc(pos - 1, pos)) != import_state4.CharCategory.Word)
    return pos;
  for (let prefix2 of prefixes2) {
    let start = pos - prefix2.length;
    if (state2.sliceDoc(start, pos) == prefix2 && charCat(state2.sliceDoc(start - 1, start)) != import_state4.CharCategory.Word)
      return start;
  }
  return -1;
}
var completionKeymap = [
  { key: "Ctrl-Space", run: startCompletion },
  { mac: "Alt-`", run: startCompletion },
  { key: "Escape", run: closeCompletion },
  { key: "ArrowDown", run: /* @__PURE__ */ moveCompletionSelection(true) },
  { key: "ArrowUp", run: /* @__PURE__ */ moveCompletionSelection(false) },
  { key: "PageDown", run: /* @__PURE__ */ moveCompletionSelection(true, "page") },
  { key: "PageUp", run: /* @__PURE__ */ moveCompletionSelection(false, "page") },
  { key: "Enter", run: acceptCompletion }
];

// src/ui/view-page.tsx
var import_lint = require("@codemirror/lint");
var import_view4 = require("@codemirror/view");
var import_highlight2 = require("@lezer/highlight");

// node_modules/@lezer/common/dist/index.js
var DefaultBufferLength = 1024;
var nextPropID = 0;
var Range = class {
  constructor(from2, to) {
    this.from = from2;
    this.to = to;
  }
};
var NodeProp = class {
  /**
  Create a new node prop type.
  */
  constructor(config3 = {}) {
    this.id = nextPropID++;
    this.perNode = !!config3.perNode;
    this.deserialize = config3.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(match4) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    if (typeof match4 != "function")
      match4 = NodeType.match(match4);
    return (type) => {
      let result = match4(type);
      return result === void 0 ? null : [this, result];
    };
  }
};
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.isolate = new NodeProp({ deserialize: (value) => {
  if (value && value != "rtl" && value != "ltr" && value != "auto")
    throw new RangeError("Invalid value for isolate: " + value);
  return value || "auto";
} });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
var MountedTree = class {
  constructor(tree, overlay, parser2) {
    this.tree = tree;
    this.overlay = overlay;
    this.parser = parser2;
  }
  /**
  @internal
  */
  static get(tree) {
    return tree && tree.props && tree.props[NodeProp.mounted.id];
  }
};
var noProps = /* @__PURE__ */ Object.create(null);
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name, props, id2, flags = 0) {
    this.name = name;
    this.props = props;
    this.id = id2;
    this.flags = flags;
  }
  /**
  Define a node type.
  */
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new _NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src))
          src = src(type);
        if (src) {
          if (src[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
    return type;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(prop) {
    return this.props[prop.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(name) {
    if (typeof name == "string") {
      if (this.name == name)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name) > -1 : false;
    }
    return this.id == name;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(map) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop in map)
      for (let name of prop.split(" "))
        direct[name] = map[prop];
    return (node2) => {
      for (let groups = node2.prop(NodeProp.group), i4 = -1; i4 < (groups ? groups.length : 0); i4++) {
        let found = direct[i4 < 0 ? node2.name : groups[i4]];
        if (found)
          return found;
      }
    };
  }
};
NodeType.none = new NodeType(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var NodeSet = class _NodeSet {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(types) {
    this.types = types;
    for (let i4 = 0; i4 < types.length; i4++)
      if (types[i4].id != i4)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...props) {
    let newTypes = [];
    for (let type of this.types) {
      let newProps = null;
      for (let source of props) {
        let add = source(type);
        if (add) {
          if (!newProps)
            newProps = Object.assign({}, type.props);
          newProps[add[0].id] = add[1];
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }
    return new _NodeSet(newTypes);
  }
};
var CachedNode = /* @__PURE__ */ new WeakMap();
var CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode2) {
  IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
var Tree = class _Tree {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(type, children, positions, length2, props) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length2;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop, value] of props)
        this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  }
  /**
  @internal
  */
  toString() {
    let mounted = MountedTree.get(this);
    if (mounted && !mounted.overlay)
      return mounted.tree.toString();
    let children = "";
    for (let ch of this.children) {
      let str = ch.toString();
      if (str) {
        if (children)
          children += ",";
        children += str;
      }
    }
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(mode = 0) {
    return new TreeCursor(this.topNode, mode);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(pos, side = 0, mode = 0) {
    let scope = CachedNode.get(this) || this.topNode;
    let cursor2 = new TreeCursor(scope);
    cursor2.moveTo(pos, side);
    CachedNode.set(this, cursor2._tree);
    return cursor2;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(pos, side = 0) {
    let node2 = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node2);
    return node2;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(pos, side = 0) {
    let node2 = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node2);
    return node2;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(pos, side = 0) {
    return stackIterator(this, pos, side);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(spec) {
    let { enter, leave, from: from2 = 0, to = this.length } = spec;
    let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
    for (let c4 = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
      let entered = false;
      if (c4.from <= to && c4.to >= from2 && (!anon && c4.type.isAnonymous || enter(c4) !== false)) {
        if (c4.firstChild())
          continue;
        entered = true;
      }
      for (; ; ) {
        if (entered && leave && (anon || !c4.type.isAnonymous))
          leave(c4);
        if (c4.nextSibling())
          break;
        if (!c4.parent())
          return;
        entered = true;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let result = [];
    if (this.props)
      for (let id2 in this.props)
        result.push([+id2, this.props[id2]]);
    return result;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(config3 = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length2) => new _Tree(this.type, children, positions, length2, this.propValues), config3.makeTree || ((children, positions, length2) => new _Tree(NodeType.none, children, positions, length2)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(data) {
    return buildTree(data);
  }
};
Tree.empty = new Tree(NodeType.none, [], [], 0);
var FlatBufferCursor = class _FlatBufferCursor {
  constructor(buffer, index2) {
    this.buffer = buffer;
    this.index = index2;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new _FlatBufferCursor(this.buffer, this.index);
  }
};
var TreeBuffer = class _TreeBuffer {
  /**
  Create a tree buffer.
  */
  constructor(buffer, length2, set) {
    this.buffer = buffer;
    this.length = length2;
    this.set = set;
  }
  /**
  @internal
  */
  get type() {
    return NodeType.none;
  }
  /**
  @internal
  */
  toString() {
    let result = [];
    for (let index2 = 0; index2 < this.buffer.length; ) {
      result.push(this.childString(index2));
      index2 = this.buffer[index2 + 3];
    }
    return result.join(",");
  }
  /**
  @internal
  */
  childString(index2) {
    let id2 = this.buffer[index2], endIndex = this.buffer[index2 + 3];
    let type = this.set.types[id2], result = type.name;
    if (/\W/.test(result) && !type.isError)
      result = JSON.stringify(result);
    index2 += 4;
    if (endIndex == index2)
      return result;
    let children = [];
    while (index2 < endIndex) {
      children.push(this.childString(index2));
      index2 = this.buffer[index2 + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer } = this, pick2 = -1;
    for (let i4 = startIndex; i4 != endIndex; i4 = buffer[i4 + 3]) {
      if (checkSide(side, pos, buffer[i4 + 1], buffer[i4 + 2])) {
        pick2 = i4;
        if (dir > 0)
          break;
      }
    }
    return pick2;
  }
  /**
  @internal
  */
  slice(startI, endI, from2) {
    let b3 = this.buffer;
    let copy2 = new Uint16Array(endI - startI), len = 0;
    for (let i4 = startI, j4 = 0; i4 < endI; ) {
      copy2[j4++] = b3[i4++];
      copy2[j4++] = b3[i4++] - from2;
      let to = copy2[j4++] = b3[i4++] - from2;
      copy2[j4++] = b3[i4++] - startI;
      len = Math.max(len, to);
    }
    return new _TreeBuffer(copy2, len, this.set);
  }
};
function checkSide(side, pos, from2, to) {
  switch (side) {
    case -2:
      return from2 < pos;
    case -1:
      return to >= pos && from2 < pos;
    case 0:
      return from2 < pos && to > pos;
    case 1:
      return from2 <= pos && to > pos;
    case 2:
      return to > pos;
    case 4:
      return true;
  }
}
function resolveNode(node2, pos, side, overlays) {
  var _a;
  while (node2.from == node2.to || (side < 1 ? node2.from >= pos : node2.from > pos) || (side > -1 ? node2.to <= pos : node2.to < pos)) {
    let parent = !overlays && node2 instanceof TreeNode && node2.index < 0 ? null : node2.parent;
    if (!parent)
      return node2;
    node2 = parent;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays)
    for (let scan = node2, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
        node2 = parent;
    }
  for (; ; ) {
    let inner = node2.enter(pos, side, mode);
    if (!inner)
      return node2;
    node2 = inner;
  }
}
var BaseNode = class {
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  getChild(type, before = null, after = null) {
    let r4 = getChildren(this, type, before, after);
    return r4.length ? r4[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  matchContext(context) {
    return matchNodeContext(this.parent, context);
  }
  enterUnfinishedNodesBefore(pos) {
    let scan = this.childBefore(pos), node2 = this;
    while (scan) {
      let last = scan.lastChild;
      if (!last || last.to != scan.to)
        break;
      if (last.type.isError && last.from == last.to) {
        node2 = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node2;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
};
var TreeNode = class _TreeNode extends BaseNode {
  constructor(_tree, from2, index2, _parent) {
    super();
    this._tree = _tree;
    this.from = from2;
    this.index = index2;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i4, dir, pos, side, mode = 0) {
    for (let parent = this; ; ) {
      for (let { children, positions } = parent._tree, e3 = dir > 0 ? children.length : -1; i4 != e3; i4 += dir) {
        let next3 = children[i4], start = positions[i4] + parent.from;
        if (!checkSide(side, pos, start, start + next3.length))
          continue;
        if (next3 instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers)
            continue;
          let index2 = next3.findChild(0, next3.buffer.length, dir, pos - start, side);
          if (index2 > -1)
            return new BufferNode(new BufferContext(parent, next3, i4, start), null, index2);
        } else if (mode & IterMode.IncludeAnonymous || (!next3.type.isAnonymous || hasChild(next3))) {
          let mounted;
          if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next3)) && !mounted.overlay)
            return new _TreeNode(mounted.tree, start, i4, parent);
          let inner = new _TreeNode(next3, start, i4, parent);
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next3.children.length - 1 : 0, dir, pos, side);
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
        return null;
      if (parent.index >= 0)
        i4 = parent.index + dir;
      else
        i4 = dir < 0 ? -1 : parent._parent._tree.children.length;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.nextChild(
      0,
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  enter(pos, side, mode = 0) {
    let mounted;
    if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
      let rPos = pos - this.from;
      for (let { from: from2, to } of mounted.overlay) {
        if ((side > 0 ? from2 <= rPos : from2 < rPos) && (side < 0 ? to >= rPos : to > rPos))
          return new _TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
};
function getChildren(node2, type, before, after) {
  let cur2 = node2.cursor(), result = [];
  if (!cur2.firstChild())
    return result;
  if (before != null)
    for (let found = false; !found; ) {
      found = cur2.type.is(before);
      if (!cur2.nextSibling())
        return result;
    }
  for (; ; ) {
    if (after != null && cur2.type.is(after))
      return result;
    if (cur2.type.is(type))
      result.push(cur2.node);
    if (!cur2.nextSibling())
      return after == null ? result : [];
  }
}
function matchNodeContext(node2, context, i4 = context.length - 1) {
  for (let p3 = node2; i4 >= 0; p3 = p3.parent) {
    if (!p3)
      return false;
    if (!p3.type.isAnonymous) {
      if (context[i4] && context[i4] != p3.name)
        return false;
      i4--;
    }
  }
  return true;
}
var BufferContext = class {
  constructor(parent, buffer, index2, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index2;
    this.start = start;
  }
};
var BufferNode = class _BufferNode extends BaseNode {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(context, _parent, index2) {
    super();
    this.context = context;
    this._parent = _parent;
    this.index = index2;
    this.type = context.buffer.set.types[context.buffer.buffer[index2]];
  }
  child(dir, pos, side) {
    let { buffer } = this.context;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index2 < 0 ? null : new _BufferNode(this.context, this, index2);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.child(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.child(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  enter(pos, side, mode = 0) {
    if (mode & IterMode.ExcludeBuffers)
      return null;
    let { buffer } = this.context;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index2 < 0 ? null : new _BufferNode(this.context, this, index2);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + dir,
      dir,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new _BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new _BufferNode(this.context, this._parent, buffer.findChild(
      parentStart,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let children = [], positions = [];
    let { buffer } = this.context;
    let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from2 = buffer.buffer[this.index + 1];
      children.push(buffer.slice(startI, endI, from2));
      positions.push(0);
    }
    return new Tree(this.type, children, positions, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
};
function iterStack(heads) {
  if (!heads.length)
    return null;
  let pick2 = 0, picked = heads[0];
  for (let i4 = 1; i4 < heads.length; i4++) {
    let node2 = heads[i4];
    if (node2.from > picked.from || node2.to < picked.to) {
      picked = node2;
      pick2 = i4;
    }
  }
  let next3 = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
  let newHeads = heads.slice();
  if (next3)
    newHeads[pick2] = next3;
  else
    newHeads.splice(pick2, 1);
  return new StackIterator(newHeads, picked);
}
var StackIterator = class {
  constructor(heads, node2) {
    this.heads = heads;
    this.node = node2;
  }
  get next() {
    return iterStack(this.heads);
  }
};
function stackIterator(tree, pos, side) {
  let inner = tree.resolveInner(pos, side), layers = null;
  for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
    if (scan.index < 0) {
      let parent = scan.parent;
      (layers || (layers = [inner])).push(parent.resolve(pos, side));
      scan = parent;
    } else {
      let mount = MountedTree.get(scan.tree);
      if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
        let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
        (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
      }
    }
  }
  return layers ? iterStack(layers) : inner;
}
var TreeCursor = class {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(node2, mode = 0) {
    this.mode = mode;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node2 instanceof TreeNode) {
      this.yieldNode(node2);
    } else {
      this._tree = node2.context.parent;
      this.buffer = node2.context;
      for (let n3 = node2._parent; n3; n3 = n3._parent)
        this.stack.unshift(n3.index);
      this.bufferNode = node2;
      this.yieldBuf(node2.index);
    }
  }
  yieldNode(node2) {
    if (!node2)
      return false;
    this._tree = node2;
    this.type = node2.type;
    this.from = node2.from;
    this.to = node2.to;
    return true;
  }
  yieldBuf(index2, type) {
    this.index = index2;
    let { start, buffer } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index2]];
    this.from = start + buffer.buffer[index2 + 1];
    this.to = start + buffer.buffer[index2 + 2];
    return true;
  }
  /**
  @internal
  */
  yield(node2) {
    if (!node2)
      return false;
    if (node2 instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node2);
    }
    this.buffer = node2.context;
    return this.yieldBuf(node2.index, node2.type);
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let { buffer } = this.buffer;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index2 < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index2);
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(pos) {
    return this.enterChild(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(pos) {
    return this.enterChild(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(pos, side, mode = this.mode) {
    if (!this.buffer)
      return this.yield(this._tree.enter(pos, side, mode));
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  /**
  @internal
  */
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let { buffer } = this.buffer, d3 = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d3 < 0 ? 0 : this.stack[d3] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(
          parentStart,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d3 < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d3] + 3]))
        return this.yieldBuf(after);
    }
    return d3 < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index2, parent, { buffer } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i4 = 0; i4 < this.index; i4++)
          if (buffer.buffer.buffer[i4 + 3] < this.index)
            return false;
      }
      ({ index: index2, parent } = buffer);
    } else {
      ({ index: index2, _parent: parent } = this._tree);
    }
    for (; parent; { index: index2, _parent: parent } = parent) {
      if (index2 > -1)
        for (let i4 = index2 + dir, e3 = dir < 0 ? -1 : parent._tree.children.length; i4 != e3; i4 += dir) {
          let child = parent._tree.children[i4];
          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
            return false;
        }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(
      dir,
      0,
      4
      /* Side.DontCare */
    ))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(enter = true) {
    return this.move(1, enter);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(enter = true) {
    return this.move(-1, enter);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache2 = this.bufferNode, result = null, depth = 0;
    if (cache2 && cache2.context == this.buffer) {
      scan: for (let index2 = this.index, d3 = this.stack.length; d3 >= 0; ) {
        for (let c4 = cache2; c4; c4 = c4._parent)
          if (c4.index == index2) {
            if (index2 == this.index)
              return c4;
            result = c4;
            depth = d3 + 1;
            break scan;
          }
        index2 = this.stack[--d3];
      }
    }
    for (let i4 = depth; i4 < this.stack.length; i4++)
      result = new BufferNode(this.buffer, result, this.stack[i4]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(enter, leave) {
    for (let depth = 0; ; ) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth++;
          continue;
        }
        if (!this.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(this);
        mustLeave = this.type.isAnonymous;
        if (!depth)
          return;
        if (this.nextSibling())
          break;
        this.parent();
        depth--;
        mustLeave = true;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(context) {
    if (!this.buffer)
      return matchNodeContext(this.node.parent, context);
    let { buffer } = this.buffer, { types } = buffer.set;
    for (let i4 = context.length - 1, d3 = this.stack.length - 1; i4 >= 0; d3--) {
      if (d3 < 0)
        return matchNodeContext(this._tree, context, i4);
      let type = types[buffer.buffer[this.stack[d3]]];
      if (!type.isAnonymous) {
        if (context[i4] && context[i4] != type.name)
          return false;
        i4--;
      }
    }
    return true;
  }
};
function hasChild(tree) {
  return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
  var _a;
  let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
  let cursor2 = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types = nodeSet.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat, depth) {
    let { id: id2, start, end: end2, size: size2 } = cursor2;
    let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
    while (size2 < 0) {
      cursor2.next();
      if (size2 == -1) {
        let node3 = reused[id2];
        children2.push(node3);
        positions2.push(start - parentStart);
        return;
      } else if (size2 == -3) {
        contextHash = id2;
        return;
      } else if (size2 == -4) {
        lookAhead = id2;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size2}`);
      }
    }
    let type = types[id2], node2, buffer2;
    let startPos = start - parentStart;
    if (end2 - start <= maxBufferLength && (buffer2 = findBufferSize(cursor2.pos - minPos, inRepeat))) {
      let data2 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor2.pos - buffer2.size, index2 = data2.length;
      while (cursor2.pos > endPos)
        index2 = copyToBuffer(buffer2.start, data2, index2);
      node2 = new TreeBuffer(data2, end2 - buffer2.start, nodeSet);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor2.pos - size2;
      cursor2.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id2 >= minRepeatType ? id2 : -1;
      let lastGroup = 0, lastEnd = end2;
      while (cursor2.pos > endPos) {
        if (localInRepeat >= 0 && cursor2.id == localInRepeat && cursor2.size >= 0) {
          if (cursor2.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor2.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor2.end;
          }
          cursor2.next();
        } else if (depth > 2500) {
          takeFlatNode(start, endPos, localChildren, localPositions);
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type, contextAtStart);
        node2 = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end2 - start, make, make);
      } else {
        node2 = makeTree(type, localChildren, localPositions, end2 - start, lookAheadAtStart - end2, contextAtStart);
      }
    }
    children2.push(node2);
    positions2.push(startPos);
  }
  function takeFlatNode(parentStart, minPos, children2, positions2) {
    let nodes = [];
    let nodeCount = 0, stopAt = -1;
    while (cursor2.pos > minPos) {
      let { id: id2, start, end: end2, size: size2 } = cursor2;
      if (size2 > 4) {
        cursor2.next();
      } else if (stopAt > -1 && start < stopAt) {
        break;
      } else {
        if (stopAt < 0)
          stopAt = end2 - maxBufferLength;
        nodes.push(id2, start, end2);
        nodeCount++;
        cursor2.next();
      }
    }
    if (nodeCount) {
      let buffer2 = new Uint16Array(nodeCount * 4);
      let start = nodes[nodes.length - 2];
      for (let i4 = nodes.length - 3, j4 = 0; i4 >= 0; i4 -= 3) {
        buffer2[j4++] = nodes[i4];
        buffer2[j4++] = nodes[i4 + 1] - start;
        buffer2[j4++] = nodes[i4 + 2] - start;
        buffer2[j4++] = j4;
      }
      children2.push(new TreeBuffer(buffer2, nodes[2] - start, nodeSet));
      positions2.push(start - parentStart);
    }
  }
  function makeBalanced(type, contextHash2) {
    return (children2, positions2, length3) => {
      let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
      if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
        if (!lastI && last.type == type && last.length == length3)
          return last;
        if (lookAheadProp = last.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
      }
      return makeTree(type, children2, positions2, length3, lookAhead2, contextHash2);
    };
  }
  function makeRepeatLeaf(children2, positions2, base, i4, from2, to, type, lookAhead2, contextHash2) {
    let localChildren = [], localPositions = [];
    while (children2.length > i4) {
      localChildren.push(children2.pop());
      localPositions.push(positions2.pop() + base - from2);
    }
    children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from2, lookAhead2 - to, contextHash2));
    positions2.push(from2 - base);
  }
  function makeTree(type, children2, positions2, length3, lookAhead2, contextHash2, props) {
    if (contextHash2) {
      let pair2 = [NodeProp.contextHash, contextHash2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    if (lookAhead2 > 25) {
      let pair2 = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    return new Tree(type, children2, positions2, length3, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor2.fork();
    let size2 = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
      let nodeSize2 = fork.size;
      if (fork.id == inRepeat && nodeSize2 >= 0) {
        result.size = size2;
        result.start = start;
        result.skip = skip;
        skip += 4;
        size2 += 4;
        fork.next();
        continue;
      }
      let startPos = fork.pos - nodeSize2;
      if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
        break;
      let localSkipped = fork.id >= minRepeatType ? 4 : 0;
      let nodeStart2 = fork.start;
      fork.next();
      while (fork.pos > startPos) {
        if (fork.size < 0) {
          if (fork.size == -3)
            localSkipped += 4;
          else
            break scan;
        } else if (fork.id >= minRepeatType) {
          localSkipped += 4;
        }
        fork.next();
      }
      start = nodeStart2;
      size2 += nodeSize2;
      skip += localSkipped;
    }
    if (inRepeat < 0 || size2 == maxSize) {
      result.size = size2;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index2) {
    let { id: id2, start, end: end2, size: size2 } = cursor2;
    cursor2.next();
    if (size2 >= 0 && id2 < minRepeatType) {
      let startIndex = index2;
      if (size2 > 4) {
        let endPos = cursor2.pos - (size2 - 4);
        while (cursor2.pos > endPos)
          index2 = copyToBuffer(bufferStart, buffer2, index2);
      }
      buffer2[--index2] = startIndex;
      buffer2[--index2] = end2 - bufferStart;
      buffer2[--index2] = start - bufferStart;
      buffer2[--index2] = id2;
    } else if (size2 == -3) {
      contextHash = id2;
    } else if (size2 == -4) {
      lookAhead = id2;
    }
    return index2;
  }
  let children = [], positions = [];
  while (cursor2.pos > 0)
    takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
  let length2 = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types[data.topID], children.reverse(), positions.reverse(), length2);
}
var nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node2) {
  if (!balanceType.isAnonymous || node2 instanceof TreeBuffer || node2.type != balanceType)
    return 1;
  let size2 = nodeSizeCache.get(node2);
  if (size2 == null) {
    size2 = 1;
    for (let child of node2.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size2 = 1;
        break;
      }
      size2 += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node2, size2);
  }
  return size2;
}
function balanceRange(balanceType, children, positions, from2, to, start, length2, mkTop, mkTree) {
  let total = 0;
  for (let i4 = from2; i4 < to; i4++)
    total += nodeSize(balanceType, children[i4]);
  let maxChild = Math.ceil(
    total * 1.5 / 8
    /* Balance.BranchFactor */
  );
  let localChildren = [], localPositions = [];
  function divide(children2, positions2, from3, to2, offset3) {
    for (let i4 = from3; i4 < to2; ) {
      let groupFrom = i4, groupStart = positions2[i4], groupSize = nodeSize(balanceType, children2[i4]);
      i4++;
      for (; i4 < to2; i4++) {
        let nextSize = nodeSize(balanceType, children2[i4]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i4 == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset3);
          continue;
        }
        localChildren.push(children2[groupFrom]);
      } else {
        let length3 = positions2[i4 - 1] + children2[i4 - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i4, groupStart, length3, null, mkTree));
      }
      localPositions.push(groupStart + offset3 - start);
    }
  }
  divide(children, positions, from2, to, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length2);
}
var NodeWeakMap = class {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(buffer, index2, value) {
    let inner = this.map.get(buffer);
    if (!inner)
      this.map.set(buffer, inner = /* @__PURE__ */ new Map());
    inner.set(index2, value);
  }
  getBuffer(buffer, index2) {
    let inner = this.map.get(buffer);
    return inner && inner.get(index2);
  }
  /**
  Set the value for this syntax node.
  */
  set(node2, value) {
    if (node2 instanceof BufferNode)
      this.setBuffer(node2.context.buffer, node2.index, value);
    else if (node2 instanceof TreeNode)
      this.map.set(node2.tree, value);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(node2) {
    return node2 instanceof BufferNode ? this.getBuffer(node2.context.buffer, node2.index) : node2 instanceof TreeNode ? this.map.get(node2.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(cursor2, value) {
    if (cursor2.buffer)
      this.setBuffer(cursor2.buffer.buffer, cursor2.index, value);
    else
      this.map.set(cursor2.tree, value);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(cursor2) {
    return cursor2.buffer ? this.getBuffer(cursor2.buffer.buffer, cursor2.index) : this.map.get(cursor2.tree);
  }
};
var Parser = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(input2, fragments, ranges) {
    if (typeof input2 == "string")
      input2 = new StringInput(input2);
    ranges = !ranges ? [new Range(0, input2.length)] : ranges.length ? ranges.map((r4) => new Range(r4.from, r4.to)) : [new Range(0, 0)];
    return this.createParse(input2, fragments || [], ranges);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(input2, fragments, ranges) {
    let parse5 = this.startParse(input2, fragments, ranges);
    for (; ; ) {
      let done = parse5.advance();
      if (done)
        return done;
    }
  }
};
var StringInput = class {
  constructor(string2) {
    this.string = string2;
  }
  get length() {
    return this.string.length;
  }
  chunk(from2) {
    return this.string.slice(from2);
  }
  get lineChunks() {
    return false;
  }
  read(from2, to) {
    return this.string.slice(from2, to);
  }
};
var stoppedInner = new NodeProp({ perNode: true });

// node_modules/@lezer/lr/dist/index.js
var Stack2 = class _Stack {
  /**
  @internal
  */
  constructor(p3, stack, state2, reducePos, pos, score2, buffer, bufferBase, curContext, lookAhead = 0, parent) {
    this.p = p3;
    this.stack = stack;
    this.state = state2;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score2;
    this.buffer = buffer;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.lookAhead = lookAhead;
    this.parent = parent;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((_3, i4) => i4 % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(p3, state2, pos = 0) {
    let cx = p3.parser.context;
    return new _Stack(p3, [], state2, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(state2, start) {
    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
    this.state = state2;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(action) {
    var _a;
    let depth = action >> 19, type = action & 65535;
    let { parser: parser2 } = this.p;
    let lookaheadRecord = this.reducePos < this.pos - 25;
    if (lookaheadRecord)
      this.setLookAhead(this.pos);
    let dPrec = parser2.dynamicPrecedence(type);
    if (dPrec)
      this.score += dPrec;
    if (depth == 0) {
      this.pushState(parser2.getGoto(this.state, type, true), this.reducePos);
      if (type < parser2.minRepeatTerm)
        this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);
      this.reduceContext(type, this.reducePos);
      return;
    }
    let base = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
    let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size2 = this.reducePos - start;
    if (size2 >= 2e3 && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {
      if (start == this.p.lastBigReductionStart) {
        this.p.bigReductionCount++;
        this.p.lastBigReductionSize = size2;
      } else if (this.p.lastBigReductionSize < size2) {
        this.p.bigReductionCount = 1;
        this.p.lastBigReductionStart = start;
        this.p.lastBigReductionSize = size2;
      }
    }
    let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;
    if (type < parser2.minRepeatTerm || action & 131072) {
      let pos = parser2.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(type, start, pos, count + 4, true);
    }
    if (action & 262144) {
      this.state = this.stack[base];
    } else {
      let baseStateID = this.stack[base - 3];
      this.state = parser2.getGoto(baseStateID, type, true);
    }
    while (this.stack.length > base)
      this.stack.pop();
    this.reduceContext(type, start);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(term, start, end2, size2 = 4, mustSink = false) {
    if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let cur2 = this, top = this.buffer.length;
      if (top == 0 && cur2.parent) {
        top = cur2.bufferBase - cur2.parent.bufferBase;
        cur2 = cur2.parent;
      }
      if (top > 0 && cur2.buffer[top - 4] == 0 && cur2.buffer[top - 1] > -1) {
        if (start == end2)
          return;
        if (cur2.buffer[top - 2] >= start) {
          cur2.buffer[top - 2] = end2;
          return;
        }
      }
    }
    if (!mustSink || this.pos == end2) {
      this.buffer.push(term, start, end2, size2);
    } else {
      let index2 = this.buffer.length;
      if (index2 > 0 && this.buffer[index2 - 4] != 0) {
        let mustMove = false;
        for (let scan = index2; scan > 0 && this.buffer[scan - 2] > end2; scan -= 4) {
          if (this.buffer[scan - 1] >= 0) {
            mustMove = true;
            break;
          }
        }
        if (mustMove)
          while (index2 > 0 && this.buffer[index2 - 2] > end2) {
            this.buffer[index2] = this.buffer[index2 - 4];
            this.buffer[index2 + 1] = this.buffer[index2 - 3];
            this.buffer[index2 + 2] = this.buffer[index2 - 2];
            this.buffer[index2 + 3] = this.buffer[index2 - 1];
            index2 -= 4;
            if (size2 > 4)
              size2 -= 4;
          }
      }
      this.buffer[index2] = term;
      this.buffer[index2 + 1] = start;
      this.buffer[index2 + 2] = end2;
      this.buffer[index2 + 3] = size2;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(action, type, start, end2) {
    if (action & 131072) {
      this.pushState(action & 65535, this.pos);
    } else if ((action & 262144) == 0) {
      let nextState = action, { parser: parser2 } = this.p;
      if (end2 > this.pos || type <= parser2.maxNode) {
        this.pos = end2;
        if (!parser2.stateFlag(
          nextState,
          1
          /* StateFlag.Skipped */
        ))
          this.reducePos = end2;
      }
      this.pushState(nextState, start);
      this.shiftContext(type, start);
      if (type <= parser2.maxNode)
        this.buffer.push(type, start, end2, 4);
    } else {
      this.pos = end2;
      this.shiftContext(type, start);
      if (type <= this.p.parser.maxNode)
        this.buffer.push(type, start, end2, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(action, next3, nextStart, nextEnd) {
    if (action & 65536)
      this.reduce(action);
    else
      this.shift(action, next3, nextStart, nextEnd);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(value, next3) {
    let index2 = this.p.reused.length - 1;
    if (index2 < 0 || this.p.reused[index2] != value) {
      this.p.reused.push(value);
      index2++;
    }
    let start = this.pos;
    this.reducePos = this.pos = start + value.length;
    this.pushState(next3, start);
    this.buffer.push(
      index2,
      start,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    );
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let parent = this;
    let off2 = parent.buffer.length;
    while (off2 > 0 && parent.buffer[off2 - 2] > parent.reducePos)
      off2 -= 4;
    let buffer = parent.buffer.slice(off2), base = parent.bufferBase + off2;
    while (parent && base == parent.bufferBase)
      parent = parent.parent;
    return new _Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(next3, nextEnd) {
    let isNode2 = next3 <= this.p.parser.maxNode;
    if (isNode2)
      this.storeNode(next3, this.pos, nextEnd, 4);
    this.storeNode(0, this.pos, nextEnd, isNode2 ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(term) {
    for (let sim = new SimulatedStack(this); ; ) {
      let action = this.p.parser.stateSlot(
        sim.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(sim.state, term);
      if (action == 0)
        return false;
      if ((action & 65536) == 0)
        return true;
      sim.reduce(action);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(next3) {
    if (this.stack.length >= 300)
      return [];
    let nextStates = this.p.parser.nextStates(this.state);
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = [];
      for (let i4 = 0, s4; i4 < nextStates.length; i4 += 2) {
        if ((s4 = nextStates[i4 + 1]) != this.state && this.p.parser.hasAction(s4, next3))
          best.push(nextStates[i4], s4);
      }
      if (this.stack.length < 120)
        for (let i4 = 0; best.length < 4 << 1 && i4 < nextStates.length; i4 += 2) {
          let s4 = nextStates[i4 + 1];
          if (!best.some((v3, i5) => i5 & 1 && v3 == s4))
            best.push(nextStates[i4], s4);
        }
      nextStates = best;
    }
    let result = [];
    for (let i4 = 0; i4 < nextStates.length && result.length < 4; i4 += 2) {
      let s4 = nextStates[i4 + 1];
      if (s4 == this.state)
        continue;
      let stack = this.split();
      stack.pushState(s4, this.pos);
      stack.storeNode(0, stack.pos, stack.pos, 4, true);
      stack.shiftContext(nextStates[i4], this.pos);
      stack.reducePos = this.pos;
      stack.score -= 200;
      result.push(stack);
    }
    return result;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: parser2 } = this.p;
    let reduce2 = parser2.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((reduce2 & 65536) == 0)
      return false;
    if (!parser2.validAction(this.state, reduce2)) {
      let depth = reduce2 >> 19, term = reduce2 & 65535;
      let target = this.stack.length - depth * 3;
      if (target < 0 || parser2.getGoto(this.stack[target], term, false) < 0) {
        let backup = this.findForcedReduction();
        if (backup == null)
          return false;
        reduce2 = backup;
      }
      this.storeNode(0, this.pos, this.pos, 4, true);
      this.score -= 100;
    }
    this.reducePos = this.pos;
    this.reduce(reduce2);
    return true;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: parser2 } = this.p, seen = [];
    let explore = (state2, depth) => {
      if (seen.includes(state2))
        return;
      seen.push(state2);
      return parser2.allActions(state2, (action) => {
        if (action & (262144 | 131072)) ;
        else if (action & 65536) {
          let rDepth = (action >> 19) - depth;
          if (rDepth > 1) {
            let term = action & 65535, target = this.stack.length - rDepth * 3;
            if (target >= 0 && parser2.getGoto(this.stack[target], term, false) >= 0)
              return rDepth << 19 | 65536 | term;
          }
        } else {
          let found = explore(action, depth + 1);
          if (found != null)
            return found;
        }
      });
    };
    return explore(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    while (!this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    )) {
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: parser2 } = this.p;
    return parser2.data[parser2.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !parser2.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, true);
    this.state = this.stack[0];
    this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length)
      return false;
    for (let i4 = 0; i4 < this.stack.length; i4 += 3)
      if (this.stack[i4] != other.stack[i4])
        return false;
    return true;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }
  shiftContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  reduceContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  /**
  @internal
  */
  emitContext() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -3)
      this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -4)
      this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash)
        this.emitContext();
      this.curContext = newCx;
    }
  }
  /**
  @internal
  */
  setLookAhead(lookAhead) {
    if (lookAhead > this.lookAhead) {
      this.emitLookAhead();
      this.lookAhead = lookAhead;
    }
  }
  /**
  @internal
  */
  close() {
    if (this.curContext && this.curContext.tracker.strict)
      this.emitContext();
    if (this.lookAhead > 0)
      this.emitLookAhead();
  }
};
var StackContext = class {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.strict ? tracker.hash(context) : 0;
  }
};
var SimulatedStack = class {
  constructor(start) {
    this.start = start;
    this.state = start.state;
    this.stack = start.stack;
    this.base = this.stack.length;
  }
  reduce(action) {
    let term = action & 65535, depth = action >> 19;
    if (depth == 0) {
      if (this.stack == this.start.stack)
        this.stack = this.stack.slice();
      this.stack.push(this.state, 0, 0);
      this.base += 3;
    } else {
      this.base -= (depth - 1) * 3;
    }
    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
    this.state = goto;
  }
};
var StackBufferCursor = class _StackBufferCursor {
  constructor(stack, pos, index2) {
    this.stack = stack;
    this.pos = pos;
    this.index = index2;
    this.buffer = stack.buffer;
    if (this.index == 0)
      this.maybeNext();
  }
  static create(stack, pos = stack.bufferBase + stack.buffer.length) {
    return new _StackBufferCursor(stack, pos, pos - stack.bufferBase);
  }
  maybeNext() {
    let next3 = this.stack.parent;
    if (next3 != null) {
      this.index = this.stack.bufferBase - next3.bufferBase;
      this.stack = next3;
      this.buffer = next3.buffer;
    }
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0)
      this.maybeNext();
  }
  fork() {
    return new _StackBufferCursor(this.stack, this.pos, this.index);
  }
};
function decodeArray(input2, Type = Uint16Array) {
  if (typeof input2 != "string")
    return input2;
  let array2 = null;
  for (let pos = 0, out = 0; pos < input2.length; ) {
    let value = 0;
    for (; ; ) {
      let next3 = input2.charCodeAt(pos++), stop = false;
      if (next3 == 126) {
        value = 65535;
        break;
      }
      if (next3 >= 92)
        next3--;
      if (next3 >= 34)
        next3--;
      let digit = next3 - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop)
        break;
      value *= 46;
    }
    if (array2)
      array2[out++] = value;
    else
      array2 = new Type(value);
  }
  return array2;
}
var CachedToken = class {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
    this.extended = -1;
    this.lookAhead = 0;
    this.mask = 0;
    this.context = 0;
  }
};
var nullToken = new CachedToken();
var InputStream = class {
  /**
  @internal
  */
  constructor(input2, ranges) {
    this.input = input2;
    this.ranges = ranges;
    this.chunk = "";
    this.chunkOff = 0;
    this.chunk2 = "";
    this.chunk2Pos = 0;
    this.next = -1;
    this.token = nullToken;
    this.rangeIndex = 0;
    this.pos = this.chunkPos = ranges[0].from;
    this.range = ranges[0];
    this.end = ranges[ranges.length - 1].to;
    this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(offset3, assoc) {
    let range = this.range, index2 = this.rangeIndex;
    let pos = this.pos + offset3;
    while (pos < range.from) {
      if (!index2)
        return null;
      let next3 = this.ranges[--index2];
      pos -= range.from - next3.to;
      range = next3;
    }
    while (assoc < 0 ? pos > range.to : pos >= range.to) {
      if (index2 == this.ranges.length - 1)
        return null;
      let next3 = this.ranges[++index2];
      pos += next3.from - range.to;
      range = next3;
    }
    return pos;
  }
  /**
  @internal
  */
  clipPos(pos) {
    if (pos >= this.range.from && pos < this.range.to)
      return pos;
    for (let range of this.ranges)
      if (range.to > pos)
        return Math.max(pos, range.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(offset3) {
    let idx = this.chunkOff + offset3, pos, result;
    if (idx >= 0 && idx < this.chunk.length) {
      pos = this.pos + offset3;
      result = this.chunk.charCodeAt(idx);
    } else {
      let resolved = this.resolveOffset(offset3, 1);
      if (resolved == null)
        return -1;
      pos = resolved;
      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
        result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
      } else {
        let i4 = this.rangeIndex, range = this.range;
        while (range.to <= pos)
          range = this.ranges[++i4];
        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
        if (pos + this.chunk2.length > range.to)
          this.chunk2 = this.chunk2.slice(0, range.to - pos);
        result = this.chunk2.charCodeAt(0);
      }
    }
    if (pos >= this.token.lookAhead)
      this.token.lookAhead = pos + 1;
    return result;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(token2, endOffset = 0) {
    let end2 = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
    if (end2 == null || end2 < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = token2;
    this.token.end = end2;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(token2, endPos) {
    this.token.value = token2;
    this.token.end = endPos;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk, chunkPos } = this;
      this.chunk = this.chunk2;
      this.chunkPos = this.chunk2Pos;
      this.chunk2 = chunk;
      this.chunk2Pos = chunkPos;
      this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk;
      this.chunk2Pos = this.chunkPos;
      let nextChunk = this.input.chunk(this.pos);
      let end2 = this.pos + nextChunk.length;
      this.chunk = end2 > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
      this.chunkPos = this.pos;
      this.chunkOff = 0;
    }
  }
  readNext() {
    if (this.chunkOff >= this.chunk.length) {
      this.getChunk();
      if (this.chunkOff == this.chunk.length)
        return this.next = -1;
    }
    return this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(n3 = 1) {
    this.chunkOff += n3;
    while (this.pos + n3 >= this.range.to) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      n3 -= this.range.to - this.pos;
      this.range = this.ranges[++this.rangeIndex];
      this.pos = this.range.from;
    }
    this.pos += n3;
    if (this.pos >= this.token.lookAhead)
      this.token.lookAhead = this.pos + 1;
    return this.readNext();
  }
  setDone() {
    this.pos = this.chunkPos = this.end;
    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
    this.chunk = "";
    return this.next = -1;
  }
  /**
  @internal
  */
  reset(pos, token2) {
    if (token2) {
      this.token = token2;
      token2.start = pos;
      token2.lookAhead = pos + 1;
      token2.value = token2.extended = -1;
    } else {
      this.token = nullToken;
    }
    if (this.pos != pos) {
      this.pos = pos;
      if (pos == this.end) {
        this.setDone();
        return this;
      }
      while (pos < this.range.from)
        this.range = this.ranges[--this.rangeIndex];
      while (pos >= this.range.to)
        this.range = this.ranges[++this.rangeIndex];
      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
        this.chunkOff = pos - this.chunkPos;
      } else {
        this.chunk = "";
        this.chunkOff = 0;
      }
      this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(from2, to) {
    if (from2 >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(from2 - this.chunkPos, to - this.chunkPos);
    if (from2 >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(from2 - this.chunk2Pos, to - this.chunk2Pos);
    if (from2 >= this.range.from && to <= this.range.to)
      return this.input.read(from2, to);
    let result = "";
    for (let r4 of this.ranges) {
      if (r4.from >= to)
        break;
      if (r4.to > from2)
        result += this.input.read(Math.max(r4.from, from2), Math.min(r4.to, to));
    }
    return result;
  }
};
var TokenGroup = class {
  constructor(data, id2) {
    this.data = data;
    this.id = id2;
  }
  token(input2, stack) {
    let { parser: parser2 } = stack.p;
    readToken2(this.data, input2, stack, this.id, parser2.data, parser2.tokenPrecTable);
  }
};
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var LocalTokenGroup = class {
  constructor(data, precTable, elseToken) {
    this.precTable = precTable;
    this.elseToken = elseToken;
    this.data = typeof data == "string" ? decodeArray(data) : data;
  }
  token(input2, stack) {
    let start = input2.pos, skipped = 0;
    for (; ; ) {
      let atEof = input2.next < 0, nextPos = input2.resolveOffset(1, 1);
      readToken2(this.data, input2, stack, 0, this.data, this.precTable);
      if (input2.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (!atEof)
        skipped++;
      if (nextPos == null)
        break;
      input2.reset(nextPos, input2.token);
    }
    if (skipped) {
      input2.reset(start, input2.token);
      input2.acceptToken(this.elseToken, skipped);
    }
  }
};
LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var ExternalTokenizer = class {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(token2, options2 = {}) {
    this.token = token2;
    this.contextual = !!options2.contextual;
    this.fallback = !!options2.fallback;
    this.extend = !!options2.extend;
  }
};
function readToken2(data, input2, stack, group, precTable, precOffset) {
  let state2 = 0, groupMask = 1 << group, { dialect } = stack.p.parser;
  scan: for (; ; ) {
    if ((groupMask & data[state2]) == 0)
      break;
    let accEnd = data[state2 + 1];
    for (let i4 = state2 + 3; i4 < accEnd; i4 += 2)
      if ((data[i4 + 1] & groupMask) > 0) {
        let term = data[i4];
        if (dialect.allows(term) && (input2.token.value == -1 || input2.token.value == term || overrides(term, input2.token.value, precTable, precOffset))) {
          input2.acceptToken(term);
          break;
        }
      }
    let next3 = input2.next, low = 0, high = data[state2 + 2];
    if (input2.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535) {
      state2 = data[accEnd + high * 3 - 1];
      continue scan;
    }
    for (; low < high; ) {
      let mid = low + high >> 1;
      let index2 = accEnd + mid + (mid << 1);
      let from2 = data[index2], to = data[index2 + 1] || 65536;
      if (next3 < from2)
        high = mid;
      else if (next3 >= to)
        low = mid + 1;
      else {
        state2 = data[index2 + 2];
        input2.advance();
        continue scan;
      }
    }
    break;
  }
}
function findOffset(data, start, term) {
  for (let i4 = start, next3; (next3 = data[i4]) != 65535; i4++)
    if (next3 == term)
      return i4 - start;
  return -1;
}
function overrides(token2, prev2, tableData, tableOffset) {
  let iPrev = findOffset(tableData, tableOffset, prev2);
  return iPrev < 0 || findOffset(tableData, tableOffset, token2) < iPrev;
}
var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
var stackIDs = null;
function cutAt(tree, pos, side) {
  let cursor2 = tree.cursor(IterMode.IncludeAnonymous);
  cursor2.moveTo(pos);
  for (; ; ) {
    if (!(side < 0 ? cursor2.childBefore(pos) : cursor2.childAfter(pos)))
      for (; ; ) {
        if ((side < 0 ? cursor2.to < pos : cursor2.from > pos) && !cursor2.type.isError)
          return side < 0 ? Math.max(0, Math.min(
            cursor2.to - 1,
            pos - 25
            /* Lookahead.Margin */
          )) : Math.min(tree.length, Math.max(
            cursor2.from + 1,
            pos + 25
            /* Lookahead.Margin */
          ));
        if (side < 0 ? cursor2.prevSibling() : cursor2.nextSibling())
          break;
        if (!cursor2.parent())
          return side < 0 ? 0 : tree.length;
      }
  }
}
var FragmentCursor = class {
  constructor(fragments, nodeSet) {
    this.fragments = fragments;
    this.nodeSet = nodeSet;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }
  nextFragment() {
    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (fr) {
      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }
      this.trees.push(fr.tree);
      this.start.push(-fr.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(pos) {
    if (pos < this.nextStart)
      return null;
    while (this.fragment && this.safeTo <= pos)
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let last = this.trees.length - 1;
      if (last < 0) {
        this.nextFragment();
        return null;
      }
      let top = this.trees[last], index2 = this.index[last];
      if (index2 == top.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }
      let next3 = top.children[index2];
      let start = this.start[last] + top.positions[index2];
      if (start > pos) {
        this.nextStart = start;
        return null;
      }
      if (next3 instanceof Tree) {
        if (start == pos) {
          if (start < this.safeFrom)
            return null;
          let end2 = start + next3.length;
          if (end2 <= this.safeTo) {
            let lookAhead = next3.prop(NodeProp.lookAhead);
            if (!lookAhead || end2 + lookAhead < this.fragment.to)
              return next3;
          }
        }
        this.index[last]++;
        if (start + next3.length >= Math.max(this.safeFrom, pos)) {
          this.trees.push(next3);
          this.start.push(start);
          this.index.push(0);
        }
      } else {
        this.index[last]++;
        this.nextStart = start + next3.length;
      }
    }
  }
};
var TokenCache = class {
  constructor(parser2, stream) {
    this.stream = stream;
    this.tokens = [];
    this.mainToken = null;
    this.actions = [];
    this.tokens = parser2.tokenizers.map((_3) => new CachedToken());
  }
  getActions(stack) {
    let actionIndex = 0;
    let main = null;
    let { parser: parser2 } = stack.p, { tokenizers } = parser2;
    let mask = parser2.stateSlot(
      stack.state,
      3
      /* ParseState.TokenizerMask */
    );
    let context = stack.curContext ? stack.curContext.hash : 0;
    let lookAhead = 0;
    for (let i4 = 0; i4 < tokenizers.length; i4++) {
      if ((1 << i4 & mask) == 0)
        continue;
      let tokenizer = tokenizers[i4], token2 = this.tokens[i4];
      if (main && !tokenizer.fallback)
        continue;
      if (tokenizer.contextual || token2.start != stack.pos || token2.mask != mask || token2.context != context) {
        this.updateCachedToken(token2, tokenizer, stack);
        token2.mask = mask;
        token2.context = context;
      }
      if (token2.lookAhead > token2.end + 25)
        lookAhead = Math.max(token2.lookAhead, lookAhead);
      if (token2.value != 0) {
        let startIndex = actionIndex;
        if (token2.extended > -1)
          actionIndex = this.addActions(stack, token2.extended, token2.end, actionIndex);
        actionIndex = this.addActions(stack, token2.value, token2.end, actionIndex);
        if (!tokenizer.extend) {
          main = token2;
          if (actionIndex > startIndex)
            break;
        }
      }
    }
    while (this.actions.length > actionIndex)
      this.actions.pop();
    if (lookAhead)
      stack.setLookAhead(lookAhead);
    if (!main && stack.pos == this.stream.end) {
      main = new CachedToken();
      main.value = stack.p.parser.eofTerm;
      main.start = main.end = stack.pos;
      actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
    }
    this.mainToken = main;
    return this.actions;
  }
  getMainToken(stack) {
    if (this.mainToken)
      return this.mainToken;
    let main = new CachedToken(), { pos, p: p3 } = stack;
    main.start = pos;
    main.end = Math.min(pos + 1, p3.stream.end);
    main.value = pos == p3.stream.end ? p3.parser.eofTerm : 0;
    return main;
  }
  updateCachedToken(token2, tokenizer, stack) {
    let start = this.stream.clipPos(stack.pos);
    tokenizer.token(this.stream.reset(start, token2), stack);
    if (token2.value > -1) {
      let { parser: parser2 } = stack.p;
      for (let i4 = 0; i4 < parser2.specialized.length; i4++)
        if (parser2.specialized[i4] == token2.value) {
          let result = parser2.specializers[i4](this.stream.read(token2.start, token2.end), stack);
          if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
            if ((result & 1) == 0)
              token2.value = result >> 1;
            else
              token2.extended = result >> 1;
            break;
          }
        }
    } else {
      token2.value = 0;
      token2.end = this.stream.clipPos(start + 1);
    }
  }
  putAction(action, token2, end2, index2) {
    for (let i4 = 0; i4 < index2; i4 += 3)
      if (this.actions[i4] == action)
        return index2;
    this.actions[index2++] = action;
    this.actions[index2++] = token2;
    this.actions[index2++] = end2;
    return index2;
  }
  addActions(stack, token2, end2, index2) {
    let { state: state2 } = stack, { parser: parser2 } = stack.p, { data } = parser2;
    for (let set = 0; set < 2; set++) {
      for (let i4 = parser2.stateSlot(
        state2,
        set ? 2 : 1
        /* ParseState.Actions */
      ); ; i4 += 3) {
        if (data[i4] == 65535) {
          if (data[i4 + 1] == 1) {
            i4 = pair(data, i4 + 2);
          } else {
            if (index2 == 0 && data[i4 + 1] == 2)
              index2 = this.putAction(pair(data, i4 + 2), token2, end2, index2);
            break;
          }
        }
        if (data[i4] == token2)
          index2 = this.putAction(pair(data, i4 + 1), token2, end2, index2);
      }
    }
    return index2;
  }
};
var Parse = class {
  constructor(parser2, input2, fragments, ranges) {
    this.parser = parser2;
    this.input = input2;
    this.ranges = ranges;
    this.recovering = 0;
    this.nextStackID = 9812;
    this.minStackPos = 0;
    this.reused = [];
    this.stoppedAt = null;
    this.lastBigReductionStart = -1;
    this.lastBigReductionSize = 0;
    this.bigReductionCount = 0;
    this.stream = new InputStream(input2, ranges);
    this.tokens = new TokenCache(parser2, this.stream);
    this.topTerm = parser2.top[1];
    let { from: from2 } = ranges[0];
    this.stacks = [Stack2.start(this, parser2.top[0], from2)];
    this.fragments = fragments.length && this.stream.end - from2 > parser2.bufferLength * 4 ? new FragmentCursor(fragments, parser2.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let stacks = this.stacks, pos = this.minStackPos;
    let newStacks = this.stacks = [];
    let stopped, stoppedTokens;
    if (this.bigReductionCount > 300 && stacks.length == 1) {
      let [s4] = stacks;
      while (s4.forceReduce() && s4.stack.length && s4.stack[s4.stack.length - 2] >= this.lastBigReductionStart) {
      }
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let i4 = 0; i4 < stacks.length; i4++) {
      let stack = stacks[i4];
      for (; ; ) {
        this.tokens.mainToken = null;
        if (stack.pos > pos) {
          newStacks.push(stack);
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }
          stopped.push(stack);
          let tok = this.tokens.getMainToken(stack);
          stoppedTokens.push(tok.value, tok.end);
        }
        break;
      }
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished) {
        if (verbose)
          console.log("Finish with " + this.stackID(finished));
        return this.stackToTree(finished);
      }
      if (this.parser.strict) {
        if (verbose && stopped)
          console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
        throw new SyntaxError("No parse at " + pos);
      }
      if (!this.recovering)
        this.recovering = 5;
    }
    if (this.recovering && stopped) {
      let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished) {
        if (verbose)
          console.log("Force-finish " + this.stackID(finished));
        return this.stackToTree(finished.forceAll());
      }
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a4, b3) => b3.score - a4.score);
        while (newStacks.length > maxRemaining)
          newStacks.pop();
      }
      if (newStacks.some((s4) => s4.reducePos > pos))
        this.recovering--;
    } else if (newStacks.length > 1) {
      outer: for (let i4 = 0; i4 < newStacks.length - 1; i4++) {
        let stack = newStacks[i4];
        for (let j4 = i4 + 1; j4 < newStacks.length; j4++) {
          let other = newStacks[j4];
          if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
            if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
              newStacks.splice(j4--, 1);
            } else {
              newStacks.splice(i4--, 1);
              continue outer;
            }
          }
        }
      }
      if (newStacks.length > 12)
        newStacks.splice(
          12,
          newStacks.length - 12
          /* Rec.MaxStackCount */
        );
    }
    this.minStackPos = newStacks[0].pos;
    for (let i4 = 1; i4 < newStacks.length; i4++)
      if (newStacks[i4].pos < this.minStackPos)
        this.minStackPos = newStacks[i4].pos;
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(stack, stacks, split) {
    let start = stack.pos, { parser: parser2 } = this;
    let base = verbose ? this.stackID(stack) + " -> " : "";
    if (this.stoppedAt != null && start > this.stoppedAt)
      return stack.forceReduce() ? stack : null;
    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
      for (let cached = this.fragments.nodeAt(start); cached; ) {
        let match4 = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack.state, cached.type.id) : -1;
        if (match4 > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
          stack.useNode(cached, match4);
          if (verbose)
            console.log(base + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached.type.id)})`);
          return true;
        }
        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
          break;
        let inner = cached.children[0];
        if (inner instanceof Tree && cached.positions[0] == 0)
          cached = inner;
        else
          break;
      }
    }
    let defaultReduce = parser2.stateSlot(
      stack.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (defaultReduce > 0) {
      stack.reduce(defaultReduce);
      if (verbose)
        console.log(base + this.stackID(stack) + ` (via always-reduce ${parser2.getName(
          defaultReduce & 65535
          /* Action.ValueMask */
        )})`);
      return true;
    }
    if (stack.stack.length >= 8400) {
      while (stack.stack.length > 6e3 && stack.forceReduce()) {
      }
    }
    let actions = this.tokens.getActions(stack);
    for (let i4 = 0; i4 < actions.length; ) {
      let action = actions[i4++], term = actions[i4++], end2 = actions[i4++];
      let last = i4 == actions.length || !split;
      let localStack = last ? stack : stack.split();
      let main = this.tokens.mainToken;
      localStack.apply(action, term, main ? main.start : localStack.pos, end2);
      if (verbose)
        console.log(base + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(
          action & 65535
          /* Action.ValueMask */
        )}`} for ${parser2.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
      if (last)
        return true;
      else if (localStack.pos > start)
        stacks.push(localStack);
      else
        split.push(localStack);
    }
    return false;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(stack, newStacks) {
    let pos = stack.pos;
    for (; ; ) {
      if (!this.advanceStack(stack, null, null))
        return false;
      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks);
        return true;
      }
    }
  }
  runRecovery(stacks, tokens, newStacks) {
    let finished = null, restarted = false;
    for (let i4 = 0; i4 < stacks.length; i4++) {
      let stack = stacks[i4], token2 = tokens[i4 << 1], tokenEnd = tokens[(i4 << 1) + 1];
      let base = verbose ? this.stackID(stack) + " -> " : "";
      if (stack.deadEnd) {
        if (restarted)
          continue;
        restarted = true;
        stack.restart();
        if (verbose)
          console.log(base + this.stackID(stack) + " (restarted)");
        let done = this.advanceFully(stack, newStacks);
        if (done)
          continue;
      }
      let force = stack.split(), forceBase = base;
      for (let j4 = 0; force.forceReduce() && j4 < 10; j4++) {
        if (verbose)
          console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done = this.advanceFully(force, newStacks);
        if (done)
          break;
        if (verbose)
          forceBase = this.stackID(force) + " -> ";
      }
      for (let insert of stack.recoverByInsert(token2)) {
        if (verbose)
          console.log(base + this.stackID(insert) + " (via recover-insert)");
        this.advanceFully(insert, newStacks);
      }
      if (this.stream.end > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++;
          token2 = 0;
        }
        stack.recoverByDelete(token2, tokenEnd);
        if (verbose)
          console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token2)})`);
        pushStackDedup(stack, newStacks);
      } else if (!finished || finished.score < stack.score) {
        finished = stack;
      }
    }
    return finished;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(stack) {
    stack.close();
    return Tree.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: stack.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(stack) {
    let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
    if (!id2)
      stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
    return id2 + stack;
  }
};
function pushStackDedup(stack, newStacks) {
  for (let i4 = 0; i4 < newStacks.length; i4++) {
    let other = newStacks[i4];
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i4].score < stack.score)
        newStacks[i4] = stack;
      return;
    }
  }
  newStacks.push(stack);
}
var Dialect = class {
  constructor(source, flags, disabled2) {
    this.source = source;
    this.flags = flags;
    this.disabled = disabled2;
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }
};
var id = (x4) => x4;
var ContextTracker = class {
  /**
  Define a context tracker.
  */
  constructor(spec) {
    this.start = spec.start;
    this.shift = spec.shift || id;
    this.reduce = spec.reduce || id;
    this.reuse = spec.reuse || id;
    this.hash = spec.hash || (() => 0);
    this.strict = spec.strict !== false;
  }
};
var LRParser = class _LRParser extends Parser {
  /**
  @internal
  */
  constructor(spec) {
    super();
    this.wrappers = [];
    if (spec.version != 14)
      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;
    for (let i4 = 0; i4 < spec.repeatNodeCount; i4++)
      nodeNames.push("");
    let topTerms = Object.keys(spec.topRules).map((r4) => spec.topRules[r4][1]);
    let nodeProps = [];
    for (let i4 = 0; i4 < nodeNames.length; i4++)
      nodeProps.push([]);
    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
    }
    if (spec.nodeProps)
      for (let propSpec of spec.nodeProps) {
        let prop = propSpec[0];
        if (typeof prop == "string")
          prop = NodeProp[prop];
        for (let i4 = 1; i4 < propSpec.length; ) {
          let next3 = propSpec[i4++];
          if (next3 >= 0) {
            setProp(next3, prop, propSpec[i4++]);
          } else {
            let value = propSpec[i4 + -next3];
            for (let j4 = -next3; j4 > 0; j4--)
              setProp(propSpec[i4++], prop, value);
            i4++;
          }
        }
      }
    this.nodeSet = new NodeSet(nodeNames.map((name, i4) => NodeType.define({
      name: i4 >= this.minRepeatTerm ? void 0 : name,
      id: i4,
      props: nodeProps[i4],
      top: topTerms.indexOf(i4) > -1,
      error: i4 == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i4) > -1
    })));
    if (spec.propSources)
      this.nodeSet = this.nodeSet.extend(...spec.propSources);
    this.strict = false;
    this.bufferLength = DefaultBufferLength;
    let tokenArray = decodeArray(spec.tokenData);
    this.context = spec.context;
    this.specializerSpecs = spec.specialized || [];
    this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let i4 = 0; i4 < this.specializerSpecs.length; i4++)
      this.specialized[i4] = this.specializerSpecs[i4].term;
    this.specializers = this.specializerSpecs.map(getSpecializer);
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(input2, fragments, ranges) {
    let parse5 = new Parse(this, input2, fragments, ranges);
    for (let w5 of this.wrappers)
      parse5 = w5(parse5, input2, fragments, ranges);
    return parse5;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(state2, term, loose = false) {
    let table = this.goto;
    if (term >= table[0])
      return -1;
    for (let pos = table[term + 1]; ; ) {
      let groupTag = table[pos++], last = groupTag & 1;
      let target = table[pos++];
      if (last && loose)
        return target;
      for (let end2 = pos + (groupTag >> 1); pos < end2; pos++)
        if (table[pos] == state2)
          return target;
      if (last)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(state2, terminal) {
    let data = this.data;
    for (let set = 0; set < 2; set++) {
      for (let i4 = this.stateSlot(
        state2,
        set ? 2 : 1
        /* ParseState.Actions */
      ), next3; ; i4 += 3) {
        if ((next3 = data[i4]) == 65535) {
          if (data[i4 + 1] == 1)
            next3 = data[i4 = pair(data, i4 + 2)];
          else if (data[i4 + 1] == 2)
            return pair(data, i4 + 2);
          else
            break;
        }
        if (next3 == terminal || next3 == 0)
          return pair(data, i4 + 1);
      }
    }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(state2, slot) {
    return this.states[state2 * 6 + slot];
  }
  /**
  @internal
  */
  stateFlag(state2, flag) {
    return (this.stateSlot(
      state2,
      0
      /* ParseState.Flags */
    ) & flag) > 0;
  }
  /**
  @internal
  */
  validAction(state2, action) {
    return !!this.allActions(state2, (a4) => a4 == action ? true : null);
  }
  /**
  @internal
  */
  allActions(state2, action) {
    let deflt = this.stateSlot(
      state2,
      4
      /* ParseState.DefaultReduce */
    );
    let result = deflt ? action(deflt) : void 0;
    for (let i4 = this.stateSlot(
      state2,
      1
      /* ParseState.Actions */
    ); result == null; i4 += 3) {
      if (this.data[i4] == 65535) {
        if (this.data[i4 + 1] == 1)
          i4 = pair(this.data, i4 + 2);
        else
          break;
      }
      result = action(pair(this.data, i4 + 1));
    }
    return result;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(state2) {
    let result = [];
    for (let i4 = this.stateSlot(
      state2,
      1
      /* ParseState.Actions */
    ); ; i4 += 3) {
      if (this.data[i4] == 65535) {
        if (this.data[i4 + 1] == 1)
          i4 = pair(this.data, i4 + 2);
        else
          break;
      }
      if ((this.data[i4 + 2] & 65536 >> 16) == 0) {
        let value = this.data[i4 + 1];
        if (!result.some((v3, i5) => i5 & 1 && v3 == value))
          result.push(this.data[i4], value);
      }
    }
    return result;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(config3) {
    let copy2 = Object.assign(Object.create(_LRParser.prototype), this);
    if (config3.props)
      copy2.nodeSet = this.nodeSet.extend(...config3.props);
    if (config3.top) {
      let info = this.topRules[config3.top];
      if (!info)
        throw new RangeError(`Invalid top rule name ${config3.top}`);
      copy2.top = info;
    }
    if (config3.tokenizers)
      copy2.tokenizers = this.tokenizers.map((t5) => {
        let found = config3.tokenizers.find((r4) => r4.from == t5);
        return found ? found.to : t5;
      });
    if (config3.specializers) {
      copy2.specializers = this.specializers.slice();
      copy2.specializerSpecs = this.specializerSpecs.map((s4, i4) => {
        let found = config3.specializers.find((r4) => r4.from == s4.external);
        if (!found)
          return s4;
        let spec = Object.assign(Object.assign({}, s4), { external: found.to });
        copy2.specializers[i4] = getSpecializer(spec);
        return spec;
      });
    }
    if (config3.contextTracker)
      copy2.context = config3.contextTracker;
    if (config3.dialect)
      copy2.dialect = this.parseDialect(config3.dialect);
    if (config3.strict != null)
      copy2.strict = config3.strict;
    if (config3.wrap)
      copy2.wrappers = copy2.wrappers.concat(config3.wrap);
    if (config3.bufferLength != null)
      copy2.bufferLength = config3.bufferLength;
    return copy2;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(term) {
    let prec = this.dynamicPrecedences;
    return prec == null ? 0 : prec[term] || 0;
  }
  /**
  @internal
  */
  parseDialect(dialect) {
    let values = Object.keys(this.dialects), flags = values.map(() => false);
    if (dialect)
      for (let part of dialect.split(" ")) {
        let id2 = values.indexOf(part);
        if (id2 >= 0)
          flags[id2] = true;
      }
    let disabled2 = null;
    for (let i4 = 0; i4 < values.length; i4++)
      if (!flags[i4]) {
        for (let j4 = this.dialects[values[i4]], id2; (id2 = this.data[j4++]) != 65535; )
          (disabled2 || (disabled2 = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
      }
    return new Dialect(dialect, flags, disabled2);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(spec) {
    return new _LRParser(spec);
  }
};
function pair(data, off2) {
  return data[off2] | data[off2 + 1] << 16;
}
function findFinished(stacks) {
  let best = null;
  for (let stack of stacks) {
    let stopped = stack.p.stoppedAt;
    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(
      stack.state,
      2
      /* StateFlag.Accepting */
    ) && (!best || best.score < stack.score))
      best = stack;
  }
  return best;
}
function getSpecializer(spec) {
  if (spec.external) {
    let mask = spec.extend ? 1 : 0;
    return (value, stack) => spec.external(value, stack) << 1 | mask;
  }
  return spec.get;
}

// node_modules/@lezer/javascript/dist/index.js
var import_highlight = require("@lezer/highlight");
var noSemi = 312;
var noSemiType = 313;
var incdec = 1;
var incdecPrefix = 2;
var questionDot = 3;
var JSXStartTag = 4;
var insertSemi = 314;
var spaces = 316;
var newline = 317;
var LineComment = 5;
var BlockComment = 6;
var Dialect_jsx = 0;
var space = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
var braceR = 125;
var semicolon2 = 59;
var slash = 47;
var star = 42;
var plus = 43;
var minus = 45;
var lt = 60;
var comma = 44;
var question = 63;
var dot = 46;
var bracketL = 91;
var trackNewline = new ContextTracker({
  start: false,
  shift(context, term) {
    return term == LineComment || term == BlockComment || term == spaces ? context : term == newline;
  },
  strict: false
});
var insertSemicolon = new ExternalTokenizer((input2, stack) => {
  let { next: next3 } = input2;
  if (next3 == braceR || next3 == -1 || stack.context)
    input2.acceptToken(insertSemi);
}, { contextual: true, fallback: true });
var noSemicolon = new ExternalTokenizer((input2, stack) => {
  let { next: next3 } = input2, after;
  if (space.indexOf(next3) > -1) return;
  if (next3 == slash && ((after = input2.peek(1)) == slash || after == star)) return;
  if (next3 != braceR && next3 != semicolon2 && next3 != -1 && !stack.context)
    input2.acceptToken(noSemi);
}, { contextual: true });
var noSemicolonType = new ExternalTokenizer((input2, stack) => {
  if (input2.next == bracketL && !stack.context) input2.acceptToken(noSemiType);
}, { contextual: true });
var operatorToken = new ExternalTokenizer((input2, stack) => {
  let { next: next3 } = input2;
  if (next3 == plus || next3 == minus) {
    input2.advance();
    if (next3 == input2.next) {
      input2.advance();
      let mayPostfix = !stack.context && stack.canShift(incdec);
      input2.acceptToken(mayPostfix ? incdec : incdecPrefix);
    }
  } else if (next3 == question && input2.peek(1) == dot) {
    input2.advance();
    input2.advance();
    if (input2.next < 48 || input2.next > 57)
      input2.acceptToken(questionDot);
  }
}, { contextual: true });
function identifierChar(ch, start) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch == 95 || ch >= 192 || !start && ch >= 48 && ch <= 57;
}
var jsx3 = new ExternalTokenizer((input2, stack) => {
  if (input2.next != lt || !stack.dialectEnabled(Dialect_jsx)) return;
  input2.advance();
  if (input2.next == slash) return;
  let back = 0;
  while (space.indexOf(input2.next) > -1) {
    input2.advance();
    back++;
  }
  if (identifierChar(input2.next, true)) {
    input2.advance();
    back++;
    while (identifierChar(input2.next, false)) {
      input2.advance();
      back++;
    }
    while (space.indexOf(input2.next) > -1) {
      input2.advance();
      back++;
    }
    if (input2.next == comma) return;
    for (let i4 = 0; ; i4++) {
      if (i4 == 7) {
        if (!identifierChar(input2.next, true)) return;
        break;
      }
      if (input2.next != "extends".charCodeAt(i4)) break;
      input2.advance();
      back++;
    }
  }
  input2.acceptToken(JSXStartTag, -back);
});
var jsHighlight = (0, import_highlight.styleTags)({
  "get set async static": import_highlight.tags.modifier,
  "for while do if else switch try catch finally return throw break continue default case": import_highlight.tags.controlKeyword,
  "in of await yield void typeof delete instanceof": import_highlight.tags.operatorKeyword,
  "let var const using function class extends": import_highlight.tags.definitionKeyword,
  "import export from": import_highlight.tags.moduleKeyword,
  "with debugger as new": import_highlight.tags.keyword,
  TemplateString: import_highlight.tags.special(import_highlight.tags.string),
  super: import_highlight.tags.atom,
  BooleanLiteral: import_highlight.tags.bool,
  this: import_highlight.tags.self,
  null: import_highlight.tags.null,
  Star: import_highlight.tags.modifier,
  VariableName: import_highlight.tags.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": import_highlight.tags.function(import_highlight.tags.variableName),
  VariableDefinition: import_highlight.tags.definition(import_highlight.tags.variableName),
  Label: import_highlight.tags.labelName,
  PropertyName: import_highlight.tags.propertyName,
  PrivatePropertyName: import_highlight.tags.special(import_highlight.tags.propertyName),
  "CallExpression/MemberExpression/PropertyName": import_highlight.tags.function(import_highlight.tags.propertyName),
  "FunctionDeclaration/VariableDefinition": import_highlight.tags.function(import_highlight.tags.definition(import_highlight.tags.variableName)),
  "ClassDeclaration/VariableDefinition": import_highlight.tags.definition(import_highlight.tags.className),
  PropertyDefinition: import_highlight.tags.definition(import_highlight.tags.propertyName),
  PrivatePropertyDefinition: import_highlight.tags.definition(import_highlight.tags.special(import_highlight.tags.propertyName)),
  UpdateOp: import_highlight.tags.updateOperator,
  "LineComment Hashbang": import_highlight.tags.lineComment,
  BlockComment: import_highlight.tags.blockComment,
  Number: import_highlight.tags.number,
  String: import_highlight.tags.string,
  Escape: import_highlight.tags.escape,
  ArithOp: import_highlight.tags.arithmeticOperator,
  LogicOp: import_highlight.tags.logicOperator,
  BitOp: import_highlight.tags.bitwiseOperator,
  CompareOp: import_highlight.tags.compareOperator,
  RegExp: import_highlight.tags.regexp,
  Equals: import_highlight.tags.definitionOperator,
  Arrow: import_highlight.tags.function(import_highlight.tags.punctuation),
  ": Spread": import_highlight.tags.punctuation,
  "( )": import_highlight.tags.paren,
  "[ ]": import_highlight.tags.squareBracket,
  "{ }": import_highlight.tags.brace,
  "InterpolationStart InterpolationEnd": import_highlight.tags.special(import_highlight.tags.brace),
  ".": import_highlight.tags.derefOperator,
  ", ;": import_highlight.tags.separator,
  "@": import_highlight.tags.meta,
  TypeName: import_highlight.tags.typeName,
  TypeDefinition: import_highlight.tags.definition(import_highlight.tags.typeName),
  "type enum interface implements namespace module declare": import_highlight.tags.definitionKeyword,
  "abstract global Privacy readonly override": import_highlight.tags.modifier,
  "is keyof unique infer": import_highlight.tags.operatorKeyword,
  JSXAttributeValue: import_highlight.tags.attributeValue,
  JSXText: import_highlight.tags.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": import_highlight.tags.angleBracket,
  "JSXIdentifier JSXNameSpacedName": import_highlight.tags.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": import_highlight.tags.attributeName,
  "JSXBuiltin/JSXIdentifier": import_highlight.tags.standard(import_highlight.tags.tagName)
});
var spec_identifier = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, extends: 54, this: 58, true: 66, false: 66, null: 78, void: 82, typeof: 86, super: 102, new: 136, delete: 148, yield: 157, await: 161, class: 166, public: 229, private: 229, protected: 229, readonly: 231, instanceof: 250, satisfies: 253, in: 254, const: 256, import: 290, keyof: 345, unique: 349, infer: 355, is: 391, abstract: 411, implements: 413, type: 415, let: 418, var: 420, using: 423, interface: 429, enum: 433, namespace: 439, module: 441, declare: 445, global: 449, for: 468, of: 477, while: 480, with: 484, do: 488, if: 492, else: 494, switch: 498, case: 504, try: 510, catch: 514, finally: 518, return: 522, throw: 526, break: 530, continue: 534, debugger: 538 };
var spec_word = { __proto__: null, async: 123, get: 125, set: 127, declare: 189, public: 191, private: 191, protected: 191, static: 193, abstract: 195, override: 197, readonly: 203, accessor: 205, new: 395 };
var spec_LessThan = { __proto__: null, "<": 187 };
var parser = LRParser.deserialize({
  version: 14,
  states: "$CdQ%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#D^O.QQlO'#DdO.bQlO'#DoO%[QlO'#DwO0fQlO'#EPOOQ!0Lf'#EX'#EXO1PQ`O'#EUOOQO'#Em'#EmOOQO'#Ih'#IhO1XQ`O'#GpO1dQ`O'#ElO1iQ`O'#ElO3hQ!0MxO'#JnO6[Q!0MxO'#JoO6uQ`O'#F[O6zQ,UO'#FsOOQ!0Lf'#Fe'#FeO7VO7dO'#FeO7eQMhO'#FzO9RQ`O'#FyOOQ!0Lf'#Jo'#JoOOQ!0Lb'#Jn'#JnO9WQ`O'#GtOOQ['#K['#K[O9cQ`O'#IUO9hQ!0LrO'#IVOOQ['#J['#J[OOQ['#IZ'#IZQ`QlOOQ`QlOOO9pQ!L^O'#DsO9wQlO'#D{O:OQlO'#D}O9^Q`O'#GpO:VQMhO'#CoO:eQ`O'#EkO:pQ`O'#EvO:uQMhO'#FdO;dQ`O'#GpOOQO'#K]'#K]O;iQ`O'#K]O;wQ`O'#GxO;wQ`O'#GyO;wQ`O'#G{O9^Q`O'#HOO<nQ`O'#HRO>VQ`O'#CeO>gQ`O'#H_O>oQ`O'#HeO>oQ`O'#HgO`QlO'#HiO>oQ`O'#HkO>oQ`O'#HnO>tQ`O'#HtO>yQ!0LsO'#HzO%[QlO'#H|O?UQ!0LsO'#IOO?aQ!0LsO'#IQO9hQ!0LrO'#ISO?lQ!0MxO'#CiO@nQpO'#DiQOQ`OOO%[QlO'#D}OAUQ`O'#EQO:VQMhO'#EkOAaQ`O'#EkOAlQ!bO'#FdOOQ['#Cg'#CgOOQ!0Lb'#Dn'#DnOOQ!0Lb'#Jr'#JrO%[QlO'#JrOOQO'#Ju'#JuOOQO'#Id'#IdOBlQpO'#EdOOQ!0Lb'#Ec'#EcOOQ!0Lb'#Jy'#JyOChQ!0MSO'#EdOCrQpO'#ETOOQO'#Jt'#JtODWQpO'#JuOEeQpO'#ETOCrQpO'#EdPErO&2DjO'#CbPOOO)CDy)CDyOOOO'#I['#I[OE}O#tO,59UOOQ!0Lh,59U,59UOOOO'#I]'#I]OF]O&jO,59UOFkQ!L^O'#D`OOOO'#I_'#I_OFrO#@ItO,59xOOQ!0Lf,59x,59xOGQQlO'#I`OGeQ`O'#JpOIdQ!fO'#JpO+}QlO'#JpOIkQ`O,5:OOJRQ`O'#EmOJ`Q`O'#KPOJkQ`O'#KOOJkQ`O'#KOOJsQ`O,5;ZOJxQ`O'#J}OOQ!0Ln,5:Z,5:ZOKPQlO,5:ZOL}Q!0MxO,5:cOMnQ`O,5:kONXQ!0LrO'#J|ON`Q`O'#J{O9WQ`O'#J{ONtQ`O'#J{ON|Q`O,5;YO! RQ`O'#J{O!#WQ!fO'#JoOOQ!0Lh'#Ci'#CiO%[QlO'#EPO!#vQ!fO,5:pOOQS'#Jv'#JvOOQO-E<f-E<fO9^Q`O,5=[O!$^Q`O,5=[O!$cQlO,5;WO!&fQMhO'#EhO!(PQ`O,5;WO!(UQlO'#DvO!(`QpO,5;aO!(hQpO,5;aO%[QlO,5;aOOQ['#FS'#FSOOQ['#FU'#FUO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bOOQ['#FY'#FYO!(vQlO,5;sOOQ!0Lf,5;x,5;xOOQ!0Lf,5;y,5;yOOQ!0Lf,5;{,5;{O%[QlO'#IlO!*yQ!0LrO,5<gO%[QlO,5;bO!&fQMhO,5;bO!+hQMhO,5;bO!-YQMhO'#EZO%[QlO,5;vOOQ!0Lf,5;z,5;zO!-aQ,UO'#FiO!.^Q,UO'#KTO!-xQ,UO'#KTO!.eQ,UO'#KTOOQO'#KT'#KTO!.yQ,UO,5<ROOOW,5<_,5<_O!/[QlO'#FuOOOW'#Ik'#IkO7VO7dO,5<PO!/cQ,UO'#FwOOQ!0Lf,5<P,5<PO!0SQ$IUO'#CvOOQ!0Lh'#Cz'#CzO!0gO#@ItO'#DOO!1TQMjO,5<dO!1[Q`O,5<fO!2wQ(CWO'#GVO!3UQ`O'#GWO!3ZQ`O'#GWO!4yQ(CWO'#G[O!6OQpO'#G`OOQO'#Gk'#GkO!+oQMhO'#GjOOQO'#Gm'#GmO!+oQMhO'#GlO!6qQ$IUO'#JhOOQ!0Lh'#Jh'#JhO!6{Q`O'#JgO!7ZQ`O'#JfO!7cQ`O'#CuOOQ!0Lh'#Cx'#CxO!7kQ`O'#CzOOQ!0Lh'#DS'#DSOOQ!0Lh'#DU'#DUO1SQ`O'#DWO!+oQMhO'#F}O!+oQMhO'#GPO!7pQ`O'#GRO!7uQ`O'#GSO!3ZQ`O'#GYO!+oQMhO'#G_O!7zQ`O'#EnO!8iQ`O,5<eOOQ!0Lb'#Cr'#CrO!8qQ`O'#EoO!9kQpO'#EpOOQ!0Lb'#J}'#J}O!9rQ!0LrO'#K^O9hQ!0LrO,5=`O`QlO,5>pOOQ['#Jd'#JdOOQ[,5>q,5>qOOQ[-E<X-E<XO!;qQ!0MxO,5:_O!9fQpO,5:]O!>[Q!0MxO,5:gO%[QlO,5:gO!@rQ!0MxO,5:iOOQO,5@w,5@wO!AcQMhO,5=[O!AqQ!0LrO'#JeO9RQ`O'#JeO!BSQ!0LrO,59ZO!B_QpO,59ZO!BgQMhO,59ZO:VQMhO,59ZO!BrQ`O,5;WO!BzQ`O'#H^O!C`Q`O'#KaO%[QlO,5;|O!9fQpO,5<OO!ChQ`O,5=wO!CmQ`O,5=wO!CrQ`O,5=wO9hQ!0LrO,5=wO;wQ`O,5=gOOQO'#Cv'#CvO!DQQpO,5=dO!DYQMhO,5=eO!DeQ`O,5=gO!DjQ!bO,5=jO!DrQ`O'#K]O>tQ`O'#HTO9^Q`O'#HVO!DwQ`O'#HVO:VQMhO'#HXO!D|Q`O'#HXOOQ[,5=m,5=mO!ERQ`O'#HYO!EdQ`O'#CoO!EiQ`O,59PO!EsQ`O,59PO!GxQlO,59POOQ[,59P,59PO!HYQ!0LrO,59PO%[QlO,59PO!JeQlO'#HaOOQ['#Hb'#HbOOQ['#Hc'#HcO`QlO,5=yO!J{Q`O,5=yO`QlO,5>PO`QlO,5>RO!KQQ`O,5>TO`QlO,5>VO!KVQ`O,5>YO!K[QlO,5>`OOQ[,5>f,5>fO%[QlO,5>fO9hQ!0LrO,5>hOOQ[,5>j,5>jO# fQ`O,5>jOOQ[,5>l,5>lO# fQ`O,5>lOOQ[,5>n,5>nO#!SQpO'#D[O%[QlO'#JrO#!uQpO'#JrO##PQpO'#DjO##bQpO'#DjO#%sQlO'#DjO#%zQ`O'#JqO#&SQ`O,5:TO#&XQ`O'#EqO#&gQ`O'#KQO#&oQ`O,5;[O#&tQpO'#DjO#'RQpO'#ESOOQ!0Lf,5:l,5:lO%[QlO,5:lO#'YQ`O,5:lO>tQ`O,5;VO!B_QpO,5;VO!BgQMhO,5;VO:VQMhO,5;VO#'bQ`O,5@^O#'gQ07dO,5:pOOQO-E<b-E<bO#(mQ!0MSO,5;OOCrQpO,5:oO#(wQpO,5:oOCrQpO,5;OO!BSQ!0LrO,5:oOOQ!0Lb'#Eg'#EgOOQO,5;O,5;OO%[QlO,5;OO#)UQ!0LrO,5;OO#)aQ!0LrO,5;OO!B_QpO,5:oOOQO,5;U,5;UO#)oQ!0LrO,5;OPOOO'#IY'#IYP#*TO&2DjO,58|POOO,58|,58|OOOO-E<Y-E<YOOQ!0Lh1G.p1G.pOOOO-E<Z-E<ZOOOO,59z,59zO#*`Q!bO,59zOOOO-E<]-E<]OOQ!0Lf1G/d1G/dO#*eQ!fO,5>zO+}QlO,5>zOOQO,5?Q,5?QO#*oQlO'#I`OOQO-E<^-E<^O#*|Q`O,5@[O#+UQ!fO,5@[O#+]Q`O,5@jOOQ!0Lf1G/j1G/jO%[QlO,5@kO#+eQ`O'#IfOOQO-E<d-E<dO#+]Q`O,5@jOOQ!0Lb1G0u1G0uOOQ!0Ln1G/u1G/uOOQ!0Ln1G0V1G0VO%[QlO,5@hO#+yQ!0LrO,5@hO#,[Q!0LrO,5@hO#,cQ`O,5@gO9WQ`O,5@gO#,kQ`O,5@gO#,yQ`O'#IiO#,cQ`O,5@gOOQ!0Lb1G0t1G0tO!(`QpO,5:rO!(kQpO,5:rOOQS,5:t,5:tO#-kQdO,5:tO#-sQMhO1G2vO9^Q`O1G2vOOQ!0Lf1G0r1G0rO#.RQ!0MxO1G0rO#/WQ!0MvO,5;SOOQ!0Lh'#GU'#GUO#/tQ!0MzO'#JhO!$cQlO1G0rO#2PQ!fO'#JsO%[QlO'#JsO#2ZQ`O,5:bOOQ!0Lh'#D['#D[OOQ!0Lf1G0{1G0{O%[QlO1G0{OOQ!0Lf1G1e1G1eO#2`Q`O1G0{O#4tQ!0MxO1G0|O#4{Q!0MxO1G0|O#7cQ!0MxO1G0|O#7jQ!0MxO1G0|O#:QQ!0MxO1G0|O#<hQ!0MxO1G0|O#<oQ!0MxO1G0|O#<vQ!0MxO1G0|O#?^Q!0MxO1G0|O#?eQ!0MxO1G0|O#ArQ?MtO'#CiO#CmQ?MtO1G1_O#CtQ?MtO'#JoO#DXQ!0MxO,5?WOOQ!0Lb-E<j-E<jO#FfQ!0MxO1G0|O#GcQ!0MzO1G0|OOQ!0Lf1G0|1G0|O#HfQMjO'#JxO#HpQ`O,5:uO#HuQ!0MxO1G1bO#IiQ,UO,5<VO#IqQ,UO,5<WO#IyQ,UO'#FnO#JbQ`O'#FmOOQO'#KU'#KUOOQO'#Ij'#IjO#JgQ,UO1G1mOOQ!0Lf1G1m1G1mOOOW1G1x1G1xO#JxQ?MtO'#JnO#KSQ`O,5<aO!(vQlO,5<aOOOW-E<i-E<iOOQ!0Lf1G1k1G1kO#KXQpO'#KTOOQ!0Lf,5<c,5<cO#KaQpO,5<cO#KfQMhO'#DQOOOO'#I^'#I^O#KmO#@ItO,59jOOQ!0Lh,59j,59jO%[QlO1G2OO!7uQ`O'#InO#KxQ`O,5<xOOQ!0Lh,5<u,5<uO!+oQMhO'#IqO#LfQMjO,5=UO!+oQMhO'#IsO#MXQMjO,5=WO!&fQMhO,5=YOOQO1G2Q1G2QO#McQ!dO'#CrO#MvQ(CWO'#EoO#N{QpO'#G`O$ cQ!dO,5<qO$ jQ`O'#KXO9WQ`O'#KXO$ xQ`O,5<sO!+oQMhO,5<rO$ }Q`O'#GXO$!`Q`O,5<rO$!eQ!dO'#GUO$!rQ!dO'#KYO$!|Q`O'#KYO!&fQMhO'#KYO$#RQ`O,5<vO$#WQlO'#JrO$#bQpO'#GaO##bQpO'#GaO$#sQ`O'#GeO!3ZQ`O'#GhO$#xQ!0LrO'#IpO$$TQpO,5<zOOQ!0Lp,5<z,5<zO$$[QpO'#GaO$$iQpO'#GbO$$zQpO'#GbO$%PQMjO,5=UO$%aQMjO,5=WOOQ!0Lh,5=Z,5=ZO!+oQMhO,5@RO!+oQMhO,5@RO$%qQ`O'#IuO$%|Q`O,5@QO$&UQ`O,59aOOQ!0Lh,59f,59fO$&{Q$IYO,59rOOQ!0Lh'#Jl'#JlO$'nQMjO,5<iO$(aQMjO,5<kO@fQ`O,5<mOOQ!0Lh,5<n,5<nO$(kQ`O,5<tO$(pQMjO,5<yO$)QQ`O'#J{O!$cQlO1G2PO$)VQ`O1G2PO9WQ`O'#KOO9WQ`O'#EqO%[QlO'#EqO9WQ`O'#IwO$)[Q!0LrO,5@xOOQ[1G2z1G2zOOQ[1G4[1G4[OOQ!0Lf1G/y1G/yOOQ!0Lf1G/w1G/wO$+^Q!0MxO1G0ROOQ[1G2v1G2vO!&fQMhO1G2vO%[QlO1G2vO#-vQ`O1G2vO$-bQMhO'#EhOOQ!0Lb,5@P,5@PO$-lQ!0LrO,5@POOQ[1G.u1G.uO!BSQ!0LrO1G.uO!B_QpO1G.uO!BgQMhO1G.uO$-}Q`O1G0rO$.SQ`O'#CiO$._Q`O'#KbO$.gQ`O,5=xO$.lQ`O'#KbO$.qQ`O'#KbO$/PQ`O'#I}O$/_Q`O,5@{O$/gQ!fO1G1hOOQ!0Lf1G1j1G1jO9^Q`O1G3cO@fQ`O1G3cO$/nQ`O1G3cO$/sQ`O1G3cOOQ[1G3c1G3cO!DeQ`O1G3RO!&fQMhO1G3OO$/xQ`O1G3OOOQ[1G3P1G3PO!&fQMhO1G3PO$/}Q`O1G3PO$0VQpO'#G}OOQ[1G3R1G3RO!5yQpO'#IyO!DjQ!bO1G3UOOQ[1G3U1G3UOOQ[,5=o,5=oO$0_QMhO,5=qO9^Q`O,5=qO$#sQ`O,5=sO9RQ`O,5=sO!B_QpO,5=sO!BgQMhO,5=sO:VQMhO,5=sO$0mQ`O'#K`O$0xQ`O,5=tOOQ[1G.k1G.kO$0}Q!0LrO1G.kO@fQ`O1G.kO$1YQ`O1G.kO9hQ!0LrO1G.kO$3bQ!fO,5@}O$3oQ`O,5@}O9WQ`O,5@}O$3zQlO,5={O$4RQ`O,5={OOQ[1G3e1G3eO`QlO1G3eOOQ[1G3k1G3kOOQ[1G3m1G3mO>oQ`O1G3oO$4WQlO1G3qO$8[QlO'#HpOOQ[1G3t1G3tO$8iQ`O'#HvO>tQ`O'#HxOOQ[1G3z1G3zO$8qQlO1G3zO9hQ!0LrO1G4QOOQ[1G4S1G4SOOQ!0Lb'#G]'#G]O9hQ!0LrO1G4UO9hQ!0LrO1G4WO$<xQ`O,5@^O!(vQlO,5;]O9WQ`O,5;]O>tQ`O,5:UO!(vQlO,5:UO!B_QpO,5:UO$<}Q?MtO,5:UOOQO,5;],5;]O$=XQpO'#IaO$=oQ`O,5@]OOQ!0Lf1G/o1G/oO$=wQpO'#IgO$>RQ`O,5@lOOQ!0Lb1G0v1G0vO##bQpO,5:UOOQO'#Ic'#IcO$>ZQpO,5:nOOQ!0Ln,5:n,5:nO#']Q`O1G0WOOQ!0Lf1G0W1G0WO%[QlO1G0WOOQ!0Lf1G0q1G0qO>tQ`O1G0qO!B_QpO1G0qO!BgQMhO1G0qOOQ!0Lb1G5x1G5xO!BSQ!0LrO1G0ZOOQO1G0j1G0jO%[QlO1G0jO$>bQ!0LrO1G0jO$>mQ!0LrO1G0jO!B_QpO1G0ZOCrQpO1G0ZO$>{Q!0LrO1G0jOOQO1G0Z1G0ZO$?aQ!0MxO1G0jPOOO-E<W-E<WPOOO1G.h1G.hOOOO1G/f1G/fO$?kQ!bO,5<gO$?sQ!fO1G4fOOQO1G4l1G4lO%[QlO,5>zO$?}Q`O1G5vO$@VQ`O1G6UO$@_Q!fO1G6VO9WQ`O,5?QO$@iQ!0MxO1G6SO%[QlO1G6SO$@yQ!0LrO1G6SO$A[Q`O1G6RO$A[Q`O1G6RO9WQ`O1G6RO$AdQ`O,5?TO9WQ`O,5?TOOQO,5?T,5?TO$AxQ`O,5?TO$)QQ`O,5?TOOQO-E<g-E<gOOQS1G0^1G0^OOQS1G0`1G0`O#-nQ`O1G0`OOQ[7+(b7+(bO!&fQMhO7+(bO%[QlO7+(bO$BWQ`O7+(bO$BcQMhO7+(bO$BqQ!0MzO,5=UO$D|Q!0MzO,5=WO$GXQ!0MzO,5=UO$IjQ!0MzO,5=WO$K{Q!0MzO,59rO$NQQ!0MzO,5<iO%!]Q!0MzO,5<kO%$hQ!0MzO,5<yOOQ!0Lf7+&^7+&^O%&yQ!0MxO7+&^O%'mQlO'#IbO%'zQ`O,5@_O%(SQ!fO,5@_OOQ!0Lf1G/|1G/|O%(^Q`O7+&gOOQ!0Lf7+&g7+&gO%(cQ?MtO,5:cO%[QlO7+&yO%(mQ?MtO,5:_O%(zQ?MtO,5:gO%)UQ?MtO,5:iO%)`QMhO'#IeO%)jQ`O,5@dOOQ!0Lh1G0a1G0aOOQO1G1q1G1qOOQO1G1r1G1rO%)rQ!jO,5<YO!(vQlO,5<XOOQO-E<h-E<hOOQ!0Lf7+'X7+'XOOOW7+'d7+'dOOOW1G1{1G1{O%)}Q`O1G1{OOQ!0Lf1G1}1G1}OOOO,59l,59lO%*SQ!dO,59lOOOO-E<[-E<[OOQ!0Lh1G/U1G/UO%*ZQ!0MxO7+'jOOQ!0Lh,5?Y,5?YO%*}QMhO1G2dP%+UQ`O'#InPOQ!0Lh-E<l-E<lO%+rQMjO,5?]OOQ!0Lh-E<o-E<oO%,eQMjO,5?_OOQ!0Lh-E<q-E<qO%,oQ!dO1G2tO%,vQ!dO'#CrO%-^QMhO'#KOO$#WQlO'#JrOOQ!0Lh1G2]1G2]O%-eQ`O'#ImO%-yQ`O,5@sO%-yQ`O,5@sO%.RQ`O,5@sO%.^Q`O,5@sOOQO1G2_1G2_O%.lQMjO1G2^O!+oQMhO1G2^O%.|Q(CWO'#IoO%/ZQ`O,5@tO!&fQMhO,5@tO%/cQ!dO,5@tOOQ!0Lh1G2b1G2bO%1sQ!fO'#CiO%1}Q`O,5<}OOQ!0Lb,5<{,5<{O%2VQpO,5<{OOQ!0Lb,5<|,5<|OCcQ`O,5<{O%2bQpO,5<{OOQ!0Lb,5=P,5=PO$)QQ`O,5=SOOQO,5?[,5?[OOQO-E<n-E<nOOQ!0Lp1G2f1G2fO##bQpO,5<{O$#WQlO,5<}O%2pQ`O,5<|O%2{QpO,5<|O!+oQMhO'#IqO%3uQMjO1G2pO!+oQMhO'#IsO%4hQMjO1G2rO%4rQMjO1G5mO%4|QMjO1G5mOOQO,5?a,5?aOOQO-E<s-E<sOOQO1G.{1G.{O!9fQpO,59tO%[QlO,59tOOQ!0Lh,5<h,5<hO%5ZQ`O1G2XO!+oQMhO1G2`O%5`Q!0MxO7+'kOOQ!0Lf7+'k7+'kO!$cQlO7+'kO%6SQ`O,5;]OOQ!0Lb,5?c,5?cOOQ!0Lb-E<u-E<uO%6XQ!dO'#KZO#']Q`O7+(bO4UQ!fO7+(bO$BZQ`O7+(bO%6cQ!0MvO'#CiO%6vQ!0MvO,5=QO%7hQ`O,5=QOOQ!0Lb1G5k1G5kOOQ[7+$a7+$aO!BSQ!0LrO7+$aO!B_QpO7+$aO!$cQlO7+&^O%7mQ`O'#I|O%8UQ`O,5@|OOQO1G3d1G3dO9^Q`O,5@|O%8UQ`O,5@|O%8^Q`O,5@|OOQO,5?i,5?iOOQO-E<{-E<{OOQ!0Lf7+'S7+'SO%8cQ`O7+(}O9hQ!0LrO7+(}O9^Q`O7+(}O@fQ`O7+(}OOQ[7+(m7+(mO%8hQ!0MvO7+(jO!&fQMhO7+(jO!D`Q`O7+(kOOQ[7+(k7+(kO!&fQMhO7+(kO%8rQ`O'#K_O%8}Q`O,5=iOOQO,5?e,5?eOOQO-E<w-E<wOOQ[7+(p7+(pO%:aQpO'#HWOOQ[1G3]1G3]O!&fQMhO1G3]O%[QlO1G3]O%:hQ`O1G3]O%:sQMhO1G3]O9hQ!0LrO1G3_O$#sQ`O1G3_O9RQ`O1G3_O!B_QpO1G3_O!BgQMhO1G3_O%;RQ`O'#I{O%;gQ`O,5@zO%;oQpO,5@zOOQ!0Lb1G3`1G3`OOQ[7+$V7+$VO@fQ`O7+$VO9hQ!0LrO7+$VO%;zQ`O7+$VO%[QlO1G6iO%[QlO1G6jO%<PQ!0LrO1G6iO%<ZQlO1G3gO%<bQ`O1G3gO%<gQlO1G3gOOQ[7+)P7+)PO9hQ!0LrO7+)ZO`QlO7+)]OOQ['#Ke'#KeOOQ['#JO'#JOO%<nQlO,5>[OOQ[,5>[,5>[O%[QlO'#HqO%<{Q`O'#HsOOQ[,5>b,5>bO9WQ`O,5>bOOQ[,5>d,5>dOOQ[7+)f7+)fOOQ[7+)l7+)lOOQ[7+)p7+)pOOQ[7+)r7+)rO%=QQpO1G5xO%=lQ?MtO1G0wO%=vQ`O1G0wOOQO1G/p1G/pO%>RQ?MtO1G/pO>tQ`O1G/pO!(vQlO'#DjOOQO,5>{,5>{OOQO-E<_-E<_OOQO,5?R,5?ROOQO-E<e-E<eO!B_QpO1G/pOOQO-E<a-E<aOOQ!0Ln1G0Y1G0YOOQ!0Lf7+%r7+%rO#']Q`O7+%rOOQ!0Lf7+&]7+&]O>tQ`O7+&]O!B_QpO7+&]OOQO7+%u7+%uO$?aQ!0MxO7+&UOOQO7+&U7+&UO%[QlO7+&UO%>]Q!0LrO7+&UO!BSQ!0LrO7+%uO!B_QpO7+%uO%>hQ!0LrO7+&UO%>vQ!0MxO7++nO%[QlO7++nO%?WQ`O7++mO%?WQ`O7++mOOQO1G4o1G4oO9WQ`O1G4oO%?`Q`O1G4oOOQS7+%z7+%zO#']Q`O<<K|O4UQ!fO<<K|O%?nQ`O<<K|OOQ[<<K|<<K|O!&fQMhO<<K|O%[QlO<<K|O%?vQ`O<<K|O%@RQ!0MzO,5?]O%B^Q!0MzO,5?_O%DiQ!0MzO1G2^O%FzQ!0MzO1G2pO%IVQ!0MzO1G2rO%KbQ!fO,5>|O%[QlO,5>|OOQO-E<`-E<`O%KlQ`O1G5yOOQ!0Lf<<JR<<JRO%KtQ?MtO1G0rO%M{Q?MtO1G0|O%NSQ?MtO1G0|O&!TQ?MtO1G0|O&![Q?MtO1G0|O&$]Q?MtO1G0|O&&^Q?MtO1G0|O&&eQ?MtO1G0|O&&lQ?MtO1G0|O&(mQ?MtO1G0|O&(tQ?MtO1G0|O&({Q!0MxO<<JeO&*sQ?MtO1G0|O&+pQ?MvO1G0|O&,sQ?MvO'#JhO&.yQ?MtO1G1bO&/WQ?MtO1G0RO&/bQMjO,5?POOQO-E<c-E<cO!(vQlO'#FpOOQO'#KV'#KVOOQO1G1t1G1tO&/lQ`O1G1sO&/qQ?MtO,5?WOOOW7+'g7+'gOOOO1G/W1G/WO&/{Q!dO1G4tOOQ!0Lh7+(O7+(OP!&fQMhO,5?YO!+oQMhO7+(`O&0SQ`O,5?XO9WQ`O,5?XOOQO-E<k-E<kO&0bQ`O1G6_O&0bQ`O1G6_O&0jQ`O1G6_O&0uQMjO7+'xO&1VQ!dO,5?ZO&1aQ`O,5?ZO!&fQMhO,5?ZOOQO-E<m-E<mO&1fQ!dO1G6`O&1pQ`O1G6`O&1xQ`O1G2iO!&fQMhO1G2iOOQ!0Lb1G2g1G2gOOQ!0Lb1G2h1G2hO%2VQpO1G2gO!B_QpO1G2gOCcQ`O1G2gOOQ!0Lb1G2n1G2nO&1}QpO1G2gO&2]Q`O1G2iO$)QQ`O1G2hOCcQ`O1G2hO$#WQlO1G2iO&2eQ`O1G2hO&3XQMjO,5?]OOQ!0Lh-E<p-E<pO&3zQMjO,5?_OOQ!0Lh-E<r-E<rO!+oQMhO7++XOOQ!0Lh1G/`1G/`O&4UQ`O1G/`OOQ!0Lh7+'s7+'sO&4ZQMjO7+'zO&4kQ!0MxO<<KVOOQ!0Lf<<KV<<KVO&5_Q`O1G0wO!&fQMhO'#IvO&5dQ`O,5@uO&7fQ!fO<<K|O!&fQMhO1G2lOOQ[<<G{<<G{O!BSQ!0LrO<<G{O&7mQ!0MxO<<IxOOQ!0Lf<<Ix<<IxOOQO,5?h,5?hO&8aQ`O,5?hO&8fQ`O,5?hOOQO-E<z-E<zO&8tQ`O1G6hO&8tQ`O1G6hO9^Q`O1G6hO@fQ`O<<LiOOQ[<<Li<<LiO&8|Q`O<<LiO9hQ!0LrO<<LiOOQ[<<LU<<LUO%8hQ!0MvO<<LUOOQ[<<LV<<LVO!D`Q`O<<LVO&9RQpO'#IxO&9^Q`O,5@yO!(vQlO,5@yOOQ[1G3T1G3TOOQO'#Iz'#IzO9hQ!0LrO'#IzO&9fQpO,5=rOOQ[,5=r,5=rO&9mQpO'#EdO&9tQpO'#GcO&9yQ`O7+(wO&:OQ`O7+(wOOQ[7+(w7+(wO!&fQMhO7+(wO%[QlO7+(wO&:WQ`O7+(wOOQ[7+(y7+(yO9hQ!0LrO7+(yO$#sQ`O7+(yO9RQ`O7+(yO!B_QpO7+(yO&:cQ`O,5?gOOQO-E<y-E<yOOQO'#HZ'#HZO&:nQ`O1G6fO9hQ!0LrO<<GqOOQ[<<Gq<<GqO@fQ`O<<GqO&:vQ`O7+,TO&:{Q`O7+,UO%[QlO7+,TO%[QlO7+,UOOQ[7+)R7+)RO&;QQ`O7+)RO&;VQlO7+)RO&;^Q`O7+)ROOQ[<<Lu<<LuOOQ[<<Lw<<LwOOQ[-E<|-E<|OOQ[1G3v1G3vO&;cQ`O,5>]OOQ[,5>_,5>_O&;hQ`O1G3|O9WQ`O7+&cO!(vQlO7+&cOOQO7+%[7+%[O&;mQ?MtO1G6VO>tQ`O7+%[OOQ!0Lf<<I^<<I^OOQ!0Lf<<Iw<<IwO>tQ`O<<IwOOQO<<Ip<<IpO$?aQ!0MxO<<IpO%[QlO<<IpOOQO<<Ia<<IaO!BSQ!0LrO<<IaO&;wQ!0LrO<<IpO&<SQ!0MxO<= YO&<dQ`O<= XOOQO7+*Z7+*ZO9WQ`O7+*ZOOQ[ANAhANAhO&<lQ!fOANAhO!&fQMhOANAhO#']Q`OANAhO4UQ!fOANAhO&<sQ`OANAhO%[QlOANAhO&<{Q!0MzO7+'xO&?^Q!0MzO,5?]O&AiQ!0MzO,5?_O&CtQ!0MzO7+'zO&FVQ!fO1G4hO&FaQ?MtO7+&^O&HeQ?MvO,5=UO&JlQ?MvO,5=WO&J|Q?MvO,5=UO&K^Q?MvO,5=WO&KnQ?MvO,59rO&MtQ?MvO,5<iO' wQ?MvO,5<kO'$]Q?MvO,5<yO'&RQ?MtO7+'jO'&`Q?MtO7+'kO'&mQ`O,5<[OOQO7+'_7+'_OOQ!0Lh7+*`7+*`O'&rQMjO<<KzOOQO1G4s1G4sO'&yQ`O1G4sO''UQ`O1G4sO''dQ`O7++yO''dQ`O7++yO!&fQMhO1G4uO''lQ!dO1G4uO''vQ`O7++zO'(OQ`O7+(TO'(ZQ!dO7+(TOOQ!0Lb7+(R7+(ROOQ!0Lb7+(S7+(SO!B_QpO7+(ROCcQ`O7+(RO'(eQ`O7+(TO!&fQMhO7+(TO$)QQ`O7+(SO'(jQ`O7+(TOCcQ`O7+(SO'(rQMjO<<NsOOQ!0Lh7+$z7+$zO'(|Q!dO,5?bOOQO-E<t-E<tO')WQ!0MvO7+(WOOQ[AN=gAN=gO9^Q`O1G5SOOQO1G5S1G5SO')hQ`O1G5SO')mQ`O7+,SO')mQ`O7+,SO9hQ!0LrOANBTO@fQ`OANBTOOQ[ANBTANBTOOQ[ANApANApOOQ[ANAqANAqO')uQ`O,5?dOOQO-E<v-E<vO'*QQ?MtO1G6eOOQO,5?f,5?fOOQO-E<x-E<xOOQ[1G3^1G3^O'*[Q`O,5<}OOQ[<<Lc<<LcO!&fQMhO<<LcO&9yQ`O<<LcO'*aQ`O<<LcO%[QlO<<LcOOQ[<<Le<<LeO9hQ!0LrO<<LeO$#sQ`O<<LeO9RQ`O<<LeO'*iQpO1G5RO'*tQ`O7+,QOOQ[AN=]AN=]O9hQ!0LrOAN=]OOQ[<= o<= oOOQ[<= p<= pO'*|Q`O<= oO'+RQ`O<= pOOQ[<<Lm<<LmO'+WQ`O<<LmO'+]QlO<<LmOOQ[1G3w1G3wO>tQ`O7+)hO'+dQ`O<<I}O'+oQ?MtO<<I}OOQO<<Hv<<HvOOQ!0LfAN?cAN?cOOQOAN?[AN?[O$?aQ!0MxOAN?[OOQOAN>{AN>{O%[QlOAN?[OOQO<<Mu<<MuOOQ[G27SG27SO!&fQMhOG27SO#']Q`OG27SO'+yQ!fOG27SO4UQ!fOG27SO',QQ`OG27SO',YQ?MtO<<JeO',gQ?MvO1G2^O'.]Q?MvO,5?]O'0`Q?MvO,5?_O'2cQ?MvO1G2pO'4fQ?MvO1G2rO'6iQ?MtO<<KVO'6vQ?MtO<<IxOOQO1G1v1G1vO!+oQMhOANAfOOQO7+*_7+*_O'7TQ`O7+*_O'7`Q`O<= eO'7hQ!dO7+*aOOQ!0Lb<<Ko<<KoO$)QQ`O<<KoOCcQ`O<<KoO'7rQ`O<<KoO!&fQMhO<<KoOOQ!0Lb<<Km<<KmO!B_QpO<<KmO'7}Q!dO<<KoOOQ!0Lb<<Kn<<KnO'8XQ`O<<KoO!&fQMhO<<KoO$)QQ`O<<KnOOQO7+*n7+*nO9^Q`O7+*nO'8^Q`O<= nOOQ[G27oG27oO9hQ!0LrOG27oO!(vQlO1G5OO'8fQ`O7+,PO'8nQ`O1G2iO&9yQ`OANA}OOQ[ANA}ANA}O!&fQMhOANA}O'8sQ`OANA}OOQ[ANBPANBPO9hQ!0LrOANBPO$#sQ`OANBPOOQO'#H['#H[OOQO7+*m7+*mOOQ[G22wG22wOOQ[ANEZANEZOOQ[ANE[ANE[OOQ[ANBXANBXO'8{Q`OANBXOOQ[<<MS<<MSO!(vQlOAN?iOOQOG24vG24vO$?aQ!0MxOG24vO#']Q`OLD,nOOQ[LD,nLD,nO!&fQMhOLD,nO'9QQ!fOLD,nO'9XQ?MvO7+'xO':}Q?MvO,5?]O'=QQ?MvO,5?_O'?TQ?MvO7+'zO'@yQMjOG27QOOQO<<My<<MyOOQ!0LbANAZANAZO$)QQ`OANAZOCcQ`OANAZO'AZQ!dOANAZOOQ!0LbANAXANAXO'AbQ`OANAZO!&fQMhOANAZO'AmQ!dOANAZOOQ!0LbANAYANAYOOQO<<NY<<NYOOQ[LD-ZLD-ZO'AwQ?MtO7+*jOOQO'#Gd'#GdOOQ[G27iG27iO&9yQ`OG27iO!&fQMhOG27iOOQ[G27kG27kO9hQ!0LrOG27kOOQ[G27sG27sO'BRQ?MtOG25TOOQOLD*bLD*bOOQ[!$(!Y!$(!YO#']Q`O!$(!YO!&fQMhO!$(!YO'B]Q!0MzOG27QOOQ!0LbG26uG26uO$)QQ`OG26uO'DnQ`OG26uOCcQ`OG26uO'DyQ!dOG26uO!&fQMhOG26uOOQ[LD-TLD-TO&9yQ`OLD-TOOQ[LD-VLD-VOOQ[!)9Et!)9EtO#']Q`O!)9EtOOQ!0LbLD,aLD,aO$)QQ`OLD,aOCcQ`OLD,aO'EQQ`OLD,aO'E]Q!dOLD,aOOQ[!$(!o!$(!oOOQ[!.K;`!.K;`O'EdQ?MvOG27QOOQ!0Lb!$( {!$( {O$)QQ`O!$( {OCcQ`O!$( {O'GYQ`O!$( {OOQ!0Lb!)9Eg!)9EgO$)QQ`O!)9EgOCcQ`O!)9EgOOQ!0Lb!.K;R!.K;RO$)QQ`O!.K;ROOQ!0Lb!4/0m!4/0mO!(vQlO'#DwO1PQ`O'#EUO'GeQ!fO'#JnO'GlQ!L^O'#DsO'GsQlO'#D{O'GzQ!fO'#CiO'JbQ!fO'#CiO!(vQlO'#D}O'JrQlO,5;WO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO'#IlO'LuQ`O,5<gO!(vQlO,5;bO'L}QMhO,5;bO'NhQMhO,5;bO!(vQlO,5;vO!&fQMhO'#GjO'L}QMhO'#GjO!&fQMhO'#GlO'L}QMhO'#GlO1SQ`O'#DWO1SQ`O'#DWO!&fQMhO'#F}O'L}QMhO'#F}O!&fQMhO'#GPO'L}QMhO'#GPO!&fQMhO'#G_O'L}QMhO'#G_O!(vQlO,5:gO'NoQpO'#D[O'NyQpO'#JrO!(vQlO,5@kO'JrQlO1G0rO( TQ?MtO'#CiO!(vQlO1G2OO!&fQMhO'#IqO'L}QMhO'#IqO!&fQMhO'#IsO'L}QMhO'#IsO( _Q!dO'#CrO!&fQMhO,5<rO'L}QMhO,5<rO'JrQlO1G2PO!(vQlO7+&yO!&fQMhO1G2^O'L}QMhO1G2^O!&fQMhO'#IqO'L}QMhO'#IqO!&fQMhO'#IsO'L}QMhO'#IsO!&fQMhO1G2`O'L}QMhO1G2`O'JrQlO7+'kO'JrQlO7+&^O!&fQMhOANAfO'L}QMhOANAfO( rQ`O'#ElO( wQ`O'#ElO(!PQ`O'#F[O(!UQ`O'#EvO(!ZQ`O'#KPO(!fQ`O'#J}O(!qQ`O,5;WO(!vQMjO,5<dO(!}Q`O'#GWO(#SQ`O'#GWO(#XQ`O,5<eO(#aQ`O,5;WO(#iQ?MtO1G1_O(#pQ`O,5<rO(#uQ`O,5<rO(#zQ`O,5<tO($PQ`O,5<tO($UQ`O1G2PO($ZQ`O1G0rO($`QMjO<<KzO($gQMjO<<KzO7eQMhO'#FzO9RQ`O'#FyOAaQ`O'#EkO!(vQlO,5;sO!3ZQ`O'#GWO!3ZQ`O'#GWO!3ZQ`O'#GYO!3ZQ`O'#GYO!+oQMhO7+(`O!+oQMhO7+(`O%,oQ!dO1G2tO%,oQ!dO1G2tO!&fQMhO,5=YO!&fQMhO,5=Y",
  stateData: "(%k~O'xOS'yOSTOS'zRQ~OPYOQYOSfOY!VOaqOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!rwO!uxO!y]O#t!PO$V|O%e}O%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO&S!WO&Y!XO&[!YO&^!ZO&`![O&c!]O&i!^O&o!_O&q!`O&s!aO&u!bO&w!cO(PSO(RTO(UUO(]VO(k[O(ziO~OWtO~P`OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(P!dO(RTO(UUO(]VO(k[O(ziO~Oa!wOp!nO!P!oO!_!yO!`!vO!a!vO!y;kO#Q!pO#R!pO#S!xO#T!pO#U!pO#X!zO#Y!zO(Q!lO(RTO(UUO(a!mO(k!sO~O'z!{O~OP]XR]X[]Xa]Xo]X}]X!P]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X'v]X(]]X(n]X(u]X(v]X~O!d%PX~P(qO_!}O(R#PO(S!}O(T#PO~O_#QO(T#PO(U#PO(V#QO~Ou#SO!R#TO(^#TO(_#VO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(P;oO(RTO(UUO(]VO(k[O(ziO~O!X#ZO!Y#WO!V(dP!V(rP~P+}O!Z#cO~P`OPYOQYOSfOd!jOe!iOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(RTO(UUO(]VO(k[O(ziO~Om#mO!X#iO!y]O#f#lO#g#iO(P;pO!h(oP~P.iO!i#oO(P#nO~O!u#sO!y]O%e#tO~O#h#uO~O!d#vO#h#uO~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y$_O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO(]VO(n$YO(u#|O(v#}O~Oa(bX'v(bX's(bX!h(bX!V(bX![(bX%f(bX!d(bX~P1qO#P$dO#]$eO$P$eOP(cXR(cX[(cXo(cX}(cX!P(cX!Y(cX!i(cX!m(cX#O(cX#k(cX#l(cX#m(cX#n(cX#o(cX#p(cX#q(cX#r(cX#s(cX#u(cX#w(cX#y(cX#z(cX(](cX(n(cX(u(cX(v(cX![(cX%f(cX~Oa(cX'v(cX's(cX!V(cX!h(cXs(cX!d(cX~P4UO#]$eO~O$[$hO$^$gO$e$mO~OSfO![$nO$h$oO$j$qO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(P$sO(RTO(UUO(]$uO(u$}O(v%POg(YP~O!i%cO~O!P%fO![%gO(P%eO~O!d%kO~Oa%lO'v%lO~O}%pO~P%[O(Q!lO~P%[O%k%tO~P%[Oh%VO!i%cO(P%eO(Q!lO~Oe%{O!i%cO(P%eO~O#s$RO~O}&QO![%}O!i&PO%g&TO(P%eO(Q!lO(RTO(UUO`)TP~O!u#sO~O%p&VO!P)PX![)PX(P)PX~O(P&WO~O!r&]O#t!PO%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO~Od&bOe&aO!u&_O%e&`O%x&^O~P;|Od&eOeyO![&dO!r&]O!uxO!y]O#t!PO%e}O%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO~Ob&hO#]&kO%g&fO(Q!lO~P=RO!i&lO!r&pO~O!i#oO~O![XO~Oa%lO't&xO'v%lO~Oa%lO't&{O'v%lO~Oa%lO't&}O'v%lO~O's]X!V]Xs]X!h]X&W]X![]X%f]X!d]X~P(qO!_'[O!`'TO!a'TO(Q!lO(RTO(UUO~Op'RO!P'QO!X'UO(a'PO!Z(eP!Z(tP~P@YOk'_O![']O(P%eO~Oe'dO!i%cO(P%eO~O}&QO!i&PO~Op!nO!P!oO!y;kO#Q!pO#R!pO#T!pO#U!pO(Q!lO(RTO(UUO(a!mO(k!sO~O!_'jO!`'iO!a'iO#S!pO#X'kO#Y'kO~PAtOa%lOh%VO!d#vO!i%cO'v%lO(n'mO~O!m'qO#]'oO~PCSOp!nO!P!oO(RTO(UUO(a!mO(k!sO~O![XOp(iX!P(iX!_(iX!`(iX!a(iX!y(iX#Q(iX#R(iX#S(iX#T(iX#U(iX#X(iX#Y(iX(Q(iX(R(iX(U(iX(a(iX(k(iX~O!`'iO!a'iO(Q!lO~PCrO'{'uO'|'uO'}'wO~O_!}O(R'yO(S!}O(T'yO~O_#QO(T'yO(U'yO(V#QO~Os'{O~P%[Ou#SO!R#TO(^#TO(_(OO~O!X(QO!V'SX!V'YX!Y'SX!Y'YX~P+}O!Y(SO!V(dX~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y(SO!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO(]VO(n$YO(u#|O(v#}O~O!V(dX~PGmO!V(XO~O!V(qX!Y(qX!d(qX!h(qX(n(qX~O#](qX#h#aX!Z(qX~PIpO#](YO!V(sX!Y(sX~O!Y(ZO!V(rX~O!V(^O~O#]$eO~PIpO!Z(_O~P`OR#zO}#yO!P#{O!i#xO(]VOP!ka[!kao!ka!Y!ka!m!ka#O!ka#k!ka#l!ka#m!ka#n!ka#o!ka#p!ka#q!ka#r!ka#s!ka#u!ka#w!ka#y!ka#z!ka(n!ka(u!ka(v!ka~Oa!ka'v!ka's!ka!V!ka!h!kas!ka![!ka%f!ka!d!ka~PKWO!h(`O~O!d#vO#](aO(n'mO!Y(pXa(pX'v(pX~O!h(pX~PMsO!P%fO![%gO!y]O#f(fO#g(eO(P%eO~O!Y(gO!h(oX~O!h(iO~O!P%fO![%gO#g(eO(P%eO~OP(cXR(cX[(cXo(cX}(cX!P(cX!Y(cX!i(cX!m(cX#O(cX#k(cX#l(cX#m(cX#n(cX#o(cX#p(cX#q(cX#r(cX#s(cX#u(cX#w(cX#y(cX#z(cX(](cX(n(cX(u(cX(v(cX~O!d#vO!h(cX~P! aOR(kO}(jO!i#xO#P$dO!y!xa!P!xa~O!u!xa%e!xa![!xa#f!xa#g!xa(P!xa~P!#bO!u(oO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(P!dO(RTO(UUO(]VO(k[O(ziO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{<XO!P${O![$|O!f=jO!i$xO#g<_O$V%_O$r<ZO$t<]O$w%`O(P(sO(RTO(UUO(]$uO(u$}O(v%PO~O#h(uO~O!X(wO!h(gP~P%[O(a(yO(k[O~O!P({O!i#xO(a(yO(k[O~OP;jOQ;jOSfOd=fOe!iOmkOo;jOpkOqkOwkOy;jO{;jO!PWO!TkO!UkO![!eO!f;mO!iZO!l;jO!m;jO!n;jO!p;nO!r;qO!u!hO$V!kO(P)YO(RTO(UUO(]VO(k[O(z=dO~O!Y$_Oa$oa'v$oa's$oa!h$oa!V$oa![$oa%f$oa!d$oa~O#t)aO~P!&fOh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(P(sO(RTO(UUO(]$uO(u$}O(v%PO~Og(lP~P!+oO})fO!d)eO![$]X$Y$]X$[$]X$^$]X$e$]X~O!d)eO![(wX$Y(wX$[(wX$^(wX$e(wX~O})fO~P!-xO})fO![(wX$Y(wX$[(wX$^(wX$e(wX~O![)hO$Y)lO$[)gO$^)gO$e)mO~O!X)pO~P!(vO$[$hO$^$gO$e)tO~Ok$xX}$xX#P$xX'u$xX(u$xX(v$xX~OgjXg$xXkjX!YjX#]jX~P!/nOu)vO(^)wO(_)yO~Ok*SO}){O'u)|O(u$}O(v%PO~Og)zO~P!0rOg*TO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{<XO!P*VO![*WO!f=jO!i$xO#g<_O$V%_O$r<ZO$t<]O$w%`O(RTO(UUO(]$uO(u$}O(v%PO~O!X*ZO(P*UO!h({P~P!1aO#h*]O~O!i*^O~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{<XO!P${O![$|O!f=jO!i$xO#g<_O$V%_O$r<ZO$t<]O$w%`O(P*`O(RTO(UUO(]$uO(u$}O(v%PO~O!X*cO!V(|P~P!3`Oo*oOp!nO!P*eO!_*mO!`*gO!a*gO!i*^O#X*nO%]*iO(Q!lO(RTO(UUO(a!mO~O!Z*lO~P!5TO#P$dOk([X}([X'u([X(u([X(v([X!Y([X#]([X~Og([X#}([X~P!6VOk*tO#]*sOg(ZX!Y(ZX~O!Y*uOg(YX~O(P&WOg(YP~Op*xO~O!i*}O~O(P(sO~Om+RO!P%fO!X#iO![%gO!y]O#f#lO#g#iO(P%eO!h(oP~O!d#vO#h+SO~O!P%fO!X+UO!Y(ZO![%gO(P%eO!V(rP~Op'XO!P+WO!X+VO(RTO(UUO(a(yO~O!Z(tP~P!9VO!Y+XOa)QX'v)QX~OP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO(]VO(n$YO(u#|O(v#}O~Oa!ga!Y!ga'v!ga's!ga!V!ga!h!gas!ga![!ga%f!ga!d!ga~P!9}OR#zO}#yO!P#{O!i#xO(]VOP!oa[!oao!oa!Y!oa!m!oa#O!oa#k!oa#l!oa#m!oa#n!oa#o!oa#p!oa#q!oa#r!oa#s!oa#u!oa#w!oa#y!oa#z!oa(n!oa(u!oa(v!oa~Oa!oa'v!oa's!oa!V!oa!h!oas!oa![!oa%f!oa!d!oa~P!<eOR#zO}#yO!P#{O!i#xO(]VOP!qa[!qao!qa!Y!qa!m!qa#O!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#s!qa#u!qa#w!qa#y!qa#z!qa(n!qa(u!qa(v!qa~Oa!qa'v!qa's!qa!V!qa!h!qas!qa![!qa%f!qa!d!qa~P!>{Oh%VOk+bO![']O%f+aO~O!d+dOa(XX![(XX'v(XX!Y(XX~Oa%lO![XO'v%lO~Oh%VO!i%cO~Oh%VO!i%cO(P%eO~O!d#vO#h(uO~Ob+oO%g+pO(P+lO(RTO(UUO!Z)UP~O!Y+qO`)TX~O[+uO~O`+vO~O![%}O(P%eO(Q!lO`)TP~Oh%VO#]+{O~Oh%VOk,OO![$|O~O![,QO~O},SO![XO~O%k%tO~O!u,XO~Oe,^O~Ob,_O(P#nO(RTO(UUO!Z)SP~Oe%{O~O%g!QO(P&WO~P=RO[,dO`,cO~OPYOQYOSfOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO!fuO!iZO!lYO!mYO!nYO!pvO!uxO!y]O%e}O(RTO(UUO(]VO(k[O(ziO~O![!eO!r!gO$V!kO(P!dO~P!E{O`,cOa%lO'v%lO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!u!hO$V!kO(P!dO(RTO(UUO(]VO(k[O(ziO~Oa,iO!rwO#t!OO%i!OO%j!OO%k!OO~P!HeO!i&lO~O&Y,oO~O![,qO~O&k,sO&m,tOP&haQ&haS&haY&haa&had&hae&ham&hao&hap&haq&haw&hay&ha{&ha!P&ha!T&ha!U&ha![&ha!f&ha!i&ha!l&ha!m&ha!n&ha!p&ha!r&ha!u&ha!y&ha#t&ha$V&ha%e&ha%g&ha%i&ha%j&ha%k&ha%n&ha%p&ha%s&ha%t&ha%v&ha&S&ha&Y&ha&[&ha&^&ha&`&ha&c&ha&i&ha&o&ha&q&ha&s&ha&u&ha&w&ha's&ha(P&ha(R&ha(U&ha(]&ha(k&ha(z&ha!Z&ha&a&hab&ha&f&ha~O(P,yO~Oh!bX!Y!OX!Z!OX!d!OX!d!bX!i!bX#]!OX~O!Y!bX!Z!bX~P# kO!d-OO#],}Oh(fX!Y#eX!Z#eX!d(fX!i(fX~O!Y(fX!Z(fX~P#!^Oh%VO!d-QO!i%cO!Y!^X!Z!^X~Op!nO!P!oO(RTO(UUO(a!mO~OP;jOQ;jOSfOd=fOe!iOmkOo;jOpkOqkOwkOy;jO{;jO!PWO!TkO!UkO![!eO!f;mO!iZO!l;jO!m;jO!n;jO!p;nO!r;qO!u!hO$V!kO(RTO(UUO(]VO(k[O(z=dO~O(P<fO~P##sO!Y-UO!Z(eX~O!Z-WO~O!d-OO#],}O!Y#eX!Z#eX~O!Y-XO!Z(tX~O!Z-ZO~O!`-[O!a-[O(Q!lO~P##bO!Z-_O~P'_Ok-bO![']O~O!V-gO~Op!xa!_!xa!`!xa!a!xa#Q!xa#R!xa#S!xa#T!xa#U!xa#X!xa#Y!xa(Q!xa(R!xa(U!xa(a!xa(k!xa~P!#bO!m-lO#]-jO~PCSO!`-nO!a-nO(Q!lO~PCrOa%lO#]-jO'v%lO~Oa%lO!d#vO#]-jO'v%lO~Oa%lO!d#vO!m-lO#]-jO'v%lO(n'mO~O'{'uO'|'uO'}-sO~Os-tO~O!V'Sa!Y'Sa~P!9}O!X-xO!V'SX!Y'SX~P%[O!Y(SO!V(da~O!V(da~PGmO!Y(ZO!V(ra~O!P%fO!X-|O![%gO(P%eO!V'YX!Y'YX~O#].OO!Y(pa!h(paa(pa'v(pa~O!d#vO~P#+yO!Y(gO!h(oa~O!P%fO![%gO#g.SO(P%eO~Om.XO!P%fO!X.UO![%gO!y]O#f.WO#g.UO(P%eO!Y']X!h']X~OR.]O!i#xO~Oh%VOk.`O![']O%f._O~Oa#`i!Y#`i'v#`i's#`i!V#`i!h#`is#`i![#`i%f#`i!d#`i~P!9}Ok=pO}){O'u)|O(u$}O(v%PO~O#h#[aa#[a#]#[a'v#[a!Y#[a!h#[a![#[a!V#[a~P#.uO#h([XP([XR([X[([Xa([Xo([X!P([X!i([X!m([X#O([X#k([X#l([X#m([X#n([X#o([X#p([X#q([X#r([X#s([X#u([X#w([X#y([X#z([X'v([X(]([X(n([X!h([X!V([X's([Xs([X![([X%f([X!d([X~P!6VO!Y.mO!h(gX~P!9}O!h.pO~O!V.rO~OP$[OR#zO}#yO!P#{O!i#xO!m$[O(]VO[#jia#jio#ji!Y#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'v#ji(n#ji(u#ji(v#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#k#ji~P#2eO#k$OO~P#2eOP$[OR#zOo$aO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO(]VO[#jia#ji!Y#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'v#ji(n#ji(u#ji(v#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#o#ji~P#5SO#o$QO~P#5SOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO(]VOa#ji!Y#ji#w#ji#y#ji#z#ji'v#ji(n#ji(u#ji(v#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#u#ji~P#7qOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO(]VO(v#}Oa#ji!Y#ji#y#ji#z#ji'v#ji(n#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#w$UO~P#:XO#w#ji~P#:XO#u$SO~P#7qOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO(]VO(u#|O(v#}Oa#ji!Y#ji#z#ji'v#ji(n#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#y#ji~P#<}O#y$WO~P#<}OP]XR]X[]Xo]X}]X!P]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X(]]X(n]X(u]X(v]X!Y]X!Z]X~O#}]X~P#?lOP$[OR#zO[<ROo<PO}#yO!P#{O!i#xO!m$[O#O;vO#k;sO#l;tO#m;tO#n;tO#o;uO#p;vO#q;vO#r<QO#s;vO#u;wO#w;yO#y;{O#z;|O(]VO(n$YO(u#|O(v#}O~O#}.tO~P#AyO#P$dO#]<SO$P<SO#}(cX!Z(cX~P! aOa'`a!Y'`a'v'`a's'`a!h'`a!V'`as'`a!['`a%f'`a!d'`a~P!9}O[#jia#jio#ji!Y#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'v#ji(n#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO(]VO(u#ji(v#ji~P#D{Ok=pO}){O'u)|O(u$}O(v%POP#jiR#ji!P#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji(]#ji~P#D{O!Y.xOg(lX~P!0rOg.zO~Oa$Oi!Y$Oi'v$Oi's$Oi!V$Oi!h$Ois$Oi![$Oi%f$Oi!d$Oi~P!9}O$[.{O$^.{O~O$[.|O$^.|O~O!d)eO#].}O![$bX$Y$bX$[$bX$^$bX$e$bX~O!X/OO~O![)hO$Y/QO$[)gO$^)gO$e/RO~O!Y;}O!Z(bX~P#AyO!Z/SO~O!d)eO$e(wX~O$e/UO~Os/VO~P!&fOu)vO(^)wO(_/YO~O!P/]O~O(u$}Ok%^a}%^a'u%^a(v%^a!Y%^a#]%^a~Og%^a#}%^a~P#K}O(v%POk%`a}%`a'u%`a(u%`a!Y%`a#]%`a~Og%`a#}%`a~P#LpO!YfX!dfX!hfX!h$xX(nfX~P!/nO!X/fO!Y(ZO(P/eO!V(rP!V(|P~P!1aOo*oO!_*mO!`*gO!a*gO!i*^O#X*nO%]*iO(Q!lO(RTO(UUO~Op<cO!P/gO!X+VO!Z*lO(a<bO!Z(tP~P#NZO!h/hO~P#.uO!Y/iO!d#vO(n'mO!h({X~O!h/nO~O!P%fO!X*ZO![%gO(P%eO!h({P~O#h/pO~O!V$xX!Y$xX!d%PX~P!/nO!Y/qO!V(|X~P#.uO!d/sO~O!V/uO~OmkO(P/vO~P.iOh%VOo/{O!d#vO!i%cO(n'mO~O!d+dO~Oa%lO!Y0PO'v%lO~O!Z0RO~P!5TO!`0SO!a0SO(Q!lO~P##bOp!nO!P0TO(RTO(UUO(a!mO~O#X0VO~Og%^a!Y%^a#]%^a#}%^a~P!0rOg%`a!Y%`a#]%`a#}%`a~P!0rO(P&WOg'iX!Y'iX~O!Y*uOg(Ya~Og0`O~OR0aO}0aO!P0bO#P$dOkza'uza(uza(vza!Yza#]za~Ogza#}za~P$&ZO}){O'u)|Ok$qa(u$qa(v$qa!Y$qa#]$qa~Og$qa#}$qa~P$'VO}){O'u)|Ok$sa(u$sa(v$sa!Y$sa#]$sa~Og$sa#}$sa~P$'xO#h0eO~Og%Ra!Y%Ra#]%Ra#}%Ra~P!0rO!d#vO~O#h0hO~O!Y+XOa)Qa'v)Qa~OR#zO}#yO!P#{O!i#xO(]VOP!oi[!oio!oi!Y!oi!m!oi#O!oi#k!oi#l!oi#m!oi#n!oi#o!oi#p!oi#q!oi#r!oi#s!oi#u!oi#w!oi#y!oi#z!oi(n!oi(u!oi(v!oi~Oa!oi'v!oi's!oi!V!oi!h!ois!oi![!oi%f!oi!d!oi~P$)gOh%VOo%XOp$tOq$tOw%YOy%ZO{<XO!P${O![$|O!f=jO!i$xO#g<_O$V%_O$r<ZO$t<]O$w%`O(RTO(UUO(]$uO(u$}O(v%PO~Om0qO(P0pO~P$+}O!d+dOa(Xa![(Xa'v(Xa!Y(Xa~O#h0wO~O[]X!YfX!ZfX~O!Y0xO!Z)UX~O!Z0zO~O[0{O~Ob0}O(P+lO(RTO(UUO~O![%}O(P%eO`'qX!Y'qX~O!Y+qO`)Ta~O!h1QO~P!9}O[1TO~O`1UO~O#]1XO~Ok1[O![$|O~O(a(yO!Z)RP~Oh%VOk1eO![1bO%f1dO~O[1oO!Y1mO!Z)SX~O!Z1pO~O`1rOa%lO'v%lO~O(P#nO(RTO(UUO~O#P$dO#]$eO$P$eOP(cXR(cX[(cXo(cX}(cX!P(cX!Y(cX!i(cX!m(cX#O(cX#k(cX#l(cX#m(cX#n(cX#o(cX#p(cX#q(cX#r(cX#u(cX#w(cX#y(cX#z(cX(](cX(n(cX(u(cX(v(cX~O#s1uO&W1vOa(cX~P$1eO#]$eO#s1uO&W1vO~Oa1xO~P%[Oa1zO~O&a1}OP&_iQ&_iS&_iY&_ia&_id&_ie&_im&_io&_ip&_iq&_iw&_iy&_i{&_i!P&_i!T&_i!U&_i![&_i!f&_i!i&_i!l&_i!m&_i!n&_i!p&_i!r&_i!u&_i!y&_i#t&_i$V&_i%e&_i%g&_i%i&_i%j&_i%k&_i%n&_i%p&_i%s&_i%t&_i%v&_i&S&_i&Y&_i&[&_i&^&_i&`&_i&c&_i&i&_i&o&_i&q&_i&s&_i&u&_i&w&_i's&_i(P&_i(R&_i(U&_i(]&_i(k&_i(z&_i!Z&_ib&_i&f&_i~Ob2TO!Z2RO&f2SO~P`O![XO!i2VO~O&m,tOP&hiQ&hiS&hiY&hia&hid&hie&him&hio&hip&hiq&hiw&hiy&hi{&hi!P&hi!T&hi!U&hi![&hi!f&hi!i&hi!l&hi!m&hi!n&hi!p&hi!r&hi!u&hi!y&hi#t&hi$V&hi%e&hi%g&hi%i&hi%j&hi%k&hi%n&hi%p&hi%s&hi%t&hi%v&hi&S&hi&Y&hi&[&hi&^&hi&`&hi&c&hi&i&hi&o&hi&q&hi&s&hi&u&hi&w&hi's&hi(P&hi(R&hi(U&hi(]&hi(k&hi(z&hi!Z&hi&a&hib&hi&f&hi~O!V2]O~O!Y!^a!Z!^a~P#AyOp!nO!P!oO!X2cO(a!mO!Y'TX!Z'TX~P@YO!Y-UO!Z(ea~O!Y'ZX!Z'ZX~P!9VO!Y-XO!Z(ta~O!Z2jO~P'_Oa%lO#]2sO'v%lO~Oa%lO!d#vO#]2sO'v%lO~Oa%lO!d#vO!m2wO#]2sO'v%lO(n'mO~Oa%lO'v%lO~P!9}O!Y$_Os$oa~O!V'Si!Y'Si~P!9}O!Y(SO!V(di~O!Y(ZO!V(ri~O!V(si!Y(si~P!9}O!Y(pi!h(pia(pi'v(pi~P!9}O#]2yO!Y(pi!h(pia(pi'v(pi~O!Y(gO!h(oi~O!P%fO![%gO!y]O#f3OO#g2}O(P%eO~O!P%fO![%gO#g2}O(P%eO~Ok3VO![']O%f3UO~Oh%VOk3VO![']O%f3UO~O#h%^aP%^aR%^a[%^aa%^ao%^a!P%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'v%^a(]%^a(n%^a!h%^a!V%^a's%^as%^a![%^a%f%^a!d%^a~P#K}O#h%`aP%`aR%`a[%`aa%`ao%`a!P%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'v%`a(]%`a(n%`a!h%`a!V%`a's%`as%`a![%`a%f%`a!d%`a~P#LpO#h%^aP%^aR%^a[%^aa%^ao%^a!P%^a!Y%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'v%^a(]%^a(n%^a!h%^a!V%^a's%^a#]%^as%^a![%^a%f%^a!d%^a~P#.uO#h%`aP%`aR%`a[%`aa%`ao%`a!P%`a!Y%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'v%`a(]%`a(n%`a!h%`a!V%`a's%`a#]%`as%`a![%`a%f%`a!d%`a~P#.uO#hzaPza[zaazaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza'vza(]za(nza!hza!Vza'szasza![za%fza!dza~P$&ZO#h$qaP$qaR$qa[$qaa$qao$qa!P$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa'v$qa(]$qa(n$qa!h$qa!V$qa's$qas$qa![$qa%f$qa!d$qa~P$'VO#h$saP$saR$sa[$saa$sao$sa!P$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa'v$sa(]$sa(n$sa!h$sa!V$sa's$sas$sa![$sa%f$sa!d$sa~P$'xO#h%RaP%RaR%Ra[%Raa%Rao%Ra!P%Ra!Y%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra'v%Ra(]%Ra(n%Ra!h%Ra!V%Ra's%Ra#]%Ras%Ra![%Ra%f%Ra!d%Ra~P#.uOa#`q!Y#`q'v#`q's#`q!V#`q!h#`qs#`q![#`q%f#`q!d#`q~P!9}O!X3_O!Y'UX!h'UX~P%[O!Y.mO!h(ga~O!Y.mO!h(ga~P!9}O!V3bO~O#}!ka!Z!ka~PKWO#}!ga!Y!ga!Z!ga~P#AyO#}!oa!Z!oa~P!<eO#}!qa!Z!qa~P!>{Og'XX!Y'XX~P!+oO!Y.xOg(la~OSfO![3vO$c3wO~O!Z3{O~Os3|O~P#.uOa$lq!Y$lq'v$lq's$lq!V$lq!h$lqs$lq![$lq%f$lq!d$lq~P!9}O!V4OO~P!&fO!P4PO~O}){O'u)|O(v%POk'ea(u'ea!Y'ea#]'ea~Og'ea#}'ea~P%+ZO}){O'u)|Ok'ga(u'ga(v'ga!Y'ga#]'ga~Og'ga#}'ga~P%+|O(n$YO~P#.uO!VfX!V$xX!YfX!Y$xX!d%PX#]fX~P!/nO(P<lO~P!1aO!P%fO!X4SO![%gO(P%eO!Y'aX!h'aX~O!Y/iO!h({a~O!Y/iO!d#vO!h({a~O!Y/iO!d#vO(n'mO!h({a~Og$zi!Y$zi#]$zi#}$zi~P!0rO!X4[O!V'cX!Y'cX~P!3`O!Y/qO!V(|a~O!Y/qO!V(|a~P#.uOP]XR]X[]Xo]X}]X!P]X!V]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X(]]X(n]X(u]X(v]X~O!d%WX#s%WX~P%/mO!d#vO#s4aO~Oh%VO!d#vO!i%cO~Oh%VOo4fO!i%cO(n'mO~Oo4kO!d#vO(n'mO~Op!nO!P4lO(RTO(UUO(a!mO~O(u$}Ok%^i}%^i'u%^i(v%^i!Y%^i#]%^i~Og%^i#}%^i~P%3^O(v%POk%`i}%`i'u%`i(u%`i!Y%`i#]%`i~Og%`i#}%`i~P%4POg(Zi!Y(Zi~P!0rO#]4rOg(Zi!Y(Zi~P!0rO!h4uO~Oa$mq!Y$mq'v$mq's$mq!V$mq!h$mqs$mq![$mq%f$mq!d$mq~P!9}O!V4yO~O!Y4zO![(}X~P#.uOa$xX![$xX%Z]X'v$xX!Y$xX~P!/nO%Z4}OalXklX}lX![lX'ulX'vlX(ulX(vlX!YlX~O%Z4}O~Ob5TO%g5UO(P+lO(RTO(UUO!Y'pX!Z'pX~O!Y0xO!Z)Ua~O[5YO~O`5ZO~Oa%lO'v%lO~P#.uO!Y5cO#]5eO!Z)RX~O!Z5fO~Oo5lOp!nO!P*eO!_!yO!`!vO!a!vO!y;kO#Q!pO#R!pO#S!pO#T!pO#U!pO#X5kO#Y!zO(Q!lO(RTO(UUO(a!mO(k!sO~O!Z5jO~P%9SOk5qO![1bO%f5pO~Oh%VOk5qO![1bO%f5pO~Ob5xO(P#nO(RTO(UUO!Y'oX!Z'oX~O!Y1mO!Z)Sa~O(RTO(UUO(a5zO~O`6OO~O#s6RO&W6SO~PMsO!h6TO~P%[Oa6VO~Oa6VO~P%[Ob2TO!Z6[O&f2SO~P`O!d6^O~O!d6`Oh(fi!Y(fi!Z(fi!d(fi!i(fio(fi(n(fi~O!Y#ei!Z#ei~P#AyO#]6aO!Y#ei!Z#ei~O!Y!^i!Z!^i~P#AyOa%lO#]6jO'v%lO~Oa%lO!d#vO#]6jO'v%lO~O!Y(pq!h(pqa(pq'v(pq~P!9}O!Y(gO!h(oq~O!P%fO![%gO#g6qO(P%eO~O![']O%f6tO~Ok6xO![']O%f6tO~O#h'eaP'eaR'ea['eaa'eao'ea!P'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea'v'ea(]'ea(n'ea!h'ea!V'ea's'eas'ea!['ea%f'ea!d'ea~P%+ZO#h'gaP'gaR'ga['gaa'gao'ga!P'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga'v'ga(]'ga(n'ga!h'ga!V'ga's'gas'ga!['ga%f'ga!d'ga~P%+|O#h$ziP$ziR$zi[$zia$zio$zi!P$zi!Y$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi'v$zi(]$zi(n$zi!h$zi!V$zi's$zi#]$zis$zi![$zi%f$zi!d$zi~P#.uO#h%^iP%^iR%^i[%^ia%^io%^i!P%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i'v%^i(]%^i(n%^i!h%^i!V%^i's%^is%^i![%^i%f%^i!d%^i~P%3^O#h%`iP%`iR%`i[%`ia%`io%`i!P%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i'v%`i(]%`i(n%`i!h%`i!V%`i's%`is%`i![%`i%f%`i!d%`i~P%4PO!Y'Ua!h'Ua~P!9}O!Y.mO!h(gi~O#}#`i!Y#`i!Z#`i~P#AyOP$[OR#zO}#yO!P#{O!i#xO!m$[O(]VO[#jio#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(n#ji(u#ji(v#ji!Y#ji!Z#ji~O#k#ji~P%LRO#k;sO~P%LROP$[OR#zOo<PO}#yO!P#{O!i#xO!m$[O#k;sO#l;tO#m;tO#n;tO(]VO[#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(n#ji(u#ji(v#ji!Y#ji!Z#ji~O#o#ji~P%NZO#o;uO~P%NZOP$[OR#zO[<ROo<PO}#yO!P#{O!i#xO!m$[O#O;vO#k;sO#l;tO#m;tO#n;tO#o;uO#p;vO#q;vO#r<QO#s;vO(]VO#w#ji#y#ji#z#ji#}#ji(n#ji(u#ji(v#ji!Y#ji!Z#ji~O#u#ji~P&!cOP$[OR#zO[<ROo<PO}#yO!P#{O!i#xO!m$[O#O;vO#k;sO#l;tO#m;tO#n;tO#o;uO#p;vO#q;vO#r<QO#s;vO#u;wO(]VO(v#}O#y#ji#z#ji#}#ji(n#ji(u#ji!Y#ji!Z#ji~O#w;yO~P&$dO#w#ji~P&$dO#u;wO~P&!cOP$[OR#zO[<ROo<PO}#yO!P#{O!i#xO!m$[O#O;vO#k;sO#l;tO#m;tO#n;tO#o;uO#p;vO#q;vO#r<QO#s;vO#u;wO#w;yO(]VO(u#|O(v#}O#z#ji#}#ji(n#ji!Y#ji!Z#ji~O#y#ji~P&&sO#y;{O~P&&sOa#{y!Y#{y'v#{y's#{y!V#{y!h#{ys#{y![#{y%f#{y!d#{y~P!9}O[#jio#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(n#ji!Y#ji!Z#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k;sO#l;tO#m;tO#n;tO(]VO(u#ji(v#ji~P&)oOk=qO}){O'u)|O(u$}O(v%POP#jiR#ji!P#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji(]#ji~P&)oO#P$dOP([XR([X[([Xk([Xo([X}([X!P([X!i([X!m([X#O([X#k([X#l([X#m([X#n([X#o([X#p([X#q([X#r([X#s([X#u([X#w([X#y([X#z([X#}([X'u([X(]([X(n([X(u([X(v([X!Y([X!Z([X~O#}$Oi!Y$Oi!Z$Oi~P#AyO#}!oi!Z!oi~P$)gOg'Xa!Y'Xa~P!0rO!Z7[O~O!Y'`a!Z'`a~P#AyO!V7]O~P#.uO!d#vO(n'mO!Y'aa!h'aa~O!Y/iO!h({i~O!Y/iO!d#vO!h({i~Og$zq!Y$zq#]$zq#}$zq~P!0rO!V'ca!Y'ca~P#.uO!d7dO~O!Y/qO!V(|i~P#.uO!Y/qO!V(|i~O!V7gO~Oh%VOo7lO!i%cO(n'mO~O!d#vO#s7nO~Oo7qO!d#vO(n'mO~O}){O'u)|O(v%POk'fa(u'fa!Y'fa#]'fa~Og'fa#}'fa~P&2pO}){O'u)|Ok'ha(u'ha(v'ha!Y'ha#]'ha~Og'ha#}'ha~P&3cO!V7sO~Og$|q!Y$|q#]$|q#}$|q~P!0rOa$my!Y$my'v$my's$my!V$my!h$mys$my![$my%f$my!d$my~P!9}O!d6`O~O!Y4zO![(}a~O![']OP$SaR$Sa[$Sao$Sa}$Sa!P$Sa!Y$Sa!i$Sa!m$Sa#O$Sa#k$Sa#l$Sa#m$Sa#n$Sa#o$Sa#p$Sa#q$Sa#r$Sa#s$Sa#u$Sa#w$Sa#y$Sa#z$Sa(]$Sa(n$Sa(u$Sa(v$Sa~O%f6tO~P&5lOa#`y!Y#`y'v#`y's#`y!V#`y!h#`ys#`y![#`y%f#`y!d#`y~P!9}O[7xO~Ob7zO(P+lO(RTO(UUO~O!Y0xO!Z)Ui~O`8OO~O(a(yO!Y'lX!Z'lX~O!Y5cO!Z)Ra~O!Z8XO~P%9SO(k!sO~P$$iO#X8YO~O![1bO~O![1bO%f8[O~Ok8_O![1bO%f8[O~O[8dO!Y'oa!Z'oa~O!Y1mO!Z)Si~O!h8hO~O!h8iO~O!h8lO~O!h8lO~P%[Oa8nO~O!d8oO~O!h8pO~O!Y(si!Z(si~P#AyOa%lO#]8xO'v%lO~O!Y(py!h(pya(py'v(py~P!9}O!Y(gO!h(oy~O%f8{O~P&5lO![']O%f8{O~O#h$zqP$zqR$zq[$zqa$zqo$zq!P$zq!Y$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq'v$zq(]$zq(n$zq!h$zq!V$zq's$zq#]$zqs$zq![$zq%f$zq!d$zq~P#.uO#h'faP'faR'fa['faa'fao'fa!P'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa'v'fa(]'fa(n'fa!h'fa!V'fa's'fas'fa!['fa%f'fa!d'fa~P&2pO#h'haP'haR'ha['haa'hao'ha!P'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha'v'ha(]'ha(n'ha!h'ha!V'ha's'has'ha!['ha%f'ha!d'ha~P&3cO#h$|qP$|qR$|q[$|qa$|qo$|q!P$|q!Y$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q'v$|q(]$|q(n$|q!h$|q!V$|q's$|q#]$|qs$|q![$|q%f$|q!d$|q~P#.uO!Y'Ui!h'Ui~P!9}O#}#`q!Y#`q!Z#`q~P#AyO(u$}OP%^aR%^a[%^ao%^a!P%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a#}%^a(]%^a(n%^a!Y%^a!Z%^a~Ok%^a}%^a'u%^a(v%^a~P&FnO(v%POP%`aR%`a[%`ao%`a!P%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a#}%`a(]%`a(n%`a!Y%`a!Z%`a~Ok%`a}%`a'u%`a(u%`a~P&HuOk=qO}){O'u)|O(v%PO~P&FnOk=qO}){O'u)|O(u$}O~P&HuOR0aO}0aO!P0bO#P$dOPza[zakzaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza#}za'uza(]za(nza(uza(vza!Yza!Zza~O}){O'u)|OP$qaR$qa[$qak$qao$qa!P$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa#}$qa(]$qa(n$qa(u$qa(v$qa!Y$qa!Z$qa~O}){O'u)|OP$saR$sa[$sak$sao$sa!P$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa#}$sa(]$sa(n$sa(u$sa(v$sa!Y$sa!Z$sa~Ok=qO}){O'u)|O(u$}O(v%PO~OP%RaR%Ra[%Rao%Ra!P%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra#}%Ra(]%Ra(n%Ra!Y%Ra!Z%Ra~P'#zO#}$lq!Y$lq!Z$lq~P#AyO#}$mq!Y$mq!Z$mq~P#AyO!Z9YO~O#}9ZO~P!0rO!d#vO!Y'ai!h'ai~O!d#vO(n'mO!Y'ai!h'ai~O!Y/iO!h({q~O!V'ci!Y'ci~P#.uO!Y/qO!V(|q~Oo9bO!d#vO(n'mO~O[9dO!V9cO~P#.uO!V9cO~O!d#vO#s9jO~Og(Zy!Y(Zy~P!0rO!Y'ja!['ja~P#.uOa%Yq![%Yq'v%Yq!Y%Yq~P#.uO[9mO~O!Y0xO!Z)Uq~O#]9qO!Y'la!Z'la~O!Y5cO!Z)Ri~P#AyO!P9sO~O![1bO%f9vO~O(RTO(UUO(a9{O~O!Y1mO!Z)Sq~O!h:OO~O!h:PO~O!h:QO~O!h:QO~P%[O#]:TO!Y#ey!Z#ey~O!Y#ey!Z#ey~P#AyO%f:YO~P&5lO![']O%f:YO~O#}#{y!Y#{y!Z#{y~P#AyOP$ziR$zi[$zio$zi!P$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi#}$zi(]$zi(n$zi!Y$zi!Z$zi~P'#zO}){O'u)|O(v%POP'eaR'ea['eak'eao'ea!P'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea#}'ea(]'ea(n'ea(u'ea!Y'ea!Z'ea~O}){O'u)|OP'gaR'ga['gak'gao'ga!P'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga#}'ga(]'ga(n'ga(u'ga(v'ga!Y'ga!Z'ga~O(u$}OP%^iR%^i[%^ik%^io%^i}%^i!P%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i#}%^i'u%^i(]%^i(n%^i(v%^i!Y%^i!Z%^i~O(v%POP%`iR%`i[%`ik%`io%`i}%`i!P%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i#}%`i'u%`i(]%`i(n%`i(u%`i!Y%`i!Z%`i~O#}$my!Y$my!Z$my~P#AyO#}#`y!Y#`y!Z#`y~P#AyO!d#vO!Y'aq!h'aq~O!Y/iO!h({y~O!V'cq!Y'cq~P#.uOo:dO!d#vO(n'mO~O[:hO!V:gO~P#.uO!V:gO~O!Y0xO!Z)Uy~O!Y5cO!Z)Rq~O(P:nO~O![1bO%f:qO~O!h:tO~O%f:yO~P&5lOP$zqR$zq[$zqo$zq!P$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq#}$zq(]$zq(n$zq!Y$zq!Z$zq~P'#zO}){O'u)|O(v%POP'faR'fa['fak'fao'fa!P'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa#}'fa(]'fa(n'fa(u'fa!Y'fa!Z'fa~O}){O'u)|OP'haR'ha['hak'hao'ha!P'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha#}'ha(]'ha(n'ha(u'ha(v'ha!Y'ha!Z'ha~OP$|qR$|q[$|qo$|q!P$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q#}$|q(]$|q(n$|q!Y$|q!Z$|q~P'#zOg%b!Z!Y%b!Z#]%b!Z#}%b!Z~P!0rO!V:}O~P#.uOo;OO!d#vO(n'mO~O[;QO!V:}O~P#.uO!Y'lq!Z'lq~P#AyO!Y#e!Z!Z#e!Z~P#AyO#h%b!ZP%b!ZR%b!Z[%b!Za%b!Zo%b!Z!P%b!Z!Y%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z'v%b!Z(]%b!Z(n%b!Z!h%b!Z!V%b!Z's%b!Z#]%b!Zs%b!Z![%b!Z%f%b!Z!d%b!Z~P#.uOo;YO!d#vO(n'mO~O!V;ZO~P#.uOo;bO!d#vO(n'mO~O!V;cO~P#.uOP%b!ZR%b!Z[%b!Zo%b!Z!P%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z#}%b!Z(]%b!Z(n%b!Z!Y%b!Z!Z%b!Z~P'#zOo;fO!d#vO(n'mO~Os(bX~P1qO}%pO~P!(vO(Q!lO~P!(vO!VfX!YfX#]fX~P%/mOP]XR]X[]Xo]X}]X!P]X!Y]X!YfX!i]X!m]X#O]X#P]X#]]X#]fX#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X(]]X(n]X(u]X(v]X~O!dfX!h]X!hfX(nfX~P'HXOP;jOQ;jOSfOd=fOe!iOmkOo;jOpkOqkOwkOy;jO{;jO!PWO!TkO!UkO![XO!f;mO!iZO!l;jO!m;jO!n;jO!p;nO!r;qO!u!hO$V!kO(P)YO(RTO(UUO(]VO(k[O(z=dO~O!Y;}O!Z$oa~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{<YO!P${O![$|O!f=kO!i$xO#g<`O$V%_O$r<[O$t<^O$w%`O(P(sO(RTO(UUO(]$uO(u$}O(v%PO~O#t)aO~P'L}Oo!bX(n!bX~P# kOo(fX(n(fX~P#!^O!Z]X!ZfX~P'HXO!VfX!V$xX!YfX!Y$xX#]fX~P!/nO#h;rO~O!d#vO#h;rO~O#]<SO~O#s;vO~O#]<dO!Y(sX!Z(sX~O#]<SO!Y(qX!Z(qX~O#h<eO~Og<gO~P!0rO#h<mO~O#h<nO~O!d#vO#h<oO~O!d#vO#h<eO~O#}<pO~P#AyO#h<qO~O#h<rO~O#h<wO~O#h<xO~O#h<yO~O#h<zO~O#}<{O~P!0rO#}<|O~P!0rO#P#Q#R#T#U#X#f#g#r(z$r$t$w%Z%e%f%g%n%p%s%t%v%x~'zT#l!U'x(Q#mp#k#no}'y$['y(P$^(a~",
  goto: "$6w)YPPPPPP)ZPP)^P)oP+P/RPPPP6XPP6oPP<g@VP@jP@jPPP@jPBnP@jP@jP@jPBrPBwPCfPH`PPPHdPPPPHdKgPPPKmL_PHdPHdPPNmHdPPPHdPHdP!!tHdP!&[!'a!'jP!(^!(b!(^!+oPPPPPPP!,`!'aPP!,p!.bP!1nHdHd!1s!5P!9m!9m!=lPPP!=tHdPPPPPPPPPPP!ATP!BbPPHd!CsPHdPHdHdHdHdHdPHd!EVP!HaP!KgP!Kk!Ku!Ky!KyP!H^P!K}!K}P# TP# XHdHd# _#$dBr@jP@jP@j@jP#%q@j@j#(P@j#*s@j#,{@j@j#-k#/{#/{#0Q#0Z#/{#0fP#/{P@j#1O@j#4u@j@j6XPPP#8rPPP#9]#9]P#9]P#9s#9]PP#9yP#9pP#9p#:^#9p#:x#;O#;R)^#;U)^P#;]#;]#;]P)^P)^P)^P)^PP)^P#;c#;fP#;f)^P#;jP#;mP)^P)^P)^P)^P)^P)^)^PP#;s#;y#<U#<[#<b#<h#<n#<|#=S#=^#=d#=n#=t#>U#>[#>|#?`#?f#?l#?z#@a#BQ#B`#Bg#C}#D]#Ey#FX#F_#Fe#Fk#Fu#F{#GR#G]#Go#GuPPPPPPPPPPP#G{PPPPPPP#Hp#Kw#Ma#Mh#MpPPP$%OP$%X$(Q$.k$.n$.q$/p$/s$/z$0SP$0Y$0]P$0y$0}$1u$3T$3Y$3pPP$3u$3{$4PP$4S$4W$4[$5W$5o$6W$6[$6_$6b$6h$6k$6o$6sR!|RoqOXst!Z#d%k&o&q&r&t,l,q1}2QY!vQ']-^1b5iQ%rvQ%zyQ&R|Q&g!VS'T!e-UQ'c!iS'i!r!yU*g$|*W*kQ+j%{Q+w&TQ,]&aQ-['[Q-f'dQ-n'jQ0S*mQ1l,^R<a;n%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W,i,l,q-b-j-x.O.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3_4l5q6R6S6V6j8_8n8xS#q];k!r)[$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gU*z%[<X<YQ+o%}Q,_&dQ,f&lQ0n+bQ0r+dQ0}+pQ1t,dQ3R.`Q5T0xQ5x1mQ6v3VQ7z5UR9O6x'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=g!S!nQ!r!v!y!z$|'T'[']'i'j'k*g*k*m*n-U-[-^-n0S0V1b5i5k%S$ti#v$b$c$d$x${%O%Q%]%^%b)v*O*Q*S*V*]*c*s*t+a+d+{,O._.x/]/f/p/q/s0W0Y0e1X1[1d3U4P4Q4[4a4r4z4}5p6t7d7n8[8{9Z9d9j9v:Y:h:q:y;Q<Q<R<T<U<V<W<Z<[<]<^<_<`<h<i<j<k<m<n<q<r<s<t<u<v<w<x<{<|=d=l=m=p=qQ&U|Q'R!eS'X%g-XQ+o%}Q,_&dQ0d*}Q0}+pQ1S+vQ1s,cQ1t,dQ5T0xQ5^1UQ5x1mQ5{1oQ5|1rQ7z5UQ7}5ZQ8g6OQ9p8OQ9|8dR<c*WrnOXst!V!Z#d%k&f&o&q&r&t,l,q1}2QR,a&h&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=f=g[#]WZ#W#Z'U(Q!b%hm#h#i#l$x%c%f(Z(e(f(g*V*Z*^+U+V+X,h-O-|.S.T.U.W/f/i2V2}3O4S6`6qQ%uxQ%yyS&O|&TQ&[!TQ'`!hQ'b!iQ(n#sS+i%z%{Q+m%}Q,W&_Q,[&aS-e'c'dQ.b(oQ0v+jQ0|+pQ1O+qQ1R+uQ1g,XS1k,],^Q2o-fQ5S0xQ5W0{Q5]1TQ5w1lQ7y5UQ7|5YQ9l7xR:k9m!O$zi$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=m!^%wy!i!u%y%z%{'S'b'c'd'h'r*f+i+j-R-e-f-m/y/|0v2h2o2v4d4e4h7k9fQ+c%uQ+|&XQ,P&YQ,Z&aQ.a(nQ1f,WU1j,[,],^Q3W.bQ5r1gS5v1k1lQ8c5w#d=h#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qo=i<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|W%Ti%V*u=dS&X!Q&fQ&Y!RQ&Z!SR+z&V%T%Si#v$b$c$d$x${%O%Q%]%^%b)v*O*Q*S*V*]*c*s*t+a+d+{,O._.x/]/f/p/q/s0W0Y0e1X1[1d3U4P4Q4[4a4r4z4}5p6t7d7n8[8{9Z9d9j9v:Y:h:q:y;Q<Q<R<T<U<V<W<Z<[<]<^<_<`<h<i<j<k<m<n<q<r<s<t<u<v<w<x<{<|=d=l=m=p=qT)w$u)xV*z%[<X<YW'X!e%g*W-XS(z#y#zQ+^%pQ+t&QS.Z(j(kQ1],QQ4s0aR8S5c'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=g$i$^c#Y#e%o%q%s(P(V(q(v)O)P)Q)R)S)T)U)V)W)X)Z)])_)d)n+_+s-S-q-v-{-}.l.o.s.u.v.w/Z0f2^2a2q2x3^3c3d3e3f3g3h3i3j3k3l3m3n3o3r3s3z4w5Q6c6i6n6}7O7X7Y8U8r8v9Q9W9X:V:m:u;l=ZT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gQ'V!eR2d-U!W!nQ!e!r!v!y!z$|'T'[']'i'j'k*W*g*k*m*n-U-[-^-n0S0V1b5i5kR1_,SnqOXst!Z#d%k&o&q&r&t,l,q1}2QQ&v!^Q's!xS(p#u;rQ+g%xQ,U&[Q,V&^Q-c'aQ-p'lS.k(u<eS0g+S<oQ0t+hQ1a,TQ2U,sQ2W,tQ2`-PQ2m-dQ2p-hS4x0h<yQ5O0uS5R0w<zQ6b2bQ6f2nQ6k2uQ7w5PQ8s6dQ8t6gQ8w6lR:S8p$d$]c#Y#e%q%s(P(V(q(v)O)P)Q)R)S)T)U)V)W)X)Z)])_)d)n+_+s-S-q-v-{-}.l.o.s.v.w/Z0f2^2a2q2x3^3c3d3e3f3g3h3i3j3k3l3m3n3o3r3s3z4w5Q6c6i6n6}7O7X7Y8U8r8v9Q9W9X:V:m:u;l=ZS(l#p'fQ(|#zS+]%o.uS.[(k(mR3P.]'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gS#q];kQ&q!XQ&r!YQ&t![Q&u!]R1|,oQ'^!hQ+`%uQ-a'`S.^(n+cQ2k-`W3T.a.b0m0oQ6e2lW6r3Q3S3W4|U8z6s6u6wU:X8|8}9PS:w:W:ZQ;U:xR;^;VU!wQ']-^T5g1b5i!Q_OXZ`st!V!Z#d#h%c%k&f&h&o&q&r&t(g,l,q.T1}2Q]!pQ!r']-^1b5iT#q];k%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8xS(z#y#zS.Z(j(k!s=Q$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gU$fd)[,fS(m#p'fU*r%R(t3qU0c*y.g7TQ4|0nQ6s3RQ8}6vR:Z9Om!tQ!r!v!y!z']'i'j'k-^-n1b5i5kQ'q!uS(c#g1wS-l'h'tQ/l*YQ/y*fQ2w-oQ4W/mQ4d/{Q4e/|Q4j0UQ7`4RS7k4f4hS7o4k4mQ9]7aQ9a7gQ9f7lQ9k7qS:c9b9cS:|:d:gS;X:};OS;a;Y;ZS;e;b;cR;h;fQ#wbQ'p!uS(b#g1wS(d#m+RQ+T%dQ+e%vQ+k%|U-k'h'q'tQ.P(cQ/k*YQ/z*fQ/}*hQ0s+fQ1h,YS2t-l-oQ2|.XS4V/l/mQ4`/wS4c/y0UQ4g0OQ5t1iQ6m2wQ7_4RQ7c4WU7j4d4j4mQ7m4iQ8a5uS9[7`7aQ9`7gQ9h7oQ9i7pQ9y8bQ:a9]S:b9a9cQ:j9kQ:s9zS:{:c:gS;W:|:}S;`;X;ZS;d;a;cQ;g;eQ;i;hQ=T=OQ=`=XR=a=YV!wQ']-^%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8xS#wz!j!r<}$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gR=T=f%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8xQ%dj!^%vy!i!u%y%z%{'S'b'c'd'h'r*f+i+j-R-e-f-m/y/|0v2h2o2v4d4e4h7k9fS%|z!jQ+f%wQ,Y&aW1i,Z,[,],^U5u1j1k1lS8b5v5wQ9z8c!r=O$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gQ=X=eR=Y=f%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8xY#bWZ#W#Z(Q!b%hm#h#i#l$x%c%f(Z(e(f(g*V*Z*^+U+V+X,h-O-|.S.T.U.W/f/i2V2}3O4S6`6qQ,g&l!p=P$Z$n)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gR=S'UU'Y!e%g*WR2f-X%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W,i,l,q-b-j-x.O.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3_4l5q6R6S6V6j8_8n8x!r)[$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gQ,f&lQ0n+bQ3R.`Q6v3VR9O6x!b$Tc#Y%o(P(V(q(v)W)X)])d+s-q-v-{-}.l.o/Z0f2q2x3^3n4w5Q6i6n6}8v:V;l!P;x)Z)n-S.u2^2a3c3l3m3r3z6c7O7X7Y8U8r9Q9W9X:m:u=Z!f$Vc#Y%o(P(V(q(v)T)U)W)X)])d+s-q-v-{-}.l.o/Z0f2q2x3^3n4w5Q6i6n6}8v:V;l!T;z)Z)n-S.u2^2a3c3i3j3l3m3r3z6c7O7X7Y8U8r9Q9W9X:m:u=Z!^$Zc#Y%o(P(V(q(v)])d+s-q-v-{-}.l.o/Z0f2q2x3^3n4w5Q6i6n6}8v:V;lQ4Q/dz=g)Z)n-S.u2^2a3c3r3z6c7O7X7Y8U8r9Q9W9X:m:u=ZQ=l=nR=m=o'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gS$oh$pR3w.}'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t.}/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gT$kf$qQ$ifS)g$l)kR)s$qT$jf$qT)i$l)k'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t.}/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gT$oh$pQ$rhR)r$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8x!s=e$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=g#glOPXZst!Z!`!o#S#d#o#{$n%k&h&k&l&o&q&r&t&x'Q'_({)p*e+W+b,i,l,q-b.`/O/g0T0b1e1u1v1x1z1}2Q2S3V3v4l5q6R6S6V6x8_8n!O%Ri$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=m#d(t#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qQ+O%`Q/[){o3q<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|!O$yi$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=mQ*_$zU*h$|*W*kQ+P%aQ0O*i#d=V#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qn=W<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|Q=[=hQ=]=iQ=^=jR=_=k!O%Ri$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=m#d(t#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qo3q<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|noOXst!Z#d%k&o&q&r&t,l,q1}2QS*b${*VQ,z&{Q,{&}R4Z/q%S%Si#v$b$c$d$x${%O%Q%]%^%b)v*O*Q*S*V*]*c*s*t+a+d+{,O._.x/]/f/p/q/s0W0Y0e1X1[1d3U4P4Q4[4a4r4z4}5p6t7d7n8[8{9Z9d9j9v:Y:h:q:y;Q<Q<R<T<U<V<W<Z<[<]<^<_<`<h<i<j<k<m<n<q<r<s<t<u<v<w<x<{<|=d=l=m=p=qQ+}&YQ1Z,PQ5a1YR8R5bV*j$|*W*kU*j$|*W*kT5h1b5iS/w*e/gQ4i0TT7p4l9sQ+e%vQ/}*hQ0s+fQ1h,YQ5t1iQ8a5uQ9y8bR:s9z!O%Oi$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=mr*O$v)b*P*q+Q/o0[0]3t4X4v7^7r:`=U=b=cS0W*p0X#d<T#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qn<U<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|!b<h(r)`*X*a.c.f.j/W/d/t0l1W3Z3}4Y4^5`6y6|7e7h7t7v9_9g:e:i:z;P;[=n=o`<i3p7P7S7W9R:[:_;_S<s.e3[T<t7R9U!O%Qi$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=mv*Q$v)b*R*p+Q/`/o0[0]3t4X4n4v7^7r:`=U=b=cS0Y*q0Z#d<V#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qn<W<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|!f<j(r)`*X*a.d.e.j/W/d/t0l1W3X3Z3}4Y4^5`6y6z6|7e7h7t7v9_9g:e:i:z;P;[=n=od<k3p7Q7R7W9R9S:[:]:_;_S<u.f3]T<v7S9VrnOXst!V!Z#d%k&f&o&q&r&t,l,q1}2QQ&c!UR,i&lrnOXst!V!Z#d%k&f&o&q&r&t,l,q1}2QR&c!UQ,R&ZR1V+zsnOXst!V!Z#d%k&f&o&q&r&t,l,q1}2QQ1c,WS5o1f1gU8Z5m5n5rS9u8]8^S:o9t9wQ;R:pR;];SQ&j!VR,b&fR5{1oR9|8dS&O|&TR1O+qQ&o!WR,l&pR,r&uT2O,q2QR,v&vQ,u&vR2X,vQ'v!{R-r'vSsOtQ#dXT%ns#dQ#OTR'x#OQ#RUR'z#RQ)x$uR/X)xQ#UVR'}#UQ#XWU(T#X(U-yQ(U#YR-y(VQ-V'VR2e-VQ.n(vS3`.n3aR3a.oQ-^']R2i-^Y!rQ']-^1b5iR'g!rQ.y)bR3u.yU#_W%f*VU([#_(]-zQ(]#`R-z(WQ-Y'YR2g-Yt`OXst!V!Z#d%k&f&h&o&q&r&t,l,q1}2QS#hZ%cU#r`#h.TR.T(gQ(h#jQ.Q(dW.Y(h.Q2z6oQ2z.RR6o2{Q)k$lR/P)kQ$phR)q$pQ$`cU)^$`-u<OQ-u;lR<O)nQ/j*YW4T/j4U7b9^U4U/k/l/mS7b4V4WR9^7c$])}$v(r)`)b*X*a*p*q*{*|+Q.e.f.h.i.j/W/`/b/d/o/t0[0]0l1W3X3Y3Z3p3t3}4X4Y4^4n4p4v5`6y6z6{6|7R7S7U7V7W7^7e7h7r7t7v9R9S9T9_9g:[:]:^:_:`:e:i:z;P;[;_=U=b=c=n=oQ/r*aU4]/r4_7fQ4_/tR7f4^S*k$|*WR0Q*kr*P$v)b*p*q+Q/o0[0]3t4X4v7^7r:`=U=b=c!b.c(r)`*X*a.e.f.j/W/d/t0l1W3Z3}4Y4^5`6y6|7e7h7t7v9_9g:e:i:z;P;[=n=oU/a*P.c7Pa7P3p7R7S7W9R:[:_;_Q0X*pQ3[.eU4o0X3[9UR9U7Rv*R$v)b*p*q+Q/`/o0[0]3t4X4n4v7^7r:`=U=b=c!f.d(r)`*X*a.e.f.j/W/d/t0l1W3X3Z3}4Y4^5`6y6z6|7e7h7t7v9_9g:e:i:z;P;[=n=oU/c*R.d7Qe7Q3p7R7S7W9R9S:[:]:_;_Q0Z*qQ3].fU4q0Z3]9VR9V7SQ*v%UR0_*vQ4{0lR7u4{Q+Y%iR0k+YQ5d1]S8T5d9rR9r8UQ,T&[R1`,TQ5i1bR8W5iQ1n,_S5y1n8eR8e5{Q0y+mW5V0y5X7{9nQ5X0|Q7{5WR9n7|Q+r&OR1P+rQ2Q,qR6Z2QYrOXst#dQ&s!ZQ+[%kQ,k&oQ,m&qQ,n&rQ,p&tQ1{,lS2O,q2QR6Y1}Q%mpQ&w!_Q&z!aQ&|!bQ'O!cQ'n!uQ+Z%jQ+g%xQ+y&UQ,a&jQ,x&yW-i'h'p'q'tQ-p'lQ0P*jQ0t+hS1q,b,eQ2Y,wQ2Z,zQ2[,{Q2p-hW2r-k-l-o-qQ5O0uQ5[1SQ5_1WQ5s1hQ5}1sQ6X1|U6h2q2t2wQ6k2uQ7w5PQ8P5^Q8Q5`Q8V5hQ8`5tQ8f5|S8u6i6mQ8w6lQ9o7}Q9x8aQ9}8gQ:U8vQ:l9pQ:r9yQ:v:VR;T:sQ%xyQ'a!iQ'l!uU+h%y%z%{Q-P'SU-d'b'c'dS-h'h'rQ/x*fS0u+i+jQ2b-RS2n-e-fQ2u-mS4b/y/|Q5P0vQ6d2hQ6g2oQ6l2vU7i4d4e4hQ9e7kR:f9fS$wi=dR*w%VU%Ui%V=dR0^*uQ$viS(r#v+dS)`$b$cQ)b$dQ*X$xS*a${*VQ*p%OQ*q%QQ*{%]Q*|%^Q+Q%bQ.e<TQ.f<VQ.h<ZQ.i<]Q.j<_Q/W)vQ/`*OQ/b*QQ/d*SQ/o*]S/t*c/fQ0[*sQ0]*tl0l+a,O._1[1d3U5p6t8[8{9v:Y:q:yQ1W+{Q3X<hQ3Y<jQ3Z<mS3p<Q<RQ3t.xS3}/]4PQ4X/pQ4Y/qQ4^/sQ4n0WQ4p0YQ4v0eQ5`1XQ6y<qQ6z<sQ6{<uQ6|<wQ7R<UQ7S<WQ7U<[Q7V<^Q7W<`Q7^4QQ7e4[Q7h4aQ7r4rQ7t4zQ7v4}Q9R<nQ9S<iQ9T<kQ9_7dQ9g7nQ:[<rQ:]<tQ:^<vQ:_<xQ:`9ZQ:e9dQ:i9jQ:z<{Q;P:hQ;[;QQ;_<|Q=U=dQ=b=lQ=c=mQ=n=pR=o=qQ*y%[Q.g<XR7T<YnpOXst!Z#d%k&o&q&r&t,l,q1}2QQ!fPS#fZ#oQ&y!`W'e!o*e0T4lQ'|#SQ(}#{Q)o$nS,e&h&kQ,j&lQ,w&xS,|'Q/gQ-`'_Q.q({Q/T)pQ0i+WQ0o+bQ1y,iQ2l-bQ3S.`Q3y/OQ4t0bQ5n1eQ6P1uQ6Q1vQ6U1xQ6W1zQ6]2SQ6w3VQ7Z3vQ8^5qQ8j6RQ8k6SQ8m6VQ9P6xQ9w8_R:R8n#[cOPXZst!Z!`!o#d#o#{%k&h&k&l&o&q&r&t&x'Q'_({*e+W+b,i,l,q-b.`/g0T0b1e1u1v1x1z1}2Q2S3V4l5q6R6S6V6x8_8nQ#YWQ#eYQ%ouQ%qvS%sw!gS(P#W(SQ(V#ZQ(q#uQ(v#xQ)O$OQ)P$PQ)Q$QQ)R$RQ)S$SQ)T$TQ)U$UQ)V$VQ)W$WQ)X$XQ)Z$ZQ)]$_Q)_$aQ)d$eW)n$n)p/O3vQ+_%rQ+s&PS-S'U2cQ-q'oS-v(Q-xQ-{(YQ-}(aQ.l(uQ.o(wQ.s;jQ.u;mQ.v;nQ.w;qQ/Z)zQ0f+SQ2^,}Q2a-QQ2q-jQ2x.OQ3^.mQ3c;rQ3d;sQ3e;tQ3f;uQ3g;vQ3h;wQ3i;xQ3j;yQ3k;zQ3l;{Q3m;|Q3n.tQ3o<PQ3r<SQ3s<aQ3z;}Q4w0hQ5Q0wQ6c<dQ6i2sQ6n2yQ6}3_Q7O<eQ7X<gQ7Y<oQ8U5eQ8r6aQ8v6jQ9Q<pQ9W<yQ9X<zQ:V8xQ:m9qQ:u:TQ;l#SR=Z=gR#[WR'W!el!tQ!r!v!y!z']'i'j'k-^-n1b5i5kS'S!e-UU*f$|*W*kS-R'T'[S/|*g*mQ0U*nQ2h-[Q4h0SR4m0VR(x#xQ!fQT-]']-^]!qQ!r']-^1b5iQ#p]R'f;kR)c$dY!uQ']-^1b5iQ'h!rS'r!v!yS't!z5kS-m'i'jQ-o'kR2v-nT#kZ%cS#jZ%cS%im,hU(d#h#i#lS.R(e(fQ.V(gQ0j+XQ2{.SU2|.T.U.WS6p2}3OR8y6qd#^W#W#Z%f(Q(Z*V+U-|/fr#gZm#h#i#l%c(e(f(g+X.S.T.U.W2}3O6qS*Y$x*^Q/m*ZQ1w,hQ2_-OQ4R/iQ6_2VQ7a4SQ8q6`T=R'U+VV#aW%f*VU#`W%f*VS(R#W(ZU(W#Z+U/fS-T'U+VT-w(Q-|V'Z!e%g*WQ$lfR)u$qT)j$l)kR3x.}T*[$x*^T*d${*VQ0m+aQ1Y,OQ3Q._Q5b1[Q5m1dQ6u3UQ8]5pQ8|6tQ9t8[Q:W8{Q:p9vQ:x:YQ;S:qR;V:ynqOXst!Z#d%k&o&q&r&t,l,q1}2QQ&i!VR,a&ftmOXst!U!V!Z#d%k&f&o&q&r&t,l,q1}2QR,h&lT%jm,hR1^,QR,`&dQ&S|R+x&TR+n%}T&m!W&pT&n!W&pT2P,q2Q",
  nodeNames: "\u26A0 ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 377,
  context: trackNewline,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 34, 36, 48, 50, 52, ""],
    ["group", -26, 9, 17, 19, 65, 204, 208, 212, 213, 215, 218, 221, 231, 233, 239, 241, 243, 245, 248, 254, 260, 262, 264, 266, 268, 270, 271, "Statement", -34, 13, 14, 29, 32, 33, 39, 48, 51, 52, 54, 59, 67, 69, 73, 77, 79, 81, 82, 107, 108, 117, 118, 135, 138, 140, 141, 142, 143, 144, 146, 147, 166, 167, 169, "Expression", -23, 28, 30, 34, 38, 40, 42, 171, 173, 175, 176, 178, 179, 180, 182, 183, 184, 186, 187, 188, 198, 200, 202, 203, "Type", -3, 85, 100, 106, "ClassItem"],
    ["openedBy", 23, "<", 35, "InterpolationStart", 53, "[", 57, "{", 70, "(", 159, "JSXStartCloseTag"],
    ["closedBy", 24, ">", 37, "InterpolationEnd", 47, "]", 58, "}", 71, ")", 164, "JSXEndTag"]
  ],
  propSources: [jsHighlight],
  skippedNodes: [0, 5, 6, 274],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$h&j(V!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(V!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$h&j(SpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(SpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$h&j(Sp(V!b'x0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(T#S$h&j'y0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$h&j(Sp(V!b'y0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$h&j!m),Q(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#u(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#u(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(R':f$h&j(V!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$h&j(V!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$h&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$c`$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$c``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$c`$h&j(V!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(V!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$c`(V!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$h&j(Sp(V!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$h&j(Sp(V!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$h&j(V!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$h&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(V!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$h&j(SpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(SpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Sp(V!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$h&j(k%1l(Sp(V!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$h&j(Sp(V!b$[#t(P,2j(a$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$h&j(Sp(V!b$[#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$h&j(Sp(V!b#m(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$h&j$P(Ch(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(v+JY$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$h&j#y(Ch(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(U';W$h&j(SpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$h&j(SpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$h&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$c`$h&j(SpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(SpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$c`(SpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!i/.^$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!h!Lf$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$h&j(Sp(V!b(Q%&f#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$h&j(Sp(V!b#k(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$h&j(Sp(V!bo+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!Y+Jf$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$h&j(Sp(V!b}.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_!X!L^$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$h&j(Sp(V!b#l(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$h&j(Sp(V!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$h&j(V!b!U7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$h&j!U7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$h&j!U7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!U7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!U7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$h&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$h&j(V!b!U7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(V!b!U7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(V!b!U7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(V!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$h&j(V!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$h&j(Sp!U7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$h&j(Sp!U7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Sp!U7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Sp!U7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(SpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$h&j(SpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$h&j(Sp(V!b!U7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Sp(V!b!U7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Sp(V!b!U7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Sp(V!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$h&j(Sp(V!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$h&j(Sp(V!b'z0/l!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$h&j(Sp(V!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$h&j(V!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$h&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(V!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$h&j(SpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(SpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Sp(V!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$h&j$P(Ch(Sp(V!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Y#t$h&j(Sp(V!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!d$b$h&j#})Lv(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#O-<U(Sp(V!b(z7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$j&j(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#o(Ch(Sp(V!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$P(Ch(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#p(Ch(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#]*!Y$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#h(Cl$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#p(Ch$e#|$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#p(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#o(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#o(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(n(Ct$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$h&j#z(Ch(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!y$Ip$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!P0,v$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$h&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$h&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$h&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$h&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$h&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!V#)l$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#w(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$h&j(Sp(V!b(]+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$h&j(Sp(V!b(P,2j$^#t(a$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$h&j(Sp(V!b$^#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X![#Hb(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(u+JY$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!Z(CdsBr$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!n7`$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$h&j(Sp(V!b'x0/l$[#t(P,2j(a$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$h&j(Sp(V!b'y0/l$[#t(P,2j(a$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [noSemicolon, noSemicolonType, operatorToken, jsx3, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, insertSemicolon, new LocalTokenGroup("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOu~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(_~~", 141, 336), new LocalTokenGroup("j~RQYZXz{^~^O'|~~aP!P!Qd~iO'}~~", 25, 319)],
  topRules: { "Script": [0, 7], "SingleExpression": [1, 272], "SingleClassItem": [2, 273] },
  dialects: { jsx: 0, ts: 14980 },
  dynamicPrecedences: { "77": 1, "79": 1, "91": 1, "167": 1, "196": 1 },
  specialized: [{ term: 323, get: (value) => spec_identifier[value] || -1 }, { term: 339, get: (value) => spec_word[value] || -1 }, { term: 92, get: (value) => spec_LessThan[value] || -1 }],
  tokenPrec: 15004
});

// node_modules/@codemirror/lang-javascript/dist/index.js
var import_language2 = require("@codemirror/language");
var import_state5 = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var snippets = [
  /* @__PURE__ */ snippetCompletion("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("try {\n	${}\n} catch (${error}) {\n	${}\n}", {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("if (${}) {\n	${}\n} else {\n	${}\n}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("class ${name} {\n	constructor(${params}) {\n		${}\n	}\n}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
];
var typescriptSnippets = /* @__PURE__ */ snippets.concat([
  /* @__PURE__ */ snippetCompletion("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]);
var cache = /* @__PURE__ */ new NodeWeakMap();
var ScopeNodes = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function defID(type) {
  return (node2, def) => {
    let id2 = node2.node.getChild("VariableDefinition");
    if (id2)
      def(id2, type);
    return true;
  };
}
var functionContext = ["FunctionDeclaration"];
var gatherCompletions = {
  FunctionDeclaration: /* @__PURE__ */ defID("function"),
  ClassDeclaration: /* @__PURE__ */ defID("class"),
  ClassExpression: () => true,
  EnumDeclaration: /* @__PURE__ */ defID("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ defID("type"),
  NamespaceDeclaration: /* @__PURE__ */ defID("namespace"),
  VariableDefinition(node2, def) {
    if (!node2.matchContext(functionContext))
      def(node2, "variable");
  },
  TypeDefinition(node2, def) {
    def(node2, "type");
  },
  __proto__: null
};
function getScope(doc, node2) {
  let cached = cache.get(node2);
  if (cached)
    return cached;
  let completions = [], top = true;
  function def(node3, type) {
    let name = doc.sliceString(node3.from, node3.to);
    completions.push({ label: name, type });
  }
  node2.cursor(IterMode.IncludeAnonymous).iterate((node3) => {
    if (top) {
      top = false;
    } else if (node3.name) {
      let gather = gatherCompletions[node3.name];
      if (gather && gather(node3, def) || ScopeNodes.has(node3.name))
        return false;
    } else if (node3.to - node3.from > 8192) {
      for (let c4 of getScope(doc, node3.node))
        completions.push(c4);
      return false;
    }
  });
  cache.set(node2, completions);
  return completions;
}
var Identifier = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/;
var dontComplete = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function localCompletionSource(context) {
  let inner = (0, import_language2.syntaxTree)(context.state).resolveInner(context.pos, -1);
  if (dontComplete.indexOf(inner.name) > -1)
    return null;
  let isWord = inner.name == "VariableName" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));
  if (!isWord && !context.explicit)
    return null;
  let options2 = [];
  for (let pos = inner; pos; pos = pos.parent) {
    if (ScopeNodes.has(pos.name))
      options2 = options2.concat(getScope(context.state.doc, pos));
  }
  return {
    options: options2,
    from: isWord ? inner.from : context.pos,
    validFor: Identifier
  };
}
var javascriptLanguage = /* @__PURE__ */ import_language2.LRLanguage.define({
  name: "javascript",
  parser: /* @__PURE__ */ parser.configure({
    props: [
      /* @__PURE__ */ import_language2.indentNodeProp.add({
        IfStatement: /* @__PURE__ */ (0, import_language2.continuedIndent)({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ (0, import_language2.continuedIndent)({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: import_language2.flatIndent,
        SwitchBody: (context) => {
          let after = context.textAfter, closed = /^\s*\}/.test(after), isCase = /^\s*(case|default)\b/.test(after);
          return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;
        },
        Block: /* @__PURE__ */ (0, import_language2.delimitedIndent)({ closing: "}" }),
        ArrowFunction: (cx) => cx.baseIndent + cx.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ (0, import_language2.continuedIndent)({ except: /^{/ }),
        JSXElement(context) {
          let closed = /^\s*<\//.test(context.textAfter);
          return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
        },
        JSXEscape(context) {
          let closed = /\s*\}/.test(context.textAfter);
          return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(context) {
          return context.column(context.node.from) + context.unit;
        }
      }),
      /* @__PURE__ */ import_language2.foldNodeProp.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": import_language2.foldInside,
        BlockComment(tree) {
          return { from: tree.from + 2, to: tree.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
});
var jsxSublanguage = {
  test: (node2) => /^JSX/.test(node2.name),
  facet: /* @__PURE__ */ (0, import_language2.defineLanguageFacet)({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
};
var typescriptLanguage = /* @__PURE__ */ javascriptLanguage.configure({ dialect: "ts" }, "typescript");
var jsxLanguage = /* @__PURE__ */ javascriptLanguage.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ import_language2.sublanguageProp.add((n3) => n3.isTop ? [jsxSublanguage] : void 0)]
});
var tsxLanguage = /* @__PURE__ */ javascriptLanguage.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ import_language2.sublanguageProp.add((n3) => n3.isTop ? [jsxSublanguage] : void 0)]
}, "typescript");
var kwCompletion = (name) => ({ label: name, type: "keyword" });
var keywords = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(kwCompletion);
var typescriptKeywords = /* @__PURE__ */ keywords.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(kwCompletion));
function javascript(config3 = {}) {
  let lang = config3.jsx ? config3.typescript ? tsxLanguage : jsxLanguage : config3.typescript ? typescriptLanguage : javascriptLanguage;
  let completions = config3.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords);
  return new import_language2.LanguageSupport(lang, [
    javascriptLanguage.data.of({
      autocomplete: ifNotIn(dontComplete, completeFromList(completions))
    }),
    javascriptLanguage.data.of({
      autocomplete: localCompletionSource
    }),
    config3.jsx ? autoCloseTags : []
  ]);
}
function findOpenTag(node2) {
  for (; ; ) {
    if (node2.name == "JSXOpenTag" || node2.name == "JSXSelfClosingTag" || node2.name == "JSXFragmentTag")
      return node2;
    if (node2.name == "JSXEscape" || !node2.parent)
      return null;
    node2 = node2.parent;
  }
}
function elementName(doc, tree, max2 = doc.length) {
  for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {
    if (ch.name == "JSXIdentifier" || ch.name == "JSXBuiltin" || ch.name == "JSXNamespacedName" || ch.name == "JSXMemberExpression")
      return doc.sliceString(ch.from, Math.min(ch.to, max2));
  }
  return "";
}
var android2 = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
var autoCloseTags = /* @__PURE__ */ import_view2.EditorView.inputHandler.of((view, from2, to, text2, defaultInsert) => {
  if ((android2 ? view.composing : view.compositionStarted) || view.state.readOnly || from2 != to || text2 != ">" && text2 != "/" || !javascriptLanguage.isActiveAt(view.state, from2, -1))
    return false;
  let base = defaultInsert(), { state: state2 } = base;
  let closeTags = state2.changeByRange((range) => {
    var _a;
    let { head } = range, around = (0, import_language2.syntaxTree)(state2).resolveInner(head - 1, -1), name;
    if (around.name == "JSXStartTag")
      around = around.parent;
    if (state2.doc.sliceString(head - 1, head) != text2 || around.name == "JSXAttributeValue" && around.to > head) ;
    else if (text2 == ">" && around.name == "JSXFragmentTag") {
      return { range, changes: { from: head, insert: `</>` } };
    } else if (text2 == "/" && around.name == "JSXStartCloseTag") {
      let empty = around.parent, base2 = empty.parent;
      if (base2 && empty.from == head - 2 && ((name = elementName(state2.doc, base2.firstChild, head)) || ((_a = base2.firstChild) === null || _a === void 0 ? void 0 : _a.name) == "JSXFragmentTag")) {
        let insert = `${name}>`;
        return { range: import_state5.EditorSelection.cursor(head + insert.length, -1), changes: { from: head, insert } };
      }
    } else if (text2 == ">") {
      let openTag = findOpenTag(around);
      if (openTag && openTag.name == "JSXOpenTag" && !/^\/?>|^<\//.test(state2.doc.sliceString(head, head + 2)) && (name = elementName(state2.doc, openTag, head)))
        return { range, changes: { from: head, insert: `</${name}>` } };
    }
    return { range };
  });
  if (closeTags.changes.empty)
    return false;
  view.dispatch([
    base,
    state2.update(closeTags, { userEvent: "input.complete", scrollIntoView: true })
  ]);
  return true;
});

// node_modules/@replit/codemirror-vim/dist/index.js
var import_state6 = require("@codemirror/state");
var import_language3 = require("@codemirror/language");
var View = __toESM(require("@codemirror/view"), 1);
var import_view3 = require("@codemirror/view");
var import_search = require("@codemirror/search");
var import_commands = require("@codemirror/commands");
function initVim(CodeMirror2) {
  var Pos2 = CodeMirror2.Pos;
  function updateSelectionForSurrogateCharacters(cm, curStart, curEnd) {
    if (curStart.line === curEnd.line && curStart.ch >= curEnd.ch - 1) {
      var text2 = cm.getLine(curStart.line);
      var charCode = text2.charCodeAt(curStart.ch);
      if (55296 <= charCode && charCode <= 55551) {
        curEnd.ch += 1;
      }
    }
    return { start: curStart, end: curEnd };
  }
  var defaultKeymap2 = [
    // Key to key mapping. This goes first to make it possible to override
    // existing mappings.
    { keys: "<Left>", type: "keyToKey", toKeys: "h" },
    { keys: "<Right>", type: "keyToKey", toKeys: "l" },
    { keys: "<Up>", type: "keyToKey", toKeys: "k" },
    { keys: "<Down>", type: "keyToKey", toKeys: "j" },
    { keys: "g<Up>", type: "keyToKey", toKeys: "gk" },
    { keys: "g<Down>", type: "keyToKey", toKeys: "gj" },
    { keys: "<Space>", type: "keyToKey", toKeys: "l" },
    { keys: "<BS>", type: "keyToKey", toKeys: "h" },
    { keys: "<Del>", type: "keyToKey", toKeys: "x" },
    { keys: "<C-Space>", type: "keyToKey", toKeys: "W" },
    { keys: "<C-BS>", type: "keyToKey", toKeys: "B" },
    { keys: "<S-Space>", type: "keyToKey", toKeys: "w" },
    { keys: "<S-BS>", type: "keyToKey", toKeys: "b" },
    { keys: "<C-n>", type: "keyToKey", toKeys: "j" },
    { keys: "<C-p>", type: "keyToKey", toKeys: "k" },
    { keys: "<C-[>", type: "keyToKey", toKeys: "<Esc>" },
    { keys: "<C-c>", type: "keyToKey", toKeys: "<Esc>" },
    { keys: "<C-[>", type: "keyToKey", toKeys: "<Esc>", context: "insert" },
    { keys: "<C-c>", type: "keyToKey", toKeys: "<Esc>", context: "insert" },
    { keys: "<C-Esc>", type: "keyToKey", toKeys: "<Esc>" },
    // ipad keyboard sends C-Esc instead of C-[
    { keys: "<C-Esc>", type: "keyToKey", toKeys: "<Esc>", context: "insert" },
    { keys: "s", type: "keyToKey", toKeys: "cl", context: "normal" },
    { keys: "s", type: "keyToKey", toKeys: "c", context: "visual" },
    { keys: "S", type: "keyToKey", toKeys: "cc", context: "normal" },
    { keys: "S", type: "keyToKey", toKeys: "VdO", context: "visual" },
    { keys: "<Home>", type: "keyToKey", toKeys: "0" },
    { keys: "<End>", type: "keyToKey", toKeys: "$" },
    { keys: "<PageUp>", type: "keyToKey", toKeys: "<C-b>" },
    { keys: "<PageDown>", type: "keyToKey", toKeys: "<C-f>" },
    { keys: "<CR>", type: "keyToKey", toKeys: "j^", context: "normal" },
    { keys: "<Ins>", type: "keyToKey", toKeys: "i", context: "normal" },
    { keys: "<Ins>", type: "action", action: "toggleOverwrite", context: "insert" },
    // Motions
    { keys: "H", type: "motion", motion: "moveToTopLine", motionArgs: { linewise: true, toJumplist: true } },
    { keys: "M", type: "motion", motion: "moveToMiddleLine", motionArgs: { linewise: true, toJumplist: true } },
    { keys: "L", type: "motion", motion: "moveToBottomLine", motionArgs: { linewise: true, toJumplist: true } },
    { keys: "h", type: "motion", motion: "moveByCharacters", motionArgs: { forward: false } },
    { keys: "l", type: "motion", motion: "moveByCharacters", motionArgs: { forward: true } },
    { keys: "j", type: "motion", motion: "moveByLines", motionArgs: { forward: true, linewise: true } },
    { keys: "k", type: "motion", motion: "moveByLines", motionArgs: { forward: false, linewise: true } },
    { keys: "gj", type: "motion", motion: "moveByDisplayLines", motionArgs: { forward: true } },
    { keys: "gk", type: "motion", motion: "moveByDisplayLines", motionArgs: { forward: false } },
    { keys: "w", type: "motion", motion: "moveByWords", motionArgs: { forward: true, wordEnd: false } },
    { keys: "W", type: "motion", motion: "moveByWords", motionArgs: { forward: true, wordEnd: false, bigWord: true } },
    { keys: "e", type: "motion", motion: "moveByWords", motionArgs: { forward: true, wordEnd: true, inclusive: true } },
    { keys: "E", type: "motion", motion: "moveByWords", motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true } },
    { keys: "b", type: "motion", motion: "moveByWords", motionArgs: { forward: false, wordEnd: false } },
    { keys: "B", type: "motion", motion: "moveByWords", motionArgs: { forward: false, wordEnd: false, bigWord: true } },
    { keys: "ge", type: "motion", motion: "moveByWords", motionArgs: { forward: false, wordEnd: true, inclusive: true } },
    { keys: "gE", type: "motion", motion: "moveByWords", motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true } },
    { keys: "{", type: "motion", motion: "moveByParagraph", motionArgs: { forward: false, toJumplist: true } },
    { keys: "}", type: "motion", motion: "moveByParagraph", motionArgs: { forward: true, toJumplist: true } },
    { keys: "(", type: "motion", motion: "moveBySentence", motionArgs: { forward: false } },
    { keys: ")", type: "motion", motion: "moveBySentence", motionArgs: { forward: true } },
    { keys: "<C-f>", type: "motion", motion: "moveByPage", motionArgs: { forward: true } },
    { keys: "<C-b>", type: "motion", motion: "moveByPage", motionArgs: { forward: false } },
    { keys: "<C-d>", type: "motion", motion: "moveByScroll", motionArgs: { forward: true, explicitRepeat: true } },
    { keys: "<C-u>", type: "motion", motion: "moveByScroll", motionArgs: { forward: false, explicitRepeat: true } },
    { keys: "gg", type: "motion", motion: "moveToLineOrEdgeOfDocument", motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true } },
    { keys: "G", type: "motion", motion: "moveToLineOrEdgeOfDocument", motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true } },
    { keys: "g$", type: "motion", motion: "moveToEndOfDisplayLine" },
    { keys: "g^", type: "motion", motion: "moveToStartOfDisplayLine" },
    { keys: "g0", type: "motion", motion: "moveToStartOfDisplayLine" },
    { keys: "0", type: "motion", motion: "moveToStartOfLine" },
    { keys: "^", type: "motion", motion: "moveToFirstNonWhiteSpaceCharacter" },
    { keys: "+", type: "motion", motion: "moveByLines", motionArgs: { forward: true, toFirstChar: true } },
    { keys: "-", type: "motion", motion: "moveByLines", motionArgs: { forward: false, toFirstChar: true } },
    { keys: "_", type: "motion", motion: "moveByLines", motionArgs: { forward: true, toFirstChar: true, repeatOffset: -1 } },
    { keys: "$", type: "motion", motion: "moveToEol", motionArgs: { inclusive: true } },
    { keys: "%", type: "motion", motion: "moveToMatchedSymbol", motionArgs: { inclusive: true, toJumplist: true } },
    { keys: "f<character>", type: "motion", motion: "moveToCharacter", motionArgs: { forward: true, inclusive: true } },
    { keys: "F<character>", type: "motion", motion: "moveToCharacter", motionArgs: { forward: false } },
    { keys: "t<character>", type: "motion", motion: "moveTillCharacter", motionArgs: { forward: true, inclusive: true } },
    { keys: "T<character>", type: "motion", motion: "moveTillCharacter", motionArgs: { forward: false } },
    { keys: ";", type: "motion", motion: "repeatLastCharacterSearch", motionArgs: { forward: true } },
    { keys: ",", type: "motion", motion: "repeatLastCharacterSearch", motionArgs: { forward: false } },
    { keys: "'<register>", type: "motion", motion: "goToMark", motionArgs: { toJumplist: true, linewise: true } },
    { keys: "`<register>", type: "motion", motion: "goToMark", motionArgs: { toJumplist: true } },
    { keys: "]`", type: "motion", motion: "jumpToMark", motionArgs: { forward: true } },
    { keys: "[`", type: "motion", motion: "jumpToMark", motionArgs: { forward: false } },
    { keys: "]'", type: "motion", motion: "jumpToMark", motionArgs: { forward: true, linewise: true } },
    { keys: "['", type: "motion", motion: "jumpToMark", motionArgs: { forward: false, linewise: true } },
    // the next two aren't motions but must come before more general motion declarations
    { keys: "]p", type: "action", action: "paste", isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true } },
    { keys: "[p", type: "action", action: "paste", isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true } },
    { keys: "]<character>", type: "motion", motion: "moveToSymbol", motionArgs: { forward: true, toJumplist: true } },
    { keys: "[<character>", type: "motion", motion: "moveToSymbol", motionArgs: { forward: false, toJumplist: true } },
    { keys: "|", type: "motion", motion: "moveToColumn" },
    { keys: "o", type: "motion", motion: "moveToOtherHighlightedEnd", context: "visual" },
    { keys: "O", type: "motion", motion: "moveToOtherHighlightedEnd", motionArgs: { sameLine: true }, context: "visual" },
    // Operators
    { keys: "d", type: "operator", operator: "delete" },
    { keys: "y", type: "operator", operator: "yank" },
    { keys: "c", type: "operator", operator: "change" },
    { keys: "=", type: "operator", operator: "indentAuto" },
    { keys: ">", type: "operator", operator: "indent", operatorArgs: { indentRight: true } },
    { keys: "<", type: "operator", operator: "indent", operatorArgs: { indentRight: false } },
    { keys: "g~", type: "operator", operator: "changeCase" },
    { keys: "gu", type: "operator", operator: "changeCase", operatorArgs: { toLower: true }, isEdit: true },
    { keys: "gU", type: "operator", operator: "changeCase", operatorArgs: { toLower: false }, isEdit: true },
    { keys: "n", type: "motion", motion: "findNext", motionArgs: { forward: true, toJumplist: true } },
    { keys: "N", type: "motion", motion: "findNext", motionArgs: { forward: false, toJumplist: true } },
    { keys: "gn", type: "motion", motion: "findAndSelectNextInclusive", motionArgs: { forward: true } },
    { keys: "gN", type: "motion", motion: "findAndSelectNextInclusive", motionArgs: { forward: false } },
    { keys: "gq", type: "operator", operator: "hardWrap" },
    { keys: "gw", type: "operator", operator: "hardWrap", operatorArgs: { keepCursor: true } },
    // Operator-Motion dual commands
    { keys: "x", type: "operatorMotion", operator: "delete", motion: "moveByCharacters", motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false } },
    { keys: "X", type: "operatorMotion", operator: "delete", motion: "moveByCharacters", motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true } },
    { keys: "D", type: "operatorMotion", operator: "delete", motion: "moveToEol", motionArgs: { inclusive: true }, context: "normal" },
    { keys: "D", type: "operator", operator: "delete", operatorArgs: { linewise: true }, context: "visual" },
    { keys: "Y", type: "operatorMotion", operator: "yank", motion: "expandToLine", motionArgs: { linewise: true }, context: "normal" },
    { keys: "Y", type: "operator", operator: "yank", operatorArgs: { linewise: true }, context: "visual" },
    { keys: "C", type: "operatorMotion", operator: "change", motion: "moveToEol", motionArgs: { inclusive: true }, context: "normal" },
    { keys: "C", type: "operator", operator: "change", operatorArgs: { linewise: true }, context: "visual" },
    { keys: "~", type: "operatorMotion", operator: "changeCase", motion: "moveByCharacters", motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: "normal" },
    { keys: "~", type: "operator", operator: "changeCase", context: "visual" },
    { keys: "<C-u>", type: "operatorMotion", operator: "delete", motion: "moveToStartOfLine", context: "insert" },
    { keys: "<C-w>", type: "operatorMotion", operator: "delete", motion: "moveByWords", motionArgs: { forward: false, wordEnd: false }, context: "insert" },
    //ignore C-w in normal mode
    { keys: "<C-w>", type: "idle", context: "normal" },
    // Actions
    { keys: "<C-i>", type: "action", action: "jumpListWalk", actionArgs: { forward: true } },
    { keys: "<C-o>", type: "action", action: "jumpListWalk", actionArgs: { forward: false } },
    { keys: "<C-e>", type: "action", action: "scroll", actionArgs: { forward: true, linewise: true } },
    { keys: "<C-y>", type: "action", action: "scroll", actionArgs: { forward: false, linewise: true } },
    { keys: "a", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "charAfter" }, context: "normal" },
    { keys: "A", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "eol" }, context: "normal" },
    { keys: "A", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "endOfSelectedArea" }, context: "visual" },
    { keys: "i", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "inplace" }, context: "normal" },
    { keys: "gi", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "lastEdit" }, context: "normal" },
    { keys: "I", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "firstNonBlank" }, context: "normal" },
    { keys: "gI", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "bol" }, context: "normal" },
    { keys: "I", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "startOfSelectedArea" }, context: "visual" },
    { keys: "o", type: "action", action: "newLineAndEnterInsertMode", isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: "normal" },
    { keys: "O", type: "action", action: "newLineAndEnterInsertMode", isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: "normal" },
    { keys: "v", type: "action", action: "toggleVisualMode" },
    { keys: "V", type: "action", action: "toggleVisualMode", actionArgs: { linewise: true } },
    { keys: "<C-v>", type: "action", action: "toggleVisualMode", actionArgs: { blockwise: true } },
    { keys: "<C-q>", type: "action", action: "toggleVisualMode", actionArgs: { blockwise: true } },
    { keys: "gv", type: "action", action: "reselectLastSelection" },
    { keys: "J", type: "action", action: "joinLines", isEdit: true },
    { keys: "gJ", type: "action", action: "joinLines", actionArgs: { keepSpaces: true }, isEdit: true },
    { keys: "p", type: "action", action: "paste", isEdit: true, actionArgs: { after: true, isEdit: true } },
    { keys: "P", type: "action", action: "paste", isEdit: true, actionArgs: { after: false, isEdit: true } },
    { keys: "r<character>", type: "action", action: "replace", isEdit: true },
    { keys: "@<register>", type: "action", action: "replayMacro" },
    { keys: "q<register>", type: "action", action: "enterMacroRecordMode" },
    // Handle Replace-mode as a special case of insert mode.
    { keys: "R", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { replace: true }, context: "normal" },
    { keys: "R", type: "operator", operator: "change", operatorArgs: { linewise: true, fullLine: true }, context: "visual", exitVisualBlock: true },
    { keys: "u", type: "action", action: "undo", context: "normal" },
    { keys: "u", type: "operator", operator: "changeCase", operatorArgs: { toLower: true }, context: "visual", isEdit: true },
    { keys: "U", type: "operator", operator: "changeCase", operatorArgs: { toLower: false }, context: "visual", isEdit: true },
    { keys: "<C-r>", type: "action", action: "redo" },
    { keys: "m<register>", type: "action", action: "setMark" },
    { keys: '"<register>', type: "action", action: "setRegister" },
    { keys: "<C-r><register>", type: "action", action: "insertRegister", context: "insert", isEdit: true },
    { keys: "<C-o>", type: "action", action: "oneNormalCommand", context: "insert" },
    { keys: "zz", type: "action", action: "scrollToCursor", actionArgs: { position: "center" } },
    { keys: "z.", type: "action", action: "scrollToCursor", actionArgs: { position: "center" }, motion: "moveToFirstNonWhiteSpaceCharacter" },
    { keys: "zt", type: "action", action: "scrollToCursor", actionArgs: { position: "top" } },
    { keys: "z<CR>", type: "action", action: "scrollToCursor", actionArgs: { position: "top" }, motion: "moveToFirstNonWhiteSpaceCharacter" },
    { keys: "zb", type: "action", action: "scrollToCursor", actionArgs: { position: "bottom" } },
    { keys: "z-", type: "action", action: "scrollToCursor", actionArgs: { position: "bottom" }, motion: "moveToFirstNonWhiteSpaceCharacter" },
    { keys: ".", type: "action", action: "repeatLastEdit" },
    { keys: "<C-a>", type: "action", action: "incrementNumberToken", isEdit: true, actionArgs: { increase: true, backtrack: false } },
    { keys: "<C-x>", type: "action", action: "incrementNumberToken", isEdit: true, actionArgs: { increase: false, backtrack: false } },
    { keys: "<C-t>", type: "action", action: "indent", actionArgs: { indentRight: true }, context: "insert" },
    { keys: "<C-d>", type: "action", action: "indent", actionArgs: { indentRight: false }, context: "insert" },
    // Text object motions
    { keys: "a<register>", type: "motion", motion: "textObjectManipulation" },
    { keys: "i<register>", type: "motion", motion: "textObjectManipulation", motionArgs: { textObjectInner: true } },
    // Search
    { keys: "/", type: "search", searchArgs: { forward: true, querySrc: "prompt", toJumplist: true } },
    { keys: "?", type: "search", searchArgs: { forward: false, querySrc: "prompt", toJumplist: true } },
    { keys: "*", type: "search", searchArgs: { forward: true, querySrc: "wordUnderCursor", wholeWordOnly: true, toJumplist: true } },
    { keys: "#", type: "search", searchArgs: { forward: false, querySrc: "wordUnderCursor", wholeWordOnly: true, toJumplist: true } },
    { keys: "g*", type: "search", searchArgs: { forward: true, querySrc: "wordUnderCursor", toJumplist: true } },
    { keys: "g#", type: "search", searchArgs: { forward: false, querySrc: "wordUnderCursor", toJumplist: true } },
    // Ex command
    { keys: ":", type: "ex" }
  ];
  var defaultKeymapLength = defaultKeymap2.length;
  var defaultExCommandMap = [
    { name: "colorscheme", shortName: "colo" },
    { name: "map" },
    { name: "imap", shortName: "im" },
    { name: "nmap", shortName: "nm" },
    { name: "vmap", shortName: "vm" },
    { name: "omap", shortName: "om" },
    { name: "noremap", shortName: "no" },
    { name: "nnoremap", shortName: "nn" },
    { name: "vnoremap", shortName: "vn" },
    { name: "inoremap", shortName: "ino" },
    { name: "onoremap", shortName: "ono" },
    { name: "unmap" },
    { name: "mapclear", shortName: "mapc" },
    { name: "nmapclear", shortName: "nmapc" },
    { name: "vmapclear", shortName: "vmapc" },
    { name: "imapclear", shortName: "imapc" },
    { name: "omapclear", shortName: "omapc" },
    { name: "write", shortName: "w" },
    { name: "undo", shortName: "u" },
    { name: "redo", shortName: "red" },
    { name: "set", shortName: "se" },
    { name: "setlocal", shortName: "setl" },
    { name: "setglobal", shortName: "setg" },
    { name: "sort", shortName: "sor" },
    { name: "substitute", shortName: "s", possiblyAsync: true },
    { name: "startinsert", shortName: "start" },
    { name: "nohlsearch", shortName: "noh" },
    { name: "yank", shortName: "y" },
    { name: "delmarks", shortName: "delm" },
    { name: "registers", shortName: "reg", excludeFromCommandHistory: true },
    { name: "vglobal", shortName: "v" },
    { name: "delete", shortName: "d" },
    { name: "join", shortName: "j" },
    { name: "normal", shortName: "norm" },
    { name: "global", shortName: "g" }
  ];
  var langmap = parseLangmap("");
  function enterVimMode(cm) {
    cm.setOption("disableInput", true);
    cm.setOption("showCursorWhenSelecting", false);
    CodeMirror2.signal(cm, "vim-mode-change", { mode: "normal" });
    cm.on("cursorActivity", onCursorActivity);
    maybeInitVimState(cm);
    CodeMirror2.on(cm.getInputField(), "paste", getOnPasteFn(cm));
  }
  function leaveVimMode(cm) {
    cm.setOption("disableInput", false);
    cm.off("cursorActivity", onCursorActivity);
    CodeMirror2.off(cm.getInputField(), "paste", getOnPasteFn(cm));
    cm.state.vim = null;
    if (highlightTimeout) clearTimeout(highlightTimeout);
  }
  function getOnPasteFn(cm) {
    var vim2 = cm.state.vim;
    if (!vim2.onPasteFn) {
      vim2.onPasteFn = function() {
        if (!vim2.insertMode) {
          cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));
          actions.enterInsertMode(cm, {}, vim2);
        }
      };
    }
    return vim2.onPasteFn;
  }
  var numberRegex = /[\d]/;
  var wordCharTest = [CodeMirror2.isWordChar, function(ch) {
    return ch && !CodeMirror2.isWordChar(ch) && !/\s/.test(ch);
  }], bigWordCharTest = [function(ch) {
    return /\S/.test(ch);
  }];
  var validMarks = ["<", ">"];
  var validRegisters = ["-", '"', ".", ":", "_", "/", "+"];
  var latinCharRegex = /^\w$/;
  var upperCaseChars;
  try {
    upperCaseChars = new RegExp("^[\\p{Lu}]$", "u");
  } catch (_3) {
    upperCaseChars = /^[A-Z]$/;
  }
  function isLine(cm, line2) {
    return line2 >= cm.firstLine() && line2 <= cm.lastLine();
  }
  function isLowerCase(k4) {
    return /^[a-z]$/.test(k4);
  }
  function isMatchableSymbol(k4) {
    return "()[]{}".indexOf(k4) != -1;
  }
  function isNumber2(k4) {
    return numberRegex.test(k4);
  }
  function isUpperCase(k4) {
    return upperCaseChars.test(k4);
  }
  function isWhiteSpaceString(k4) {
    return /^\s*$/.test(k4);
  }
  function isEndOfSentenceSymbol(k4) {
    return ".?!".indexOf(k4) != -1;
  }
  function inArray(val, arr) {
    for (var i4 = 0; i4 < arr.length; i4++) {
      if (arr[i4] == val) {
        return true;
      }
    }
    return false;
  }
  var options2 = {};
  function defineOption(name, defaultValue, type, aliases, callback) {
    if (defaultValue === void 0 && !callback) {
      throw Error("defaultValue is required unless callback is provided");
    }
    if (!type) {
      type = "string";
    }
    options2[name] = {
      type,
      defaultValue,
      callback
    };
    if (aliases) {
      for (var i4 = 0; i4 < aliases.length; i4++) {
        options2[aliases[i4]] = options2[name];
      }
    }
    if (defaultValue) {
      setOption(name, defaultValue);
    }
  }
  function setOption(name, value, cm, cfg) {
    var option = options2[name];
    cfg = cfg || {};
    var scope = cfg.scope;
    if (!option) {
      return new Error("Unknown option: " + name);
    }
    if (option.type == "boolean") {
      if (value && value !== true) {
        return new Error("Invalid argument: " + name + "=" + value);
      } else if (value !== false) {
        value = true;
      }
    }
    if (option.callback) {
      if (scope !== "local") {
        option.callback(value, void 0);
      }
      if (scope !== "global" && cm) {
        option.callback(value, cm);
      }
    } else {
      if (scope !== "local") {
        option.value = option.type == "boolean" ? !!value : value;
      }
      if (scope !== "global" && cm) {
        cm.state.vim.options[name] = { value };
      }
    }
  }
  function getOption(name, cm, cfg) {
    var option = options2[name];
    cfg = cfg || {};
    var scope = cfg.scope;
    if (!option) {
      return new Error("Unknown option: " + name);
    }
    if (option.callback) {
      let local = cm && option.callback(void 0, cm);
      if (scope !== "global" && local !== void 0) {
        return local;
      }
      if (scope !== "local") {
        return option.callback();
      }
      return;
    } else {
      let local = scope !== "global" && (cm && cm.state.vim.options[name]);
      return (local || scope !== "local" && option || {}).value;
    }
  }
  defineOption("filetype", void 0, "string", ["ft"], function(name, cm) {
    if (cm === void 0) {
      return;
    }
    if (name === void 0) {
      let mode = cm.getOption("mode");
      return mode == "null" ? "" : mode;
    } else {
      let mode = name == "" ? "null" : name;
      cm.setOption("mode", mode);
    }
  });
  defineOption("textwidth", 80, "number", ["tw"], function(width, cm) {
    if (cm === void 0) {
      return;
    }
    if (width === void 0) {
      var value = cm.getOption("textwidth");
      return value;
    } else {
      var column2 = Math.round(
        /**@type {any}*/
        width
      );
      if (column2 > 1) {
        cm.setOption("textwidth", column2);
      }
    }
  });
  var createCircularJumpList = function() {
    var size2 = 100;
    var pointer = -1;
    var head = 0;
    var tail = 0;
    var buffer = new Array(size2);
    function add(cm, oldCur, newCur) {
      var current = pointer % size2;
      var curMark = buffer[current];
      function useNextSlot(cursor2) {
        var next3 = ++pointer % size2;
        var trashMark = buffer[next3];
        if (trashMark) {
          trashMark.clear();
        }
        buffer[next3] = cm.setBookmark(cursor2);
      }
      if (curMark) {
        var markPos = curMark.find();
        if (markPos && !cursorEqual(markPos, oldCur)) {
          useNextSlot(oldCur);
        }
      } else {
        useNextSlot(oldCur);
      }
      useNextSlot(newCur);
      head = pointer;
      tail = pointer - size2 + 1;
      if (tail < 0) {
        tail = 0;
      }
    }
    function move(cm, offset3) {
      pointer += offset3;
      if (pointer > head) {
        pointer = head;
      } else if (pointer < tail) {
        pointer = tail;
      }
      var mark = buffer[(size2 + pointer) % size2];
      if (mark && !mark.find()) {
        var inc = offset3 > 0 ? 1 : -1;
        var newCur;
        var oldCur = cm.getCursor();
        do {
          pointer += inc;
          mark = buffer[(size2 + pointer) % size2];
          if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {
            break;
          }
        } while (pointer < head && pointer > tail);
      }
      return mark;
    }
    function find(cm, offset3) {
      var oldPointer = pointer;
      var mark = move(cm, offset3);
      pointer = oldPointer;
      return mark && mark.find();
    }
    return {
      cachedCursor: void 0,
      //used for # and * jumps
      add,
      find,
      move
    };
  };
  var createInsertModeChanges = function(c4) {
    if (c4) {
      return {
        changes: c4.changes,
        expectCursorActivityForChange: c4.expectCursorActivityForChange
      };
    }
    return {
      // Change list
      changes: [],
      // Set to true on change, false on cursorActivity.
      expectCursorActivityForChange: false
    };
  };
  class MacroModeState {
    constructor() {
      this.latestRegister = void 0;
      this.isPlaying = false;
      this.isRecording = false;
      this.replaySearchQueries = [];
      this.onRecordingDone = void 0;
      this.lastInsertModeChanges = createInsertModeChanges();
    }
    exitMacroRecordMode() {
      var macroModeState = vimGlobalState.macroModeState;
      if (macroModeState.onRecordingDone) {
        macroModeState.onRecordingDone();
      }
      macroModeState.onRecordingDone = void 0;
      macroModeState.isRecording = false;
    }
    enterMacroRecordMode(cm, registerName) {
      var register = vimGlobalState.registerController.getRegister(registerName);
      if (register) {
        register.clear();
        this.latestRegister = registerName;
        if (cm.openDialog) {
          var template = dom2("span", { class: "cm-vim-message" }, "recording @" + registerName);
          this.onRecordingDone = cm.openDialog(template, null, { bottom: true });
        }
        this.isRecording = true;
      }
    }
  }
  function maybeInitVimState(cm) {
    if (!cm.state.vim) {
      cm.state.vim = {
        inputState: new InputState(),
        // Vim's input state that triggered the last edit, used to repeat
        // motions and operators with '.'.
        lastEditInputState: void 0,
        // Vim's action command before the last edit, used to repeat actions
        // with '.' and insert mode repeat.
        lastEditActionCommand: void 0,
        // When using jk for navigation, if you move from a longer line to a
        // shorter line, the cursor may clip to the end of the shorter line.
        // If j is pressed again and cursor goes to the next line, the
        // cursor should go back to its horizontal position on the longer
        // line if it can. This is to keep track of the horizontal position.
        lastHPos: -1,
        // Doing the same with screen-position for gj/gk
        lastHSPos: -1,
        // The last motion command run. Cleared if a non-motion command gets
        // executed in between.
        lastMotion: null,
        marks: {},
        insertMode: false,
        insertModeReturn: false,
        // Repeat count for changes made in insert mode, triggered by key
        // sequences like 3,i. Only exists when insertMode is true.
        insertModeRepeat: void 0,
        visualMode: false,
        // If we are in visual line mode. No effect if visualMode is false.
        visualLine: false,
        visualBlock: false,
        lastSelection: null,
        lastPastedText: null,
        sel: {},
        // Buffer-local/window-local values of vim options.
        options: {},
        // Whether the next character should be interpreted literally
        // Necassary for correct implementation of f<character>, r<character> etc.
        // in terms of langmaps.
        expectLiteralNext: false
      };
    }
    return cm.state.vim;
  }
  var vimGlobalState;
  function resetVimGlobalState() {
    vimGlobalState = {
      // The current search query.
      searchQuery: null,
      // Whether we are searching backwards.
      searchIsReversed: false,
      // Replace part of the last substituted pattern
      lastSubstituteReplacePart: void 0,
      jumpList: createCircularJumpList(),
      macroModeState: new MacroModeState(),
      // Recording latest f, t, F or T motion command.
      lastCharacterSearch: { increment: 0, forward: true, selectedCharacter: "" },
      registerController: new RegisterController({}),
      // search history buffer
      searchHistoryController: new HistoryController(),
      // ex Command history buffer
      exCommandHistoryController: new HistoryController()
    };
    for (var optionName in options2) {
      var option = options2[optionName];
      option.value = option.defaultValue;
    }
  }
  var lastInsertModeKeyTimer;
  var vimApi = {
    enterVimMode,
    leaveVimMode,
    buildKeyMap: function() {
    },
    // Testing hook, though it might be useful to expose the register
    // controller anyway.
    getRegisterController: function() {
      return vimGlobalState.registerController;
    },
    // Testing hook.
    resetVimGlobalState_: resetVimGlobalState,
    // Testing hook.
    getVimGlobalState_: function() {
      return vimGlobalState;
    },
    // Testing hook.
    maybeInitVimState_: maybeInitVimState,
    suppressErrorLogging: false,
    InsertModeKey,
    /**@type {(lhs: string, rhs: string, ctx: string) => void} */
    map: function(lhs, rhs, ctx) {
      exCommandDispatcher.map(lhs, rhs, ctx);
    },
    /**@type {(lhs: string, ctx: string) => any} */
    unmap: function(lhs, ctx) {
      return exCommandDispatcher.unmap(lhs, ctx);
    },
    // Non-recursive map function.
    // NOTE: This will not create mappings to key maps that aren't present
    // in the default key map. See TODO at bottom of function.
    /**@type {(lhs: string, rhs: string, ctx: string) => void} */
    noremap: function(lhs, rhs, ctx) {
      exCommandDispatcher.map(lhs, rhs, ctx, true);
    },
    // Remove all user-defined mappings for the provided context.
    /**@arg {string} [ctx]} */
    mapclear: function(ctx) {
      var actualLength = defaultKeymap2.length, origLength = defaultKeymapLength;
      var userKeymap = defaultKeymap2.slice(0, actualLength - origLength);
      defaultKeymap2 = defaultKeymap2.slice(actualLength - origLength);
      if (ctx) {
        for (var i4 = userKeymap.length - 1; i4 >= 0; i4--) {
          var mapping = userKeymap[i4];
          if (ctx !== mapping.context) {
            if (mapping.context) {
              this._mapCommand(mapping);
            } else {
              var contexts = ["normal", "insert", "visual"];
              for (var j4 in contexts) {
                if (contexts[j4] !== ctx) {
                  var newMapping = Object.assign({}, mapping);
                  newMapping.context = contexts[j4];
                  this._mapCommand(newMapping);
                }
              }
            }
          }
        }
      }
    },
    langmap: updateLangmap,
    vimKeyFromEvent,
    // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace
    // them, or somehow make them work with the existing CodeMirror setOption/getOption API.
    setOption,
    getOption,
    defineOption,
    /**@type {(name: string, prefix: string|undefined, func: ExFn) => void} */
    defineEx: function(name, prefix2, func) {
      if (!prefix2) {
        prefix2 = name;
      } else if (name.indexOf(prefix2) !== 0) {
        throw new Error('(Vim.defineEx) "' + prefix2 + '" is not a prefix of "' + name + '", command not registered');
      }
      exCommands[name] = func;
      exCommandDispatcher.commandMap_[prefix2] = { name, shortName: prefix2, type: "api" };
    },
    /**@type {(cm: CodeMirror, key: string, origin: string) => undefined | boolean} */
    handleKey: function(cm, key, origin) {
      var command = this.findKey(cm, key, origin);
      if (typeof command === "function") {
        return command();
      }
    },
    multiSelectHandleKey,
    /**
     * This is the outermost function called by CodeMirror, after keys have
     * been mapped to their Vim equivalents.
     *
     * Finds a command based on the key (and cached keys if there is a
     * multi-key sequence). Returns `undefined` if no key is matched, a noop
     * function if a partial match is found (multi-key), and a function to
     * execute the bound command if a a key is matched. The function always
     * returns true.
     */
    /**@type {(cm_: CodeMirror, key: string, origin?: string| undefined) => (() => boolean) | undefined} */
    findKey: function(cm_, key, origin) {
      var vim2 = maybeInitVimState(cm_);
      var cm = (
        /**@type {CodeMirrorV}*/
        cm_
      );
      function handleMacroRecording() {
        var macroModeState = vimGlobalState.macroModeState;
        if (macroModeState.isRecording) {
          if (key == "q") {
            macroModeState.exitMacroRecordMode();
            clearInputState(cm);
            return true;
          }
          if (origin != "mapping") {
            logKey(macroModeState, key);
          }
        }
      }
      function handleEsc() {
        if (key == "<Esc>") {
          if (vim2.visualMode) {
            exitVisualMode(cm);
          } else if (vim2.insertMode) {
            exitInsertMode(cm);
          } else {
            return;
          }
          clearInputState(cm);
          return true;
        }
      }
      function handleKeyInsertMode() {
        if (handleEsc()) {
          return true;
        }
        vim2.inputState.keyBuffer.push(key);
        var keys2 = vim2.inputState.keyBuffer.join("");
        var keysAreChars = key.length == 1;
        var match4 = commandDispatcher.matchCommand(keys2, defaultKeymap2, vim2.inputState, "insert");
        var changeQueue = vim2.inputState.changeQueue;
        if (match4.type == "none") {
          clearInputState(cm);
          return false;
        } else if (match4.type == "partial") {
          if (match4.expectLiteralNext) vim2.expectLiteralNext = true;
          if (lastInsertModeKeyTimer) {
            window.clearTimeout(lastInsertModeKeyTimer);
          }
          lastInsertModeKeyTimer = keysAreChars && window.setTimeout(
            function() {
              if (vim2.insertMode && vim2.inputState.keyBuffer.length) {
                clearInputState(cm);
              }
            },
            getOption("insertModeEscKeysTimeout")
          );
          if (keysAreChars) {
            var selections = cm.listSelections();
            if (!changeQueue || changeQueue.removed.length != selections.length)
              changeQueue = vim2.inputState.changeQueue = new ChangeQueue();
            changeQueue.inserted += key;
            for (var i4 = 0; i4 < selections.length; i4++) {
              var from2 = cursorMin(selections[i4].anchor, selections[i4].head);
              var to = cursorMax(selections[i4].anchor, selections[i4].head);
              var text2 = cm.getRange(from2, cm.state.overwrite ? offsetCursor(to, 0, 1) : to);
              changeQueue.removed[i4] = (changeQueue.removed[i4] || "") + text2;
            }
          }
          return !keysAreChars;
        }
        vim2.expectLiteralNext = false;
        if (lastInsertModeKeyTimer) {
          window.clearTimeout(lastInsertModeKeyTimer);
        }
        if (match4.command && changeQueue) {
          var selections = cm.listSelections();
          for (var i4 = 0; i4 < selections.length; i4++) {
            var here = selections[i4].head;
            cm.replaceRange(
              changeQueue.removed[i4] || "",
              offsetCursor(here, 0, -changeQueue.inserted.length),
              here,
              "+input"
            );
          }
          vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();
        }
        if (!match4.command) clearInputState(cm);
        return match4.command;
      }
      function handleKeyNonInsertMode() {
        if (handleMacroRecording() || handleEsc()) {
          return true;
        }
        vim2.inputState.keyBuffer.push(key);
        var keys2 = vim2.inputState.keyBuffer.join("");
        if (/^[1-9]\d*$/.test(keys2)) {
          return true;
        }
        var keysMatcher = /^(\d*)(.*)$/.exec(keys2);
        if (!keysMatcher) {
          clearInputState(cm);
          return false;
        }
        var context = vim2.visualMode ? "visual" : "normal";
        var mainKey = keysMatcher[2] || keysMatcher[1];
        if (vim2.inputState.operatorShortcut && vim2.inputState.operatorShortcut.slice(-1) == mainKey) {
          mainKey = vim2.inputState.operatorShortcut;
        }
        var match4 = commandDispatcher.matchCommand(mainKey, defaultKeymap2, vim2.inputState, context);
        if (match4.type == "none") {
          clearInputState(cm);
          return false;
        } else if (match4.type == "partial") {
          if (match4.expectLiteralNext) vim2.expectLiteralNext = true;
          return true;
        } else if (match4.type == "clear") {
          clearInputState(cm);
          return true;
        }
        vim2.expectLiteralNext = false;
        vim2.inputState.keyBuffer.length = 0;
        keysMatcher = /^(\d*)(.*)$/.exec(keys2);
        if (keysMatcher && keysMatcher[1] && keysMatcher[1] != "0") {
          vim2.inputState.pushRepeatDigit(keysMatcher[1]);
        }
        return match4.command;
      }
      var command;
      if (vim2.insertMode) {
        command = handleKeyInsertMode();
      } else {
        command = handleKeyNonInsertMode();
      }
      if (command === false) {
        return !vim2.insertMode && key.length === 1 ? function() {
          return true;
        } : void 0;
      } else if (command === true) {
        return function() {
          return true;
        };
      } else {
        return function() {
          return cm.operation(function() {
            cm.curOp.isVimOp = true;
            try {
              if (command.type == "keyToKey") {
                doKeyToKey(cm, command.toKeys, command);
              } else {
                commandDispatcher.processCommand(cm, vim2, command);
              }
            } catch (e3) {
              cm.state.vim = void 0;
              maybeInitVimState(cm);
              if (!vimApi.suppressErrorLogging) {
                console["log"](e3);
              }
              throw e3;
            }
            return true;
          });
        };
      }
    },
    handleEx: function(cm, input2) {
      exCommandDispatcher.processCommand(cm, input2);
    },
    defineMotion,
    defineAction,
    defineOperator,
    mapCommand,
    _mapCommand,
    defineRegister,
    exitVisualMode,
    exitInsertMode
  };
  var keyToKeyStack = [];
  var noremap = false;
  var virtualPrompt;
  function sendKeyToPrompt(key) {
    if (key[0] == "<") {
      var lowerKey = key.toLowerCase().slice(1, -1);
      var parts = lowerKey.split("-");
      lowerKey = parts.pop() || "";
      if (lowerKey == "lt") key = "<";
      else if (lowerKey == "space") key = " ";
      else if (lowerKey == "cr") key = "\n";
      else if (vimToCmKeyMap[lowerKey]) {
        var value = virtualPrompt.value;
        var event = {
          key: vimToCmKeyMap[lowerKey],
          target: {
            value,
            selectionEnd: value.length,
            selectionStart: value.length
          }
        };
        if (virtualPrompt.onKeyDown) {
          virtualPrompt.onKeyDown(event, virtualPrompt.value, close);
        }
        if (virtualPrompt && virtualPrompt.onKeyUp) {
          virtualPrompt.onKeyUp(event, virtualPrompt.value, close);
        }
        return;
      }
    }
    if (key == "\n") {
      var prompt2 = virtualPrompt;
      virtualPrompt = null;
      prompt2.onClose && prompt2.onClose(prompt2.value);
    } else {
      virtualPrompt.value = (virtualPrompt.value || "") + key;
    }
    function close(value2) {
      if (typeof value2 == "string") {
        virtualPrompt.value = value2;
      } else {
        virtualPrompt = null;
      }
    }
  }
  function doKeyToKey(cm, keys2, fromKey) {
    var noremapBefore = noremap;
    if (fromKey) {
      if (keyToKeyStack.indexOf(fromKey) != -1) return;
      keyToKeyStack.push(fromKey);
      noremap = fromKey.noremap != false;
    }
    try {
      var vim2 = maybeInitVimState(cm);
      var keyRe = /<(?:[CSMA]-)*\w+>|./gi;
      var match4;
      while (match4 = keyRe.exec(keys2)) {
        var key = match4[0];
        var wasInsert = vim2.insertMode;
        if (virtualPrompt) {
          sendKeyToPrompt(key);
          continue;
        }
        var result = vimApi.handleKey(cm, key, "mapping");
        if (!result && wasInsert && vim2.insertMode) {
          if (key[0] == "<") {
            var lowerKey = key.toLowerCase().slice(1, -1);
            var parts = lowerKey.split("-");
            lowerKey = parts.pop() || "";
            if (lowerKey == "lt") key = "<";
            else if (lowerKey == "space") key = " ";
            else if (lowerKey == "cr") key = "\n";
            else if (vimToCmKeyMap.hasOwnProperty(lowerKey)) {
              key = vimToCmKeyMap[lowerKey];
              sendCmKey(cm, key);
              continue;
            } else {
              key = key[0];
              keyRe.lastIndex = match4.index + 1;
            }
          }
          cm.replaceSelection(key);
        }
      }
    } finally {
      keyToKeyStack.pop();
      noremap = keyToKeyStack.length ? noremapBefore : false;
      if (!keyToKeyStack.length && virtualPrompt) {
        var promptOptions = virtualPrompt;
        virtualPrompt = null;
        showPrompt(cm, promptOptions);
      }
    }
  }
  var specialKey = {
    Return: "CR",
    Backspace: "BS",
    "Delete": "Del",
    Escape: "Esc",
    Insert: "Ins",
    ArrowLeft: "Left",
    ArrowRight: "Right",
    ArrowUp: "Up",
    ArrowDown: "Down",
    Enter: "CR",
    " ": "Space"
  };
  var ignoredKeys = {
    Shift: 1,
    Alt: 1,
    Command: 1,
    Control: 1,
    CapsLock: 1,
    AltGraph: 1,
    Dead: 1,
    Unidentified: 1
  };
  var vimToCmKeyMap = {};
  "Left|Right|Up|Down|End|Home".split("|").concat(Object.keys(specialKey)).forEach(function(x4) {
    vimToCmKeyMap[(specialKey[x4] || "").toLowerCase()] = vimToCmKeyMap[x4.toLowerCase()] = x4;
  });
  function vimKeyFromEvent(e3, vim2) {
    var _a;
    var key = e3.key;
    if (ignoredKeys[key]) return;
    if (key.length > 1 && key[0] == "n") {
      key = key.replace("Numpad", "");
    }
    key = specialKey[key] || key;
    var name = "";
    if (e3.ctrlKey) {
      name += "C-";
    }
    if (e3.altKey) {
      name += "A-";
    }
    if (e3.metaKey) {
      name += "M-";
    }
    if (CodeMirror2.isMac && e3.altKey && !e3.metaKey && !e3.ctrlKey) {
      name = name.slice(2);
    }
    if ((name || key.length > 1) && e3.shiftKey) {
      name += "S-";
    }
    if (vim2 && !vim2.expectLiteralNext && key.length == 1) {
      if (langmap.keymap && key in langmap.keymap) {
        if (langmap.remapCtrl != false || !name)
          key = langmap.keymap[key];
      } else if (key.charCodeAt(0) > 255) {
        var code = ((_a = e3.code) == null ? void 0 : _a.slice(-1)) || "";
        if (!e3.shiftKey) code = code.toLowerCase();
        if (code) key = code;
      }
    }
    name += key;
    if (name.length > 1) {
      name = "<" + name + ">";
    }
    return name;
  }
  function updateLangmap(langmapString, remapCtrl) {
    if (langmap.string !== langmapString) {
      langmap = parseLangmap(langmapString);
    }
    langmap.remapCtrl = remapCtrl;
  }
  function parseLangmap(langmapString) {
    let keymap3 = {};
    if (!langmapString) return { keymap: keymap3, string: "" };
    function getEscaped(list) {
      return list.split(/\\?(.)/).filter(Boolean);
    }
    langmapString.split(/((?:[^\\,]|\\.)+),/).map((part) => {
      if (!part) return;
      const semicolon3 = part.split(/((?:[^\\;]|\\.)+);/);
      if (semicolon3.length == 3) {
        const from2 = getEscaped(semicolon3[1]);
        const to = getEscaped(semicolon3[2]);
        if (from2.length !== to.length) return;
        for (let i4 = 0; i4 < from2.length; ++i4) keymap3[from2[i4]] = to[i4];
      } else if (semicolon3.length == 1) {
        const pairs = getEscaped(part);
        if (pairs.length % 2 !== 0) return;
        for (let i4 = 0; i4 < pairs.length; i4 += 2) keymap3[pairs[i4]] = pairs[i4 + 1];
      }
    });
    return { keymap: keymap3, string: langmapString };
  }
  defineOption("langmap", void 0, "string", ["lmap"], function(name, cm) {
    if (name === void 0) {
      return langmap.string;
    } else {
      updateLangmap(name);
    }
  });
  class InputState {
    constructor() {
      this.prefixRepeat = [];
      this.motionRepeat = [];
      this.operator = null;
      this.operatorArgs = null;
      this.motion = null;
      this.motionArgs = null;
      this.keyBuffer = [];
      this.registerName = null;
      this.changeQueue = null;
    }
    pushRepeatDigit(n3) {
      if (!this.operator) {
        this.prefixRepeat = this.prefixRepeat.concat(n3);
      } else {
        this.motionRepeat = this.motionRepeat.concat(n3);
      }
    }
    getRepeat() {
      var repeat = 0;
      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {
        repeat = 1;
        if (this.prefixRepeat.length > 0) {
          repeat *= parseInt(this.prefixRepeat.join(""), 10);
        }
        if (this.motionRepeat.length > 0) {
          repeat *= parseInt(this.motionRepeat.join(""), 10);
        }
      }
      return repeat;
    }
  }
  function clearInputState(cm, reason) {
    cm.state.vim.inputState = new InputState();
    cm.state.vim.expectLiteralNext = false;
    CodeMirror2.signal(cm, "vim-command-done", reason);
  }
  function ChangeQueue() {
    this.removed = [];
    this.inserted = "";
  }
  class Register {
    constructor(text2, linewise, blockwise) {
      this.clear();
      this.keyBuffer = [text2 || ""];
      this.insertModeChanges = [];
      this.searchQueries = [];
      this.linewise = !!linewise;
      this.blockwise = !!blockwise;
    }
    setText(text2, linewise, blockwise) {
      this.keyBuffer = [text2 || ""];
      this.linewise = !!linewise;
      this.blockwise = !!blockwise;
    }
    pushText(text2, linewise) {
      if (linewise) {
        if (!this.linewise) {
          this.keyBuffer.push("\n");
        }
        this.linewise = true;
      }
      this.keyBuffer.push(text2);
    }
    pushInsertModeChanges(changes) {
      this.insertModeChanges.push(createInsertModeChanges(changes));
    }
    pushSearchQuery(query) {
      this.searchQueries.push(query);
    }
    clear() {
      this.keyBuffer = [];
      this.insertModeChanges = [];
      this.searchQueries = [];
      this.linewise = false;
    }
    toString() {
      return this.keyBuffer.join("");
    }
  }
  function defineRegister(name, register) {
    var registers = vimGlobalState.registerController.registers;
    if (!name || name.length != 1) {
      throw Error("Register name must be 1 character");
    }
    if (registers[name]) {
      throw Error("Register already defined " + name);
    }
    registers[name] = register;
    validRegisters.push(name);
  }
  class RegisterController {
    /** @arg {Object<string, Register>} registers */
    constructor(registers) {
      this.registers = registers;
      this.unnamedRegister = registers['"'] = new Register();
      registers["."] = new Register();
      registers[":"] = new Register();
      registers["/"] = new Register();
      registers["+"] = new Register();
    }
    pushText(registerName, operator, text2, linewise, blockwise) {
      if (registerName === "_") return;
      if (linewise && text2.charAt(text2.length - 1) !== "\n") {
        text2 += "\n";
      }
      var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null;
      if (!register) {
        switch (operator) {
          case "yank":
            this.registers["0"] = new Register(text2, linewise, blockwise);
            break;
          case "delete":
          case "change":
            if (text2.indexOf("\n") == -1) {
              this.registers["-"] = new Register(text2, linewise);
            } else {
              this.shiftNumericRegisters_();
              this.registers["1"] = new Register(text2, linewise);
            }
            break;
        }
        this.unnamedRegister.setText(text2, linewise, blockwise);
        return;
      }
      var append2 = isUpperCase(registerName);
      if (append2) {
        register.pushText(text2, linewise);
      } else {
        register.setText(text2, linewise, blockwise);
      }
      if (registerName === "+") {
        navigator.clipboard.writeText(text2);
      }
      this.unnamedRegister.setText(register.toString(), linewise);
    }
    /**
     * Gets the register named @name.  If one of @name doesn't already exist,
     * create it.  If @name is invalid, return the unnamedRegister.
     * @arg {string} [name]
     */
    getRegister(name) {
      if (!this.isValidRegister(name)) {
        return this.unnamedRegister;
      }
      name = name.toLowerCase();
      if (!this.registers[name]) {
        this.registers[name] = new Register();
      }
      return this.registers[name];
    }
    /**@type {{(name: any): name is string}} */
    isValidRegister(name) {
      return name && (inArray(name, validRegisters) || latinCharRegex.test(name));
    }
    shiftNumericRegisters_() {
      for (var i4 = 9; i4 >= 2; i4--) {
        this.registers[i4] = this.getRegister("" + (i4 - 1));
      }
    }
  }
  class HistoryController {
    constructor() {
      this.historyBuffer = [];
      this.iterator = 0;
      this.initialPrefix = null;
    }
    // the input argument here acts a user entered prefix for a small time
    // until we start autocompletion in which case it is the autocompleted.
    nextMatch(input2, up) {
      var historyBuffer = this.historyBuffer;
      var dir = up ? -1 : 1;
      if (this.initialPrefix === null) this.initialPrefix = input2;
      for (var i4 = this.iterator + dir; up ? i4 >= 0 : i4 < historyBuffer.length; i4 += dir) {
        var element = historyBuffer[i4];
        for (var j4 = 0; j4 <= element.length; j4++) {
          if (this.initialPrefix == element.substring(0, j4)) {
            this.iterator = i4;
            return element;
          }
        }
      }
      if (i4 >= historyBuffer.length) {
        this.iterator = historyBuffer.length;
        return this.initialPrefix;
      }
      if (i4 < 0) return input2;
    }
    pushInput(input2) {
      var index2 = this.historyBuffer.indexOf(input2);
      if (index2 > -1) this.historyBuffer.splice(index2, 1);
      if (input2.length) this.historyBuffer.push(input2);
    }
    reset() {
      this.initialPrefix = null;
      this.iterator = this.historyBuffer.length;
    }
  }
  var commandDispatcher = {
    matchCommand: function(keys2, keyMap, inputState, context) {
      var matches = commandMatches(keys2, keyMap, context, inputState);
      if (!matches.full && !matches.partial) {
        return { type: "none" };
      } else if (!matches.full && matches.partial) {
        return {
          type: "partial",
          expectLiteralNext: matches.partial.length == 1 && matches.partial[0].keys.slice(-11) == "<character>"
          // langmap literal logic
        };
      }
      var bestMatch;
      for (var i4 = 0; i4 < matches.full.length; i4++) {
        var match4 = matches.full[i4];
        if (!bestMatch) {
          bestMatch = match4;
        }
      }
      if (bestMatch.keys.slice(-11) == "<character>" || bestMatch.keys.slice(-10) == "<register>") {
        var character2 = lastChar(keys2);
        if (!character2 || character2.length > 1) return { type: "clear" };
        inputState.selectedCharacter = character2;
      }
      return { type: "full", command: bestMatch };
    },
    /**
     * @arg {CodeMirrorV} cm
     * @arg {vimState} vim
     * @arg {vimKey} command
     */
    processCommand: function(cm, vim2, command) {
      vim2.inputState.repeatOverride = command.repeatOverride;
      switch (command.type) {
        case "motion":
          this.processMotion(cm, vim2, command);
          break;
        case "operator":
          this.processOperator(cm, vim2, command);
          break;
        case "operatorMotion":
          this.processOperatorMotion(cm, vim2, command);
          break;
        case "action":
          this.processAction(cm, vim2, command);
          break;
        case "search":
          this.processSearch(cm, vim2, command);
          break;
        case "ex":
        case "keyToEx":
          this.processEx(cm, vim2, command);
          break;
      }
    },
    /**
     * @arg {CodeMirrorV} cm
     * @arg {vimState} vim
     * @arg {import("./types").motionCommand|import("./types").operatorMotionCommand} command
     */
    processMotion: function(cm, vim2, command) {
      vim2.inputState.motion = command.motion;
      vim2.inputState.motionArgs = /**@type {MotionArgs}*/
      copyArgs(command.motionArgs);
      this.evalInput(cm, vim2);
    },
    /**
     * @arg {CodeMirrorV} cm
     * @arg {vimState} vim
     * @arg {import("./types").operatorCommand|import("./types").operatorMotionCommand} command
     */
    processOperator: function(cm, vim2, command) {
      var inputState = vim2.inputState;
      if (inputState.operator) {
        if (inputState.operator == command.operator) {
          inputState.motion = "expandToLine";
          inputState.motionArgs = { linewise: true, repeat: 1 };
          this.evalInput(cm, vim2);
          return;
        } else {
          clearInputState(cm);
        }
      }
      inputState.operator = command.operator;
      inputState.operatorArgs = copyArgs(command.operatorArgs);
      if (command.keys.length > 1) {
        inputState.operatorShortcut = command.keys;
      }
      if (command.exitVisualBlock) {
        vim2.visualBlock = false;
        updateCmSelection(cm);
      }
      if (vim2.visualMode) {
        this.evalInput(cm, vim2);
      }
    },
    /**
     * @arg {CodeMirrorV} cm
     * @arg {vimState} vim
     * @arg {import("./types").operatorMotionCommand} command
     */
    processOperatorMotion: function(cm, vim2, command) {
      var visualMode = vim2.visualMode;
      var operatorMotionArgs = copyArgs(command.operatorMotionArgs);
      if (operatorMotionArgs) {
        if (visualMode && operatorMotionArgs.visualLine) {
          vim2.visualLine = true;
        }
      }
      this.processOperator(cm, vim2, command);
      if (!visualMode) {
        this.processMotion(cm, vim2, command);
      }
    },
    /**
     * @arg {CodeMirrorV} cm
     * @arg {vimState} vim
     * @arg {import("./types").actionCommand} command
     */
    processAction: function(cm, vim2, command) {
      var inputState = vim2.inputState;
      var repeat = inputState.getRepeat();
      var repeatIsExplicit = !!repeat;
      var actionArgs = (
        /**@type {ActionArgs}*/
        copyArgs(command.actionArgs) || { repeat: 1 }
      );
      if (inputState.selectedCharacter) {
        actionArgs.selectedCharacter = inputState.selectedCharacter;
      }
      if (command.operator) {
        this.processOperator(cm, vim2, command);
      }
      if (command.motion) {
        this.processMotion(cm, vim2, command);
      }
      if (command.motion || command.operator) {
        this.evalInput(cm, vim2);
      }
      actionArgs.repeat = repeat || 1;
      actionArgs.repeatIsExplicit = repeatIsExplicit;
      actionArgs.registerName = inputState.registerName;
      clearInputState(cm);
      vim2.lastMotion = null;
      if (command.isEdit) {
        this.recordLastEdit(vim2, inputState, command);
      }
      actions[command.action](cm, actionArgs, vim2);
    },
    /** @arg {CodeMirrorV} cm @arg {vimState} vim @arg {import("./types").searchCommand} command*/
    processSearch: function(cm, vim2, command) {
      if (!cm.getSearchCursor) {
        return;
      }
      var forward = command.searchArgs.forward;
      var wholeWordOnly = command.searchArgs.wholeWordOnly;
      getSearchState(cm).setReversed(!forward);
      var promptPrefix = forward ? "/" : "?";
      var originalQuery = getSearchState(cm).getQuery();
      var originalScrollPos = cm.getScrollInfo();
      function handleQuery(query, ignoreCase, smartCase) {
        vimGlobalState.searchHistoryController.pushInput(query);
        vimGlobalState.searchHistoryController.reset();
        try {
          updateSearchQuery(cm, query, ignoreCase, smartCase);
        } catch (e3) {
          showConfirm(cm, "Invalid regex: " + query);
          clearInputState(cm);
          return;
        }
        commandDispatcher.processMotion(cm, vim2, {
          keys: "",
          type: "motion",
          motion: "findNext",
          motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }
        });
      }
      function onPromptClose(query) {
        cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
        handleQuery(
          query,
          true,
          true
          /** smartCase */
        );
        var macroModeState2 = vimGlobalState.macroModeState;
        if (macroModeState2.isRecording) {
          logSearchQuery(macroModeState2, query);
        }
      }
      function onPromptKeyUp(e3, query, close) {
        var keyName = vimKeyFromEvent(e3), up, offset3;
        if (keyName == "<Up>" || keyName == "<Down>") {
          up = keyName == "<Up>" ? true : false;
          offset3 = e3.target ? e3.target.selectionEnd : 0;
          query = vimGlobalState.searchHistoryController.nextMatch(query, up) || "";
          close(query);
          if (offset3 && e3.target) e3.target.selectionEnd = e3.target.selectionStart = Math.min(offset3, e3.target.value.length);
        } else if (keyName && keyName != "<Left>" && keyName != "<Right>") {
          vimGlobalState.searchHistoryController.reset();
        }
        var parsedQuery;
        try {
          parsedQuery = updateSearchQuery(
            cm,
            query,
            true,
            true
            /** smartCase */
          );
        } catch (e4) {
        }
        if (parsedQuery) {
          cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);
        } else {
          clearSearchHighlight(cm);
          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
        }
      }
      function onPromptKeyDown(e3, query, close) {
        var keyName = vimKeyFromEvent(e3);
        if (keyName == "<Esc>" || keyName == "<C-c>" || keyName == "<C-[>" || keyName == "<BS>" && query == "") {
          vimGlobalState.searchHistoryController.pushInput(query);
          vimGlobalState.searchHistoryController.reset();
          updateSearchQuery(cm, originalQuery);
          clearSearchHighlight(cm);
          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
          CodeMirror2.e_stop(e3);
          clearInputState(cm);
          close();
          cm.focus();
        } else if (keyName == "<Up>" || keyName == "<Down>") {
          CodeMirror2.e_stop(e3);
        } else if (keyName == "<C-u>") {
          CodeMirror2.e_stop(e3);
          close("");
        }
      }
      switch (command.searchArgs.querySrc) {
        case "prompt":
          var macroModeState = vimGlobalState.macroModeState;
          if (macroModeState.isPlaying) {
            let query2 = macroModeState.replaySearchQueries.shift();
            handleQuery(
              query2,
              true,
              false
              /** smartCase */
            );
          } else {
            showPrompt(cm, {
              onClose: onPromptClose,
              prefix: promptPrefix,
              desc: "(JavaScript regexp)",
              onKeyUp: onPromptKeyUp,
              onKeyDown: onPromptKeyDown
            });
          }
          break;
        case "wordUnderCursor":
          var word = expandWordUnderCursor(cm, { noSymbol: true });
          var isKeyword = true;
          if (!word) {
            word = expandWordUnderCursor(cm, { noSymbol: false });
            isKeyword = false;
          }
          if (!word) {
            showConfirm(cm, "No word under cursor");
            clearInputState(cm);
            return;
          }
          let query = cm.getLine(word.start.line).substring(
            word.start.ch,
            word.end.ch
          );
          if (isKeyword && wholeWordOnly) {
            query = "\\b" + query + "\\b";
          } else {
            query = escapeRegex2(query);
          }
          vimGlobalState.jumpList.cachedCursor = cm.getCursor();
          cm.setCursor(word.start);
          handleQuery(
            query,
            true,
            false
            /** smartCase */
          );
          break;
      }
    },
    /**
     * @arg {CodeMirrorV} cm
     * @arg {vimState} vim
     * @arg {import("./types").exCommand | import("./types").keyToExCommand} command
     */
    processEx: function(cm, vim2, command) {
      function onPromptClose(input2) {
        vimGlobalState.exCommandHistoryController.pushInput(input2);
        vimGlobalState.exCommandHistoryController.reset();
        exCommandDispatcher.processCommand(cm, input2);
        if (cm.state.vim) clearInputState(cm);
      }
      function onPromptKeyDown(e3, input2, close) {
        var keyName = vimKeyFromEvent(e3), up, offset3;
        if (keyName == "<Esc>" || keyName == "<C-c>" || keyName == "<C-[>" || keyName == "<BS>" && input2 == "") {
          vimGlobalState.exCommandHistoryController.pushInput(input2);
          vimGlobalState.exCommandHistoryController.reset();
          CodeMirror2.e_stop(e3);
          clearInputState(cm);
          close();
          cm.focus();
        }
        if (keyName == "<Up>" || keyName == "<Down>") {
          CodeMirror2.e_stop(e3);
          up = keyName == "<Up>" ? true : false;
          offset3 = e3.target ? e3.target.selectionEnd : 0;
          input2 = vimGlobalState.exCommandHistoryController.nextMatch(input2, up) || "";
          close(input2);
          if (offset3 && e3.target) e3.target.selectionEnd = e3.target.selectionStart = Math.min(offset3, e3.target.value.length);
        } else if (keyName == "<C-u>") {
          CodeMirror2.e_stop(e3);
          close("");
        } else if (keyName && keyName != "<Left>" && keyName != "<Right>") {
          vimGlobalState.exCommandHistoryController.reset();
        }
      }
      if (command.type == "keyToEx") {
        exCommandDispatcher.processCommand(cm, command.exArgs.input);
      } else {
        if (vim2.visualMode) {
          showPrompt(cm, {
            onClose: onPromptClose,
            prefix: ":",
            value: "'<,'>",
            onKeyDown: onPromptKeyDown,
            selectValueOnOpen: false
          });
        } else {
          showPrompt(cm, {
            onClose: onPromptClose,
            prefix: ":",
            onKeyDown: onPromptKeyDown
          });
        }
      }
    },
    /**@arg {CodeMirrorV} cm   @arg {vimState} vim */
    evalInput: function(cm, vim2) {
      var inputState = vim2.inputState;
      var motion = inputState.motion;
      var motionArgs = inputState.motionArgs || { repeat: 1 };
      var operator = inputState.operator;
      var operatorArgs = inputState.operatorArgs || {};
      var registerName = inputState.registerName;
      var sel = vim2.sel;
      var origHead = copyCursor(vim2.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor("head"));
      var origAnchor = copyCursor(vim2.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor("anchor"));
      var oldHead = copyCursor(origHead);
      var oldAnchor = copyCursor(origAnchor);
      var newHead, newAnchor;
      var repeat;
      if (operator) {
        this.recordLastEdit(vim2, inputState);
      }
      if (inputState.repeatOverride !== void 0) {
        repeat = inputState.repeatOverride;
      } else {
        repeat = inputState.getRepeat();
      }
      if (repeat > 0 && motionArgs.explicitRepeat) {
        motionArgs.repeatIsExplicit = true;
      } else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {
        repeat = 1;
        motionArgs.repeatIsExplicit = false;
      }
      if (inputState.selectedCharacter) {
        motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;
      }
      motionArgs.repeat = repeat;
      clearInputState(cm);
      if (motion) {
        var motionResult = motions[motion](cm, origHead, motionArgs, vim2, inputState);
        vim2.lastMotion = motions[motion];
        if (!motionResult) {
          return;
        }
        if (motionArgs.toJumplist) {
          var jumpList = vimGlobalState.jumpList;
          var cachedCursor = jumpList.cachedCursor;
          if (cachedCursor) {
            recordJumpPosition(cm, cachedCursor, motionResult);
            delete jumpList.cachedCursor;
          } else {
            recordJumpPosition(cm, origHead, motionResult);
          }
        }
        if (motionResult instanceof Array) {
          newAnchor = motionResult[0];
          newHead = motionResult[1];
        } else {
          newHead = motionResult;
        }
        if (!newHead) {
          newHead = copyCursor(origHead);
        }
        if (vim2.visualMode) {
          if (!(vim2.visualBlock && newHead.ch === Infinity)) {
            newHead = clipCursorToContent(cm, newHead, oldHead);
          }
          if (newAnchor) {
            newAnchor = clipCursorToContent(cm, newAnchor);
          }
          newAnchor = newAnchor || oldAnchor;
          sel.anchor = newAnchor;
          sel.head = newHead;
          updateCmSelection(cm);
          updateMark(
            cm,
            vim2,
            "<",
            cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead
          );
          updateMark(
            cm,
            vim2,
            ">",
            cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor
          );
        } else if (!operator) {
          newHead = clipCursorToContent(cm, newHead, oldHead);
          cm.setCursor(newHead.line, newHead.ch);
        }
      }
      if (operator) {
        if (operatorArgs.lastSel) {
          newAnchor = oldAnchor;
          var lastSel = operatorArgs.lastSel;
          var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);
          var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);
          if (lastSel.visualLine) {
            newHead = new Pos2(oldAnchor.line + lineOffset, oldAnchor.ch);
          } else if (lastSel.visualBlock) {
            newHead = new Pos2(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);
          } else if (lastSel.head.line == lastSel.anchor.line) {
            newHead = new Pos2(oldAnchor.line, oldAnchor.ch + chOffset);
          } else {
            newHead = new Pos2(oldAnchor.line + lineOffset, oldAnchor.ch);
          }
          vim2.visualMode = true;
          vim2.visualLine = lastSel.visualLine;
          vim2.visualBlock = lastSel.visualBlock;
          sel = vim2.sel = {
            anchor: newAnchor,
            head: newHead
          };
          updateCmSelection(cm);
        } else if (vim2.visualMode) {
          operatorArgs.lastSel = {
            anchor: copyCursor(sel.anchor),
            head: copyCursor(sel.head),
            visualBlock: vim2.visualBlock,
            visualLine: vim2.visualLine
          };
        }
        var curStart, curEnd, linewise;
        var mode;
        var cmSel;
        if (vim2.visualMode) {
          curStart = cursorMin(sel.head, sel.anchor);
          curEnd = cursorMax(sel.head, sel.anchor);
          linewise = vim2.visualLine || operatorArgs.linewise;
          mode = vim2.visualBlock ? "block" : linewise ? "line" : "char";
          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);
          cmSel = makeCmSelection(cm, {
            anchor: newPositions.start,
            head: newPositions.end
          }, mode);
          if (linewise) {
            var ranges = cmSel.ranges;
            if (mode == "block") {
              for (var i4 = 0; i4 < ranges.length; i4++) {
                ranges[i4].head.ch = lineLength(cm, ranges[i4].head.line);
              }
            } else if (mode == "line") {
              ranges[0].head = new Pos2(ranges[0].head.line + 1, 0);
            }
          }
        } else {
          curStart = copyCursor(newAnchor || oldAnchor);
          curEnd = copyCursor(newHead || oldHead);
          if (cursorIsBefore(curEnd, curStart)) {
            var tmp = curStart;
            curStart = curEnd;
            curEnd = tmp;
          }
          linewise = motionArgs.linewise || operatorArgs.linewise;
          if (linewise) {
            expandSelectionToLine(cm, curStart, curEnd);
          } else if (motionArgs.forward) {
            clipToLine(cm, curStart, curEnd);
          }
          mode = "char";
          var exclusive = !motionArgs.inclusive || linewise;
          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);
          cmSel = makeCmSelection(cm, {
            anchor: newPositions.start,
            head: newPositions.end
          }, mode, exclusive);
        }
        cm.setSelections(cmSel.ranges, cmSel.primary);
        vim2.lastMotion = null;
        operatorArgs.repeat = repeat;
        operatorArgs.registerName = registerName;
        operatorArgs.linewise = linewise;
        var operatorMoveTo = operators[operator](
          cm,
          operatorArgs,
          cmSel.ranges,
          oldAnchor,
          newHead
        );
        if (vim2.visualMode) {
          exitVisualMode(cm, operatorMoveTo != null);
        }
        if (operatorMoveTo) {
          cm.setCursor(operatorMoveTo);
        }
      }
    },
    /**@arg {vimState} vim  @arg {InputStateInterface} inputState, @arg {import("./types").actionCommand} [actionCommand] */
    recordLastEdit: function(vim2, inputState, actionCommand) {
      var macroModeState = vimGlobalState.macroModeState;
      if (macroModeState.isPlaying) {
        return;
      }
      vim2.lastEditInputState = inputState;
      vim2.lastEditActionCommand = actionCommand;
      macroModeState.lastInsertModeChanges.changes = [];
      macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;
      macroModeState.lastInsertModeChanges.visualBlock = vim2.visualBlock ? vim2.sel.head.line - vim2.sel.anchor.line : 0;
    }
  };
  var motions = {
    moveToTopLine: function(cm, _head, motionArgs) {
      var line2 = getUserVisibleLines(cm).top + motionArgs.repeat - 1;
      return new Pos2(line2, findFirstNonWhiteSpaceCharacter(cm.getLine(line2)));
    },
    moveToMiddleLine: function(cm) {
      var range = getUserVisibleLines(cm);
      var line2 = Math.floor((range.top + range.bottom) * 0.5);
      return new Pos2(line2, findFirstNonWhiteSpaceCharacter(cm.getLine(line2)));
    },
    moveToBottomLine: function(cm, _head, motionArgs) {
      var line2 = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;
      return new Pos2(line2, findFirstNonWhiteSpaceCharacter(cm.getLine(line2)));
    },
    expandToLine: function(_cm, head, motionArgs) {
      var cur2 = head;
      return new Pos2(cur2.line + motionArgs.repeat - 1, Infinity);
    },
    findNext: function(cm, _head, motionArgs) {
      var state2 = getSearchState(cm);
      var query = state2.getQuery();
      if (!query) {
        return;
      }
      var prev2 = !motionArgs.forward;
      prev2 = state2.isReversed() ? !prev2 : prev2;
      highlightSearchMatches(cm, query);
      return findNext(cm, prev2, query, motionArgs.repeat);
    },
    /**
     * Find and select the next occurrence of the search query. If the cursor is currently
     * within a match, then find and select the current match. Otherwise, find the next occurrence in the
     * appropriate direction.
     *
     * This differs from `findNext` in the following ways:
     *
     * 1. Instead of only returning the "from", this returns a "from", "to" range.
     * 2. If the cursor is currently inside a search match, this selects the current match
     *    instead of the next match.
     * 3. If there is no associated operator, this will turn on visual mode.
     */
    findAndSelectNextInclusive: function(cm, _head, motionArgs, vim2, prevInputState) {
      var state2 = getSearchState(cm);
      var query = state2.getQuery();
      if (!query) {
        return;
      }
      var prev2 = !motionArgs.forward;
      prev2 = state2.isReversed() ? !prev2 : prev2;
      var next3 = findNextFromAndToInclusive(cm, prev2, query, motionArgs.repeat, vim2);
      if (!next3) {
        return;
      }
      if (prevInputState.operator) {
        return next3;
      }
      var from2 = next3[0];
      var to = new Pos2(next3[1].line, next3[1].ch - 1);
      if (vim2.visualMode) {
        if (vim2.visualLine || vim2.visualBlock) {
          vim2.visualLine = false;
          vim2.visualBlock = false;
          CodeMirror2.signal(cm, "vim-mode-change", { mode: "visual", subMode: "" });
        }
        var anchor = vim2.sel.anchor;
        if (anchor) {
          if (state2.isReversed()) {
            if (motionArgs.forward) {
              return [anchor, from2];
            }
            return [anchor, to];
          } else {
            if (motionArgs.forward) {
              return [anchor, to];
            }
            return [anchor, from2];
          }
        }
      } else {
        vim2.visualMode = true;
        vim2.visualLine = false;
        vim2.visualBlock = false;
        CodeMirror2.signal(cm, "vim-mode-change", { mode: "visual", subMode: "" });
      }
      return prev2 ? [to, from2] : [from2, to];
    },
    goToMark: function(cm, _head, motionArgs, vim2) {
      var pos = getMarkPos(cm, vim2, motionArgs.selectedCharacter || "");
      if (pos) {
        return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;
      }
      return null;
    },
    moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim2) {
      if (vim2.visualBlock && motionArgs.sameLine) {
        var sel = vim2.sel;
        return [
          clipCursorToContent(cm, new Pos2(sel.anchor.line, sel.head.ch)),
          clipCursorToContent(cm, new Pos2(sel.head.line, sel.anchor.ch))
        ];
      } else {
        return [vim2.sel.head, vim2.sel.anchor];
      }
    },
    jumpToMark: function(cm, head, motionArgs, vim2) {
      var best = head;
      for (var i4 = 0; i4 < motionArgs.repeat; i4++) {
        var cursor2 = best;
        for (var key in vim2.marks) {
          if (!isLowerCase(key)) {
            continue;
          }
          var mark = vim2.marks[key].find();
          var isWrongDirection = motionArgs.forward ? (
            // @ts-ignore
            cursorIsBefore(mark, cursor2)
          ) : cursorIsBefore(cursor2, mark);
          if (isWrongDirection) {
            continue;
          }
          if (motionArgs.linewise && mark.line == cursor2.line) {
            continue;
          }
          var equal = cursorEqual(cursor2, best);
          var between = motionArgs.forward ? (
            // @ts-ignore
            cursorIsBetween(cursor2, mark, best)
          ) : (
            // @ts-ignore
            cursorIsBetween(best, mark, cursor2)
          );
          if (equal || between) {
            best = mark;
          }
        }
      }
      if (motionArgs.linewise) {
        best = new Pos2(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));
      }
      return best;
    },
    moveByCharacters: function(_cm, head, motionArgs) {
      var cur2 = head;
      var repeat = motionArgs.repeat;
      var ch = motionArgs.forward ? cur2.ch + repeat : cur2.ch - repeat;
      return new Pos2(cur2.line, ch);
    },
    moveByLines: function(cm, head, motionArgs, vim2) {
      var cur2 = head;
      var endCh = cur2.ch;
      switch (vim2.lastMotion) {
        case this.moveByLines:
        case this.moveByDisplayLines:
        case this.moveByScroll:
        case this.moveToColumn:
        case this.moveToEol:
          endCh = vim2.lastHPos;
          break;
        default:
          vim2.lastHPos = endCh;
      }
      var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);
      var line2 = motionArgs.forward ? cur2.line + repeat : cur2.line - repeat;
      var first = cm.firstLine();
      var last = cm.lastLine();
      var posV = cm.findPosV(cur2, motionArgs.forward ? repeat : -repeat, "line", vim2.lastHSPos);
      var hasMarkedText = motionArgs.forward ? posV.line > line2 : posV.line < line2;
      if (hasMarkedText) {
        line2 = posV.line;
        endCh = posV.ch;
      }
      if (line2 < first && cur2.line == first) {
        return this.moveToStartOfLine(cm, head, motionArgs, vim2);
      } else if (line2 > last && cur2.line == last) {
        return moveToEol(cm, head, motionArgs, vim2, true);
      }
      if (motionArgs.toFirstChar) {
        endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line2));
        vim2.lastHPos = endCh;
      }
      vim2.lastHSPos = cm.charCoords(new Pos2(line2, endCh), "div").left;
      return new Pos2(line2, endCh);
    },
    moveByDisplayLines: function(cm, head, motionArgs, vim2) {
      var cur2 = head;
      switch (vim2.lastMotion) {
        case this.moveByDisplayLines:
        case this.moveByScroll:
        case this.moveByLines:
        case this.moveToColumn:
        case this.moveToEol:
          break;
        default:
          vim2.lastHSPos = cm.charCoords(cur2, "div").left;
      }
      var repeat = motionArgs.repeat;
      var res = cm.findPosV(cur2, motionArgs.forward ? repeat : -repeat, "line", vim2.lastHSPos);
      if (res.hitSide) {
        if (motionArgs.forward) {
          var lastCharCoords = cm.charCoords(res, "div");
          var goalCoords = { top: lastCharCoords.top + 8, left: vim2.lastHSPos };
          res = cm.coordsChar(goalCoords, "div");
        } else {
          var resCoords = cm.charCoords(new Pos2(cm.firstLine(), 0), "div");
          resCoords.left = vim2.lastHSPos;
          res = cm.coordsChar(resCoords, "div");
        }
      }
      vim2.lastHPos = res.ch;
      return res;
    },
    moveByPage: function(cm, head, motionArgs) {
      var curStart = head;
      var repeat = motionArgs.repeat;
      return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, "page");
    },
    moveByParagraph: function(cm, head, motionArgs) {
      var dir = motionArgs.forward ? 1 : -1;
      return findParagraph(cm, head, motionArgs.repeat, dir).start;
    },
    moveBySentence: function(cm, head, motionArgs) {
      var dir = motionArgs.forward ? 1 : -1;
      return findSentence(cm, head, motionArgs.repeat, dir);
    },
    moveByScroll: function(cm, head, motionArgs, vim2) {
      var scrollbox = cm.getScrollInfo();
      var curEnd = null;
      var repeat = motionArgs.repeat;
      if (!repeat) {
        repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());
      }
      var orig = cm.charCoords(head, "local");
      motionArgs.repeat = repeat;
      curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim2);
      if (!curEnd) {
        return null;
      }
      var dest = cm.charCoords(curEnd, "local");
      cm.scrollTo(null, scrollbox.top + dest.top - orig.top);
      return curEnd;
    },
    moveByWords: function(cm, head, motionArgs) {
      return moveToWord(
        cm,
        head,
        motionArgs.repeat,
        !!motionArgs.forward,
        !!motionArgs.wordEnd,
        !!motionArgs.bigWord
      );
    },
    moveTillCharacter: function(cm, head, motionArgs) {
      var repeat = motionArgs.repeat;
      var curEnd = moveToCharacter(
        cm,
        repeat,
        motionArgs.forward,
        motionArgs.selectedCharacter,
        head
      );
      var increment = motionArgs.forward ? -1 : 1;
      recordLastCharacterSearch(increment, motionArgs);
      if (!curEnd) return null;
      curEnd.ch += increment;
      return curEnd;
    },
    moveToCharacter: function(cm, head, motionArgs) {
      var repeat = motionArgs.repeat;
      recordLastCharacterSearch(0, motionArgs);
      return moveToCharacter(
        cm,
        repeat,
        motionArgs.forward,
        motionArgs.selectedCharacter,
        head
      ) || head;
    },
    moveToSymbol: function(cm, head, motionArgs) {
      var repeat = motionArgs.repeat;
      return motionArgs.selectedCharacter && findSymbol(
        cm,
        repeat,
        motionArgs.forward,
        motionArgs.selectedCharacter
      ) || head;
    },
    moveToColumn: function(cm, head, motionArgs, vim2) {
      var repeat = motionArgs.repeat;
      vim2.lastHPos = repeat - 1;
      vim2.lastHSPos = cm.charCoords(head, "div").left;
      return moveToColumn(cm, repeat);
    },
    moveToEol: function(cm, head, motionArgs, vim2) {
      return moveToEol(cm, head, motionArgs, vim2, false);
    },
    moveToFirstNonWhiteSpaceCharacter: function(cm, head) {
      var cursor2 = head;
      return new Pos2(
        cursor2.line,
        findFirstNonWhiteSpaceCharacter(cm.getLine(cursor2.line))
      );
    },
    moveToMatchedSymbol: function(cm, head) {
      var cursor2 = head;
      var line2 = cursor2.line;
      var ch = cursor2.ch;
      var lineText = cm.getLine(line2);
      var symbol;
      for (; ch < lineText.length; ch++) {
        symbol = lineText.charAt(ch);
        if (symbol && isMatchableSymbol(symbol)) {
          var style = cm.getTokenTypeAt(new Pos2(line2, ch + 1));
          if (style !== "string" && style !== "comment") {
            break;
          }
        }
      }
      if (ch < lineText.length) {
        var re = symbol === "<" || symbol === ">" ? /[(){}[\]<>]/ : /[(){}[\]]/;
        var matched = cm.findMatchingBracket(new Pos2(line2, ch), { bracketRegex: re });
        return matched.to;
      } else {
        return cursor2;
      }
    },
    moveToStartOfLine: function(_cm, head) {
      return new Pos2(head.line, 0);
    },
    moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {
      var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();
      if (motionArgs.repeatIsExplicit) {
        lineNum = motionArgs.repeat - cm.getOption("firstLineNumber");
      }
      return new Pos2(
        lineNum,
        findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum))
      );
    },
    moveToStartOfDisplayLine: function(cm) {
      cm.execCommand("goLineLeft");
      return cm.getCursor();
    },
    moveToEndOfDisplayLine: function(cm) {
      cm.execCommand("goLineRight");
      var head = cm.getCursor();
      if (head.sticky == "before") head.ch--;
      return head;
    },
    textObjectManipulation: function(cm, head, motionArgs, vim2) {
      var mirroredPairs = {
        "(": ")",
        ")": "(",
        "{": "}",
        "}": "{",
        "[": "]",
        "]": "[",
        "<": ">",
        ">": "<"
      };
      var selfPaired = { "'": true, '"': true, "`": true };
      var character2 = motionArgs.selectedCharacter || "";
      if (character2 == "b") {
        character2 = "(";
      } else if (character2 == "B") {
        character2 = "{";
      }
      var inclusive = !motionArgs.textObjectInner;
      var tmp, move;
      if (mirroredPairs[character2]) {
        move = true;
        tmp = selectCompanionObject(cm, head, character2, inclusive);
        if (!tmp) {
          var sc = cm.getSearchCursor(new RegExp("\\" + character2, "g"), head);
          if (sc.find()) {
            tmp = selectCompanionObject(cm, sc.from(), character2, inclusive);
          }
        }
      } else if (selfPaired[character2]) {
        move = true;
        tmp = findBeginningAndEnd(cm, head, character2, inclusive);
      } else if (character2 === "W" || character2 === "w") {
        var repeat = motionArgs.repeat || 1;
        while (repeat-- > 0) {
          var repeated = expandWordUnderCursor(cm, {
            inclusive,
            innerWord: !inclusive,
            bigWord: character2 === "W",
            noSymbol: character2 === "W",
            multiline: true
          }, tmp && tmp.end);
          if (repeated) {
            if (!tmp) tmp = repeated;
            tmp.end = repeated.end;
          }
        }
      } else if (character2 === "p") {
        tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);
        motionArgs.linewise = true;
        if (vim2.visualMode) {
          if (!vim2.visualLine) {
            vim2.visualLine = true;
          }
        } else {
          var operatorArgs = vim2.inputState.operatorArgs;
          if (operatorArgs) {
            operatorArgs.linewise = true;
          }
          tmp.end.line--;
        }
      } else if (character2 === "t") {
        tmp = expandTagUnderCursor(cm, head, inclusive);
      } else if (character2 === "s") {
        var content = cm.getLine(head.line);
        if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {
          head.ch -= 1;
        }
        var end2 = getSentence(cm, head, motionArgs.repeat, 1, inclusive);
        var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);
        if (isWhiteSpaceString(cm.getLine(start.line)[start.ch]) && isWhiteSpaceString(cm.getLine(end2.line)[end2.ch - 1])) {
          start = { line: start.line, ch: start.ch + 1 };
        }
        tmp = { start, end: end2 };
      }
      if (!tmp) {
        return null;
      }
      if (!cm.state.vim.visualMode) {
        return [tmp.start, tmp.end];
      } else {
        return expandSelection(cm, tmp.start, tmp.end, move);
      }
    },
    repeatLastCharacterSearch: function(cm, head, motionArgs) {
      var lastSearch = vimGlobalState.lastCharacterSearch;
      var repeat = motionArgs.repeat;
      var forward = motionArgs.forward === lastSearch.forward;
      var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);
      cm.moveH(-increment, "char");
      motionArgs.inclusive = forward ? true : false;
      var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);
      if (!curEnd) {
        cm.moveH(increment, "char");
        return head;
      }
      curEnd.ch += increment;
      return curEnd;
    }
  };
  function defineMotion(name, fn2) {
    motions[name] = fn2;
  }
  function fillArray(val, times) {
    var arr = [];
    for (var i4 = 0; i4 < times; i4++) {
      arr.push(val);
    }
    return arr;
  }
  var operators = {
    change: function(cm, args, ranges) {
      var finalHead, text2;
      var vim2 = cm.state.vim;
      var anchor = ranges[0].anchor, head = ranges[0].head;
      if (!vim2.visualMode) {
        text2 = cm.getRange(anchor, head);
        var lastState = vim2.lastEditInputState;
        if ((lastState == null ? void 0 : lastState.motion) == "moveByWords" && !isWhiteSpaceString(text2)) {
          var match4 = /\s+$/.exec(text2);
          if (match4 && lastState.motionArgs && lastState.motionArgs.forward) {
            head = offsetCursor(head, 0, -match4[0].length);
            text2 = text2.slice(0, -match4[0].length);
          }
        }
        if (args.linewise) {
          anchor = new Pos2(anchor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(anchor.line)));
          if (head.line > anchor.line) {
            head = new Pos2(head.line - 1, Number.MAX_VALUE);
          }
        }
        cm.replaceRange("", anchor, head);
        finalHead = anchor;
      } else if (args.fullLine) {
        head.ch = Number.MAX_VALUE;
        head.line--;
        cm.setSelection(anchor, head);
        text2 = cm.getSelection();
        cm.replaceSelection("");
        finalHead = anchor;
      } else {
        text2 = cm.getSelection();
        var replacement = fillArray("", ranges.length);
        cm.replaceSelections(replacement);
        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);
      }
      vimGlobalState.registerController.pushText(
        args.registerName,
        "change",
        text2,
        args.linewise,
        ranges.length > 1
      );
      actions.enterInsertMode(cm, { head: finalHead }, cm.state.vim);
    },
    delete: function(cm, args, ranges) {
      var finalHead, text2;
      var vim2 = cm.state.vim;
      if (!vim2.visualBlock) {
        var anchor = ranges[0].anchor, head = ranges[0].head;
        if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) {
          if (anchor.line == cm.firstLine()) {
            anchor.ch = 0;
          } else {
            anchor = new Pos2(anchor.line - 1, lineLength(cm, anchor.line - 1));
          }
        }
        text2 = cm.getRange(anchor, head);
        cm.replaceRange("", anchor, head);
        finalHead = anchor;
        if (args.linewise) {
          finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);
        }
      } else {
        text2 = cm.getSelection();
        var replacement = fillArray("", ranges.length);
        cm.replaceSelections(replacement);
        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);
      }
      vimGlobalState.registerController.pushText(
        args.registerName,
        "delete",
        text2,
        args.linewise,
        vim2.visualBlock
      );
      return clipCursorToContent(cm, finalHead);
    },
    indent: function(cm, args, ranges) {
      var vim2 = cm.state.vim;
      var repeat = vim2.visualMode ? args.repeat || 0 : 1;
      if (cm.indentMore) {
        for (var j4 = 0; j4 < repeat; j4++) {
          if (args.indentRight) cm.indentMore();
          else cm.indentLess();
        }
      } else {
        var startLine = ranges[0].anchor.line;
        var endLine = vim2.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line;
        if (args.linewise) {
          endLine--;
        }
        for (var i4 = startLine; i4 <= endLine; i4++) {
          for (var j4 = 0; j4 < repeat; j4++) {
            cm.indentLine(i4, args.indentRight);
          }
        }
      }
      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
    },
    indentAuto: function(cm, _args, ranges) {
      cm.execCommand("indentAuto");
      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
    },
    hardWrap: function(cm, operatorArgs, ranges, oldAnchor) {
      if (!cm.hardWrap) return;
      var from2 = ranges[0].anchor.line;
      var to = ranges[0].head.line;
      if (operatorArgs.linewise) to--;
      var endRow = cm.hardWrap({ from: from2, to });
      if (endRow > from2 && operatorArgs.linewise) endRow--;
      return operatorArgs.keepCursor ? oldAnchor : new Pos2(endRow, 0);
    },
    changeCase: function(cm, args, ranges, oldAnchor, newHead) {
      var selections = cm.getSelections();
      var swapped = [];
      var toLower = args.toLower;
      for (var j4 = 0; j4 < selections.length; j4++) {
        var toSwap = selections[j4];
        var text2 = "";
        if (toLower === true) {
          text2 = toSwap.toLowerCase();
        } else if (toLower === false) {
          text2 = toSwap.toUpperCase();
        } else {
          for (var i4 = 0; i4 < toSwap.length; i4++) {
            var character2 = toSwap.charAt(i4);
            text2 += isUpperCase(character2) ? character2.toLowerCase() : character2.toUpperCase();
          }
        }
        swapped.push(text2);
      }
      cm.replaceSelections(swapped);
      if (args.shouldMoveCursor) {
        return newHead;
      } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {
        return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);
      } else if (args.linewise) {
        return oldAnchor;
      } else {
        return cursorMin(ranges[0].anchor, ranges[0].head);
      }
    },
    yank: function(cm, args, ranges, oldAnchor) {
      var vim2 = cm.state.vim;
      var text2 = cm.getSelection();
      var endPos = vim2.visualMode ? cursorMin(vim2.sel.anchor, vim2.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;
      vimGlobalState.registerController.pushText(
        args.registerName,
        "yank",
        text2,
        args.linewise,
        vim2.visualBlock
      );
      return endPos;
    }
  };
  function defineOperator(name, fn2) {
    operators[name] = fn2;
  }
  var actions = {
    jumpListWalk: function(cm, actionArgs, vim2) {
      if (vim2.visualMode) {
        return;
      }
      var repeat = actionArgs.repeat || 1;
      var forward = actionArgs.forward;
      var jumpList = vimGlobalState.jumpList;
      var mark = jumpList.move(cm, forward ? repeat : -repeat);
      var markPos = mark ? mark.find() : void 0;
      markPos = markPos ? markPos : cm.getCursor();
      cm.setCursor(markPos);
    },
    scroll: function(cm, actionArgs, vim2) {
      if (vim2.visualMode) {
        return;
      }
      var repeat = actionArgs.repeat || 1;
      var lineHeight = cm.defaultTextHeight();
      var top = cm.getScrollInfo().top;
      var delta = lineHeight * repeat;
      var newPos = actionArgs.forward ? top + delta : top - delta;
      var cursor2 = copyCursor(cm.getCursor());
      var cursorCoords = cm.charCoords(cursor2, "local");
      if (actionArgs.forward) {
        if (newPos > cursorCoords.top) {
          cursor2.line += (newPos - cursorCoords.top) / lineHeight;
          cursor2.line = Math.ceil(cursor2.line);
          cm.setCursor(cursor2);
          cursorCoords = cm.charCoords(cursor2, "local");
          cm.scrollTo(null, cursorCoords.top);
        } else {
          cm.scrollTo(null, newPos);
        }
      } else {
        var newBottom = newPos + cm.getScrollInfo().clientHeight;
        if (newBottom < cursorCoords.bottom) {
          cursor2.line -= (cursorCoords.bottom - newBottom) / lineHeight;
          cursor2.line = Math.floor(cursor2.line);
          cm.setCursor(cursor2);
          cursorCoords = cm.charCoords(cursor2, "local");
          cm.scrollTo(
            null,
            cursorCoords.bottom - cm.getScrollInfo().clientHeight
          );
        } else {
          cm.scrollTo(null, newPos);
        }
      }
    },
    scrollToCursor: function(cm, actionArgs) {
      var lineNum = cm.getCursor().line;
      var charCoords = cm.charCoords(new Pos2(lineNum, 0), "local");
      var height = cm.getScrollInfo().clientHeight;
      var y4 = charCoords.top;
      switch (actionArgs.position) {
        case "center":
          y4 = charCoords.bottom - height / 2;
          break;
        case "bottom":
          var lineLastCharPos = new Pos2(lineNum, cm.getLine(lineNum).length - 1);
          var lineLastCharCoords = cm.charCoords(lineLastCharPos, "local");
          var lineHeight = lineLastCharCoords.bottom - y4;
          y4 = y4 - height + lineHeight;
          break;
      }
      cm.scrollTo(null, y4);
    },
    replayMacro: function(cm, actionArgs, vim2) {
      var registerName = actionArgs.selectedCharacter || "";
      var repeat = actionArgs.repeat || 1;
      var macroModeState = vimGlobalState.macroModeState;
      if (registerName == "@") {
        registerName = macroModeState.latestRegister;
      } else {
        macroModeState.latestRegister = registerName;
      }
      while (repeat--) {
        executeMacroRegister(cm, vim2, macroModeState, registerName);
      }
    },
    enterMacroRecordMode: function(cm, actionArgs) {
      var macroModeState = vimGlobalState.macroModeState;
      var registerName = actionArgs.selectedCharacter;
      if (vimGlobalState.registerController.isValidRegister(registerName)) {
        macroModeState.enterMacroRecordMode(cm, registerName);
      }
    },
    toggleOverwrite: function(cm) {
      if (!cm.state.overwrite) {
        cm.toggleOverwrite(true);
        cm.setOption("keyMap", "vim-replace");
        CodeMirror2.signal(cm, "vim-mode-change", { mode: "replace" });
      } else {
        cm.toggleOverwrite(false);
        cm.setOption("keyMap", "vim-insert");
        CodeMirror2.signal(cm, "vim-mode-change", { mode: "insert" });
      }
    },
    enterInsertMode: function(cm, actionArgs, vim2) {
      if (cm.getOption("readOnly")) {
        return;
      }
      vim2.insertMode = true;
      vim2.insertModeRepeat = actionArgs && actionArgs.repeat || 1;
      var insertAt = actionArgs ? actionArgs.insertAt : null;
      var sel = vim2.sel;
      var head = actionArgs.head || cm.getCursor("head");
      var height = cm.listSelections().length;
      if (insertAt == "eol") {
        head = new Pos2(head.line, lineLength(cm, head.line));
      } else if (insertAt == "bol") {
        head = new Pos2(head.line, 0);
      } else if (insertAt == "charAfter") {
        var newPosition = updateSelectionForSurrogateCharacters(cm, head, offsetCursor(head, 0, 1));
        head = newPosition.end;
      } else if (insertAt == "firstNonBlank") {
        var newPosition = updateSelectionForSurrogateCharacters(cm, head, motions.moveToFirstNonWhiteSpaceCharacter(cm, head));
        head = newPosition.end;
      } else if (insertAt == "startOfSelectedArea") {
        if (!vim2.visualMode)
          return;
        if (!vim2.visualBlock) {
          if (sel.head.line < sel.anchor.line) {
            head = sel.head;
          } else {
            head = new Pos2(sel.anchor.line, 0);
          }
        } else {
          head = new Pos2(
            Math.min(sel.head.line, sel.anchor.line),
            Math.min(sel.head.ch, sel.anchor.ch)
          );
          height = Math.abs(sel.head.line - sel.anchor.line) + 1;
        }
      } else if (insertAt == "endOfSelectedArea") {
        if (!vim2.visualMode)
          return;
        if (!vim2.visualBlock) {
          if (sel.head.line >= sel.anchor.line) {
            head = offsetCursor(sel.head, 0, 1);
          } else {
            head = new Pos2(sel.anchor.line, 0);
          }
        } else {
          head = new Pos2(
            Math.min(sel.head.line, sel.anchor.line),
            Math.max(sel.head.ch, sel.anchor.ch) + 1
          );
          height = Math.abs(sel.head.line - sel.anchor.line) + 1;
        }
      } else if (insertAt == "inplace") {
        if (vim2.visualMode) {
          return;
        }
      } else if (insertAt == "lastEdit") {
        head = getLastEditPos(cm) || head;
      }
      cm.setOption("disableInput", false);
      if (actionArgs && actionArgs.replace) {
        cm.toggleOverwrite(true);
        cm.setOption("keyMap", "vim-replace");
        CodeMirror2.signal(cm, "vim-mode-change", { mode: "replace" });
      } else {
        cm.toggleOverwrite(false);
        cm.setOption("keyMap", "vim-insert");
        CodeMirror2.signal(cm, "vim-mode-change", { mode: "insert" });
      }
      if (!vimGlobalState.macroModeState.isPlaying) {
        cm.on("change", onChange3);
        if (vim2.insertEnd) vim2.insertEnd.clear();
        vim2.insertEnd = cm.setBookmark(head, { insertLeft: true });
        CodeMirror2.on(cm.getInputField(), "keydown", onKeyEventTargetKeyDown);
      }
      if (vim2.visualMode) {
        exitVisualMode(cm);
      }
      selectForInsert(cm, head, height);
    },
    toggleVisualMode: function(cm, actionArgs, vim2) {
      var repeat = actionArgs.repeat;
      var anchor = cm.getCursor();
      var head;
      if (!vim2.visualMode) {
        vim2.visualMode = true;
        vim2.visualLine = !!actionArgs.linewise;
        vim2.visualBlock = !!actionArgs.blockwise;
        head = clipCursorToContent(
          cm,
          new Pos2(anchor.line, anchor.ch + repeat - 1)
        );
        var newPosition = updateSelectionForSurrogateCharacters(cm, anchor, head);
        vim2.sel = {
          anchor: newPosition.start,
          head: newPosition.end
        };
        CodeMirror2.signal(cm, "vim-mode-change", { mode: "visual", subMode: vim2.visualLine ? "linewise" : vim2.visualBlock ? "blockwise" : "" });
        updateCmSelection(cm);
        updateMark(cm, vim2, "<", cursorMin(anchor, head));
        updateMark(cm, vim2, ">", cursorMax(anchor, head));
      } else if (vim2.visualLine != !!actionArgs.linewise || vim2.visualBlock != !!actionArgs.blockwise) {
        vim2.visualLine = !!actionArgs.linewise;
        vim2.visualBlock = !!actionArgs.blockwise;
        CodeMirror2.signal(cm, "vim-mode-change", { mode: "visual", subMode: vim2.visualLine ? "linewise" : vim2.visualBlock ? "blockwise" : "" });
        updateCmSelection(cm);
      } else {
        exitVisualMode(cm);
      }
    },
    reselectLastSelection: function(cm, _actionArgs, vim2) {
      var lastSelection = vim2.lastSelection;
      if (vim2.visualMode) {
        updateLastSelection(cm, vim2);
      }
      if (lastSelection) {
        var anchor = lastSelection.anchorMark.find();
        var head = lastSelection.headMark.find();
        if (!anchor || !head) {
          return;
        }
        vim2.sel = {
          anchor,
          head
        };
        vim2.visualMode = true;
        vim2.visualLine = lastSelection.visualLine;
        vim2.visualBlock = lastSelection.visualBlock;
        updateCmSelection(cm);
        updateMark(cm, vim2, "<", cursorMin(anchor, head));
        updateMark(cm, vim2, ">", cursorMax(anchor, head));
        CodeMirror2.signal(cm, "vim-mode-change", {
          mode: "visual",
          subMode: vim2.visualLine ? "linewise" : vim2.visualBlock ? "blockwise" : ""
        });
      }
    },
    joinLines: function(cm, actionArgs, vim2) {
      var curStart, curEnd;
      if (vim2.visualMode) {
        curStart = cm.getCursor("anchor");
        curEnd = cm.getCursor("head");
        if (cursorIsBefore(curEnd, curStart)) {
          var tmp = curEnd;
          curEnd = curStart;
          curStart = tmp;
        }
        curEnd.ch = lineLength(cm, curEnd.line) - 1;
      } else {
        var repeat = Math.max(actionArgs.repeat, 2);
        curStart = cm.getCursor();
        curEnd = clipCursorToContent(cm, new Pos2(
          curStart.line + repeat - 1,
          Infinity
        ));
      }
      var finalCh = 0;
      for (var i4 = curStart.line; i4 < curEnd.line; i4++) {
        finalCh = lineLength(cm, curStart.line);
        var text2 = "";
        var nextStartCh = 0;
        if (!actionArgs.keepSpaces) {
          var nextLine = cm.getLine(curStart.line + 1);
          nextStartCh = nextLine.search(/\S/);
          if (nextStartCh == -1) {
            nextStartCh = nextLine.length;
          } else {
            text2 = " ";
          }
        }
        cm.replaceRange(
          text2,
          new Pos2(curStart.line, finalCh),
          new Pos2(curStart.line + 1, nextStartCh)
        );
      }
      var curFinalPos = clipCursorToContent(cm, new Pos2(curStart.line, finalCh));
      if (vim2.visualMode) {
        exitVisualMode(cm, false);
      }
      cm.setCursor(curFinalPos);
    },
    newLineAndEnterInsertMode: function(cm, actionArgs, vim2) {
      vim2.insertMode = true;
      var insertAt = copyCursor(cm.getCursor());
      if (insertAt.line === cm.firstLine() && !actionArgs.after) {
        cm.replaceRange("\n", new Pos2(cm.firstLine(), 0));
        cm.setCursor(cm.firstLine(), 0);
      } else {
        insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;
        insertAt.ch = lineLength(cm, insertAt.line);
        cm.setCursor(insertAt);
        var newlineFn = CodeMirror2.commands.newlineAndIndentContinueComment || CodeMirror2.commands.newlineAndIndent;
        newlineFn(cm);
      }
      this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim2);
    },
    paste: function(cm, actionArgs, vim2) {
      var register = vimGlobalState.registerController.getRegister(
        actionArgs.registerName
      );
      if (actionArgs.registerName === "+") {
        navigator.clipboard.readText().then((value) => {
          this.continuePaste(cm, actionArgs, vim2, value, register);
        });
      } else {
        var text2 = register.toString();
        this.continuePaste(cm, actionArgs, vim2, text2, register);
      }
    },
    continuePaste: function(cm, actionArgs, vim2, text2, register) {
      var cur2 = copyCursor(cm.getCursor());
      if (!text2) {
        return;
      }
      if (actionArgs.matchIndent) {
        var tabSize = cm.getOption("tabSize");
        var whitespaceLength = function(str) {
          var tabs = str.split("	").length - 1;
          var spaces2 = str.split(" ").length - 1;
          return tabs * tabSize + spaces2 * 1;
        };
        var currentLine = cm.getLine(cm.getCursor().line);
        var indent = whitespaceLength(currentLine.match(/^\s*/)[0]);
        var chompedText = text2.replace(/\n$/, "");
        var wasChomped = text2 !== chompedText;
        var firstIndent = whitespaceLength(text2.match(/^\s*/)[0]);
        var text2 = chompedText.replace(/^\s*/gm, function(wspace) {
          var newIndent = indent + (whitespaceLength(wspace) - firstIndent);
          if (newIndent < 0) {
            return "";
          } else if (cm.getOption("indentWithTabs")) {
            var quotient = Math.floor(newIndent / tabSize);
            return Array(quotient + 1).join("	");
          } else {
            return Array(newIndent + 1).join(" ");
          }
        });
        text2 += wasChomped ? "\n" : "";
      }
      if (actionArgs.repeat > 1) {
        var text2 = Array(actionArgs.repeat + 1).join(text2);
      }
      var linewise = register.linewise;
      var blockwise = register.blockwise;
      if (blockwise) {
        text2 = text2.split("\n");
        if (linewise) {
          text2.pop();
        }
        for (var i4 = 0; i4 < text2.length; i4++) {
          text2[i4] = text2[i4] == "" ? " " : text2[i4];
        }
        cur2.ch += actionArgs.after ? 1 : 0;
        cur2.ch = Math.min(lineLength(cm, cur2.line), cur2.ch);
      } else if (linewise) {
        if (vim2.visualMode) {
          text2 = vim2.visualLine ? text2.slice(0, -1) : "\n" + text2.slice(0, text2.length - 1) + "\n";
        } else if (actionArgs.after) {
          text2 = "\n" + text2.slice(0, text2.length - 1);
          cur2.ch = lineLength(cm, cur2.line);
        } else {
          cur2.ch = 0;
        }
      } else {
        cur2.ch += actionArgs.after ? 1 : 0;
      }
      var curPosFinal;
      if (vim2.visualMode) {
        vim2.lastPastedText = text2;
        var lastSelectionCurEnd;
        var selectedArea = getSelectedAreaRange(cm, vim2);
        var selectionStart = selectedArea[0];
        var selectionEnd = selectedArea[1];
        var selectedText = cm.getSelection();
        var selections = cm.listSelections();
        var emptyStrings = new Array(selections.length).join("1").split("1");
        if (vim2.lastSelection) {
          lastSelectionCurEnd = vim2.lastSelection.headMark.find();
        }
        vimGlobalState.registerController.unnamedRegister.setText(selectedText);
        if (blockwise) {
          cm.replaceSelections(emptyStrings);
          selectionEnd = new Pos2(selectionStart.line + text2.length - 1, selectionStart.ch);
          cm.setCursor(selectionStart);
          selectBlock(cm, selectionEnd);
          cm.replaceSelections(text2);
          curPosFinal = selectionStart;
        } else if (vim2.visualBlock) {
          cm.replaceSelections(emptyStrings);
          cm.setCursor(selectionStart);
          cm.replaceRange(text2, selectionStart, selectionStart);
          curPosFinal = selectionStart;
        } else {
          cm.replaceRange(text2, selectionStart, selectionEnd);
          curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text2.length - 1);
        }
        if (lastSelectionCurEnd) {
          vim2.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);
        }
        if (linewise) {
          curPosFinal.ch = 0;
        }
      } else {
        if (blockwise) {
          cm.setCursor(cur2);
          for (var i4 = 0; i4 < text2.length; i4++) {
            var line2 = cur2.line + i4;
            if (line2 > cm.lastLine()) {
              cm.replaceRange("\n", new Pos2(line2, 0));
            }
            var lastCh = lineLength(cm, line2);
            if (lastCh < cur2.ch) {
              extendLineToColumn(cm, line2, cur2.ch);
            }
          }
          cm.setCursor(cur2);
          selectBlock(cm, new Pos2(cur2.line + text2.length - 1, cur2.ch));
          cm.replaceSelections(text2);
          curPosFinal = cur2;
        } else {
          cm.replaceRange(text2, cur2);
          if (linewise) {
            var line2 = actionArgs.after ? cur2.line + 1 : cur2.line;
            curPosFinal = new Pos2(line2, findFirstNonWhiteSpaceCharacter(cm.getLine(line2)));
          } else {
            curPosFinal = copyCursor(cur2);
            if (!/\n/.test(text2)) {
              curPosFinal.ch += text2.length - (actionArgs.after ? 1 : 0);
            }
          }
        }
      }
      if (vim2.visualMode) {
        exitVisualMode(cm, false);
      }
      cm.setCursor(curPosFinal);
    },
    undo: function(cm, actionArgs) {
      cm.operation(function() {
        repeatFn(cm, CodeMirror2.commands.undo, actionArgs.repeat)();
        cm.setCursor(clipCursorToContent(cm, cm.getCursor("start")));
      });
    },
    redo: function(cm, actionArgs) {
      repeatFn(cm, CodeMirror2.commands.redo, actionArgs.repeat)();
    },
    setRegister: function(_cm, actionArgs, vim2) {
      vim2.inputState.registerName = actionArgs.selectedCharacter;
    },
    insertRegister: function(cm, actionArgs, vim2) {
      var registerName = actionArgs.selectedCharacter;
      var register = vimGlobalState.registerController.getRegister(registerName);
      var text2 = register && register.toString();
      if (text2) {
        cm.replaceSelection(text2);
      }
    },
    oneNormalCommand: function(cm, actionArgs, vim2) {
      exitInsertMode(cm, true);
      vim2.insertModeReturn = true;
      CodeMirror2.on(cm, "vim-command-done", function handler() {
        if (vim2.visualMode) return;
        if (vim2.insertModeReturn) {
          vim2.insertModeReturn = false;
          if (!vim2.insertMode) {
            actions.enterInsertMode(cm, {}, vim2);
          }
        }
        CodeMirror2.off(cm, "vim-command-done", handler);
      });
    },
    setMark: function(cm, actionArgs, vim2) {
      var markName = actionArgs.selectedCharacter;
      if (markName) updateMark(cm, vim2, markName, cm.getCursor());
    },
    replace: function(cm, actionArgs, vim2) {
      var replaceWith = actionArgs.selectedCharacter || "";
      var curStart = cm.getCursor();
      var replaceTo;
      var curEnd;
      var selections = cm.listSelections();
      if (vim2.visualMode) {
        curStart = cm.getCursor("start");
        curEnd = cm.getCursor("end");
      } else {
        var line2 = cm.getLine(curStart.line);
        replaceTo = curStart.ch + actionArgs.repeat;
        if (replaceTo > line2.length) {
          replaceTo = line2.length;
        }
        curEnd = new Pos2(curStart.line, replaceTo);
      }
      var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);
      curStart = newPositions.start;
      curEnd = newPositions.end;
      if (replaceWith == "\n") {
        if (!vim2.visualMode) cm.replaceRange("", curStart, curEnd);
        (CodeMirror2.commands.newlineAndIndentContinueComment || CodeMirror2.commands.newlineAndIndent)(cm);
      } else {
        var replaceWithStr = cm.getRange(curStart, curEnd);
        replaceWithStr = replaceWithStr.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, replaceWith);
        replaceWithStr = replaceWithStr.replace(/[^\n]/g, replaceWith);
        if (vim2.visualBlock) {
          var spaces2 = new Array(cm.getOption("tabSize") + 1).join(" ");
          replaceWithStr = cm.getSelection();
          replaceWithStr = replaceWithStr.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, replaceWith);
          var replaceWithStrings = replaceWithStr.replace(/\t/g, spaces2).replace(/[^\n]/g, replaceWith).split("\n");
          cm.replaceSelections(replaceWithStrings);
        } else {
          cm.replaceRange(replaceWithStr, curStart, curEnd);
        }
        if (vim2.visualMode) {
          curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;
          cm.setCursor(curStart);
          exitVisualMode(cm, false);
        } else {
          cm.setCursor(offsetCursor(curEnd, 0, -1));
        }
      }
    },
    incrementNumberToken: function(cm, actionArgs) {
      var cur2 = cm.getCursor();
      var lineStr = cm.getLine(cur2.line);
      var re = /(-?)(?:(0x)([\da-f]+)|(0b|0|)(\d+))/gi;
      var match4;
      var start;
      var end2;
      var numberStr;
      while ((match4 = re.exec(lineStr)) !== null) {
        start = match4.index;
        end2 = start + match4[0].length;
        if (cur2.ch < end2) break;
      }
      if (!actionArgs.backtrack && end2 <= cur2.ch) return;
      if (match4) {
        var baseStr = match4[2] || match4[4];
        var digits = match4[3] || match4[5];
        var increment = actionArgs.increase ? 1 : -1;
        var base = { "0b": 2, "0": 8, "": 10, "0x": 16 }[baseStr.toLowerCase()];
        var number = parseInt(match4[1] + digits, base) + increment * actionArgs.repeat;
        numberStr = number.toString(base);
        var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match4[1].length).join("0") : "";
        if (numberStr.charAt(0) === "-") {
          numberStr = "-" + baseStr + zeroPadding + numberStr.substr(1);
        } else {
          numberStr = baseStr + zeroPadding + numberStr;
        }
        var from2 = new Pos2(cur2.line, start);
        var to = new Pos2(cur2.line, end2);
        cm.replaceRange(numberStr, from2, to);
      } else {
        return;
      }
      cm.setCursor(new Pos2(cur2.line, start + numberStr.length - 1));
    },
    repeatLastEdit: function(cm, actionArgs, vim2) {
      var lastEditInputState = vim2.lastEditInputState;
      if (!lastEditInputState) {
        return;
      }
      var repeat = actionArgs.repeat;
      if (repeat && actionArgs.repeatIsExplicit) {
        lastEditInputState.repeatOverride = repeat;
      } else {
        repeat = lastEditInputState.repeatOverride || repeat;
      }
      repeatLastEdit(
        cm,
        vim2,
        repeat,
        false
        /** repeatForInsert */
      );
    },
    indent: function(cm, actionArgs) {
      cm.indentLine(cm.getCursor().line, actionArgs.indentRight);
    },
    exitInsertMode: function(cm, actionArgs) {
      exitInsertMode(cm);
    }
  };
  function defineAction(name, fn2) {
    actions[name] = fn2;
  }
  function clipCursorToContent(cm, cur2, oldCur) {
    var vim2 = cm.state.vim;
    var includeLineBreak = vim2.insertMode || vim2.visualMode;
    var line2 = Math.min(Math.max(cm.firstLine(), cur2.line), cm.lastLine());
    var text2 = cm.getLine(line2);
    var maxCh = text2.length - 1 + Number(!!includeLineBreak);
    var ch = Math.min(Math.max(0, cur2.ch), maxCh);
    var charCode = text2.charCodeAt(ch);
    if (56320 <= charCode && charCode <= 57343) {
      var direction = 1;
      if (oldCur && oldCur.line == line2 && oldCur.ch > ch) {
        direction = -1;
      }
      ch += direction;
      if (ch > maxCh) ch -= 2;
    }
    return new Pos2(line2, ch);
  }
  function copyArgs(args) {
    var ret = {};
    for (var prop in args) {
      if (args.hasOwnProperty(prop)) {
        ret[prop] = args[prop];
      }
    }
    return ret;
  }
  function offsetCursor(cur2, offsetLine, offsetCh) {
    if (typeof offsetLine === "object") {
      offsetCh = offsetLine.ch;
      offsetLine = offsetLine.line;
    }
    return new Pos2(cur2.line + offsetLine, cur2.ch + offsetCh);
  }
  function commandMatches(keys2, keyMap, context, inputState) {
    if (inputState.operator) context = "operatorPending";
    var match4, partial = [], full = [];
    var startIndex = noremap ? keyMap.length - defaultKeymapLength : 0;
    for (var i4 = startIndex; i4 < keyMap.length; i4++) {
      var command = keyMap[i4];
      if (context == "insert" && command.context != "insert" || command.context && command.context != context || inputState.operator && command.type == "action" || !(match4 = commandMatch(keys2, command.keys))) {
        continue;
      }
      if (match4 == "partial") {
        partial.push(command);
      }
      if (match4 == "full") {
        full.push(command);
      }
    }
    return {
      partial: partial.length && partial,
      full: full.length && full
    };
  }
  function commandMatch(pressed, mapped) {
    const isLastCharacter = mapped.slice(-11) == "<character>";
    const isLastRegister = mapped.slice(-10) == "<register>";
    if (isLastCharacter || isLastRegister) {
      var prefixLen = mapped.length - (isLastCharacter ? 11 : 10);
      var pressedPrefix = pressed.slice(0, prefixLen);
      var mappedPrefix = mapped.slice(0, prefixLen);
      return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? "full" : mappedPrefix.indexOf(pressedPrefix) == 0 ? "partial" : false;
    } else {
      return pressed == mapped ? "full" : mapped.indexOf(pressed) == 0 ? "partial" : false;
    }
  }
  function lastChar(keys2) {
    var match4 = /^.*(<[^>]+>)$/.exec(keys2);
    var selectedCharacter = match4 ? match4[1] : keys2.slice(-1);
    if (selectedCharacter.length > 1) {
      switch (selectedCharacter) {
        case "<CR>":
        case "<S-CR>":
          selectedCharacter = "\n";
          break;
        case "<Space>":
        case "<S-Space>":
          selectedCharacter = " ";
          break;
        default:
          selectedCharacter = "";
          break;
      }
    }
    return selectedCharacter;
  }
  function repeatFn(cm, fn2, repeat) {
    return function() {
      for (var i4 = 0; i4 < repeat; i4++) {
        fn2(cm);
      }
    };
  }
  function copyCursor(cur2) {
    return new Pos2(cur2.line, cur2.ch);
  }
  function cursorEqual(cur1, cur2) {
    return cur1.ch == cur2.ch && cur1.line == cur2.line;
  }
  function cursorIsBefore(cur1, cur2) {
    if (cur1.line < cur2.line) {
      return true;
    }
    if (cur1.line == cur2.line && cur1.ch < cur2.ch) {
      return true;
    }
    return false;
  }
  function cursorMin(cur1, cur2) {
    if (arguments.length > 2) {
      cur2 = cursorMin.apply(void 0, Array.prototype.slice.call(arguments, 1));
    }
    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;
  }
  function cursorMax(cur1, cur2) {
    if (arguments.length > 2) {
      cur2 = cursorMax.apply(void 0, Array.prototype.slice.call(arguments, 1));
    }
    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;
  }
  function cursorIsBetween(cur1, cur2, cur3) {
    var cur1before2 = cursorIsBefore(cur1, cur2);
    var cur2before3 = cursorIsBefore(cur2, cur3);
    return cur1before2 && cur2before3;
  }
  function lineLength(cm, lineNum) {
    return cm.getLine(lineNum).length;
  }
  function trim2(s4) {
    if (s4.trim) {
      return s4.trim();
    }
    return s4.replace(/^\s+|\s+$/g, "");
  }
  function escapeRegex2(s4) {
    return s4.replace(/([.?*+$\[\]\/\\(){}|\-])/g, "\\$1");
  }
  function extendLineToColumn(cm, lineNum, column2) {
    var endCh = lineLength(cm, lineNum);
    var spaces2 = new Array(column2 - endCh + 1).join(" ");
    cm.setCursor(new Pos2(lineNum, endCh));
    cm.replaceRange(spaces2, cm.getCursor());
  }
  function selectBlock(cm, selectionEnd) {
    var selections = [], ranges = cm.listSelections();
    var head = copyCursor(cm.clipPos(selectionEnd));
    var isClipped = !cursorEqual(selectionEnd, head);
    var curHead = cm.getCursor("head");
    var primIndex = getIndex(ranges, curHead);
    var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);
    var max2 = ranges.length - 1;
    var index2 = max2 - primIndex > primIndex ? max2 : 0;
    var base = ranges[index2].anchor;
    var firstLine = Math.min(base.line, head.line);
    var lastLine = Math.max(base.line, head.line);
    var baseCh = base.ch, headCh = head.ch;
    var dir = ranges[index2].head.ch - baseCh;
    var newDir = headCh - baseCh;
    if (dir > 0 && newDir <= 0) {
      baseCh++;
      if (!isClipped) {
        headCh--;
      }
    } else if (dir < 0 && newDir >= 0) {
      baseCh--;
      if (!wasClipped) {
        headCh++;
      }
    } else if (dir < 0 && newDir == -1) {
      baseCh--;
      headCh++;
    }
    for (var line2 = firstLine; line2 <= lastLine; line2++) {
      var range = { anchor: new Pos2(line2, baseCh), head: new Pos2(line2, headCh) };
      selections.push(range);
    }
    cm.setSelections(selections);
    selectionEnd.ch = headCh;
    base.ch = baseCh;
    return base;
  }
  function selectForInsert(cm, head, height) {
    var sel = [];
    for (var i4 = 0; i4 < height; i4++) {
      var lineHead = offsetCursor(head, i4, 0);
      sel.push({ anchor: lineHead, head: lineHead });
    }
    cm.setSelections(sel, 0);
  }
  function getIndex(ranges, cursor2, end2) {
    for (var i4 = 0; i4 < ranges.length; i4++) {
      var atAnchor = end2 != "head" && cursorEqual(ranges[i4].anchor, cursor2);
      var atHead = end2 != "anchor" && cursorEqual(ranges[i4].head, cursor2);
      if (atAnchor || atHead) {
        return i4;
      }
    }
    return -1;
  }
  function getSelectedAreaRange(cm, vim2) {
    var lastSelection = vim2.lastSelection;
    var getCurrentSelectedAreaRange = function() {
      var selections = cm.listSelections();
      var start = selections[0];
      var end2 = selections[selections.length - 1];
      var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;
      var selectionEnd = cursorIsBefore(end2.anchor, end2.head) ? end2.head : end2.anchor;
      return [selectionStart, selectionEnd];
    };
    var getLastSelectedAreaRange = function() {
      var selectionStart = cm.getCursor();
      var selectionEnd = cm.getCursor();
      var block = lastSelection.visualBlock;
      if (block) {
        var width = block.width;
        var height = block.height;
        selectionEnd = new Pos2(selectionStart.line + height, selectionStart.ch + width);
        var selections = [];
        for (var i4 = selectionStart.line; i4 < selectionEnd.line; i4++) {
          var anchor = new Pos2(i4, selectionStart.ch);
          var head = new Pos2(i4, selectionEnd.ch);
          var range = { anchor, head };
          selections.push(range);
        }
        cm.setSelections(selections);
      } else {
        var start = lastSelection.anchorMark.find();
        var end2 = lastSelection.headMark.find();
        var line2 = end2.line - start.line;
        var ch = end2.ch - start.ch;
        selectionEnd = { line: selectionEnd.line + line2, ch: line2 ? selectionEnd.ch : ch + selectionEnd.ch };
        if (lastSelection.visualLine) {
          selectionStart = new Pos2(selectionStart.line, 0);
          selectionEnd = new Pos2(selectionEnd.line, lineLength(cm, selectionEnd.line));
        }
        cm.setSelection(selectionStart, selectionEnd);
      }
      return [selectionStart, selectionEnd];
    };
    if (!vim2.visualMode) {
      return getLastSelectedAreaRange();
    } else {
      return getCurrentSelectedAreaRange();
    }
  }
  function updateLastSelection(cm, vim2) {
    var anchor = vim2.sel.anchor;
    var head = vim2.sel.head;
    if (vim2.lastPastedText) {
      head = cm.posFromIndex(cm.indexFromPos(anchor) + vim2.lastPastedText.length);
      vim2.lastPastedText = null;
    }
    vim2.lastSelection = {
      "anchorMark": cm.setBookmark(anchor),
      "headMark": cm.setBookmark(head),
      "anchor": copyCursor(anchor),
      "head": copyCursor(head),
      "visualMode": vim2.visualMode,
      "visualLine": vim2.visualLine,
      "visualBlock": vim2.visualBlock
    };
  }
  function expandSelection(cm, start, end2, move) {
    var sel = cm.state.vim.sel;
    var head = move ? start : sel.head;
    var anchor = move ? start : sel.anchor;
    var tmp;
    if (cursorIsBefore(end2, start)) {
      tmp = end2;
      end2 = start;
      start = tmp;
    }
    if (cursorIsBefore(head, anchor)) {
      head = cursorMin(start, head);
      anchor = cursorMax(anchor, end2);
    } else {
      anchor = cursorMin(start, anchor);
      head = cursorMax(head, end2);
      head = offsetCursor(head, 0, -1);
      if (head.ch == -1 && head.line != cm.firstLine()) {
        head = new Pos2(head.line - 1, lineLength(cm, head.line - 1));
      }
    }
    return [anchor, head];
  }
  function updateCmSelection(cm, sel, mode) {
    var vim2 = cm.state.vim;
    sel = sel || vim2.sel;
    if (!mode) {
      mode = vim2.visualLine ? "line" : vim2.visualBlock ? "block" : "char";
    }
    var cmSel = makeCmSelection(cm, sel, mode);
    cm.setSelections(cmSel.ranges, cmSel.primary);
  }
  function makeCmSelection(cm, sel, mode, exclusive) {
    var head = copyCursor(sel.head);
    var anchor = copyCursor(sel.anchor);
    if (mode == "char") {
      var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
      var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
      head = offsetCursor(sel.head, 0, headOffset);
      anchor = offsetCursor(sel.anchor, 0, anchorOffset);
      return {
        ranges: [{ anchor, head }],
        primary: 0
      };
    } else if (mode == "line") {
      if (!cursorIsBefore(sel.head, sel.anchor)) {
        anchor.ch = 0;
        var lastLine = cm.lastLine();
        if (head.line > lastLine) {
          head.line = lastLine;
        }
        head.ch = lineLength(cm, head.line);
      } else {
        head.ch = 0;
        anchor.ch = lineLength(cm, anchor.line);
      }
      return {
        ranges: [{ anchor, head }],
        primary: 0
      };
    } else if (mode == "block") {
      var top = Math.min(anchor.line, head.line), fromCh = anchor.ch, bottom = Math.max(anchor.line, head.line), toCh = head.ch;
      if (fromCh < toCh) {
        toCh += 1;
      } else {
        fromCh += 1;
      }
      var height = bottom - top + 1;
      var primary = head.line == top ? 0 : height - 1;
      var ranges = [];
      for (var i4 = 0; i4 < height; i4++) {
        ranges.push({
          anchor: new Pos2(top + i4, fromCh),
          head: new Pos2(top + i4, toCh)
        });
      }
      return {
        ranges,
        primary
      };
    }
    throw "never happens";
  }
  function getHead(cm) {
    var cur2 = cm.getCursor("head");
    if (cm.getSelection().length == 1) {
      cur2 = cursorMin(cur2, cm.getCursor("anchor"));
    }
    return cur2;
  }
  function exitVisualMode(cm, moveHead) {
    var vim2 = cm.state.vim;
    if (moveHead !== false) {
      cm.setCursor(clipCursorToContent(cm, vim2.sel.head));
    }
    updateLastSelection(cm, vim2);
    vim2.visualMode = false;
    vim2.visualLine = false;
    vim2.visualBlock = false;
    if (!vim2.insertMode) CodeMirror2.signal(cm, "vim-mode-change", { mode: "normal" });
  }
  function clipToLine(cm, curStart, curEnd) {
    var selection = cm.getRange(curStart, curEnd);
    if (/\n\s*$/.test(selection)) {
      var lines = selection.split("\n");
      lines.pop();
      for (var line2 = lines.pop(); lines.length > 0 && line2 && isWhiteSpaceString(line2); line2 = lines.pop()) {
        curEnd.line--;
        curEnd.ch = 0;
      }
      if (line2) {
        curEnd.line--;
        curEnd.ch = lineLength(cm, curEnd.line);
      } else {
        curEnd.ch = 0;
      }
    }
  }
  function expandSelectionToLine(_cm, curStart, curEnd) {
    curStart.ch = 0;
    curEnd.ch = 0;
    curEnd.line++;
  }
  function findFirstNonWhiteSpaceCharacter(text2) {
    if (!text2) {
      return 0;
    }
    var firstNonWS = text2.search(/\S/);
    return firstNonWS == -1 ? text2.length : firstNonWS;
  }
  function expandWordUnderCursor(cm, { inclusive, innerWord, bigWord, noSymbol, multiline }, cursor2) {
    var cur2 = cursor2 || getHead(cm);
    var line2 = cm.getLine(cur2.line);
    var endLine = line2;
    var startLineNumber = cur2.line;
    var endLineNumber = startLineNumber;
    var idx = cur2.ch;
    var wordOnNextLine;
    var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];
    if (innerWord && /\s/.test(line2.charAt(idx))) {
      test = function(ch) {
        return /\s/.test(ch);
      };
    } else {
      while (!test(line2.charAt(idx))) {
        idx++;
        if (idx >= line2.length) {
          if (!multiline) return null;
          idx--;
          wordOnNextLine = findWord(cm, cur2, true, bigWord, true);
          break;
        }
      }
      if (bigWord) {
        test = bigWordCharTest[0];
      } else {
        test = wordCharTest[0];
        if (!test(line2.charAt(idx))) {
          test = wordCharTest[1];
        }
      }
    }
    var end2 = idx, start = idx;
    while (test(line2.charAt(start)) && start >= 0) {
      start--;
    }
    start++;
    if (wordOnNextLine) {
      end2 = wordOnNextLine.to;
      endLineNumber = wordOnNextLine.line;
      endLine = cm.getLine(endLineNumber);
      if (!endLine && end2 == 0) end2++;
    } else {
      while (test(line2.charAt(end2)) && end2 < line2.length) {
        end2++;
      }
    }
    if (inclusive) {
      var wordEnd = end2;
      var startsWithSpace = cur2.ch <= start && /\s/.test(line2.charAt(cur2.ch));
      if (!startsWithSpace) {
        while (/\s/.test(endLine.charAt(end2)) && end2 < endLine.length) {
          end2++;
        }
      }
      if (wordEnd == end2 || startsWithSpace) {
        var wordStart = start;
        while (/\s/.test(line2.charAt(start - 1)) && start > 0) {
          start--;
        }
        if (!start && !startsWithSpace) {
          start = wordStart;
        }
      }
    }
    return { start: new Pos2(startLineNumber, start), end: new Pos2(endLineNumber, end2) };
  }
  function expandTagUnderCursor(cm, head, inclusive) {
    var cur2 = head;
    if (!CodeMirror2.findMatchingTag || !CodeMirror2.findEnclosingTag) {
      return { start: cur2, end: cur2 };
    }
    var tags3 = CodeMirror2.findMatchingTag(cm, head) || CodeMirror2.findEnclosingTag(cm, head);
    if (!tags3 || !tags3.open || !tags3.close) {
      return { start: cur2, end: cur2 };
    }
    if (inclusive) {
      return { start: tags3.open.from, end: tags3.close.to };
    }
    return { start: tags3.open.to, end: tags3.close.from };
  }
  function recordJumpPosition(cm, oldCur, newCur) {
    if (!cursorEqual(oldCur, newCur)) {
      vimGlobalState.jumpList.add(cm, oldCur, newCur);
    }
  }
  function recordLastCharacterSearch(increment, args) {
    vimGlobalState.lastCharacterSearch.increment = increment;
    vimGlobalState.lastCharacterSearch.forward = args.forward;
    vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;
  }
  var symbolToMode = {
    "(": "bracket",
    ")": "bracket",
    "{": "bracket",
    "}": "bracket",
    "[": "section",
    "]": "section",
    "*": "comment",
    "/": "comment",
    "m": "method",
    "M": "method",
    "#": "preprocess"
  };
  var findSymbolModes = {
    bracket: {
      isComplete: function(state2) {
        if (state2.nextCh === state2.symb) {
          state2.depth++;
          if (state2.depth >= 1) return true;
        } else if (state2.nextCh === state2.reverseSymb) {
          state2.depth--;
        }
        return false;
      }
    },
    section: {
      init: function(state2) {
        state2.curMoveThrough = true;
        state2.symb = (state2.forward ? "]" : "[") === state2.symb ? "{" : "}";
      },
      isComplete: function(state2) {
        return state2.index === 0 && state2.nextCh === state2.symb;
      }
    },
    comment: {
      isComplete: function(state2) {
        var found = state2.lastCh === "*" && state2.nextCh === "/";
        state2.lastCh = state2.nextCh;
        return found;
      }
    },
    // TODO: The original Vim implementation only operates on level 1 and 2.
    // The current implementation doesn't check for code block level and
    // therefore it operates on any levels.
    method: {
      init: function(state2) {
        state2.symb = state2.symb === "m" ? "{" : "}";
        state2.reverseSymb = state2.symb === "{" ? "}" : "{";
      },
      isComplete: function(state2) {
        if (state2.nextCh === state2.symb) return true;
        return false;
      }
    },
    preprocess: {
      init: function(state2) {
        state2.index = 0;
      },
      isComplete: function(state2) {
        if (state2.nextCh === "#") {
          var token2 = state2.lineText.match(/^#(\w+)/)[1];
          if (token2 === "endif") {
            if (state2.forward && state2.depth === 0) {
              return true;
            }
            state2.depth++;
          } else if (token2 === "if") {
            if (!state2.forward && state2.depth === 0) {
              return true;
            }
            state2.depth--;
          }
          if (token2 === "else" && state2.depth === 0) return true;
        }
        return false;
      }
    }
  };
  function findSymbol(cm, repeat, forward, symb) {
    var cur2 = copyCursor(cm.getCursor());
    var increment = forward ? 1 : -1;
    var endLine = forward ? cm.lineCount() : -1;
    var curCh = cur2.ch;
    var line2 = cur2.line;
    var lineText = cm.getLine(line2);
    var state2 = {
      lineText,
      nextCh: lineText.charAt(curCh),
      lastCh: null,
      index: curCh,
      symb,
      reverseSymb: (forward ? { ")": "(", "}": "{" } : { "(": ")", "{": "}" })[symb],
      forward,
      depth: 0,
      curMoveThrough: false
    };
    var mode = symbolToMode[symb];
    if (!mode) return cur2;
    var init = findSymbolModes[mode].init;
    var isComplete = findSymbolModes[mode].isComplete;
    if (init) {
      init(state2);
    }
    while (line2 !== endLine && repeat) {
      state2.index += increment;
      state2.nextCh = state2.lineText.charAt(state2.index);
      if (!state2.nextCh) {
        line2 += increment;
        state2.lineText = cm.getLine(line2) || "";
        if (increment > 0) {
          state2.index = 0;
        } else {
          var lineLen = state2.lineText.length;
          state2.index = lineLen > 0 ? lineLen - 1 : 0;
        }
        state2.nextCh = state2.lineText.charAt(state2.index);
      }
      if (isComplete(state2)) {
        cur2.line = line2;
        cur2.ch = state2.index;
        repeat--;
      }
    }
    if (state2.nextCh || state2.curMoveThrough) {
      return new Pos2(line2, state2.index);
    }
    return cur2;
  }
  function findWord(cm, cur2, forward, bigWord, emptyLineIsWord) {
    var lineNum = cur2.line;
    var pos = cur2.ch;
    var line2 = cm.getLine(lineNum);
    var dir = forward ? 1 : -1;
    var charTests = bigWord ? bigWordCharTest : wordCharTest;
    if (emptyLineIsWord && line2 == "") {
      lineNum += dir;
      line2 = cm.getLine(lineNum);
      if (!isLine(cm, lineNum)) {
        return null;
      }
      pos = forward ? 0 : line2.length;
    }
    while (true) {
      if (emptyLineIsWord && line2 == "") {
        return { from: 0, to: 0, line: lineNum };
      }
      var stop = dir > 0 ? line2.length : -1;
      var wordStart = stop, wordEnd = stop;
      while (pos != stop) {
        var foundWord = false;
        for (var i4 = 0; i4 < charTests.length && !foundWord; ++i4) {
          if (charTests[i4](line2.charAt(pos))) {
            wordStart = pos;
            while (pos != stop && charTests[i4](line2.charAt(pos))) {
              pos += dir;
            }
            wordEnd = pos;
            foundWord = wordStart != wordEnd;
            if (wordStart == cur2.ch && lineNum == cur2.line && wordEnd == wordStart + dir) {
              continue;
            } else {
              return {
                from: Math.min(wordStart, wordEnd + 1),
                to: Math.max(wordStart, wordEnd),
                line: lineNum
              };
            }
          }
        }
        if (!foundWord) {
          pos += dir;
        }
      }
      lineNum += dir;
      if (!isLine(cm, lineNum)) {
        return null;
      }
      line2 = cm.getLine(lineNum);
      pos = dir > 0 ? 0 : line2.length;
    }
  }
  function moveToWord(cm, cur2, repeat, forward, wordEnd, bigWord) {
    var curStart = copyCursor(cur2);
    var words = [];
    if (forward && !wordEnd || !forward && wordEnd) {
      repeat++;
    }
    var emptyLineIsWord = !(forward && wordEnd);
    for (var i4 = 0; i4 < repeat; i4++) {
      var word = findWord(cm, cur2, forward, bigWord, emptyLineIsWord);
      if (!word) {
        var eodCh = lineLength(cm, cm.lastLine());
        words.push(forward ? { line: cm.lastLine(), from: eodCh, to: eodCh } : { line: 0, from: 0, to: 0 });
        break;
      }
      words.push(word);
      cur2 = new Pos2(word.line, forward ? word.to - 1 : word.from);
    }
    var shortCircuit = words.length != repeat;
    var firstWord = words[0];
    var lastWord = words.pop();
    if (forward && !wordEnd) {
      if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {
        lastWord = words.pop();
      }
      return lastWord && new Pos2(lastWord.line, lastWord.from);
    } else if (forward && wordEnd) {
      return lastWord && new Pos2(lastWord.line, lastWord.to - 1);
    } else if (!forward && wordEnd) {
      if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {
        lastWord = words.pop();
      }
      return lastWord && new Pos2(lastWord.line, lastWord.to);
    } else {
      return lastWord && new Pos2(lastWord.line, lastWord.from);
    }
  }
  function moveToEol(cm, head, motionArgs, vim2, keepHPos) {
    var cur2 = head;
    var retval = new Pos2(cur2.line + motionArgs.repeat - 1, Infinity);
    var end2 = cm.clipPos(retval);
    end2.ch--;
    if (!keepHPos) {
      vim2.lastHPos = Infinity;
      vim2.lastHSPos = cm.charCoords(end2, "div").left;
    }
    return retval;
  }
  function moveToCharacter(cm, repeat, forward, character2, head) {
    if (!character2) return;
    var cur2 = head || cm.getCursor();
    var start = cur2.ch;
    var idx;
    for (var i4 = 0; i4 < repeat; i4++) {
      var line2 = cm.getLine(cur2.line);
      idx = charIdxInLine(start, line2, character2, forward, true);
      if (idx == -1) {
        return void 0;
      }
      start = idx;
    }
    if (idx != void 0)
      return new Pos2(cm.getCursor().line, idx);
  }
  function moveToColumn(cm, repeat) {
    var line2 = cm.getCursor().line;
    return clipCursorToContent(cm, new Pos2(line2, repeat - 1));
  }
  function updateMark(cm, vim2, markName, pos) {
    if (!inArray(markName, validMarks) && !latinCharRegex.test(markName)) {
      return;
    }
    if (vim2.marks[markName]) {
      vim2.marks[markName].clear();
    }
    vim2.marks[markName] = cm.setBookmark(pos);
  }
  function charIdxInLine(start, line2, character2, forward, includeChar) {
    var idx;
    if (forward) {
      idx = line2.indexOf(character2, start + 1);
      if (idx != -1 && !includeChar) {
        idx -= 1;
      }
    } else {
      idx = line2.lastIndexOf(character2, start - 1);
      if (idx != -1 && !includeChar) {
        idx += 1;
      }
    }
    return idx;
  }
  function findParagraph(cm, head, repeat, dir, inclusive) {
    var line2 = head.line;
    var min2 = cm.firstLine();
    var max2 = cm.lastLine();
    var start, end2, i4 = line2;
    function isEmpty(i5) {
      return !cm.getLine(i5);
    }
    function isBoundary(i5, dir2, any3) {
      if (any3) {
        return isEmpty(i5) != isEmpty(i5 + dir2);
      }
      return !isEmpty(i5) && isEmpty(i5 + dir2);
    }
    if (dir) {
      while (min2 <= i4 && i4 <= max2 && repeat > 0) {
        if (isBoundary(i4, dir)) {
          repeat--;
        }
        i4 += dir;
      }
      return { start: new Pos2(i4, 0), end: head };
    }
    var vim2 = cm.state.vim;
    if (vim2.visualLine && isBoundary(line2, 1, true)) {
      var anchor = vim2.sel.anchor;
      if (isBoundary(anchor.line, -1, true)) {
        if (!inclusive || anchor.line != line2) {
          line2 += 1;
        }
      }
    }
    var startState = isEmpty(line2);
    for (i4 = line2; i4 <= max2 && repeat; i4++) {
      if (isBoundary(i4, 1, true)) {
        if (!inclusive || isEmpty(i4) != startState) {
          repeat--;
        }
      }
    }
    end2 = new Pos2(i4, 0);
    if (i4 > max2 && !startState) {
      startState = true;
    } else {
      inclusive = false;
    }
    for (i4 = line2; i4 > min2; i4--) {
      if (!inclusive || isEmpty(i4) == startState || i4 == line2) {
        if (isBoundary(i4, -1, true)) {
          break;
        }
      }
    }
    start = new Pos2(i4, 0);
    return { start, end: end2 };
  }
  function getSentence(cm, cur2, repeat, dir, inclusive) {
    function nextChar2(curr) {
      if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {
        curr.line = null;
      } else {
        curr.pos += curr.dir;
      }
    }
    function forward(cm2, ln2, pos, dir2) {
      var line2 = cm2.getLine(ln2);
      var curr = {
        line: line2,
        ln: ln2,
        pos,
        dir: dir2
      };
      if (curr.line === "") {
        return { ln: curr.ln, pos: curr.pos };
      }
      var lastSentencePos = curr.pos;
      nextChar2(curr);
      while (curr.line !== null) {
        lastSentencePos = curr.pos;
        if (isEndOfSentenceSymbol(curr.line[curr.pos])) {
          if (!inclusive) {
            return { ln: curr.ln, pos: curr.pos + 1 };
          } else {
            nextChar2(curr);
            while (curr.line !== null) {
              if (isWhiteSpaceString(curr.line[curr.pos])) {
                lastSentencePos = curr.pos;
                nextChar2(curr);
              } else {
                break;
              }
            }
            return { ln: curr.ln, pos: lastSentencePos + 1 };
          }
        }
        nextChar2(curr);
      }
      return { ln: curr.ln, pos: lastSentencePos + 1 };
    }
    function reverse(cm2, ln2, pos, dir2) {
      var line2 = cm2.getLine(ln2);
      var curr = {
        line: line2,
        ln: ln2,
        pos,
        dir: dir2
      };
      if (curr.line === "") {
        return { ln: curr.ln, pos: curr.pos };
      }
      var lastSentencePos = curr.pos;
      nextChar2(curr);
      while (curr.line !== null) {
        if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {
          lastSentencePos = curr.pos;
        } else if (isEndOfSentenceSymbol(curr.line[curr.pos])) {
          if (!inclusive) {
            return { ln: curr.ln, pos: lastSentencePos };
          } else {
            if (isWhiteSpaceString(curr.line[curr.pos + 1])) {
              return { ln: curr.ln, pos: curr.pos + 1 };
            } else {
              return { ln: curr.ln, pos: lastSentencePos };
            }
          }
        }
        nextChar2(curr);
      }
      curr.line = line2;
      if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {
        return { ln: curr.ln, pos: curr.pos };
      } else {
        return { ln: curr.ln, pos: lastSentencePos };
      }
    }
    var curr_index = {
      ln: cur2.line,
      pos: cur2.ch
    };
    while (repeat > 0) {
      if (dir < 0) {
        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);
      } else {
        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);
      }
      repeat--;
    }
    return new Pos2(curr_index.ln, curr_index.pos);
  }
  function findSentence(cm, cur2, repeat, dir) {
    function nextChar2(cm2, idx) {
      if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {
        idx.ln += idx.dir;
        if (!isLine(cm2, idx.ln)) {
          idx.line = null;
          idx.ln = null;
          idx.pos = null;
          return;
        }
        idx.line = cm2.getLine(idx.ln);
        idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;
      } else {
        idx.pos += idx.dir;
      }
    }
    function forward(cm2, ln2, pos, dir2) {
      var line2 = cm2.getLine(ln2);
      var stop = line2 === "";
      var curr = {
        line: line2,
        ln: ln2,
        pos,
        dir: dir2
      };
      var last_valid = {
        ln: curr.ln,
        pos: curr.pos
      };
      var skip_empty_lines = curr.line === "";
      nextChar2(cm2, curr);
      while (curr.line !== null) {
        last_valid.ln = curr.ln;
        last_valid.pos = curr.pos;
        if (curr.line === "" && !skip_empty_lines) {
          return { ln: curr.ln, pos: curr.pos };
        } else if (stop && curr.line !== "" && !isWhiteSpaceString(curr.line[curr.pos])) {
          return { ln: curr.ln, pos: curr.pos };
        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) {
          stop = true;
        }
        nextChar2(cm2, curr);
      }
      var line2 = cm2.getLine(last_valid.ln);
      last_valid.pos = 0;
      for (var i4 = line2.length - 1; i4 >= 0; --i4) {
        if (!isWhiteSpaceString(line2[i4])) {
          last_valid.pos = i4;
          break;
        }
      }
      return last_valid;
    }
    function reverse(cm2, ln2, pos, dir2) {
      var line2 = cm2.getLine(ln2);
      var curr = {
        line: line2,
        ln: ln2,
        pos,
        dir: dir2
      };
      var last_valid = {
        ln: curr.ln,
        pos: null
      };
      var skip_empty_lines = curr.line === "";
      nextChar2(cm2, curr);
      while (curr.line !== null) {
        if (curr.line === "" && !skip_empty_lines) {
          if (last_valid.pos !== null) {
            return last_valid;
          } else {
            return { ln: curr.ln, pos: curr.pos };
          }
        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {
          return last_valid;
        } else if (curr.line !== "" && !isWhiteSpaceString(curr.line[curr.pos])) {
          skip_empty_lines = false;
          last_valid = { ln: curr.ln, pos: curr.pos };
        }
        nextChar2(cm2, curr);
      }
      var line2 = cm2.getLine(last_valid.ln);
      last_valid.pos = 0;
      for (var i4 = 0; i4 < line2.length; ++i4) {
        if (!isWhiteSpaceString(line2[i4])) {
          last_valid.pos = i4;
          break;
        }
      }
      return last_valid;
    }
    var curr_index = {
      ln: cur2.line,
      pos: cur2.ch
    };
    while (repeat > 0) {
      if (dir < 0) {
        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);
      } else {
        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);
      }
      repeat--;
    }
    return new Pos2(curr_index.ln, curr_index.pos);
  }
  function selectCompanionObject(cm, head, symb, inclusive) {
    var cur2 = head;
    var bracketRegexp = {
      "(": /[()]/,
      ")": /[()]/,
      "[": /[[\]]/,
      "]": /[[\]]/,
      "{": /[{}]/,
      "}": /[{}]/,
      "<": /[<>]/,
      ">": /[<>]/
    }[symb];
    var openSym = {
      "(": "(",
      ")": "(",
      "[": "[",
      "]": "[",
      "{": "{",
      "}": "{",
      "<": "<",
      ">": "<"
    }[symb];
    var curChar = cm.getLine(cur2.line).charAt(cur2.ch);
    var offset3 = curChar === openSym ? 1 : 0;
    var startBracket = cm.scanForBracket(new Pos2(cur2.line, cur2.ch + offset3), -1, void 0, { "bracketRegex": bracketRegexp });
    var endBracket = cm.scanForBracket(new Pos2(cur2.line, cur2.ch + offset3), 1, void 0, { "bracketRegex": bracketRegexp });
    if (!startBracket || !endBracket) return null;
    var start = startBracket.pos;
    var end2 = endBracket.pos;
    if (start.line == end2.line && start.ch > end2.ch || start.line > end2.line) {
      var tmp = start;
      start = end2;
      end2 = tmp;
    }
    if (inclusive) {
      end2.ch += 1;
    } else {
      start.ch += 1;
    }
    return { start, end: end2 };
  }
  function findBeginningAndEnd(cm, head, symb, inclusive) {
    var cur2 = copyCursor(head);
    var line2 = cm.getLine(cur2.line);
    var chars = line2.split("");
    var start, end2, i4, len;
    var firstIndex = chars.indexOf(symb);
    if (cur2.ch < firstIndex) {
      cur2.ch = firstIndex;
    } else if (firstIndex < cur2.ch && chars[cur2.ch] == symb) {
      var stringAfter = /string/.test(cm.getTokenTypeAt(offsetCursor(head, 0, 1)));
      var stringBefore = /string/.test(cm.getTokenTypeAt(head));
      var isStringStart = stringAfter && !stringBefore;
      if (!isStringStart) {
        end2 = cur2.ch;
        --cur2.ch;
      }
    }
    if (chars[cur2.ch] == symb && !end2) {
      start = cur2.ch + 1;
    } else {
      for (i4 = cur2.ch; i4 > -1 && !start; i4--) {
        if (chars[i4] == symb) {
          start = i4 + 1;
        }
      }
    }
    if (start && !end2) {
      for (i4 = start, len = chars.length; i4 < len && !end2; i4++) {
        if (chars[i4] == symb) {
          end2 = i4;
        }
      }
    }
    if (!start || !end2) {
      return { start: cur2, end: cur2 };
    }
    if (inclusive) {
      --start;
      ++end2;
    }
    return {
      start: new Pos2(cur2.line, start),
      end: new Pos2(cur2.line, end2)
    };
  }
  defineOption("pcre", true, "boolean");
  class SearchState {
    getQuery() {
      return vimGlobalState.query;
    }
    setQuery(query) {
      vimGlobalState.query = query;
    }
    getOverlay() {
      return this.searchOverlay;
    }
    setOverlay(overlay) {
      this.searchOverlay = overlay;
    }
    isReversed() {
      return vimGlobalState.isReversed;
    }
    setReversed(reversed) {
      vimGlobalState.isReversed = reversed;
    }
    getScrollbarAnnotate() {
      return this.annotate;
    }
    setScrollbarAnnotate(annotate) {
      this.annotate = annotate;
    }
  }
  function getSearchState(cm) {
    var vim2 = cm.state.vim;
    return vim2.searchState_ || (vim2.searchState_ = new SearchState());
  }
  function splitBySlash(argString) {
    return splitBySeparator(argString, "/");
  }
  function findUnescapedSlashes(argString) {
    return findUnescapedSeparators(argString, "/");
  }
  function splitBySeparator(argString, separator) {
    var slashes = findUnescapedSeparators(argString, separator) || [];
    if (!slashes.length) return [];
    var tokens = [];
    if (slashes[0] !== 0) return;
    for (var i4 = 0; i4 < slashes.length; i4++) {
      if (typeof slashes[i4] == "number")
        tokens.push(argString.substring(slashes[i4] + 1, slashes[i4 + 1]));
    }
    return tokens;
  }
  function findUnescapedSeparators(str, separator) {
    if (!separator)
      separator = "/";
    var escapeNextChar = false;
    var slashes = [];
    for (var i4 = 0; i4 < str.length; i4++) {
      var c4 = str.charAt(i4);
      if (!escapeNextChar && c4 == separator) {
        slashes.push(i4);
      }
      escapeNextChar = !escapeNextChar && c4 == "\\";
    }
    return slashes;
  }
  function translateRegex(str) {
    var specials = "|(){";
    var unescape = "}";
    var escapeNextChar = false;
    var out = [];
    for (var i4 = -1; i4 < str.length; i4++) {
      var c4 = str.charAt(i4) || "";
      var n3 = str.charAt(i4 + 1) || "";
      var specialComesNext = n3 && specials.indexOf(n3) != -1;
      if (escapeNextChar) {
        if (c4 !== "\\" || !specialComesNext) {
          out.push(c4);
        }
        escapeNextChar = false;
      } else {
        if (c4 === "\\") {
          escapeNextChar = true;
          if (n3 && unescape.indexOf(n3) != -1) {
            specialComesNext = true;
          }
          if (!specialComesNext || n3 === "\\") {
            out.push(c4);
          }
        } else {
          out.push(c4);
          if (specialComesNext && n3 !== "\\") {
            out.push("\\");
          }
        }
      }
    }
    return out.join("");
  }
  var charUnescapes = { "\\n": "\n", "\\r": "\r", "\\t": "	" };
  function translateRegexReplace(str) {
    var escapeNextChar = false;
    var out = [];
    for (var i4 = -1; i4 < str.length; i4++) {
      var c4 = str.charAt(i4) || "";
      var n3 = str.charAt(i4 + 1) || "";
      if (charUnescapes[c4 + n3]) {
        out.push(charUnescapes[c4 + n3]);
        i4++;
      } else if (escapeNextChar) {
        out.push(c4);
        escapeNextChar = false;
      } else {
        if (c4 === "\\") {
          escapeNextChar = true;
          if (isNumber2(n3) || n3 === "$") {
            out.push("$");
          } else if (n3 !== "/" && n3 !== "\\") {
            out.push("\\");
          }
        } else {
          if (c4 === "$") {
            out.push("$");
          }
          out.push(c4);
          if (n3 === "/") {
            out.push("\\");
          }
        }
      }
    }
    return out.join("");
  }
  var unescapes = { "\\/": "/", "\\\\": "\\", "\\n": "\n", "\\r": "\r", "\\t": "	", "\\&": "&" };
  function unescapeRegexReplace(str) {
    var stream = new CodeMirror2.StringStream(str);
    var output = [];
    while (!stream.eol()) {
      while (stream.peek() && stream.peek() != "\\") {
        output.push(stream.next());
      }
      var matched = false;
      for (var matcher in unescapes) {
        if (stream.match(matcher, true)) {
          matched = true;
          output.push(unescapes[matcher]);
          break;
        }
      }
      if (!matched) {
        output.push(stream.next());
      }
    }
    return output.join("");
  }
  function parseQuery(query, ignoreCase, smartCase) {
    var lastSearchRegister = vimGlobalState.registerController.getRegister("/");
    lastSearchRegister.setText(query);
    if (query instanceof RegExp) {
      return query;
    }
    var slashes = findUnescapedSlashes(query);
    var regexPart;
    var forceIgnoreCase;
    if (!slashes.length) {
      regexPart = query;
    } else {
      regexPart = query.substring(0, slashes[0]);
      var flagsPart = query.substring(slashes[0]);
      forceIgnoreCase = flagsPart.indexOf("i") != -1;
    }
    if (!regexPart) {
      return null;
    }
    if (!getOption("pcre")) {
      regexPart = translateRegex(regexPart);
    }
    if (smartCase) {
      ignoreCase = /^[^A-Z]*$/.test(regexPart);
    }
    var regexp3 = new RegExp(
      regexPart,
      ignoreCase || forceIgnoreCase ? "im" : "m"
    );
    return regexp3;
  }
  function dom2(n3) {
    if (typeof n3 === "string") n3 = document.createElement(n3);
    for (var a4, i4 = 1; i4 < arguments.length; i4++) {
      if (!(a4 = arguments[i4])) continue;
      if (typeof a4 !== "object") a4 = document.createTextNode(a4);
      if (a4.nodeType) n3.appendChild(a4);
      else for (var key in a4) {
        if (!Object.prototype.hasOwnProperty.call(a4, key)) continue;
        if (key[0] === "$") n3.style[key.slice(1)] = a4[key];
        else n3.setAttribute(key, a4[key]);
      }
    }
    return n3;
  }
  function showConfirm(cm, template) {
    var pre = dom2("div", { $color: "red", $whiteSpace: "pre", class: "cm-vim-message" }, template);
    if (cm.openNotification) {
      cm.openNotification(pre, { bottom: true, duration: 5e3 });
    } else {
      alert(pre.innerText);
    }
  }
  function makePrompt(prefix2, desc) {
    return dom2(
      "div",
      { $display: "flex" },
      dom2(
        "span",
        { $fontFamily: "monospace", $whiteSpace: "pre", $flex: 1 },
        prefix2,
        dom2("input", {
          type: "text",
          autocorrect: "off",
          autocapitalize: "off",
          spellcheck: "false",
          $width: "100%"
        })
      ),
      desc && dom2("span", { $color: "#888" }, desc)
    );
  }
  function showPrompt(cm, options3) {
    if (keyToKeyStack.length) {
      if (!options3.value) options3.value = "";
      virtualPrompt = options3;
      return;
    }
    var template = makePrompt(options3.prefix, options3.desc);
    if (cm.openDialog) {
      cm.openDialog(template, options3.onClose, {
        onKeyDown: options3.onKeyDown,
        onKeyUp: options3.onKeyUp,
        bottom: true,
        selectValueOnOpen: false,
        value: options3.value
      });
    } else {
      var shortText = "";
      if (typeof options3.prefix != "string" && options3.prefix) shortText += options3.prefix.textContent;
      if (options3.desc) shortText += " " + options3.desc;
      options3.onClose(prompt(shortText, ""));
    }
  }
  function regexEqual(r1, r22) {
    if (r1 instanceof RegExp && r22 instanceof RegExp) {
      var props = ["global", "multiline", "ignoreCase", "source"];
      for (var i4 = 0; i4 < props.length; i4++) {
        var prop = props[i4];
        if (r1[prop] !== r22[prop]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {
    if (!rawQuery) {
      return;
    }
    var state2 = getSearchState(cm);
    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);
    if (!query) {
      return;
    }
    highlightSearchMatches(cm, query);
    if (regexEqual(query, state2.getQuery())) {
      return query;
    }
    state2.setQuery(query);
    return query;
  }
  function searchOverlay(query) {
    if (query.source.charAt(0) == "^") {
      var matchSol = true;
    }
    return {
      token: function(stream) {
        if (matchSol && !stream.sol()) {
          stream.skipToEnd();
          return;
        }
        var match4 = stream.match(query, false);
        if (match4) {
          if (match4[0].length == 0) {
            stream.next();
            return "searching";
          }
          if (!stream.sol()) {
            stream.backUp(1);
            if (!query.exec(stream.next() + match4[0])) {
              stream.next();
              return null;
            }
          }
          stream.match(query);
          return "searching";
        }
        while (!stream.eol()) {
          stream.next();
          if (stream.match(query, false)) break;
        }
      },
      query
    };
  }
  var highlightTimeout = 0;
  function highlightSearchMatches(cm, query) {
    clearTimeout(highlightTimeout);
    var searchState = getSearchState(cm);
    searchState.highlightTimeout = highlightTimeout;
    highlightTimeout = setTimeout(function() {
      if (!cm.state.vim) return;
      var searchState2 = getSearchState(cm);
      searchState2.highlightTimeout = null;
      var overlay = searchState2.getOverlay();
      if (!overlay || query != overlay.query) {
        if (overlay) {
          cm.removeOverlay(overlay);
        }
        overlay = searchOverlay(query);
        cm.addOverlay(overlay);
        if (cm.showMatchesOnScrollbar) {
          if (searchState2.getScrollbarAnnotate()) {
            searchState2.getScrollbarAnnotate().clear();
          }
          searchState2.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));
        }
        searchState2.setOverlay(overlay);
      }
    }, 50);
  }
  function findNext(cm, prev2, query, repeat) {
    return cm.operation(function() {
      if (repeat === void 0) {
        repeat = 1;
      }
      var pos = cm.getCursor();
      var cursor2 = cm.getSearchCursor(query, pos);
      for (var i4 = 0; i4 < repeat; i4++) {
        var found = cursor2.find(prev2);
        if (i4 == 0 && found && cursorEqual(cursor2.from(), pos)) {
          var lastEndPos = prev2 ? cursor2.from() : cursor2.to();
          found = cursor2.find(prev2);
          if (found && !found[0] && cursorEqual(cursor2.from(), lastEndPos)) {
            if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)
              found = cursor2.find(prev2);
          }
        }
        if (!found) {
          cursor2 = cm.getSearchCursor(
            query,
            // @ts-ignore
            prev2 ? new Pos2(cm.lastLine()) : new Pos2(cm.firstLine(), 0)
          );
          if (!cursor2.find(prev2)) {
            return;
          }
        }
      }
      return cursor2.from();
    });
  }
  function findNextFromAndToInclusive(cm, prev2, query, repeat, vim2) {
    return cm.operation(function() {
      if (repeat === void 0) {
        repeat = 1;
      }
      var pos = cm.getCursor();
      var cursor2 = cm.getSearchCursor(query, pos);
      var found = cursor2.find(!prev2);
      if (!vim2.visualMode && found && cursorEqual(cursor2.from(), pos)) {
        cursor2.find(!prev2);
      }
      for (var i4 = 0; i4 < repeat; i4++) {
        found = cursor2.find(prev2);
        if (!found) {
          cursor2 = cm.getSearchCursor(
            query,
            // @ts-ignore
            prev2 ? new Pos2(cm.lastLine()) : new Pos2(cm.firstLine(), 0)
          );
          if (!cursor2.find(prev2)) {
            return;
          }
        }
      }
      return [cursor2.from(), cursor2.to()];
    });
  }
  function clearSearchHighlight(cm) {
    var state2 = getSearchState(cm);
    if (state2.highlightTimeout) {
      clearTimeout(state2.highlightTimeout);
      state2.highlightTimeout = null;
    }
    cm.removeOverlay(getSearchState(cm).getOverlay());
    state2.setOverlay(null);
    if (state2.getScrollbarAnnotate()) {
      state2.getScrollbarAnnotate().clear();
      state2.setScrollbarAnnotate(null);
    }
  }
  function isInRange(pos, start, end2) {
    if (typeof pos != "number") {
      pos = pos.line;
    }
    if (start instanceof Array) {
      return inArray(pos, start);
    } else {
      if (typeof end2 == "number") {
        return pos >= start && pos <= end2;
      } else {
        return pos == start;
      }
    }
  }
  function getUserVisibleLines(cm) {
    var scrollInfo = cm.getScrollInfo();
    var occludeToleranceTop = 6;
    var occludeToleranceBottom = 10;
    var from2 = cm.coordsChar({ left: 0, top: occludeToleranceTop + scrollInfo.top }, "local");
    var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;
    var to = cm.coordsChar({ left: 0, top: bottomY }, "local");
    return { top: from2.line, bottom: to.line };
  }
  function getMarkPos(cm, vim2, markName) {
    if (markName == "'" || markName == "`") {
      return vimGlobalState.jumpList.find(cm, -1) || new Pos2(0, 0);
    } else if (markName == ".") {
      return getLastEditPos(cm);
    }
    var mark = vim2.marks[markName];
    return mark && mark.find();
  }
  function getLastEditPos(cm) {
    if (cm.getLastEditEnd) {
      return cm.getLastEditEnd();
    }
    var done = (
      /**@type{any}*/
      cm.doc.history.done
    );
    for (var i4 = done.length; i4--; ) {
      if (done[i4].changes) {
        return copyCursor(done[i4].changes[0].to);
      }
    }
  }
  class ExCommandDispatcher {
    constructor() {
      this.commandMap_;
      this.buildCommandMap_();
    }
    processCommand(cm, input2, opt_params) {
      var that = this;
      cm.operation(function() {
        cm.curOp.isVimOp = true;
        that._processCommand(cm, input2, opt_params);
      });
    }
    _processCommand(cm, input2, opt_params) {
      var vim2 = cm.state.vim;
      var commandHistoryRegister = vimGlobalState.registerController.getRegister(":");
      var previousCommand = commandHistoryRegister.toString();
      var inputStream = new CodeMirror2.StringStream(input2);
      commandHistoryRegister.setText(input2);
      var params = opt_params || {};
      params.input = input2;
      try {
        this.parseInput_(cm, inputStream, params);
      } catch (e3) {
        showConfirm(cm, e3 + "");
        throw e3;
      }
      if (vim2.visualMode) {
        exitVisualMode(cm);
      }
      var command;
      var commandName;
      if (!params.commandName) {
        if (params.line !== void 0) {
          commandName = "move";
        }
      } else {
        command = this.matchCommand_(params.commandName);
        if (command) {
          commandName = command.name;
          if (command.excludeFromCommandHistory) {
            commandHistoryRegister.setText(previousCommand);
          }
          this.parseCommandArgs_(inputStream, params, command);
          if (command.type == "exToKey") {
            doKeyToKey(cm, command.toKeys, command);
            return;
          } else if (command.type == "exToEx") {
            this.processCommand(cm, command.toInput);
            return;
          }
        }
      }
      if (!commandName) {
        showConfirm(cm, 'Not an editor command ":' + input2 + '"');
        return;
      }
      try {
        exCommands[commandName](cm, params);
        if ((!command || !command.possiblyAsync) && params.callback) {
          params.callback();
        }
      } catch (e3) {
        showConfirm(cm, e3 + "");
        throw e3;
      }
    }
    parseInput_(cm, inputStream, result) {
      var _a, _b;
      inputStream.eatWhile(":");
      if (inputStream.eat("%")) {
        result.line = cm.firstLine();
        result.lineEnd = cm.lastLine();
      } else {
        result.line = this.parseLineSpec_(cm, inputStream);
        if (result.line !== void 0 && inputStream.eat(",")) {
          result.lineEnd = this.parseLineSpec_(cm, inputStream);
        }
      }
      if (result.line == void 0) {
        if (cm.state.vim.visualMode) {
          result.selectionLine = (_a = getMarkPos(cm, cm.state.vim, "<")) == null ? void 0 : _a.line;
          result.selectionLineEnd = (_b = getMarkPos(cm, cm.state.vim, ">")) == null ? void 0 : _b.line;
        } else {
          result.selectionLine = cm.getCursor().line;
        }
      } else {
        result.selectionLine = result.line;
        result.selectionLineEnd = result.lineEnd;
      }
      var commandMatch2 = inputStream.match(/^(\w+|!!|@@|[!#&*<=>@~])/);
      if (commandMatch2) {
        result.commandName = commandMatch2[1];
      } else {
        result.commandName = inputStream.match(/.*/)[0];
      }
      return result;
    }
    parseLineSpec_(cm, inputStream) {
      var numberMatch = inputStream.match(/^(\d+)/);
      if (numberMatch) {
        return parseInt(numberMatch[1], 10) - 1;
      }
      switch (inputStream.next()) {
        case ".":
          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
        case "$":
          return this.parseLineSpecOffset_(inputStream, cm.lastLine());
        case "'":
          var markName = inputStream.next();
          var markPos = getMarkPos(cm, cm.state.vim, markName);
          if (!markPos) throw new Error("Mark not set");
          return this.parseLineSpecOffset_(inputStream, markPos.line);
        case "-":
        case "+":
          inputStream.backUp(1);
          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
        default:
          inputStream.backUp(1);
          return void 0;
      }
    }
    parseLineSpecOffset_(inputStream, line2) {
      var offsetMatch = inputStream.match(/^([+-])?(\d+)/);
      if (offsetMatch) {
        var offset3 = parseInt(offsetMatch[2], 10);
        if (offsetMatch[1] == "-") {
          line2 -= offset3;
        } else {
          line2 += offset3;
        }
      }
      return line2;
    }
    parseCommandArgs_(inputStream, params, command) {
      if (inputStream.eol()) {
        return;
      }
      params.argString = inputStream.match(/.*/)[0];
      var delim = command.argDelimiter || /\s+/;
      var args = trim2(params.argString).split(delim);
      if (args.length && args[0]) {
        params.args = args;
      }
    }
    matchCommand_(commandName) {
      for (var i4 = commandName.length; i4 > 0; i4--) {
        var prefix2 = commandName.substring(0, i4);
        if (this.commandMap_[prefix2]) {
          var command = this.commandMap_[prefix2];
          if (command.name.indexOf(commandName) === 0) {
            return command;
          }
        }
      }
      return null;
    }
    buildCommandMap_() {
      this.commandMap_ = {};
      for (var i4 = 0; i4 < defaultExCommandMap.length; i4++) {
        var command = defaultExCommandMap[i4];
        var key = command.shortName || command.name;
        this.commandMap_[key] = command;
      }
    }
    /**@type {(lhs: string, rhs: string, ctx: string, noremap?: boolean) => void} */
    map(lhs, rhs, ctx, noremap2) {
      if (lhs != ":" && lhs.charAt(0) == ":") {
        if (ctx) {
          throw Error("Mode not supported for ex mappings");
        }
        var commandName = lhs.substring(1);
        if (rhs != ":" && rhs.charAt(0) == ":") {
          this.commandMap_[commandName] = {
            name: commandName,
            type: "exToEx",
            toInput: rhs.substring(1),
            user: true
          };
        } else {
          this.commandMap_[commandName] = {
            name: commandName,
            type: "exToKey",
            toKeys: rhs,
            user: true
          };
        }
      } else {
        var mapping = {
          keys: lhs,
          type: "keyToKey",
          toKeys: rhs,
          noremap: !!noremap2
        };
        if (ctx) {
          mapping.context = ctx;
        }
        defaultKeymap2.unshift(mapping);
      }
    }
    /**@type {(lhs: string, ctx: string) => boolean|void} */
    unmap(lhs, ctx) {
      if (lhs != ":" && lhs.charAt(0) == ":") {
        if (ctx) {
          throw Error("Mode not supported for ex mappings");
        }
        var commandName = lhs.substring(1);
        if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {
          delete this.commandMap_[commandName];
          return true;
        }
      } else {
        var keys2 = lhs;
        for (var i4 = 0; i4 < defaultKeymap2.length; i4++) {
          if (keys2 == defaultKeymap2[i4].keys && defaultKeymap2[i4].context === ctx) {
            defaultKeymap2.splice(i4, 1);
            return true;
          }
        }
      }
    }
  }
  var exCommands = {
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    colorscheme: function(cm, params) {
      if (!params.args || params.args.length < 1) {
        showConfirm(cm, cm.getOption("theme"));
        return;
      }
      cm.setOption("theme", params.args[0]);
    },
    map: function(cm, params, ctx, defaultOnly) {
      var mapArgs = params.args;
      if (!mapArgs || mapArgs.length < 2) {
        if (cm) {
          showConfirm(cm, "Invalid mapping: " + params.input);
        }
        return;
      }
      exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx, defaultOnly);
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    imap: function(cm, params) {
      this.map(cm, params, "insert");
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    nmap: function(cm, params) {
      this.map(cm, params, "normal");
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    vmap: function(cm, params) {
      this.map(cm, params, "visual");
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    omap: function(cm, params) {
      this.map(cm, params, "operatorPending");
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    noremap: function(cm, params) {
      this.map(cm, params, void 0, true);
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    inoremap: function(cm, params) {
      this.map(cm, params, "insert", true);
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    nnoremap: function(cm, params) {
      this.map(cm, params, "normal", true);
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    vnoremap: function(cm, params) {
      this.map(cm, params, "visual", true);
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    onoremap: function(cm, params) {
      this.map(cm, params, "operatorPending", true);
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params @arg {string} ctx*/
    unmap: function(cm, params, ctx) {
      var mapArgs = params.args;
      if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {
        if (cm) {
          showConfirm(cm, "No such mapping: " + params.input);
        }
      }
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    mapclear: function(cm, params) {
      vimApi.mapclear();
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    imapclear: function(cm, params) {
      vimApi.mapclear("insert");
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    nmapclear: function(cm, params) {
      vimApi.mapclear("normal");
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    vmapclear: function(cm, params) {
      vimApi.mapclear("visual");
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    omapclear: function(cm, params) {
      vimApi.mapclear("operatorPending");
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    move: function(cm, params) {
      commandDispatcher.processCommand(cm, cm.state.vim, {
        keys: "",
        type: "motion",
        motion: "moveToLineOrEdgeOfDocument",
        motionArgs: { forward: false, explicitRepeat: true, linewise: true },
        repeatOverride: params.line + 1
      });
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    set: function(cm, params) {
      var setArgs = params.args;
      var setCfg = params.setCfg || {};
      if (!setArgs || setArgs.length < 1) {
        if (cm) {
          showConfirm(cm, "Invalid mapping: " + params.input);
        }
        return;
      }
      var expr = setArgs[0].split("=");
      var optionName = expr.shift() || "";
      var value = expr.length > 0 ? expr.join("=") : void 0;
      var forceGet = false;
      var forceToggle = false;
      if (optionName.charAt(optionName.length - 1) == "?") {
        if (value) {
          throw Error("Trailing characters: " + params.argString);
        }
        optionName = optionName.substring(0, optionName.length - 1);
        forceGet = true;
      } else if (optionName.charAt(optionName.length - 1) == "!") {
        optionName = optionName.substring(0, optionName.length - 1);
        forceToggle = true;
      }
      if (value === void 0 && optionName.substring(0, 2) == "no") {
        optionName = optionName.substring(2);
        value = false;
      }
      var optionIsBoolean = options2[optionName] && options2[optionName].type == "boolean";
      if (optionIsBoolean) {
        if (forceToggle) {
          value = !getOption(optionName, cm, setCfg);
        } else if (value == void 0) {
          value = true;
        }
      }
      if (!optionIsBoolean && value === void 0 || forceGet) {
        var oldValue = getOption(optionName, cm, setCfg);
        if (oldValue instanceof Error) {
          showConfirm(cm, oldValue.message);
        } else if (oldValue === true || oldValue === false) {
          showConfirm(cm, " " + (oldValue ? "" : "no") + optionName);
        } else {
          showConfirm(cm, "  " + optionName + "=" + oldValue);
        }
      } else {
        var setOptionReturn = setOption(optionName, value, cm, setCfg);
        if (setOptionReturn instanceof Error) {
          showConfirm(cm, setOptionReturn.message);
        }
      }
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    setlocal: function(cm, params) {
      params.setCfg = { scope: "local" };
      this.set(cm, params);
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    setglobal: function(cm, params) {
      params.setCfg = { scope: "global" };
      this.set(cm, params);
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    registers: function(cm, params) {
      var regArgs = params.args;
      var registers = vimGlobalState.registerController.registers;
      var regInfo = "----------Registers----------\n\n";
      if (!regArgs) {
        for (var registerName in registers) {
          var text2 = registers[registerName].toString();
          if (text2.length) {
            regInfo += '"' + registerName + "    " + text2 + "\n";
          }
        }
      } else {
        var registerNames = regArgs.join("");
        for (var i4 = 0; i4 < registerNames.length; i4++) {
          var registerName = registerNames.charAt(i4);
          if (!vimGlobalState.registerController.isValidRegister(registerName)) {
            continue;
          }
          var register = registers[registerName] || new Register();
          regInfo += '"' + registerName + "    " + register.toString() + "\n";
        }
      }
      showConfirm(cm, regInfo);
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    sort: function(cm, params) {
      var reverse, ignoreCase, unique, number, pattern;
      function parseArgs() {
        if (params.argString) {
          var args = new CodeMirror2.StringStream(params.argString);
          if (args.eat("!")) {
            reverse = true;
          }
          if (args.eol()) {
            return;
          }
          if (!args.eatSpace()) {
            return "Invalid arguments";
          }
          var opts = args.match(/([dinuox]+)?\s*(\/.+\/)?\s*/);
          if (!opts || !args.eol()) {
            return "Invalid arguments";
          }
          if (opts[1]) {
            ignoreCase = opts[1].indexOf("i") != -1;
            unique = opts[1].indexOf("u") != -1;
            var decimal = opts[1].indexOf("d") != -1 || opts[1].indexOf("n") != -1;
            var hex = opts[1].indexOf("x") != -1;
            var octal = opts[1].indexOf("o") != -1;
            if (Number(decimal) + Number(hex) + Number(octal) > 1) {
              return "Invalid arguments";
            }
            number = decimal && "decimal" || hex && "hex" || octal && "octal";
          }
          if (opts[2]) {
            pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? "i" : "");
          }
        }
      }
      var err = parseArgs();
      if (err) {
        showConfirm(cm, err + ": " + params.argString);
        return;
      }
      var lineStart = params.line || cm.firstLine();
      var lineEnd = params.lineEnd || params.line || cm.lastLine();
      if (lineStart == lineEnd) {
        return;
      }
      var curStart = new Pos2(lineStart, 0);
      var curEnd = new Pos2(lineEnd, lineLength(cm, lineEnd));
      var text2 = cm.getRange(curStart, curEnd).split("\n");
      var numberRegex2 = number == "decimal" ? /(-?)([\d]+)/ : number == "hex" ? /(-?)(?:0x)?([0-9a-f]+)/i : number == "octal" ? /([0-7]+)/ : null;
      var radix = number == "decimal" ? 10 : number == "hex" ? 16 : number == "octal" ? 8 : void 0;
      var numPart = [], textPart = [];
      if (number || pattern) {
        for (var i4 = 0; i4 < text2.length; i4++) {
          var matchPart = pattern ? text2[i4].match(pattern) : null;
          if (matchPart && matchPart[0] != "") {
            numPart.push(matchPart);
          } else if (numberRegex2 && numberRegex2.exec(text2[i4])) {
            numPart.push(text2[i4]);
          } else {
            textPart.push(text2[i4]);
          }
        }
      } else {
        textPart = text2;
      }
      function compareFn(a4, b3) {
        if (reverse) {
          var tmp;
          tmp = a4;
          a4 = b3;
          b3 = tmp;
        }
        if (ignoreCase) {
          a4 = a4.toLowerCase();
          b3 = b3.toLowerCase();
        }
        var amatch = numberRegex2 && numberRegex2.exec(a4);
        var bmatch = numberRegex2 && numberRegex2.exec(b3);
        if (!amatch || !bmatch) {
          return a4 < b3 ? -1 : 1;
        }
        var anum = parseInt((amatch[1] + amatch[2]).toLowerCase(), radix);
        var bnum = parseInt((bmatch[1] + bmatch[2]).toLowerCase(), radix);
        return anum - bnum;
      }
      function comparePatternFn(a4, b3) {
        if (reverse) {
          var tmp;
          tmp = a4;
          a4 = b3;
          b3 = tmp;
        }
        if (ignoreCase) {
          a4[0] = a4[0].toLowerCase();
          b3[0] = b3[0].toLowerCase();
        }
        return a4[0] < b3[0] ? -1 : 1;
      }
      numPart.sort(pattern ? comparePatternFn : compareFn);
      if (pattern) {
        for (var i4 = 0; i4 < numPart.length; i4++) {
          numPart[i4] = numPart[i4].input;
        }
      } else if (!number) {
        textPart.sort(compareFn);
      }
      text2 = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);
      if (unique) {
        var textOld = text2;
        var lastLine;
        text2 = [];
        for (var i4 = 0; i4 < textOld.length; i4++) {
          if (textOld[i4] != lastLine) {
            text2.push(textOld[i4]);
          }
          lastLine = textOld[i4];
        }
      }
      cm.replaceRange(text2.join("\n"), curStart, curEnd);
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    vglobal: function(cm, params) {
      this.global(cm, params);
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    normal: function(cm, params) {
      var argString = params.argString;
      if (argString && argString[0] == "!") {
        argString = argString.slice(1);
        noremap = true;
      }
      argString = argString.trimStart();
      if (!argString) {
        showConfirm(cm, "Argument is required.");
        return;
      }
      var line2 = params.line;
      if (typeof line2 == "number") {
        var lineEnd = isNaN(params.lineEnd) ? line2 : params.lineEnd;
        for (var i4 = line2; i4 <= lineEnd; i4++) {
          cm.setCursor(i4, 0);
          doKeyToKey(cm, params.argString.trimStart());
          if (cm.state.vim.insertMode) {
            exitInsertMode(cm, true);
          }
        }
      } else {
        doKeyToKey(cm, params.argString.trimStart());
        if (cm.state.vim.insertMode) {
          exitInsertMode(cm, true);
        }
      }
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    global: function(cm, params) {
      var argString = params.argString;
      if (!argString) {
        showConfirm(cm, "Regular Expression missing from global");
        return;
      }
      var inverted = params.commandName[0] === "v";
      if (argString[0] === "!" && params.commandName[0] === "g") {
        inverted = true;
        argString = argString.slice(1);
      }
      var lineStart = params.line !== void 0 ? params.line : cm.firstLine();
      var lineEnd = params.lineEnd || params.line || cm.lastLine();
      var tokens = splitBySlash(argString);
      var regexPart = argString, cmd = "";
      if (tokens && tokens.length) {
        regexPart = tokens[0];
        cmd = tokens.slice(1, tokens.length).join("/");
      }
      if (regexPart) {
        try {
          updateSearchQuery(
            cm,
            regexPart,
            true,
            true
            /** smartCase */
          );
        } catch (e3) {
          showConfirm(cm, "Invalid regex: " + regexPart);
          return;
        }
      }
      var query = getSearchState(cm).getQuery();
      var matchedLines = [];
      for (var i4 = lineStart; i4 <= lineEnd; i4++) {
        var line2 = cm.getLine(i4);
        var matched = query.test(line2);
        if (matched !== inverted) {
          matchedLines.push(cmd ? cm.getLineHandle(i4) : line2);
        }
      }
      if (!cmd) {
        showConfirm(cm, matchedLines.join("\n"));
        return;
      }
      var index2 = 0;
      var nextCommand = function() {
        if (index2 < matchedLines.length) {
          var lineHandle = matchedLines[index2++];
          var lineNum = cm.getLineNumber(lineHandle);
          if (lineNum == null) {
            nextCommand();
            return;
          }
          var command = lineNum + 1 + cmd;
          exCommandDispatcher.processCommand(cm, command, {
            callback: nextCommand
          });
        } else if (cm.releaseLineHandles) {
          cm.releaseLineHandles();
        }
      };
      nextCommand();
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    substitute: function(cm, params) {
      if (!cm.getSearchCursor) {
        throw new Error("Search feature not available. Requires searchcursor.js or any other getSearchCursor implementation.");
      }
      var argString = params.argString;
      var tokens = argString ? splitBySeparator(argString, argString[0]) : [];
      var regexPart = "", replacePart = "", trailing, flagsPart, count;
      var confirm = false;
      var global2 = false;
      if (tokens && tokens.length) {
        regexPart = tokens[0];
        if (getOption("pcre") && regexPart !== "") {
          regexPart = new RegExp(regexPart).source;
        }
        replacePart = tokens[1];
        if (replacePart !== void 0) {
          if (getOption("pcre")) {
            replacePart = unescapeRegexReplace(replacePart.replace(/([^\\])&/g, "$1$$&"));
          } else {
            replacePart = translateRegexReplace(replacePart);
          }
          vimGlobalState.lastSubstituteReplacePart = replacePart;
        }
        trailing = tokens[2] ? tokens[2].split(" ") : [];
      } else {
        if (argString && argString.length) {
          showConfirm(cm, "Substitutions should be of the form :s/pattern/replace/");
          return;
        }
      }
      if (trailing) {
        flagsPart = trailing[0];
        count = parseInt(trailing[1]);
        if (flagsPart) {
          if (flagsPart.indexOf("c") != -1) {
            confirm = true;
          }
          if (flagsPart.indexOf("g") != -1) {
            global2 = true;
          }
          if (getOption("pcre")) {
            regexPart = regexPart + "/" + flagsPart;
          } else {
            regexPart = regexPart.replace(/\//g, "\\/") + "/" + flagsPart;
          }
        }
      }
      if (regexPart) {
        try {
          updateSearchQuery(
            cm,
            regexPart,
            true,
            true
            /** smartCase */
          );
        } catch (e3) {
          showConfirm(cm, "Invalid regex: " + regexPart);
          return;
        }
      }
      replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;
      if (replacePart === void 0) {
        showConfirm(cm, "No previous substitute regular expression");
        return;
      }
      var state2 = getSearchState(cm);
      var query = state2.getQuery();
      var lineStart = params.line !== void 0 ? params.line : cm.getCursor().line;
      var lineEnd = params.lineEnd || lineStart;
      if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {
        lineEnd = Infinity;
      }
      if (count) {
        lineStart = lineEnd;
        lineEnd = lineStart + count - 1;
      }
      var startPos = clipCursorToContent(cm, new Pos2(lineStart, 0));
      var cursor2 = cm.getSearchCursor(query, startPos);
      doReplace(cm, confirm, global2, lineStart, lineEnd, cursor2, query, replacePart, params.callback);
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    startinsert: function(cm, params) {
      doKeyToKey(cm, params.argString == "!" ? "A" : "i", {});
    },
    redo: CodeMirror2.commands.redo,
    undo: CodeMirror2.commands.undo,
    /** @arg {CodeMirrorV} cm */
    write: function(cm) {
      if (CodeMirror2.commands.save) {
        CodeMirror2.commands.save(cm);
      } else if (cm.save) {
        cm.save();
      }
    },
    /** @arg {CodeMirrorV} cm */
    nohlsearch: function(cm) {
      clearSearchHighlight(cm);
    },
    /** @arg {CodeMirrorV} cm */
    yank: function(cm) {
      var cur2 = copyCursor(cm.getCursor());
      var line2 = cur2.line;
      var lineText = cm.getLine(line2);
      vimGlobalState.registerController.pushText(
        "0",
        "yank",
        lineText,
        true,
        true
      );
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    delete: function(cm, params) {
      var line2 = params.selectionLine;
      var lineEnd = isNaN(params.selectionLineEnd) ? line2 : params.selectionLineEnd;
      operators.delete(cm, { linewise: true }, [
        {
          anchor: new Pos2(line2, 0),
          head: new Pos2(lineEnd + 1, 0)
        }
      ]);
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    join: function(cm, params) {
      var line2 = params.selectionLine;
      var lineEnd = isNaN(params.selectionLineEnd) ? line2 : params.selectionLineEnd;
      cm.setCursor(new Pos2(line2, 0));
      actions.joinLines(cm, { repeat: lineEnd - line2 }, cm.state.vim);
    },
    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/
    delmarks: function(cm, params) {
      if (!params.argString || !trim2(params.argString)) {
        showConfirm(cm, "Argument required");
        return;
      }
      var state2 = cm.state.vim;
      var stream = new CodeMirror2.StringStream(trim2(params.argString));
      while (!stream.eol()) {
        stream.eatSpace();
        var count = stream.pos;
        if (!stream.match(/[a-zA-Z]/, false)) {
          showConfirm(cm, "Invalid argument: " + params.argString.substring(count));
          return;
        }
        var sym = stream.next();
        if (stream.match("-", true)) {
          if (!stream.match(/[a-zA-Z]/, false)) {
            showConfirm(cm, "Invalid argument: " + params.argString.substring(count));
            return;
          }
          var startMark = sym;
          var finishMark = stream.next();
          if (startMark && finishMark && isLowerCase(startMark) == isLowerCase(finishMark)) {
            var start = startMark.charCodeAt(0);
            var finish = finishMark.charCodeAt(0);
            if (start >= finish) {
              showConfirm(cm, "Invalid argument: " + params.argString.substring(count));
              return;
            }
            for (var j4 = 0; j4 <= finish - start; j4++) {
              var mark = String.fromCharCode(start + j4);
              delete state2.marks[mark];
            }
          } else {
            showConfirm(cm, "Invalid argument: " + startMark + "-");
            return;
          }
        } else if (sym) {
          delete state2.marks[sym];
        }
      }
    }
  };
  var exCommandDispatcher = new ExCommandDispatcher();
  function doReplace(cm, confirm, global2, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {
    cm.state.vim.exMode = true;
    var done = false;
    var lastPos;
    var modifiedLineNumber;
    var joined;
    function replaceAll() {
      cm.operation(function() {
        while (!done) {
          replace3();
          next3();
        }
        stop();
      });
    }
    function replace3() {
      var text2 = cm.getRange(searchCursor.from(), searchCursor.to());
      var newText = text2.replace(query, replaceWith);
      var unmodifiedLineNumber = searchCursor.to().line;
      searchCursor.replace(newText);
      modifiedLineNumber = searchCursor.to().line;
      lineEnd += modifiedLineNumber - unmodifiedLineNumber;
      joined = modifiedLineNumber < unmodifiedLineNumber;
    }
    function findNextValidMatch() {
      var lastMatchTo = lastPos && copyCursor(searchCursor.to());
      var match4 = searchCursor.findNext();
      if (match4 && !match4[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {
        match4 = searchCursor.findNext();
      }
      return match4;
    }
    function next3() {
      while (findNextValidMatch() && isInRange(searchCursor.from(), lineStart, lineEnd)) {
        if (!global2 && searchCursor.from().line == modifiedLineNumber && !joined) {
          continue;
        }
        cm.scrollIntoView(searchCursor.from(), 30);
        cm.setSelection(searchCursor.from(), searchCursor.to());
        lastPos = searchCursor.from();
        done = false;
        return;
      }
      done = true;
    }
    function stop(close) {
      if (close) {
        close();
      }
      cm.focus();
      if (lastPos) {
        cm.setCursor(lastPos);
        var vim2 = cm.state.vim;
        vim2.exMode = false;
        vim2.lastHPos = vim2.lastHSPos = lastPos.ch;
      }
      if (callback) {
        callback();
      }
    }
    function onPromptKeyDown(e3, _value, close) {
      CodeMirror2.e_stop(e3);
      var keyName = vimKeyFromEvent(e3);
      switch (keyName) {
        case "y":
          replace3();
          next3();
          break;
        case "n":
          next3();
          break;
        case "a":
          var savedCallback = callback;
          callback = void 0;
          cm.operation(replaceAll);
          callback = savedCallback;
          break;
        case "l":
          replace3();
        // fall through and exit.
        case "q":
        case "<Esc>":
        case "<C-c>":
        case "<C-[>":
          stop(close);
          break;
      }
      if (done) {
        stop(close);
      }
      return true;
    }
    next3();
    if (done) {
      showConfirm(cm, "No matches for " + query.source);
      return;
    }
    if (!confirm) {
      replaceAll();
      if (callback) {
        callback();
      }
      return;
    }
    showPrompt(cm, {
      prefix: dom2("span", "replace with ", dom2("strong", replaceWith), " (y/n/a/q/l)"),
      onKeyDown: onPromptKeyDown
    });
  }
  function exitInsertMode(cm, keepCursor) {
    var vim2 = cm.state.vim;
    var macroModeState = vimGlobalState.macroModeState;
    var insertModeChangeRegister = vimGlobalState.registerController.getRegister(".");
    var isPlaying = macroModeState.isPlaying;
    var lastChange = macroModeState.lastInsertModeChanges;
    if (!isPlaying) {
      cm.off("change", onChange3);
      if (vim2.insertEnd) vim2.insertEnd.clear();
      vim2.insertEnd = void 0;
      CodeMirror2.off(cm.getInputField(), "keydown", onKeyEventTargetKeyDown);
    }
    if (!isPlaying && vim2.insertModeRepeat > 1) {
      repeatLastEdit(
        cm,
        vim2,
        vim2.insertModeRepeat - 1,
        true
        /** repeatForInsert */
      );
      vim2.lastEditInputState.repeatOverride = vim2.insertModeRepeat;
    }
    delete vim2.insertModeRepeat;
    vim2.insertMode = false;
    if (!keepCursor) {
      cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);
    }
    cm.setOption("keyMap", "vim");
    cm.setOption("disableInput", true);
    cm.toggleOverwrite(false);
    insertModeChangeRegister.setText(lastChange.changes.join(""));
    CodeMirror2.signal(cm, "vim-mode-change", { mode: "normal" });
    if (macroModeState.isRecording) {
      logInsertModeChange(macroModeState);
    }
  }
  function _mapCommand(command) {
    defaultKeymap2.unshift(command);
  }
  function mapCommand(keys2, type, name, args, extra) {
    var command = { keys: keys2, type };
    command[type] = name;
    command[type + "Args"] = args;
    for (var key in extra)
      command[key] = extra[key];
    _mapCommand(command);
  }
  defineOption("insertModeEscKeysTimeout", 200, "number");
  function executeMacroRegister(cm, vim2, macroModeState, registerName) {
    var register = vimGlobalState.registerController.getRegister(registerName);
    if (registerName == ":") {
      if (register.keyBuffer[0]) {
        exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);
      }
      macroModeState.isPlaying = false;
      return;
    }
    var keyBuffer = register.keyBuffer;
    var imc = 0;
    macroModeState.isPlaying = true;
    macroModeState.replaySearchQueries = register.searchQueries.slice(0);
    for (var i4 = 0; i4 < keyBuffer.length; i4++) {
      var text2 = keyBuffer[i4];
      var match4, key;
      var keyRe = /<(?:[CSMA]-)*\w+>|./gi;
      while (match4 = keyRe.exec(text2)) {
        key = match4[0];
        vimApi.handleKey(cm, key, "macro");
        if (vim2.insertMode) {
          var changes = register.insertModeChanges[imc++].changes;
          vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;
          repeatInsertModeChanges(cm, changes, 1);
          exitInsertMode(cm);
        }
      }
    }
    macroModeState.isPlaying = false;
  }
  function logKey(macroModeState, key) {
    if (macroModeState.isPlaying) {
      return;
    }
    var registerName = macroModeState.latestRegister;
    var register = vimGlobalState.registerController.getRegister(registerName);
    if (register) {
      register.pushText(key);
    }
  }
  function logInsertModeChange(macroModeState) {
    if (macroModeState.isPlaying) {
      return;
    }
    var registerName = macroModeState.latestRegister;
    var register = vimGlobalState.registerController.getRegister(registerName);
    if (register && register.pushInsertModeChanges) {
      register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);
    }
  }
  function logSearchQuery(macroModeState, query) {
    if (macroModeState.isPlaying) {
      return;
    }
    var registerName = macroModeState.latestRegister;
    var register = vimGlobalState.registerController.getRegister(registerName);
    if (register && register.pushSearchQuery) {
      register.pushSearchQuery(query);
    }
  }
  function onChange3(cm, changeObj) {
    var macroModeState = vimGlobalState.macroModeState;
    var lastChange = macroModeState.lastInsertModeChanges;
    if (!macroModeState.isPlaying) {
      var vim2 = cm.state.vim;
      while (changeObj) {
        lastChange.expectCursorActivityForChange = true;
        if (lastChange.ignoreCount > 1) {
          lastChange.ignoreCount--;
        } else if (changeObj.origin == "+input" || changeObj.origin == "paste" || changeObj.origin === void 0) {
          var selectionCount = cm.listSelections().length;
          if (selectionCount > 1)
            lastChange.ignoreCount = selectionCount;
          var text2 = changeObj.text.join("\n");
          if (lastChange.maybeReset) {
            lastChange.changes = [];
            lastChange.maybeReset = false;
          }
          if (text2) {
            if (cm.state.overwrite && !/\n/.test(text2)) {
              lastChange.changes.push([text2]);
            } else {
              if (text2.length > 1) {
                var insertEnd = vim2 && vim2.insertEnd && vim2.insertEnd.find();
                var cursor2 = cm.getCursor();
                if (insertEnd && insertEnd.line == cursor2.line) {
                  var offset3 = insertEnd.ch - cursor2.ch;
                  if (offset3 > 0 && offset3 < text2.length) {
                    lastChange.changes.push([text2, offset3]);
                    text2 = "";
                  }
                }
              }
              if (text2) lastChange.changes.push(text2);
            }
          }
        }
        changeObj = changeObj.next;
      }
    }
  }
  function onCursorActivity(cm) {
    var _a;
    var vim2 = cm.state.vim;
    if (vim2.insertMode) {
      var macroModeState = vimGlobalState.macroModeState;
      if (macroModeState.isPlaying) {
        return;
      }
      var lastChange = macroModeState.lastInsertModeChanges;
      if (lastChange.expectCursorActivityForChange) {
        lastChange.expectCursorActivityForChange = false;
      } else {
        lastChange.maybeReset = true;
        if (vim2.insertEnd) vim2.insertEnd.clear();
        vim2.insertEnd = cm.setBookmark(cm.getCursor(), { insertLeft: true });
      }
    } else if (!((_a = cm.curOp) == null ? void 0 : _a.isVimOp)) {
      handleExternalSelection(cm, vim2);
    }
  }
  function handleExternalSelection(cm, vim2) {
    var anchor = cm.getCursor("anchor");
    var head = cm.getCursor("head");
    if (vim2.visualMode && !cm.somethingSelected()) {
      exitVisualMode(cm, false);
    } else if (!vim2.visualMode && !vim2.insertMode && cm.somethingSelected()) {
      vim2.visualMode = true;
      vim2.visualLine = false;
      CodeMirror2.signal(cm, "vim-mode-change", { mode: "visual" });
    }
    if (vim2.visualMode) {
      var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;
      var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;
      head = offsetCursor(head, 0, headOffset);
      anchor = offsetCursor(anchor, 0, anchorOffset);
      vim2.sel = {
        anchor,
        head
      };
      updateMark(cm, vim2, "<", cursorMin(head, anchor));
      updateMark(cm, vim2, ">", cursorMax(head, anchor));
    } else if (!vim2.insertMode) {
      vim2.lastHPos = cm.getCursor().ch;
    }
  }
  function InsertModeKey(keyName, e3) {
    this.keyName = keyName;
    this.key = e3.key;
    this.ctrlKey = e3.ctrlKey;
    this.altKey = e3.altKey;
    this.metaKey = e3.metaKey;
    this.shiftKey = e3.shiftKey;
  }
  function onKeyEventTargetKeyDown(e3) {
    var macroModeState = vimGlobalState.macroModeState;
    var lastChange = macroModeState.lastInsertModeChanges;
    var keyName = CodeMirror2.keyName ? CodeMirror2.keyName(e3) : e3.key;
    if (!keyName) {
      return;
    }
    if (keyName.indexOf("Delete") != -1 || keyName.indexOf("Backspace") != -1) {
      if (lastChange.maybeReset) {
        lastChange.changes = [];
        lastChange.maybeReset = false;
      }
      lastChange.changes.push(new InsertModeKey(keyName, e3));
    }
  }
  function repeatLastEdit(cm, vim2, repeat, repeatForInsert) {
    var macroModeState = vimGlobalState.macroModeState;
    macroModeState.isPlaying = true;
    var lastAction = vim2.lastEditActionCommand;
    var cachedInputState = vim2.inputState;
    function repeatCommand() {
      if (lastAction) {
        commandDispatcher.processAction(cm, vim2, lastAction);
      } else {
        commandDispatcher.evalInput(cm, vim2);
      }
    }
    function repeatInsert(repeat2) {
      if (macroModeState.lastInsertModeChanges.changes.length > 0) {
        repeat2 = !vim2.lastEditActionCommand ? 1 : repeat2;
        var changeObject = macroModeState.lastInsertModeChanges;
        repeatInsertModeChanges(cm, changeObject.changes, repeat2);
      }
    }
    vim2.inputState = vim2.lastEditInputState;
    if (lastAction && lastAction.interlaceInsertRepeat) {
      for (var i4 = 0; i4 < repeat; i4++) {
        repeatCommand();
        repeatInsert(1);
      }
    } else {
      if (!repeatForInsert) {
        repeatCommand();
      }
      repeatInsert(repeat);
    }
    vim2.inputState = cachedInputState;
    if (vim2.insertMode && !repeatForInsert) {
      exitInsertMode(cm);
    }
    macroModeState.isPlaying = false;
  }
  function sendCmKey(cm, key) {
    CodeMirror2.lookupKey(key, "vim-insert", function keyHandler(binding) {
      if (typeof binding == "string") {
        CodeMirror2.commands[binding](cm);
      } else {
        binding(cm);
      }
      return true;
    });
  }
  function repeatInsertModeChanges(cm, changes, repeat) {
    var head = cm.getCursor("head");
    var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;
    if (visualBlock) {
      selectForInsert(cm, head, visualBlock + 1);
      repeat = cm.listSelections().length;
      cm.setCursor(head);
    }
    for (var i4 = 0; i4 < repeat; i4++) {
      if (visualBlock) {
        cm.setCursor(offsetCursor(head, i4, 0));
      }
      for (var j4 = 0; j4 < changes.length; j4++) {
        var change = changes[j4];
        if (change instanceof InsertModeKey) {
          sendCmKey(cm, change.keyName);
        } else if (typeof change == "string") {
          cm.replaceSelection(change);
        } else {
          var start = cm.getCursor();
          var end2 = offsetCursor(start, 0, change[0].length - (change[1] || 0));
          cm.replaceRange(change[0], start, change[1] ? start : end2);
          cm.setCursor(end2);
        }
      }
    }
    if (visualBlock) {
      cm.setCursor(offsetCursor(head, 0, 1));
    }
  }
  function cloneVimState(state2) {
    var n3 = new state2.constructor();
    Object.keys(state2).forEach(function(key) {
      if (key == "insertEnd") return;
      var o4 = state2[key];
      if (Array.isArray(o4))
        o4 = o4.slice();
      else if (o4 && typeof o4 == "object" && o4.constructor != Object)
        o4 = cloneVimState(o4);
      n3[key] = o4;
    });
    if (state2.sel) {
      n3.sel = {
        head: state2.sel.head && copyCursor(state2.sel.head),
        anchor: state2.sel.anchor && copyCursor(state2.sel.anchor)
      };
    }
    return n3;
  }
  function multiSelectHandleKey(cm_, key, origin) {
    var vim2 = maybeInitVimState(cm_);
    var cm = (
      /**@type {CodeMirrorV}*/
      cm_
    );
    var isHandled = false;
    var vim2 = vimApi.maybeInitVimState_(cm);
    var visualBlock = vim2.visualBlock || vim2.wasInVisualBlock;
    var wasMultiselect = cm.isInMultiSelectMode();
    if (vim2.wasInVisualBlock && !wasMultiselect) {
      vim2.wasInVisualBlock = false;
    } else if (wasMultiselect && vim2.visualBlock) {
      vim2.wasInVisualBlock = true;
    }
    if (key == "<Esc>" && !vim2.insertMode && !vim2.visualMode && wasMultiselect && vim2.status == "<Esc>") {
      clearInputState(cm);
    } else if (visualBlock || !wasMultiselect || cm.inVirtualSelectionMode) {
      isHandled = vimApi.handleKey(cm, key, origin);
    } else {
      var old = cloneVimState(vim2);
      var changeQueueList = vim2.inputState.changeQueueList || [];
      cm.operation(function() {
        var _a;
        if (cm.curOp)
          cm.curOp.isVimOp = true;
        var index2 = 0;
        cm.forEachSelection(function() {
          cm.state.vim.inputState.changeQueue = changeQueueList[index2];
          var head = cm.getCursor("head");
          var anchor = cm.getCursor("anchor");
          var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;
          var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;
          head = offsetCursor(head, 0, headOffset);
          anchor = offsetCursor(anchor, 0, anchorOffset);
          cm.state.vim.sel.head = head;
          cm.state.vim.sel.anchor = anchor;
          isHandled = vimApi.handleKey(cm, key, origin);
          if (cm.virtualSelection) {
            changeQueueList[index2] = cm.state.vim.inputState.changeQueue;
            cm.state.vim = cloneVimState(old);
          }
          index2++;
        });
        if (((_a = cm.curOp) == null ? void 0 : _a.cursorActivity) && !isHandled)
          cm.curOp.cursorActivity = false;
        cm.state.vim = vim2;
        vim2.inputState.changeQueueList = changeQueueList;
        vim2.inputState.changeQueue = null;
      }, true);
    }
    if (isHandled && !vim2.visualMode && !vim2.insert && vim2.visualMode != cm.somethingSelected()) {
      handleExternalSelection(cm, vim2);
    }
    return isHandled;
  }
  resetVimGlobalState();
  return vimApi;
}
function indexFromPos(doc, pos) {
  var ch = pos.ch;
  var lineNumber = pos.line + 1;
  if (lineNumber < 1) {
    lineNumber = 1;
    ch = 0;
  }
  if (lineNumber > doc.lines) {
    lineNumber = doc.lines;
    ch = Number.MAX_VALUE;
  }
  var line2 = doc.line(lineNumber);
  return Math.min(line2.from + Math.max(0, ch), line2.to);
}
function posFromIndex(doc, offset3) {
  let line2 = doc.lineAt(offset3);
  return { line: line2.number - 1, ch: offset3 - line2.from };
}
var Pos = class {
  constructor(line2, ch) {
    this.line = line2;
    this.ch = ch;
  }
};
function on2(emitter, type, f4) {
  if (emitter.addEventListener) {
    emitter.addEventListener(type, f4, false);
  } else {
    var map = emitter._handlers || (emitter._handlers = {});
    map[type] = (map[type] || []).concat(f4);
  }
}
function off(emitter, type, f4) {
  if (emitter.removeEventListener) {
    emitter.removeEventListener(type, f4, false);
  } else {
    var map = emitter._handlers, arr = map && map[type];
    if (arr) {
      var index2 = arr.indexOf(f4);
      if (index2 > -1) {
        map[type] = arr.slice(0, index2).concat(arr.slice(index2 + 1));
      }
    }
  }
}
function signal(emitter, type, ...args) {
  var _a;
  var handlers = (_a = emitter._handlers) === null || _a === void 0 ? void 0 : _a[type];
  if (!handlers)
    return;
  for (var i4 = 0; i4 < handlers.length; ++i4) {
    handlers[i4](...args);
  }
}
function signalTo(handlers, ...args) {
  if (!handlers)
    return;
  for (var i4 = 0; i4 < handlers.length; ++i4) {
    handlers[i4](...args);
  }
}
var wordChar;
try {
  wordChar = /* @__PURE__ */ new RegExp("[\\w\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_3) {
  wordChar = /[\w]/;
}
function dispatchChange(cm, transaction) {
  var view = cm.cm6;
  if (view.state.readOnly)
    return;
  var type = "input.type.compose";
  if (cm.curOp) {
    if (!cm.curOp.lastChange)
      type = "input.type.compose.start";
  }
  if (transaction.annotations) {
    try {
      transaction.annotations.some(function(note) {
        if (note.value == "input")
          note.value = type;
      });
    } catch (e3) {
      console.error(e3);
    }
  } else {
    transaction.userEvent = type;
  }
  return view.dispatch(transaction);
}
function runHistoryCommand(cm, revert) {
  var _a;
  if (cm.curOp) {
    cm.curOp.$changeStart = void 0;
  }
  (revert ? import_commands.undo : import_commands.redo)(cm.cm6);
  let changeStartIndex = (_a = cm.curOp) === null || _a === void 0 ? void 0 : _a.$changeStart;
  if (changeStartIndex != null) {
    cm.cm6.dispatch({ selection: { anchor: changeStartIndex } });
  }
}
var keys = {};
var CodeMirror = class _CodeMirror {
  constructor(cm6) {
    this.state = {};
    this.marks = /* @__PURE__ */ Object.create(null);
    this.$mid = 0;
    this.options = {};
    this._handlers = {};
    this.$lastChangeEndOffset = 0;
    this.virtualSelection = null;
    this.cm6 = cm6;
    this.onChange = this.onChange.bind(this);
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  // --------------------------
  openDialog(template, callback, options2) {
    return openDialog(this, template, callback, options2);
  }
  openNotification(template, options2) {
    return openNotification(this, template, options2);
  }
  on(type, f4) {
    on2(this, type, f4);
  }
  off(type, f4) {
    off(this, type, f4);
  }
  signal(type, e3, handlers) {
    signal(this, type, e3, handlers);
  }
  indexFromPos(pos) {
    return indexFromPos(this.cm6.state.doc, pos);
  }
  posFromIndex(offset3) {
    return posFromIndex(this.cm6.state.doc, offset3);
  }
  foldCode(pos) {
    let view = this.cm6;
    let ranges = view.state.selection.ranges;
    let doc = this.cm6.state.doc;
    let index2 = indexFromPos(doc, pos);
    let tmpRanges = import_state6.EditorSelection.create([import_state6.EditorSelection.range(index2, index2)], 0).ranges;
    view.state.selection.ranges = tmpRanges;
    (0, import_language3.foldCode)(view);
    view.state.selection.ranges = ranges;
  }
  firstLine() {
    return 0;
  }
  lastLine() {
    return this.cm6.state.doc.lines - 1;
  }
  lineCount() {
    return this.cm6.state.doc.lines;
  }
  setCursor(line2, ch) {
    if (typeof line2 === "object") {
      ch = line2.ch;
      line2 = line2.line;
    }
    var offset3 = indexFromPos(this.cm6.state.doc, { line: line2, ch: ch || 0 });
    this.cm6.dispatch({ selection: { anchor: offset3 } }, { scrollIntoView: !this.curOp });
    if (this.curOp && !this.curOp.isVimOp)
      this.onBeforeEndOperation();
  }
  getCursor(p3) {
    var sel = this.cm6.state.selection.main;
    var offset3 = p3 == "head" || !p3 ? sel.head : p3 == "anchor" ? sel.anchor : p3 == "start" ? sel.from : p3 == "end" ? sel.to : null;
    if (offset3 == null)
      throw new Error("Invalid cursor type");
    return this.posFromIndex(offset3);
  }
  listSelections() {
    var doc = this.cm6.state.doc;
    return this.cm6.state.selection.ranges.map((r4) => {
      return {
        anchor: posFromIndex(doc, r4.anchor),
        head: posFromIndex(doc, r4.head)
      };
    });
  }
  setSelections(p3, primIndex) {
    var doc = this.cm6.state.doc;
    var ranges = p3.map((x4) => {
      var head = indexFromPos(doc, x4.head);
      var anchor = indexFromPos(doc, x4.anchor);
      if (head == anchor)
        return import_state6.EditorSelection.cursor(head, 1);
      return import_state6.EditorSelection.range(anchor, head);
    });
    this.cm6.dispatch({
      selection: import_state6.EditorSelection.create(ranges, primIndex)
    });
  }
  setSelection(anchor, head, options2) {
    this.setSelections([{ anchor, head }], 0);
    if (options2 && options2.origin == "*mouse") {
      this.onBeforeEndOperation();
    }
  }
  getLine(row) {
    var doc = this.cm6.state.doc;
    if (row < 0 || row >= doc.lines)
      return "";
    return this.cm6.state.doc.line(row + 1).text;
  }
  getLineHandle(row) {
    if (!this.$lineHandleChanges)
      this.$lineHandleChanges = [];
    return { row, index: this.indexFromPos(new Pos(row, 0)) };
  }
  getLineNumber(handle) {
    var updates = this.$lineHandleChanges;
    if (!updates)
      return null;
    var offset3 = handle.index;
    for (var i4 = 0; i4 < updates.length; i4++) {
      offset3 = updates[i4].changes.mapPos(offset3, 1, import_state6.MapMode.TrackAfter);
      if (offset3 == null)
        return null;
    }
    var pos = this.posFromIndex(offset3);
    return pos.ch == 0 ? pos.line : null;
  }
  releaseLineHandles() {
    this.$lineHandleChanges = void 0;
  }
  getRange(s4, e3) {
    var doc = this.cm6.state.doc;
    return this.cm6.state.sliceDoc(indexFromPos(doc, s4), indexFromPos(doc, e3));
  }
  replaceRange(text2, s4, e3, source) {
    if (!e3)
      e3 = s4;
    var doc = this.cm6.state.doc;
    var from2 = indexFromPos(doc, s4);
    var to = indexFromPos(doc, e3);
    dispatchChange(this, { changes: { from: from2, to, insert: text2 } });
  }
  replaceSelection(text2) {
    dispatchChange(this, this.cm6.state.replaceSelection(text2));
  }
  replaceSelections(replacements) {
    var ranges = this.cm6.state.selection.ranges;
    var changes = ranges.map((r4, i4) => {
      return { from: r4.from, to: r4.to, insert: replacements[i4] || "" };
    });
    dispatchChange(this, { changes });
  }
  getSelection() {
    return this.getSelections().join("\n");
  }
  getSelections() {
    var cm = this.cm6;
    return cm.state.selection.ranges.map((r4) => cm.state.sliceDoc(r4.from, r4.to));
  }
  somethingSelected() {
    return this.cm6.state.selection.ranges.some((r4) => !r4.empty);
  }
  getInputField() {
    return this.cm6.contentDOM;
  }
  clipPos(p3) {
    var doc = this.cm6.state.doc;
    var ch = p3.ch;
    var lineNumber = p3.line + 1;
    if (lineNumber < 1) {
      lineNumber = 1;
      ch = 0;
    }
    if (lineNumber > doc.lines) {
      lineNumber = doc.lines;
      ch = Number.MAX_VALUE;
    }
    var line2 = doc.line(lineNumber);
    ch = Math.min(Math.max(0, ch), line2.to - line2.from);
    return new Pos(lineNumber - 1, ch);
  }
  getValue() {
    return this.cm6.state.doc.toString();
  }
  setValue(text2) {
    var cm = this.cm6;
    return cm.dispatch({
      changes: { from: 0, to: cm.state.doc.length, insert: text2 },
      selection: import_state6.EditorSelection.range(0, 0)
    });
  }
  focus() {
    return this.cm6.focus();
  }
  blur() {
    return this.cm6.contentDOM.blur();
  }
  defaultTextHeight() {
    return this.cm6.defaultLineHeight;
  }
  findMatchingBracket(pos, _options) {
    var state2 = this.cm6.state;
    var offset3 = indexFromPos(state2.doc, pos);
    var m3 = (0, import_language3.matchBrackets)(state2, offset3 + 1, -1);
    if (m3 && m3.end) {
      return { to: posFromIndex(state2.doc, m3.end.from) };
    }
    m3 = (0, import_language3.matchBrackets)(state2, offset3, 1);
    if (m3 && m3.end) {
      return { to: posFromIndex(state2.doc, m3.end.from) };
    }
    return { to: void 0 };
  }
  scanForBracket(pos, dir, style, config3) {
    return scanForBracket(this, pos, dir, style, config3);
  }
  indentLine(line2, more) {
    if (more)
      this.indentMore();
    else
      this.indentLess();
  }
  indentMore() {
    (0, import_commands.indentMore)(this.cm6);
  }
  indentLess() {
    (0, import_commands.indentLess)(this.cm6);
  }
  execCommand(name) {
    if (name == "indentAuto")
      _CodeMirror.commands.indentAuto(this);
    else if (name == "goLineLeft")
      (0, import_commands.cursorLineBoundaryBackward)(this.cm6);
    else if (name == "goLineRight") {
      (0, import_commands.cursorLineBoundaryForward)(this.cm6);
      let state2 = this.cm6.state;
      let cur2 = state2.selection.main.head;
      if (cur2 < state2.doc.length && state2.sliceDoc(cur2, cur2 + 1) !== "\n") {
        (0, import_commands.cursorCharBackward)(this.cm6);
      }
    } else
      console.log(name + " is not implemented");
  }
  setBookmark(cursor2, options2) {
    var assoc = (options2 === null || options2 === void 0 ? void 0 : options2.insertLeft) ? 1 : -1;
    var offset3 = this.indexFromPos(cursor2);
    var bm = new Marker(this, offset3, assoc);
    return bm;
  }
  addOverlay({ query }) {
    let cm6Query = new import_search.SearchQuery({
      regexp: true,
      search: query.source,
      caseSensitive: !/i/.test(query.flags)
    });
    if (cm6Query.valid) {
      cm6Query.forVim = true;
      this.cm6Query = cm6Query;
      let effect = import_search.setSearchQuery.of(cm6Query);
      this.cm6.dispatch({ effects: effect });
      return cm6Query;
    }
  }
  removeOverlay(overlay) {
    if (!this.cm6Query)
      return;
    this.cm6Query.forVim = false;
    let effect = import_search.setSearchQuery.of(this.cm6Query);
    this.cm6.dispatch({ effects: effect });
  }
  getSearchCursor(query, pos) {
    var cm = this;
    var last = null;
    var lastCM5Result = null;
    if (pos.ch == void 0)
      pos.ch = Number.MAX_VALUE;
    var firstOffset = indexFromPos(cm.cm6.state.doc, pos);
    var source = query.source.replace(/(\\.|{(?:\d+(?:,\d*)?|,\d+)})|[{}]/g, function(a4, b3) {
      if (!b3)
        return "\\" + a4;
      return b3;
    });
    function rCursor(doc, from2 = 0, to = doc.length) {
      return new import_search.RegExpCursor(doc, source, { ignoreCase: query.ignoreCase }, from2, to);
    }
    function nextMatch(from2) {
      var doc = cm.cm6.state.doc;
      if (from2 > doc.length)
        return null;
      let res = rCursor(doc, from2).next();
      return res.done ? null : res.value;
    }
    var ChunkSize = 1e4;
    function prevMatchInRange(from2, to) {
      var doc = cm.cm6.state.doc;
      for (let size2 = 1; ; size2++) {
        let start = Math.max(from2, to - size2 * ChunkSize);
        let cursor2 = rCursor(doc, start, to), range = null;
        while (!cursor2.next().done)
          range = cursor2.value;
        if (range && (start == from2 || range.from > start + 10))
          return range;
        if (start == from2)
          return null;
      }
    }
    return {
      findNext: function() {
        return this.find(false);
      },
      findPrevious: function() {
        return this.find(true);
      },
      find: function(back) {
        var doc = cm.cm6.state.doc;
        if (back) {
          let endAt = last ? last.from == last.to ? last.to - 1 : last.from : firstOffset;
          last = prevMatchInRange(0, endAt);
        } else {
          let startFrom = last ? last.from == last.to ? last.to + 1 : last.to : firstOffset;
          last = nextMatch(startFrom);
        }
        lastCM5Result = last && {
          from: posFromIndex(doc, last.from),
          to: posFromIndex(doc, last.to),
          match: last.match
        };
        return last && last.match;
      },
      from: function() {
        return lastCM5Result === null || lastCM5Result === void 0 ? void 0 : lastCM5Result.from;
      },
      to: function() {
        return lastCM5Result === null || lastCM5Result === void 0 ? void 0 : lastCM5Result.to;
      },
      replace: function(text2) {
        if (last) {
          dispatchChange(cm, {
            changes: { from: last.from, to: last.to, insert: text2 }
          });
          last.to = last.from + text2.length;
          if (lastCM5Result) {
            lastCM5Result.to = posFromIndex(cm.cm6.state.doc, last.to);
          }
        }
      }
    };
  }
  findPosV(start, amount, unit, goalColumn) {
    let { cm6 } = this;
    const doc = cm6.state.doc;
    let pixels = unit == "page" ? cm6.dom.clientHeight : 0;
    const startOffset = indexFromPos(doc, start);
    let range = import_state6.EditorSelection.cursor(startOffset, 1, void 0, goalColumn);
    let count = Math.round(Math.abs(amount));
    for (let i4 = 0; i4 < count; i4++) {
      if (unit == "page") {
        range = cm6.moveVertically(range, amount > 0, pixels);
      } else if (unit == "line") {
        range = cm6.moveVertically(range, amount > 0);
      }
    }
    let pos = posFromIndex(doc, range.head);
    if (amount < 0 && range.head == 0 && goalColumn != 0 && start.line == 0 && start.ch != 0 || amount > 0 && range.head == doc.length && pos.ch != goalColumn && start.line == pos.line) {
      pos.hitSide = true;
    }
    return pos;
  }
  charCoords(pos, mode) {
    var rect = this.cm6.contentDOM.getBoundingClientRect();
    var offset3 = indexFromPos(this.cm6.state.doc, pos);
    var coords = this.cm6.coordsAtPos(offset3);
    var d3 = -rect.top;
    return { left: ((coords === null || coords === void 0 ? void 0 : coords.left) || 0) - rect.left, top: ((coords === null || coords === void 0 ? void 0 : coords.top) || 0) + d3, bottom: ((coords === null || coords === void 0 ? void 0 : coords.bottom) || 0) + d3 };
  }
  coordsChar(coords, mode) {
    var rect = this.cm6.contentDOM.getBoundingClientRect();
    var offset3 = this.cm6.posAtCoords({ x: coords.left + rect.left, y: coords.top + rect.top }) || 0;
    return posFromIndex(this.cm6.state.doc, offset3);
  }
  getScrollInfo() {
    var scroller = this.cm6.scrollDOM;
    return {
      left: scroller.scrollLeft,
      top: scroller.scrollTop,
      height: scroller.scrollHeight,
      width: scroller.scrollWidth,
      clientHeight: scroller.clientHeight,
      clientWidth: scroller.clientWidth
    };
  }
  scrollTo(x4, y4) {
    if (x4 != null)
      this.cm6.scrollDOM.scrollLeft = x4;
    if (y4 != null)
      this.cm6.scrollDOM.scrollTop = y4;
  }
  scrollIntoView(pos, margin) {
    if (pos) {
      var offset3 = this.indexFromPos(pos);
      this.cm6.dispatch({
        effects: import_view3.EditorView.scrollIntoView(offset3)
      });
    } else {
      this.cm6.dispatch({ scrollIntoView: true, userEvent: "scroll" });
    }
  }
  getWrapperElement() {
    return this.cm6.dom;
  }
  // for tests
  getMode() {
    return { name: this.getOption("mode") };
  }
  setSize(w5, h3) {
    this.cm6.dom.style.width = w5 + 4 + "px";
    this.cm6.dom.style.height = h3 + "px";
    this.refresh();
  }
  refresh() {
    this.cm6.measure();
  }
  // event listeners
  destroy() {
    this.removeOverlay();
  }
  getLastEditEnd() {
    return this.posFromIndex(this.$lastChangeEndOffset);
  }
  onChange(update) {
    if (this.$lineHandleChanges) {
      this.$lineHandleChanges.push(update);
    }
    for (let i4 in this.marks) {
      let m3 = this.marks[i4];
      m3.update(update.changes);
    }
    if (this.virtualSelection) {
      this.virtualSelection.ranges = this.virtualSelection.ranges.map((range) => range.map(update.changes));
    }
    var curOp = this.curOp = this.curOp || {};
    update.changes.iterChanges((fromA, toA, fromB, toB, text2) => {
      if (curOp.$changeStart == null || curOp.$changeStart > fromB)
        curOp.$changeStart = fromB;
      this.$lastChangeEndOffset = toB;
      var change = { text: text2.toJSON() };
      if (!curOp.lastChange) {
        curOp.lastChange = curOp.change = change;
      } else {
        curOp.lastChange.next = curOp.lastChange = change;
      }
    }, true);
    if (!curOp.changeHandlers)
      curOp.changeHandlers = this._handlers["change"] && this._handlers["change"].slice();
  }
  onSelectionChange() {
    var curOp = this.curOp = this.curOp || {};
    if (!curOp.cursorActivityHandlers)
      curOp.cursorActivityHandlers = this._handlers["cursorActivity"] && this._handlers["cursorActivity"].slice();
    this.curOp.cursorActivity = true;
  }
  operation(fn2, force) {
    if (!this.curOp)
      this.curOp = { $d: 0 };
    this.curOp.$d++;
    try {
      var result = fn2();
    } finally {
      if (this.curOp) {
        this.curOp.$d--;
        if (!this.curOp.$d)
          this.onBeforeEndOperation();
      }
    }
    return result;
  }
  onBeforeEndOperation() {
    var op = this.curOp;
    var scrollIntoView3 = false;
    if (op) {
      if (op.change) {
        signalTo(op.changeHandlers, this, op.change);
      }
      if (op && op.cursorActivity) {
        signalTo(op.cursorActivityHandlers, this, null);
        if (op.isVimOp)
          scrollIntoView3 = true;
      }
      this.curOp = null;
    }
    if (scrollIntoView3)
      this.scrollIntoView();
  }
  moveH(increment, unit) {
    if (unit == "char") {
      var cur2 = this.getCursor();
      this.setCursor(cur2.line, cur2.ch + increment);
    }
  }
  setOption(name, val) {
    switch (name) {
      case "keyMap":
        this.state.keyMap = val;
        break;
      case "textwidth":
        this.state.textwidth = val;
        break;
    }
  }
  getOption(name) {
    switch (name) {
      case "firstLineNumber":
        return 1;
      case "tabSize":
        return this.cm6.state.tabSize || 4;
      case "readOnly":
        return this.cm6.state.readOnly;
      case "indentWithTabs":
        return this.cm6.state.facet(import_language3.indentUnit) == "	";
      // TODO
      case "indentUnit":
        return this.cm6.state.facet(import_language3.indentUnit).length || 2;
      case "textwidth":
        return this.state.textwidth;
      // for tests
      case "keyMap":
        return this.state.keyMap || "vim";
    }
  }
  toggleOverwrite(on3) {
    this.state.overwrite = on3;
  }
  getTokenTypeAt(pos) {
    var _a;
    var offset3 = this.indexFromPos(pos);
    var tree = (0, import_language3.ensureSyntaxTree)(this.cm6.state, offset3);
    var node2 = tree === null || tree === void 0 ? void 0 : tree.resolve(offset3);
    var type = ((_a = node2 === null || node2 === void 0 ? void 0 : node2.type) === null || _a === void 0 ? void 0 : _a.name) || "";
    if (/comment/i.test(type))
      return "comment";
    if (/string/i.test(type))
      return "string";
    return "";
  }
  overWriteSelection(text2) {
    var doc = this.cm6.state.doc;
    var sel = this.cm6.state.selection;
    var ranges = sel.ranges.map((x4) => {
      if (x4.empty) {
        var ch = x4.to < doc.length ? doc.sliceString(x4.from, x4.to + 1) : "";
        if (ch && !/\n/.test(ch))
          return import_state6.EditorSelection.range(x4.from, x4.to + 1);
      }
      return x4;
    });
    this.cm6.dispatch({
      selection: import_state6.EditorSelection.create(ranges, sel.mainIndex)
    });
    this.replaceSelection(text2);
  }
  /*** multiselect ****/
  isInMultiSelectMode() {
    return this.cm6.state.selection.ranges.length > 1;
  }
  virtualSelectionMode() {
    return !!this.virtualSelection;
  }
  forEachSelection(command) {
    var selection = this.cm6.state.selection;
    this.virtualSelection = import_state6.EditorSelection.create(selection.ranges, selection.mainIndex);
    for (var i4 = 0; i4 < this.virtualSelection.ranges.length; i4++) {
      var range = this.virtualSelection.ranges[i4];
      if (!range)
        continue;
      this.cm6.dispatch({ selection: import_state6.EditorSelection.create([range]) });
      command();
      this.virtualSelection.ranges[i4] = this.cm6.state.selection.ranges[0];
    }
    this.cm6.dispatch({ selection: this.virtualSelection });
    this.virtualSelection = null;
  }
  hardWrap(options2) {
    return hardWrap(this, options2);
  }
};
CodeMirror.isMac = typeof navigator != "undefined" && /* @__PURE__ */ /Mac/.test(navigator.platform);
CodeMirror.Pos = Pos;
CodeMirror.StringStream = import_language3.StringStream;
CodeMirror.commands = {
  cursorCharLeft: function(cm) {
    (0, import_commands.cursorCharLeft)(cm.cm6);
  },
  redo: function(cm) {
    runHistoryCommand(cm, false);
  },
  undo: function(cm) {
    runHistoryCommand(cm, true);
  },
  newlineAndIndent: function(cm) {
    (0, import_commands.insertNewlineAndIndent)({
      state: cm.cm6.state,
      dispatch: (tr) => {
        return dispatchChange(cm, tr);
      }
    });
  },
  indentAuto: function(cm) {
    (0, import_commands.indentSelection)(cm.cm6);
  },
  newlineAndIndentContinueComment: void 0,
  save: void 0
};
CodeMirror.isWordChar = function(ch) {
  return wordChar.test(ch);
};
CodeMirror.keys = keys;
CodeMirror.addClass = function(el, str) {
};
CodeMirror.rmClass = function(el, str) {
};
CodeMirror.e_preventDefault = function(e3) {
  e3.preventDefault();
};
CodeMirror.e_stop = function(e3) {
  var _a, _b;
  (_a = e3 === null || e3 === void 0 ? void 0 : e3.stopPropagation) === null || _a === void 0 ? void 0 : _a.call(e3);
  (_b = e3 === null || e3 === void 0 ? void 0 : e3.preventDefault) === null || _b === void 0 ? void 0 : _b.call(e3);
};
CodeMirror.lookupKey = function lookupKey(key, map, handle) {
  var result = CodeMirror.keys[key];
  if (result)
    handle(result);
};
CodeMirror.on = on2;
CodeMirror.off = off;
CodeMirror.signal = signal;
CodeMirror.findMatchingTag = findMatchingTag;
CodeMirror.findEnclosingTag = findEnclosingTag;
CodeMirror.keyName = void 0;
function dialogDiv(cm, template, bottom) {
  var dialog = document.createElement("div");
  dialog.appendChild(template);
  return dialog;
}
function closeNotification(cm, newVal) {
  if (cm.state.currentNotificationClose)
    cm.state.currentNotificationClose();
  cm.state.currentNotificationClose = newVal;
}
function openNotification(cm, template, options2) {
  closeNotification(cm, close);
  var dialog = dialogDiv(cm, template, options2 && options2.bottom);
  var closed = false;
  var doneTimer;
  var duration = options2 && typeof options2.duration !== "undefined" ? options2.duration : 5e3;
  function close() {
    if (closed)
      return;
    closed = true;
    clearTimeout(doneTimer);
    dialog.remove();
    hideDialog(cm, dialog);
  }
  dialog.onclick = function(e3) {
    e3.preventDefault();
    close();
  };
  showDialog(cm, dialog);
  if (duration)
    doneTimer = setTimeout(close, duration);
  return close;
}
function showDialog(cm, dialog) {
  var oldDialog = cm.state.dialog;
  cm.state.dialog = dialog;
  if (dialog && oldDialog !== dialog) {
    if (oldDialog && oldDialog.contains(document.activeElement))
      cm.focus();
    if (oldDialog && oldDialog.parentElement) {
      oldDialog.parentElement.replaceChild(dialog, oldDialog);
    } else if (oldDialog) {
      oldDialog.remove();
    }
    CodeMirror.signal(cm, "dialog");
  }
}
function hideDialog(cm, dialog) {
  if (cm.state.dialog == dialog) {
    cm.state.dialog = null;
    CodeMirror.signal(cm, "dialog");
  }
}
function openDialog(me, template, callback, options2) {
  if (!options2)
    options2 = {};
  closeNotification(me, void 0);
  var dialog = dialogDiv(me, template, options2.bottom);
  var closed = false;
  showDialog(me, dialog);
  function close(newVal) {
    if (typeof newVal == "string") {
      inp.value = newVal;
    } else {
      if (closed)
        return;
      closed = true;
      hideDialog(me, dialog);
      if (!me.state.dialog)
        me.focus();
      if (options2.onClose)
        options2.onClose(dialog);
    }
  }
  var inp = dialog.getElementsByTagName("input")[0];
  if (inp) {
    if (options2.value) {
      inp.value = options2.value;
      if (options2.selectValueOnOpen !== false)
        inp.select();
    }
    if (options2.onInput)
      CodeMirror.on(inp, "input", function(e3) {
        options2.onInput(e3, inp.value, close);
      });
    if (options2.onKeyUp)
      CodeMirror.on(inp, "keyup", function(e3) {
        options2.onKeyUp(e3, inp.value, close);
      });
    CodeMirror.on(inp, "keydown", function(e3) {
      if (options2 && options2.onKeyDown && options2.onKeyDown(e3, inp.value, close)) {
        return;
      }
      if (e3.keyCode == 13)
        callback(inp.value);
      if (e3.keyCode == 27 || options2.closeOnEnter !== false && e3.keyCode == 13) {
        inp.blur();
        CodeMirror.e_stop(e3);
        close();
      }
    });
    if (options2.closeOnBlur !== false)
      CodeMirror.on(inp, "blur", function() {
        setTimeout(function() {
          if (document.activeElement === inp)
            return;
          close();
        });
      });
    inp.focus();
  }
  return close;
}
var matching = { "(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<", "<": ">>", ">": "<<" };
function bracketRegex(config3) {
  return config3 && config3.bracketRegex || /[(){}[\]]/;
}
function scanForBracket(cm, where, dir, style, config3) {
  var maxScanLen = config3 && config3.maxScanLineLength || 1e4;
  var maxScanLines = config3 && config3.maxScanLines || 1e3;
  var stack = [];
  var re = bracketRegex(config3);
  var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);
  for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
    var line2 = cm.getLine(lineNo);
    if (!line2)
      continue;
    var pos = dir > 0 ? 0 : line2.length - 1, end2 = dir > 0 ? line2.length : -1;
    if (line2.length > maxScanLen)
      continue;
    if (lineNo == where.line)
      pos = where.ch - (dir < 0 ? 1 : 0);
    for (; pos != end2; pos += dir) {
      var ch = line2.charAt(pos);
      if (re.test(ch)) {
        var match4 = matching[ch];
        if (match4 && match4.charAt(1) == ">" == dir > 0)
          stack.push(ch);
        else if (!stack.length)
          return { pos: new Pos(lineNo, pos), ch };
        else
          stack.pop();
      }
    }
  }
  return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
}
function findMatchingTag(cm, pos) {
}
function findEnclosingTag(cm, pos) {
  var _a, _b;
  var state2 = cm.cm6.state;
  var offset3 = cm.indexFromPos(pos);
  if (offset3 < state2.doc.length) {
    var text2 = state2.sliceDoc(offset3, offset3 + 1);
    if (text2 == "<")
      offset3++;
  }
  var tree = (0, import_language3.ensureSyntaxTree)(state2, offset3);
  var node2 = (tree === null || tree === void 0 ? void 0 : tree.resolve(offset3)) || null;
  while (node2) {
    if (((_a = node2.firstChild) === null || _a === void 0 ? void 0 : _a.type.name) == "OpenTag" && ((_b = node2.lastChild) === null || _b === void 0 ? void 0 : _b.type.name) == "CloseTag") {
      return {
        open: convertRange(state2.doc, node2.firstChild),
        close: convertRange(state2.doc, node2.lastChild)
      };
    }
    node2 = node2.parent;
  }
}
function convertRange(doc, cm6Range) {
  return {
    from: posFromIndex(doc, cm6Range.from),
    to: posFromIndex(doc, cm6Range.to)
  };
}
var Marker = class {
  constructor(cm, offset3, assoc) {
    this.cm = cm;
    this.id = cm.$mid++;
    this.offset = offset3;
    this.assoc = assoc;
    cm.marks[this.id] = this;
  }
  clear() {
    delete this.cm.marks[this.id];
  }
  find() {
    if (this.offset == null)
      return null;
    return this.cm.posFromIndex(this.offset);
  }
  update(change) {
    if (this.offset != null)
      this.offset = change.mapPos(this.offset, this.assoc, import_state6.MapMode.TrackDel);
  }
};
function hardWrap(cm, options2) {
  var _a;
  var max2 = options2.column || cm.getOption("textwidth") || 80;
  var allowMerge = options2.allowMerge != false;
  var row = Math.min(options2.from, options2.to);
  var endRow = Math.max(options2.from, options2.to);
  while (row <= endRow) {
    var line2 = cm.getLine(row);
    if (line2.length > max2) {
      var space2 = findSpace(line2, max2, 5);
      if (space2) {
        var indentation = (_a = /^\s*/.exec(line2)) === null || _a === void 0 ? void 0 : _a[0];
        cm.replaceRange("\n" + indentation, new Pos(row, space2.start), new Pos(row, space2.end));
      }
      endRow++;
    } else if (allowMerge && /\S/.test(line2) && row != endRow) {
      var nextLine = cm.getLine(row + 1);
      if (nextLine && /\S/.test(nextLine)) {
        var trimmedLine = line2.replace(/\s+$/, "");
        var trimmedNextLine = nextLine.replace(/^\s+/, "");
        var mergedLine = trimmedLine + " " + trimmedNextLine;
        var space2 = findSpace(mergedLine, max2, 5);
        if (space2 && space2.start > trimmedLine.length || mergedLine.length < max2) {
          cm.replaceRange(" ", new Pos(row, trimmedLine.length), new Pos(row + 1, nextLine.length - trimmedNextLine.length));
          row--;
          endRow--;
        } else if (trimmedLine.length < line2.length) {
          cm.replaceRange("", new Pos(row, trimmedLine.length), new Pos(row, line2.length));
        }
      }
    }
    row++;
  }
  return row;
  function findSpace(line3, max3, min2) {
    if (line3.length < max3)
      return;
    var before = line3.slice(0, max3);
    var after = line3.slice(max3);
    var spaceAfter = /^(?:(\s+)|(\S+)(\s+))/.exec(after);
    var spaceBefore = /(?:(\s+)|(\s+)(\S+))$/.exec(before);
    var start = 0;
    var end2 = 0;
    if (spaceBefore && !spaceBefore[2]) {
      start = max3 - spaceBefore[1].length;
      end2 = max3;
    }
    if (spaceAfter && !spaceAfter[2]) {
      if (!start)
        start = max3;
      end2 = max3 + spaceAfter[1].length;
    }
    if (start) {
      return {
        start,
        end: end2
      };
    }
    if (spaceBefore && spaceBefore[2] && spaceBefore.index > min2) {
      return {
        start: spaceBefore.index,
        end: spaceBefore.index + spaceBefore[2].length
      };
    }
    if (spaceAfter && spaceAfter[2]) {
      start = max3 + spaceAfter[2].length;
      return {
        start,
        end: start + spaceAfter[3].length
      };
    }
  }
}
var getDrawSelectionConfig2 = View.getDrawSelectionConfig || /* @__PURE__ */ function() {
  let defaultConfig = { cursorBlinkRate: 1200 };
  return function() {
    return defaultConfig;
  };
}();
var Piece = class {
  constructor(left, top, height, fontFamily, fontSize, fontWeight, color, className, letter, partial) {
    this.left = left;
    this.top = top;
    this.height = height;
    this.fontFamily = fontFamily;
    this.fontSize = fontSize;
    this.fontWeight = fontWeight;
    this.color = color;
    this.className = className;
    this.letter = letter;
    this.partial = partial;
  }
  draw() {
    let elt = document.createElement("div");
    elt.className = this.className;
    this.adjust(elt);
    return elt;
  }
  adjust(elt) {
    elt.style.left = this.left + "px";
    elt.style.top = this.top + "px";
    elt.style.height = this.height + "px";
    elt.style.lineHeight = this.height + "px";
    elt.style.fontFamily = this.fontFamily;
    elt.style.fontSize = this.fontSize;
    elt.style.fontWeight = this.fontWeight;
    elt.style.color = this.partial ? "transparent" : this.color;
    elt.className = this.className;
    elt.textContent = this.letter;
  }
  eq(p3) {
    return this.left == p3.left && this.top == p3.top && this.height == p3.height && this.fontFamily == p3.fontFamily && this.fontSize == p3.fontSize && this.fontWeight == p3.fontWeight && this.color == p3.color && this.className == p3.className && this.letter == p3.letter;
  }
};
var BlockCursorPlugin = class {
  constructor(view, cm) {
    this.view = view;
    this.rangePieces = [];
    this.cursors = [];
    this.cm = cm;
    this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };
    this.cursorLayer = view.scrollDOM.appendChild(document.createElement("div"));
    this.cursorLayer.className = "cm-cursorLayer cm-vimCursorLayer";
    this.cursorLayer.setAttribute("aria-hidden", "true");
    view.requestMeasure(this.measureReq);
    this.setBlinkRate();
  }
  setBlinkRate() {
    let config3 = getDrawSelectionConfig2(this.cm.cm6.state);
    let blinkRate = config3.cursorBlinkRate;
    this.cursorLayer.style.animationDuration = blinkRate + "ms";
  }
  update(update) {
    if (update.selectionSet || update.geometryChanged || update.viewportChanged) {
      this.view.requestMeasure(this.measureReq);
      this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
    }
    if (configChanged(update))
      this.setBlinkRate();
  }
  scheduleRedraw() {
    this.view.requestMeasure(this.measureReq);
  }
  readPos() {
    let { state: state2 } = this.view;
    let cursors = [];
    for (let r4 of state2.selection.ranges) {
      let prim = r4 == state2.selection.main;
      let piece = measureCursor(this.cm, this.view, r4, prim);
      if (piece)
        cursors.push(piece);
    }
    return { cursors };
  }
  drawSel({ cursors }) {
    if (cursors.length != this.cursors.length || cursors.some((c4, i4) => !c4.eq(this.cursors[i4]))) {
      let oldCursors = this.cursorLayer.children;
      if (oldCursors.length !== cursors.length) {
        this.cursorLayer.textContent = "";
        for (const c4 of cursors)
          this.cursorLayer.appendChild(c4.draw());
      } else {
        cursors.forEach((c4, idx) => c4.adjust(oldCursors[idx]));
      }
      this.cursors = cursors;
    }
  }
  destroy() {
    this.cursorLayer.remove();
  }
};
function configChanged(update) {
  return getDrawSelectionConfig2(update.startState) != getDrawSelectionConfig2(update.state);
}
var themeSpec = {
  ".cm-vimMode .cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-fat-cursor": {
    position: "absolute",
    background: "#ff9696",
    border: "none",
    whiteSpace: "pre"
  },
  "&:not(.cm-focused) .cm-fat-cursor": {
    background: "none",
    outline: "solid 1px #ff9696",
    color: "transparent !important"
  }
};
var hideNativeSelection = /* @__PURE__ */ import_state6.Prec.highest(/* @__PURE__ */ import_view3.EditorView.theme(themeSpec));
function getBase(view) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let left = view.textDirection == import_view3.Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;
  return { left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };
}
function measureCursor(cm, view, cursor2, primary) {
  var _a, _b;
  let head = cursor2.head;
  let fatCursor = false;
  let hCoeff = 1;
  let vim2 = cm.state.vim;
  if (vim2 && (!vim2.insertMode || cm.state.overwrite)) {
    fatCursor = true;
    if (vim2.visualBlock && !primary)
      return null;
    if (cursor2.anchor < cursor2.head)
      head--;
    if (cm.state.overwrite)
      hCoeff = 0.2;
    else if (vim2.status)
      hCoeff = 0.5;
  }
  if (fatCursor) {
    let letter = head < view.state.doc.length && view.state.sliceDoc(head, head + 1);
    if (letter && (/[\uDC00-\uDFFF]/.test(letter) && head > 1)) {
      head--;
      letter = view.state.sliceDoc(head, head + 1);
    }
    let pos = view.coordsAtPos(head, 1);
    if (!pos)
      return null;
    let base = getBase(view);
    let domAtPos = view.domAtPos(head);
    let node2 = domAtPos ? domAtPos.node : view.contentDOM;
    while (domAtPos && domAtPos.node instanceof HTMLElement) {
      node2 = domAtPos.node;
      domAtPos = { node: domAtPos.node.childNodes[domAtPos.offset], offset: 0 };
    }
    if (!(node2 instanceof HTMLElement)) {
      if (!node2.parentNode)
        return null;
      node2 = node2.parentNode;
    }
    let style = getComputedStyle(node2);
    let left = pos.left;
    let charCoords = (_b = (_a = view).coordsForChar) === null || _b === void 0 ? void 0 : _b.call(_a, head);
    if (charCoords) {
      left = charCoords.left;
    }
    if (!letter || letter == "\n" || letter == "\r") {
      letter = "\xA0";
    } else if (letter == "	") {
      letter = "\xA0";
      var nextPos = view.coordsAtPos(head + 1, -1);
      if (nextPos) {
        left = nextPos.left - (nextPos.left - pos.left) / parseInt(style.tabSize);
      }
    } else if (/[\uD800-\uDBFF]/.test(letter) && head < view.state.doc.length - 1) {
      letter += view.state.sliceDoc(head + 1, head + 2);
    }
    let h3 = pos.bottom - pos.top;
    return new Piece(left - base.left, pos.top - base.top + h3 * (1 - hCoeff), h3 * hCoeff, style.fontFamily, style.fontSize, style.fontWeight, style.color, primary ? "cm-fat-cursor cm-cursor-primary" : "cm-fat-cursor cm-cursor-secondary", letter, hCoeff != 1);
  } else {
    return null;
  }
}
var FIREFOX_LINUX = typeof navigator != "undefined" && /* @__PURE__ */ /linux/i.test(navigator.platform) && /* @__PURE__ */ / Gecko\/\d+/.exec(navigator.userAgent);
var Vim = /* @__PURE__ */ initVim(CodeMirror);
var HighlightMargin = 250;
var vimStyle = /* @__PURE__ */ import_view3.EditorView.baseTheme({
  ".cm-vimMode .cm-cursorLayer:not(.cm-vimCursorLayer)": {
    display: "none"
  },
  ".cm-vim-panel": {
    padding: "0px 10px",
    fontFamily: "monospace",
    minHeight: "1.3em"
  },
  ".cm-vim-panel input": {
    border: "none",
    outline: "none",
    backgroundColor: "inherit"
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" }
});
var vimPlugin = /* @__PURE__ */ import_view3.ViewPlugin.fromClass(class {
  constructor(view) {
    this.status = "";
    this.query = null;
    this.decorations = import_view3.Decoration.none;
    this.waitForCopy = false;
    this.lastKeydown = "";
    this.useNextTextInput = false;
    this.compositionText = "";
    this.view = view;
    const cm = this.cm = new CodeMirror(view);
    Vim.enterVimMode(this.cm);
    this.view.cm = this.cm;
    this.cm.state.vimPlugin = this;
    this.blockCursor = new BlockCursorPlugin(view, cm);
    this.updateClass();
    this.cm.on("vim-command-done", () => {
      if (cm.state.vim)
        cm.state.vim.status = "";
      this.blockCursor.scheduleRedraw();
      this.updateStatus();
    });
    this.cm.on("vim-mode-change", (e3) => {
      if (!cm.state.vim)
        return;
      cm.state.vim.mode = e3.mode;
      if (e3.subMode) {
        cm.state.vim.mode += " block";
      }
      cm.state.vim.status = "";
      this.blockCursor.scheduleRedraw();
      this.updateClass();
      this.updateStatus();
    });
    this.cm.on("dialog", () => {
      if (this.cm.state.statusbar) {
        this.updateStatus();
      } else {
        view.dispatch({
          effects: showVimPanel.of(!!this.cm.state.dialog)
        });
      }
    });
    this.dom = document.createElement("span");
    this.dom.style.cssText = "position: absolute; right: 10px; top: 1px";
    this.statusButton = document.createElement("span");
    this.statusButton.onclick = (e3) => {
      Vim.handleKey(this.cm, "<Esc>", "user");
      this.cm.focus();
    };
    this.statusButton.style.cssText = "cursor: pointer";
  }
  update(update) {
    var _a;
    if ((update.viewportChanged || update.docChanged) && this.query) {
      this.highlight(this.query);
    }
    if (update.docChanged) {
      this.cm.onChange(update);
    }
    if (update.selectionSet) {
      this.cm.onSelectionChange();
    }
    if (update.viewportChanged) ;
    if (this.cm.curOp && !this.cm.curOp.isVimOp) {
      this.cm.onBeforeEndOperation();
    }
    if (update.transactions) {
      for (let tr of update.transactions)
        for (let effect of tr.effects) {
          if (effect.is(import_search.setSearchQuery)) {
            let forVim = (_a = effect.value) === null || _a === void 0 ? void 0 : _a.forVim;
            if (!forVim) {
              this.highlight(null);
            } else {
              let query = effect.value.create();
              this.highlight(query);
            }
          }
        }
    }
    this.blockCursor.update(update);
  }
  updateClass() {
    const state2 = this.cm.state;
    if (!state2.vim || state2.vim.insertMode && !state2.overwrite)
      this.view.scrollDOM.classList.remove("cm-vimMode");
    else
      this.view.scrollDOM.classList.add("cm-vimMode");
  }
  updateStatus() {
    let dom2 = this.cm.state.statusbar;
    let vim2 = this.cm.state.vim;
    if (!dom2 || !vim2)
      return;
    let dialog = this.cm.state.dialog;
    if (dialog) {
      if (dialog.parentElement != dom2) {
        dom2.textContent = "";
        dom2.appendChild(dialog);
      }
    } else {
      dom2.textContent = "";
      var status = (vim2.mode || "normal").toUpperCase();
      if (vim2.insertModeReturn)
        status += "(C-O)";
      this.statusButton.textContent = `--${status}--`;
      dom2.appendChild(this.statusButton);
    }
    this.dom.textContent = vim2.status;
    dom2.appendChild(this.dom);
  }
  destroy() {
    Vim.leaveVimMode(this.cm);
    this.updateClass();
    this.blockCursor.destroy();
    delete this.view.cm;
  }
  highlight(query) {
    this.query = query;
    if (!query)
      return this.decorations = import_view3.Decoration.none;
    let { view } = this;
    let builder = new import_state6.RangeSetBuilder();
    for (let i4 = 0, ranges = view.visibleRanges, l4 = ranges.length; i4 < l4; i4++) {
      let { from: from2, to } = ranges[i4];
      while (i4 < l4 - 1 && to > ranges[i4 + 1].from - 2 * HighlightMargin)
        to = ranges[++i4].to;
      query.highlight(view.state, from2, to, (from3, to2) => {
        builder.add(from3, to2, matchMark);
      });
    }
    return this.decorations = builder.finish();
  }
  handleKey(e3, view) {
    const cm = this.cm;
    let vim2 = cm.state.vim;
    if (!vim2)
      return;
    const key = Vim.vimKeyFromEvent(e3, vim2);
    CodeMirror.signal(this.cm, "inputEvent", { type: "handleKey", key });
    if (!key)
      return;
    if (key == "<Esc>" && !vim2.insertMode && !vim2.visualMode && this.query) {
      const searchState = vim2.searchState_;
      if (searchState) {
        cm.removeOverlay(searchState.getOverlay());
        searchState.setOverlay(null);
      }
    }
    let isCopy = key === "<C-c>" && !CodeMirror.isMac;
    if (isCopy && cm.somethingSelected()) {
      this.waitForCopy = true;
      return true;
    }
    vim2.status = (vim2.status || "") + key;
    let result = Vim.multiSelectHandleKey(cm, key, "user");
    vim2 = Vim.maybeInitVimState_(cm);
    if (!result && vim2.insertMode && cm.state.overwrite) {
      if (e3.key && e3.key.length == 1 && !/\n/.test(e3.key)) {
        result = true;
        cm.overWriteSelection(e3.key);
      } else if (e3.key == "Backspace") {
        result = true;
        CodeMirror.commands.cursorCharLeft(cm);
      }
    }
    if (result) {
      CodeMirror.signal(this.cm, "vim-keypress", key);
      e3.preventDefault();
      e3.stopPropagation();
      this.blockCursor.scheduleRedraw();
    }
    this.updateStatus();
    return !!result;
  }
}, {
  eventHandlers: {
    copy: function(e3, view) {
      if (!this.waitForCopy)
        return;
      this.waitForCopy = false;
      Promise.resolve().then(() => {
        var cm = this.cm;
        var vim2 = cm.state.vim;
        if (!vim2)
          return;
        if (vim2.insertMode) {
          cm.setSelection(cm.getCursor(), cm.getCursor());
        } else {
          cm.operation(() => {
            if (cm.curOp)
              cm.curOp.isVimOp = true;
            Vim.handleKey(cm, "<Esc>", "user");
          });
        }
      });
    },
    compositionstart: function(e3, view) {
      this.useNextTextInput = true;
      CodeMirror.signal(this.cm, "inputEvent", e3);
    },
    compositionupdate: function(e3, view) {
      CodeMirror.signal(this.cm, "inputEvent", e3);
    },
    compositionend: function(e3, view) {
      CodeMirror.signal(this.cm, "inputEvent", e3);
    },
    keypress: function(e3, view) {
      CodeMirror.signal(this.cm, "inputEvent", e3);
      if (this.lastKeydown == "Dead")
        this.handleKey(e3, view);
    },
    keydown: function(e3, view) {
      CodeMirror.signal(this.cm, "inputEvent", e3);
      this.lastKeydown = e3.key;
      if (this.lastKeydown == "Unidentified" || this.lastKeydown == "Process" || this.lastKeydown == "Dead") {
        this.useNextTextInput = true;
      } else {
        this.useNextTextInput = false;
        this.handleKey(e3, view);
      }
    }
  },
  provide: () => {
    return [
      import_view3.EditorView.inputHandler.of((view, from2, to, text2) => {
        var _a, _b;
        var cm = getCM(view);
        if (!cm)
          return false;
        var vim2 = (_a = cm.state) === null || _a === void 0 ? void 0 : _a.vim;
        var vimPlugin2 = cm.state.vimPlugin;
        if (vim2 && !vim2.insertMode && !((_b = cm.curOp) === null || _b === void 0 ? void 0 : _b.isVimOp)) {
          if (text2 === "\0\0") {
            return true;
          }
          CodeMirror.signal(cm, "inputEvent", {
            type: "text",
            text: text2,
            from: from2,
            to
          });
          if (text2.length == 1 && vimPlugin2.useNextTextInput) {
            if (vim2.expectLiteralNext && view.composing) {
              vimPlugin2.compositionText = text2;
              return false;
            }
            if (vimPlugin2.compositionText) {
              var toRemove = vimPlugin2.compositionText;
              vimPlugin2.compositionText = "";
              var head = view.state.selection.main.head;
              var textInDoc = view.state.sliceDoc(head - toRemove.length, head);
              if (toRemove === textInDoc) {
                var pos = cm.getCursor();
                cm.replaceRange("", cm.posFromIndex(head - toRemove.length), pos);
              }
            }
            vimPlugin2.handleKey({
              key: text2,
              preventDefault: () => {
              },
              stopPropagation: () => {
              }
            });
            forceEndComposition(view);
            return true;
          }
        }
        return false;
      })
    ];
  },
  decorations: (v3) => v3.decorations
});
function forceEndComposition(view) {
  var parent = view.scrollDOM.parentElement;
  if (!parent)
    return;
  if (FIREFOX_LINUX) {
    view.contentDOM.textContent = "\0\0";
    view.contentDOM.dispatchEvent(new CustomEvent("compositionend"));
    return;
  }
  var sibling = view.scrollDOM.nextSibling;
  var selection = window.getSelection();
  var savedSelection = selection && {
    anchorNode: selection.anchorNode,
    anchorOffset: selection.anchorOffset,
    focusNode: selection.focusNode,
    focusOffset: selection.focusOffset
  };
  view.scrollDOM.remove();
  parent.insertBefore(view.scrollDOM, sibling);
  try {
    if (savedSelection && selection) {
      selection.setPosition(savedSelection.anchorNode, savedSelection.anchorOffset);
      if (savedSelection.focusNode) {
        selection.extend(savedSelection.focusNode, savedSelection.focusOffset);
      }
    }
  } catch (e3) {
    console.error(e3);
  }
  view.focus();
  view.contentDOM.dispatchEvent(new CustomEvent("compositionend"));
}
var matchMark = /* @__PURE__ */ import_view3.Decoration.mark({ class: "cm-searchMatch" });
var showVimPanel = /* @__PURE__ */ import_state6.StateEffect.define();
var vimPanelState = /* @__PURE__ */ import_state6.StateField.define({
  create: () => false,
  update(value, tr) {
    for (let e3 of tr.effects)
      if (e3.is(showVimPanel))
        value = e3.value;
    return value;
  },
  provide: (f4) => {
    return import_view3.showPanel.from(f4, (on3) => on3 ? createVimPanel : null);
  }
});
function createVimPanel(view) {
  let dom2 = document.createElement("div");
  dom2.className = "cm-vim-panel";
  let cm = view.cm;
  if (cm.state.dialog) {
    dom2.appendChild(cm.state.dialog);
  }
  return { top: false, dom: dom2 };
}
function statusPanel(view) {
  let dom2 = document.createElement("div");
  dom2.className = "cm-vim-panel";
  let cm = view.cm;
  cm.state.statusbar = dom2;
  cm.state.vimPlugin.updateStatus();
  return { dom: dom2 };
}
function vim(options2 = {}) {
  return [
    vimStyle,
    vimPlugin,
    hideNativeSelection,
    options2.status ? import_view3.showPanel.of(statusPanel) : vimPanelState
  ];
}
function getCM(view) {
  return view.cm || null;
}

// src/ui/view-page.tsx
var import_state7 = require("@codemirror/state");
var VIEW_TYPE_DATACOREJS = "datacorejs-view";
var CUSTOM_VIEW_CONTEXT = G(void 0);
var EDITOR_HL = (0, import_language4.syntaxHighlighting)(
  (0, import_highlight2.tagHighlighter)([
    {
      tag: import_highlight2.tags.link,
      class: "cm-link"
    },
    {
      tag: import_highlight2.tags.heading,
      class: "cm-heading"
    },
    {
      tag: import_highlight2.tags.emphasis,
      class: "cm-emphasis"
    },
    {
      tag: import_highlight2.tags.strong,
      class: "cm-strong"
    },
    {
      tag: import_highlight2.tags.keyword,
      class: "cm-keyword"
    },
    {
      tag: import_highlight2.tags.atom,
      class: "cm-atom"
    },
    {
      tag: import_highlight2.tags.bool,
      class: "cm-bool"
    },
    {
      tag: import_highlight2.tags.url,
      class: "cm-url"
    },
    {
      tag: import_highlight2.tags.labelName,
      class: "cm-labelName"
    },
    {
      tag: import_highlight2.tags.inserted,
      class: "cm-inserted"
    },
    {
      tag: import_highlight2.tags.deleted,
      class: "cm-deleted"
    },
    {
      tag: import_highlight2.tags.literal,
      class: "cm-literal"
    },
    {
      tag: import_highlight2.tags.string,
      class: "cm-string"
    },
    {
      tag: import_highlight2.tags.number,
      class: "cm-number"
    },
    {
      tag: [import_highlight2.tags.regexp, import_highlight2.tags.escape, import_highlight2.tags.special(import_highlight2.tags.string)],
      class: "cm-string2"
    },
    {
      tag: import_highlight2.tags.variableName,
      class: "cm-variableName"
    },
    {
      tag: import_highlight2.tags.local(import_highlight2.tags.variableName),
      class: "cm-variableName cm-local"
    },
    {
      tag: import_highlight2.tags.definition(import_highlight2.tags.variableName),
      class: "cm-variableName cm-definition"
    },
    {
      tag: import_highlight2.tags.special(import_highlight2.tags.variableName),
      class: "cm-variableName2"
    },
    {
      tag: import_highlight2.tags.definition(import_highlight2.tags.propertyName),
      class: "cm-propertyName cm-definition"
    },
    {
      tag: import_highlight2.tags.typeName,
      class: "cm-typeName"
    },
    {
      tag: import_highlight2.tags.namespace,
      class: "cm-namespace"
    },
    {
      tag: import_highlight2.tags.className,
      class: "cm-className"
    },
    {
      tag: import_highlight2.tags.macroName,
      class: "cm-macroName"
    },
    {
      tag: import_highlight2.tags.propertyName,
      class: "cm-propertyName"
    },
    {
      tag: import_highlight2.tags.operator,
      class: "cm-operator"
    },
    {
      tag: import_highlight2.tags.comment,
      class: "cm-comment"
    },
    {
      tag: import_highlight2.tags.meta,
      class: "cm-meta"
    },
    {
      tag: import_highlight2.tags.invalid,
      class: "cm-invalid"
    },
    {
      tag: import_highlight2.tags.punctuation,
      class: "cm-punctuation"
    }
  ])
);
var LANG_COMPARTMENT = new import_state7.Compartment();
var EDITOR_EXTS = [
  (0, import_view4.lineNumbers)(),
  (0, import_view4.highlightSpecialChars)(),
  (0, import_commands2.history)(),
  (0, import_language4.foldGutter)(),
  (0, import_view4.drawSelection)(),
  (0, import_view4.dropCursor)(),
  import_state7.EditorState.allowMultipleSelections.of(true),
  (0, import_language4.indentOnInput)(),
  (0, import_language4.bracketMatching)(),
  closeBrackets(),
  (0, import_view4.rectangularSelection)(),
  (0, import_view4.crosshairCursor)(),
  (0, import_search2.highlightSelectionMatches)(),
  import_view4.keymap.of([
    import_commands2.indentWithTab,
    ...closeBracketsKeymap,
    ...import_commands2.defaultKeymap,
    ...import_search2.searchKeymap,
    ...import_commands2.historyKeymap,
    ...import_language4.foldKeymap,
    ...completionKeymap,
    ...import_lint.lintKeymap
  ]),
  import_view4.EditorView.baseTheme({
    ".cm-cursor": {
      borderLeftColor: "var(--text)"
    },
    ".cm-tooltip": {
      backgroundColor: "var(--bg)"
    },
    "&:not(.cm-focused) .cm-fat-cursor": {
      outline: "solid 1px var(--accent) !important",
      background: "none"
    },
    "&.cm-focused .cm-fat-cursor": {
      background: "var(--accent) !important"
    }
  })
];
function CodeMirrorEditor({
  state: { script, sourceType: lang },
  setState
}) {
  const editorRef = A2(null);
  const viewRef = A2(null);
  const viewContext = x2(CUSTOM_VIEW_CONTEXT);
  y2(() => {
    var _a;
    if (editorRef.current && !viewRef.current) {
      viewRef.current = new import_view4.EditorView({
        parent: editorRef.current,
        extensions: [viewContext.app.vault.getConfig("vimMode") && vim()].filter(Boolean).concat(
          ...EDITOR_EXTS.concat(
            ...[
              LANG_COMPARTMENT.of(javascript()),
              import_view4.ViewPlugin.fromClass(
                class {
                  constructor(view) {
                    this.view = view;
                  }
                  update(update) {
                    if (update.docChanged) {
                      setState({ script: this.view.state.sliceDoc() || "" });
                    }
                  }
                }
              ),
              EDITOR_HL,
              viewContext.app.vault.getConfig("vimMode") && vim(),
              ...((_a = viewContext.app.plugins.plugins["datacore-addon-autocomplete"]) == null ? void 0 : _a.extensions) || []
            ].filter((a4) => !!a4)
          )
        ),
        doc: script || ""
      });
    }
  }, [editorRef.current]);
  y2(() => {
    if (viewRef.current)
      viewRef.current.dispatch({
        effects: LANG_COMPARTMENT.reconfigure(
          javascript({ jsx: lang == null ? void 0 : lang.endsWith("x"), typescript: lang == null ? void 0 : lang.startsWith("ts") })
        )
      });
  }, [lang]);
  return /* @__PURE__ */ u3("div", { className: "dc-cm-editor", ref: editorRef });
}
function DatacoreViewSettings() {
  var _a;
  const view = x2(CUSTOM_VIEW_CONTEXT);
  const setViewState = T2(
    () => (0, import_obsidian9.debounce)((state2) => view.setState(state2, { history: false }), 500),
    [view]
  );
  const [localState, setLocalState] = h2(view.getState());
  const setState = q2(
    (state2) => {
      const finalState = { ...localState, ...state2 };
      setLocalState(finalState);
      setViewState(finalState);
    },
    [localState, setLocalState, view]
  );
  return /* @__PURE__ */ u3(Stack, { align: "stretch", children: [
    /* @__PURE__ */ u3("button", { className: "clickable-icon", style: "align-self: start", onClick: () => view.view("script"), children: BACK_BUTTON }),
    /* @__PURE__ */ u3(Group, { justify: "space-between", align: "center", children: [
      /* @__PURE__ */ u3("h6", { children: "View Title" }),
      /* @__PURE__ */ u3(
        Textbox,
        {
          inline: true,
          defaultValue: view.getState().title,
          onChange: (e3) => setState({ title: e3.currentTarget.value })
        }
      )
    ] }),
    /* @__PURE__ */ u3(Group, { justify: "space-between", align: "center", children: [
      /* @__PURE__ */ u3("h6", { children: "View Type" }),
      /* @__PURE__ */ u3(
        VanillaSelect,
        {
          defaultValue: view.getState().sourceType,
          options: LANGUAGE_OPTIONS,
          value: localState.sourceType,
          onValueChange: (s4) => setState({ sourceType: s4 })
        }
      )
    ] }),
    /* @__PURE__ */ u3(Group, { justify: "space-between", align: "center", children: [
      /* @__PURE__ */ u3("h6", { children: "Script/View source" }),
      /* @__PURE__ */ u3("div", { style: { minWidth: "75%", fontFamily: "monospace" }, children: /* @__PURE__ */ u3(CodeMirrorEditor, { state: localState, setState, lang: (_a = localState.sourceType) != null ? _a : "js" }) })
    ] }),
    /* @__PURE__ */ u3(Group, { justify: "space-between", align: "center", children: [
      /* @__PURE__ */ u3(Stack, { children: [
        /* @__PURE__ */ u3("h6", { children: "Current File" }),
        /* @__PURE__ */ u3("small", { children: "The path returned by functions like `useCurrentPath` in this view" })
      ] }),
      /* @__PURE__ */ u3("div", { style: { minWidth: "50%" }, children: /* @__PURE__ */ u3(
        CurrentFileSelector,
        {
          defaultValue: localState.currentFile,
          onChange: (v3) => setState({ currentFile: v3 })
        }
      ) })
    ] })
  ] });
}
function CurrentFileSelector({
  defaultValue,
  onChange: onChange3
}) {
  const core = x2(DATACORE_CONTEXT);
  const revision = useIndexUpdates(core, { debounce: 2e3 });
  const defaultOption = !defaultValue ? { label: "No file", value: "" } : { label: defaultValue, value: defaultValue };
  const options2 = T2(() => {
    return core.vault.getMarkdownFiles().map((f4) => ({ label: f4.path, value: f4.path })).concat(defaultOption);
  }, [revision]);
  return /* @__PURE__ */ u3(
    StateManagedSelect$1,
    {
      options: options2,
      classNamePrefix: "datacore-selectable",
      defaultValue: defaultOption,
      onChange: (nv, _am) => onChange3(nv == null ? void 0 : nv.value),
      unstyled: true,
      menuPortalTarget: document.body,
      tabIndex: -1,
      styles: {
        container(base, _props) {
          return { ...base, minWidth: "100%" };
        },
        menu(base, _props) {
          return { ...base, minWidth: "100%" };
        }
      },
      classNames: {
        input: (props) => "prompt-input",
        valueContainer: (props) => "suggestion-item value-container",
        container: (props) => "suggestion-container",
        menu: (props) => "suggestion-content suggestion-container",
        option: (props) => `suggestion-item${props.isSelected ? " is-selected" : ""}`
      }
    }
  );
}
var LANGUAGE_OPTIONS = [
  { label: "Javascript", value: "js" },
  { label: "Typescript", value: "ts" },
  { label: "Javascript (JSX)", value: "jsx" },
  { label: "Typescript JSX", value: "tsx" }
];
var BACK_BUTTON = /* @__PURE__ */ u3(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    class: "svg-icon lucide-arrow-left",
    children: [
      /* @__PURE__ */ u3("path", { d: "m12 19-7-7 7-7" }),
      /* @__PURE__ */ u3("path", { d: "M19 12H5" })
    ]
  }
);
var DatacoreQueryView = class extends import_obsidian9.ItemView {
  constructor(leaf, api2) {
    super(leaf);
    this.api = api2;
    /** Internal current state of the view; can be modified by setState. */
    this.internalState = {
      title: "New view",
      script: "",
      sourceType: "js",
      view: "settings"
    };
    this.rerender();
  }
  /** Should always be VIEW_TYPE_DATACOREJS. */
  getViewType() {
    return VIEW_TYPE_DATACOREJS;
  }
  /** Text shown in the title window. */
  getDisplayText() {
    return `${this.internalState.title} (DatacoreJS)`;
  }
  async onload() {
    var _a;
    this.contentEl.addClass("markdown-rendered");
    this.registerDomEvent(this.containerEl, "keydown", (k4) => {
      if (k4.charCode == 27) {
        k4.preventDefault();
        k4.stopPropagation();
      }
    });
    this.scope = new import_obsidian9.Scope(this.app.scope);
    (_a = this.scope) == null ? void 0 : _a.register(null, "Escape", (ev) => {
    });
    this.rerender();
  }
  onunload() {
    if (this.activeView) this.removeChild(this.activeView);
  }
  /** Synchronizes the screen state to properly reflect the current internal state. */
  rerender() {
    this.leaf.tabHeaderInnerTitleEl.textContent = this.titleEl.textContent = this.getDisplayText();
    if (this.activeViewType == this.internalState.view) return;
    if (this.activeView) this.removeChild(this.activeView);
    if (this.internalState.view === "settings") {
      this.activeViewType = "settings";
      this.activeView = new ReactRenderer(
        this.app,
        this.api.core,
        this.contentEl,
        this.internalState.currentFile || "",
        /* @__PURE__ */ u3(CUSTOM_VIEW_CONTEXT.Provider, { value: this, children: /* @__PURE__ */ u3(DatacoreViewSettings, {}) })
      );
    } else {
      this.activeViewType = "script";
      if (this.internalState.script) {
        this.activeView = new DatacoreJSRenderer(
          new DatacoreLocalApi(this.api, this.internalState.currentFile || ""),
          this.contentEl,
          this.internalState.currentFile || "",
          this.internalState.script || "",
          this.internalState.sourceType || "js"
        );
      } else {
        this.activeView = new ReactRenderer(
          this.app,
          this.api.core,
          this.contentEl,
          this.internalState.currentFile || "",
          /* @__PURE__ */ u3(CUSTOM_VIEW_CONTEXT.Provider, { value: this, children: /* @__PURE__ */ u3(ErrorMessage, { message: "No script defined for this view." }) })
        );
      }
    }
    this.addChild(this.activeView);
  }
  getState() {
    return this.internalState;
  }
  /** Update the state of this view with new metadata. Generally controlled by the settings pane. */
  async setState(state2, _result) {
    this.internalState = state2;
    this.rerender();
  }
  /** Swap the active view. */
  view(mode) {
    this.internalState.view = mode;
    this.rerender();
  }
  async onOpen() {
  }
  /** Handle for right click menus. */
  onPaneMenu(menu, source) {
    if (source === "more-options") {
      menu.addItem((it) => {
        it.setIcon("settings");
        it.setTitle("Configure View");
        it.onClick((e3) => this.view("settings"));
      });
    }
  }
};

// src/ui/index-status.tsx
function IndexStatusBar({ datacore }) {
  useIndexUpdates(datacore, { debounce: 250 });
  if (datacore.initializer) {
    return /* @__PURE__ */ u3("span", { children: [
      "Scanning ",
      datacore.initializer.initialized,
      " of ",
      datacore.initializer.files,
      " files"
    ] });
  } else if (datacore.importer.queue.size() > 0) {
    return /* @__PURE__ */ u3("span", { children: [
      "Updating ",
      datacore.importer.queue.size(),
      " files"
    ] });
  } else {
    return /* @__PURE__ */ u3("span", { children: [
      datacore.datastore.size,
      " objects"
    ] });
  }
}

// src/main.ts
var DatacorePlugin = class extends import_obsidian10.Plugin {
  async onload() {
    var _a;
    this.settings = Object.assign({}, DEFAULT_SETTINGS, (_a = await this.loadData()) != null ? _a : {});
    this.addSettingTab(new GeneralSettingsTab(this.app, this));
    this.addChild(this.core = new Datacore(this.app, this.manifest.version, this.settings));
    this.api = new DatacoreApi(this.core);
    this.mountIndexState(this.addStatusBarItem(), this.core);
    this.registerMarkdownCodeBlockProcessor(
      "datacorejs",
      async (source, el, ctx) => this.api.executeJs(source, el, ctx, ctx.sourcePath),
      -100
    );
    this.registerMarkdownCodeBlockProcessor(
      "datacorejsx",
      async (source, el, ctx) => this.api.executeJsx(source, el, ctx, ctx.sourcePath),
      -100
    );
    this.registerMarkdownCodeBlockProcessor(
      "datacorets",
      async (source, el, ctx) => this.api.executeTs(source, el, ctx, ctx.sourcePath),
      -100
    );
    this.registerMarkdownCodeBlockProcessor(
      "datacoretsx",
      async (source, el, ctx) => this.api.executeTsx(source, el, ctx, ctx.sourcePath),
      -100
    );
    this.registerView(VIEW_TYPE_DATACOREJS, (leaf) => new DatacoreQueryView(leaf, this.api));
    this.addCommand({
      id: "datacore-add-view-page",
      name: "Create View Page",
      callback: () => {
        const newLeaf = this.app.workspace.getLeaf("tab");
        newLeaf.setViewState({ type: VIEW_TYPE_DATACOREJS, active: true });
        this.app.workspace.setActiveLeaf(newLeaf, { focus: true });
      }
    });
    this.register(this.registerCodeblockHighlighting());
    if (!this.app.workspace.layoutReady) {
      this.app.workspace.onLayoutReady(async () => this.core.initialize());
    } else {
      this.core.initialize();
    }
    window.datacore = this.api;
    console.log(`Datacore: version ${this.manifest.version} (requires obsidian ${this.manifest.minAppVersion})`);
  }
  onunload() {
    console.log(`Datacore: version ${this.manifest.version} unloaded.`);
  }
  /** Register codeblock highlighting and return a closure which unregisters. */
  registerCodeblockHighlighting() {
    window.CodeMirror.defineMode("datacorejs", (config3) => window.CodeMirror.getMode(config3, "javascript"));
    window.CodeMirror.defineMode("datacorejsx", (config3) => window.CodeMirror.getMode(config3, "jsx"));
    window.CodeMirror.defineMode("datacorets", (config3) => window.CodeMirror.getMode(config3, "javascript"));
    window.CodeMirror.defineMode("datacoretsx", (config3) => window.CodeMirror.getMode(config3, "jsx"));
    return () => {
      window.CodeMirror.defineMode("datacorejs", (config3) => window.CodeMirror.getMode(config3, "null"));
      window.CodeMirror.defineMode("datacorejsx", (config3) => window.CodeMirror.getMode(config3, "null"));
      window.CodeMirror.defineMode("datacorets", (config3) => window.CodeMirror.getMode(config3, "null"));
      window.CodeMirror.defineMode("datacoretsx", (config3) => window.CodeMirror.getMode(config3, "null"));
    };
  }
  /** Update the given settings to new values. */
  async updateSettings(settings) {
    Object.assign(this.settings, settings);
    await this.saveData(this.settings);
  }
  /** Render datacore indexing status using the index. */
  mountIndexState(root, core) {
    B(_(IndexStatusBar, { datacore: core }), root);
    this.register(() => B(null, root));
  }
};
var GeneralSettingsTab = class extends import_obsidian10.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    this.containerEl.empty();
    this.containerEl.createEl("h2", { text: "Views" });
    new import_obsidian10.Setting(this.containerEl).setName("Pagination").setDesc(
      "If enabled, splits up views into pages of results which can be traversed via buttons at the top and bottom of the view. This substantially improves the performance of large views, and can help with visual clutter. Note that this setting can also be set on a per-view basis."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.defaultPagingEnabled).onChange(async (value) => {
        await this.plugin.updateSettings({ defaultPagingEnabled: value });
      });
    });
    new import_obsidian10.Setting(this.containerEl).setName("Default Page Size").setDesc("The number of entries to show per page, by default. This can be overriden on a per-view basis.").addDropdown((dropdown) => {
      const OPTIONS = {
        "25": "25",
        "50": "50",
        "100": "100",
        "200": "200",
        "500": "500"
      };
      const current = "" + this.plugin.settings.defaultPageSize;
      if (!(current in OPTIONS)) OPTIONS[current] = current;
      dropdown.addOptions(OPTIONS).setValue(current).onChange(async (value) => {
        const parsed = parseFloat(value);
        if (isNaN(parsed)) return;
        await this.plugin.updateSettings({ defaultPageSize: parsed | 0 });
      });
    });
    new import_obsidian10.Setting(this.containerEl).setName("Scroll on Page Change").setDesc(
      "If enabled, table that are paged will scroll to the top of the table when the page changes. This can be overriden on a per-view basis."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.scrollOnPageChange).onChange(async (value) => {
        await this.plugin.updateSettings({ scrollOnPageChange: value });
      });
    });
    new import_obsidian10.Setting(this.containerEl).setName("Enable Javascript").setDesc("Whether Javascript codeblocks will be evaluated.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableJs).onChange(async (value) => {
        await this.plugin.updateSettings({ enableJs: value });
      });
    });
    this.containerEl.createEl("h2", { text: "Formatting" });
    new import_obsidian10.Setting(this.containerEl).setName("Empty Values").setDesc("What to show for unset/empty properties.").addText((text2) => {
      text2.setValue(this.plugin.settings.renderNullAs).onChange(async (value) => {
        await this.plugin.updateSettings({ renderNullAs: value });
      });
    });
    new import_obsidian10.Setting(this.containerEl).setName("Default Date Format").setDesc(
      "The default format that dates are rendered in. Uses luxon date formatting (https://github.com/moment/luxon/blob/master/docs/formatting.md#formatting-with-tokens-strings-for-cthulhu)."
    ).addText((text2) => {
      text2.setValue(this.plugin.settings.defaultDateFormat).onChange(async (value) => {
        try {
          DateTime.fromMillis(Date.now()).toFormat(value);
        } catch (e3) {
          return;
        }
        await this.plugin.updateSettings({ defaultDateFormat: value });
      });
    });
    new import_obsidian10.Setting(this.containerEl).setName("Default Date-Time format").setDesc(
      "The default format that date-times are rendered in. Uses luxon date formatting (https://github.com/moment/luxon/blob/master/docs/formatting.md#formatting-with-tokens-strings-for-cthulhu)."
    ).addText((text2) => {
      text2.setValue(this.plugin.settings.defaultDateTimeFormat).onChange(async (value) => {
        try {
          DateTime.fromMillis(Date.now()).toFormat(value);
        } catch (e3) {
          return;
        }
        await this.plugin.updateSettings({ defaultDateTimeFormat: value });
      });
    });
    this.containerEl.createEl("h2", { text: "Performance Tuning" });
    new import_obsidian10.Setting(this.containerEl).setName("Inline Fields").setDesc(
      "If enabled, inline fields will be parsed in all documents. Finding inline fields requires a full text scan through each document, which noticably slows down indexing for large vaults. Disabling this functionality will mean metadata will only come from tags, links, and Properties / frontmatter"
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.indexInlineFields).onChange(async (value) => {
        await this.plugin.updateSettings({ indexInlineFields: value });
      });
    });
    new import_obsidian10.Setting(this.containerEl).setName("Importer Threads").setDesc("The number of importer threads to use for parsing metadata.").addText((text2) => {
      text2.setValue("" + this.plugin.settings.importerNumThreads).onChange(async (value) => {
        const parsed = parseInt(value);
        if (isNaN(parsed)) return;
        await this.plugin.updateSettings({ importerNumThreads: parsed });
      });
    });
    new import_obsidian10.Setting(this.containerEl).setName("Importer Utilization").setDesc("How much CPU time each importer thread should use, as a fraction (0.1 - 1.0).").addText((text2) => {
      text2.setValue(this.plugin.settings.importerUtilization.toFixed(2)).onChange(async (value) => {
        const parsed = parseFloat(value);
        if (isNaN(parsed)) return;
        const limited = Math.max(0.1, Math.min(1, parsed));
        await this.plugin.updateSettings({ importerUtilization: limited });
      });
    });
    new import_obsidian10.Setting(this.containerEl).setName("Maximum Recursive Render Depth").setDesc(
      "Maximum depth that objects will be rendered to (i.e., how many levels of subpropertieswill be rendered by default). This avoids infinite recursion due to self-referential objectsand ensures that rendering objects is acceptably performant."
    ).addText((text2) => {
      text2.setValue(this.plugin.settings.maxRecursiveRenderDepth.toString()).onChange(async (value) => {
        const parsed = parseInt(value);
        if (isNaN(parsed)) return;
        await this.plugin.updateSettings({ maxRecursiveRenderDepth: parsed });
      });
    });
    new import_obsidian10.Setting(this.containerEl).setName("Recursive subtask completion").setDesc("Whether or not subtasks should be completed along with their parent in datacore task views").addToggle((tb) => {
      tb.setValue(this.plugin.settings.recursiveTaskCompletion).onChange(async (val) => {
        await this.plugin.updateSettings({ recursiveTaskCompletion: val });
      });
    });
    this.containerEl.createEl("h2", { text: "Tasks" });
    new import_obsidian10.Setting(this.containerEl).setName("Task Completion Text").setDesc("Name of inline field in which to store task completion date/time").addText((text2) => {
      text2.setValue(this.plugin.settings.taskCompletionText).onChange(async (value) => {
        await this.plugin.updateSettings({ taskCompletionText: value });
      });
    });
    new import_obsidian10.Setting(this.containerEl).setName("Use Emoji Shorthand for Task Completion").setDesc(
      "If enabled, automatic completion will use an emoji shorthand \u2705 YYYY-MM-DDinstead of [completion:: date]."
    ).addToggle((tb) => {
      tb.setValue(this.plugin.settings.taskCompletionUseEmojiShorthand).onChange(async (val) => {
        await this.plugin.updateSettings({ taskCompletionUseEmojiShorthand: val });
      });
    });
  }
};
//! Utilities for running javascript.
//! Utilities for forcing types to be of a specific type or returning 'undefined' if not, allowing for much more concise typing.
//! Provides utilities for executing queries against the storage layer.
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

localforage/dist/localforage.js:
  (*!
      localForage -- Offline Storage, Improved
      Version 1.10.0
      https://localforage.github.io/localForage
      (c) 2013-2017 Mozilla, Apache License 2.0
  *)

@datastructures-js/queue/src/queue.js:
  (**
   * @license MIT
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   *
   * @class
   *)
*/

/* nosourcemap */